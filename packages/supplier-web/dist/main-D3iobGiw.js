var UY = Object.defineProperty, GY = Object.defineProperties;
var YY = Object.getOwnPropertyDescriptors;
var Uh = Object.getOwnPropertySymbols;
var XP = Object.prototype.hasOwnProperty, qP = Object.prototype.propertyIsEnumerable;
var Gh = Math.pow, YP = (e, t, n) => t in e ? UY(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Be = (e, t) => {
  for (var n in t || (t = {}))
    XP.call(t, n) && YP(e, n, t[n]);
  if (Uh)
    for (var n of Uh(t))
      qP.call(t, n) && YP(e, n, t[n]);
  return e;
}, vt = (e, t) => GY(e, YY(t));
var Hr = (e, t) => {
  var n = {};
  for (var o in e)
    XP.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && Uh)
    for (var o of Uh(e))
      t.indexOf(o) < 0 && qP.call(e, o) && (n[o] = e[o]);
  return n;
};
var Rt = (e, t, n) => new Promise((o, l) => {
  var r = (s) => {
    try {
      i(n.next(s));
    } catch (c) {
      l(c);
    }
  }, a = (s) => {
    try {
      i(n.throw(s));
    } catch (c) {
      l(c);
    }
  }, i = (s) => s.done ? o(s.value) : Promise.resolve(s.value).then(r, a);
  i((n = n.apply(e, t)).next());
});
const XY = (e, t, n) => {
  const o = e[t];
  return o ? typeof o == "function" ? o() : Promise.resolve(o) : new Promise((l, r) => {
    (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(
      r.bind(
        null,
        new Error(
          "Unknown variable dynamic import: " + t + (t.split("/").length !== n ? ". Note that variables only represent file names one level deep." : "")
        )
      )
    );
  });
};
/**
* @vue/shared v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function Cs(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const n of e.split(",")) t[n] = 1;
  return (n) => n in t;
}
const eo = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, of = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], gn = () => {
}, AD = () => !1, Km = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // uppercase letter
(e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), s0 = (e) => e.startsWith("onUpdate:"), _o = Object.assign, IE = (e, t) => {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}, qY = Object.prototype.hasOwnProperty, hn = (e, t) => qY.call(e, t), We = Array.isArray, yu = (e) => Um(e) === "[object Map]", Zy = (e) => Um(e) === "[object Set]", vc = (e) => Um(e) === "[object Date]", it = (e) => typeof e == "function", rt = (e) => typeof e == "string", Ta = (e) => typeof e == "symbol", Mt = (e) => e !== null && typeof e == "object", mc = (e) => (Mt(e) || it(e)) && it(e.then) && it(e.catch), RD = Object.prototype.toString, Um = (e) => RD.call(e), TE = (e) => Um(e).slice(8, -1), Gv = (e) => Um(e) === "[object Object]", Qy = (e) => rt(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Cv = /* @__PURE__ */ Cs(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), JY = /* @__PURE__ */ Cs(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), e1 = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
}, ZY = /-\w/g, vl = e1(
  (e) => e.replace(ZY, (t) => t.slice(1).toUpperCase())
), QY = /\B([A-Z])/g, Si = e1(
  (e) => e.replace(QY, "-$1").toLowerCase()
), hc = e1((e) => e.charAt(0).toUpperCase() + e.slice(1)), Yi = e1(
  (e) => e ? `on${hc(e)}` : ""
), ac = (e, t) => !Object.is(e, t), Ld = (e, ...t) => {
  for (let n = 0; n < e.length; n++)
    e[n](...t);
}, c0 = (e, t, n, o = !1) => {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !1,
    writable: o,
    value: n
  });
}, PE = (e) => {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}, eX = (e) => {
  const t = rt(e) ? Number(e) : NaN;
  return isNaN(t) ? e : t;
};
let JP;
const Gm = () => JP || (JP = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : typeof window != "undefined" ? window : typeof global != "undefined" ? global : {});
function gt(e) {
  if (We(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const o = e[n], l = rt(o) ? lX(o) : gt(o);
      if (l)
        for (const r in l)
          t[r] = l[r];
    }
    return t;
  } else if (rt(e) || Mt(e))
    return e;
}
const tX = /;(?![^(]*\))/g, nX = /:([^]+)/, oX = /\/\*[^]*?\*\//g;
function lX(e) {
  const t = {};
  return e.replace(oX, "").split(tX).forEach((n) => {
    if (n) {
      const o = n.split(nX);
      o.length > 1 && (t[o[0].trim()] = o[1].trim());
    }
  }), t;
}
function X(e) {
  let t = "";
  if (rt(e))
    t = e;
  else if (We(e))
    for (let n = 0; n < e.length; n++) {
      const o = X(e[n]);
      o && (t += o + " ");
    }
  else if (Mt(e))
    for (const n in e)
      e[n] && (t += n + " ");
  return t.trim();
}
function cs(e) {
  if (!e) return null;
  let { class: t, style: n } = e;
  return t && !rt(t) && (e.class = X(t)), n && (e.style = gt(n)), e;
}
const rX = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", aX = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", iX = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", sX = /* @__PURE__ */ Cs(rX), cX = /* @__PURE__ */ Cs(aX), uX = /* @__PURE__ */ Cs(iX), dX = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", fX = /* @__PURE__ */ Cs(dX);
function DD(e) {
  return !!e || e === "";
}
function pX(e, t) {
  if (e.length !== t.length) return !1;
  let n = !0;
  for (let o = 0; n && o < e.length; o++)
    n = kf(e[o], t[o]);
  return n;
}
function kf(e, t) {
  if (e === t) return !0;
  let n = vc(e), o = vc(t);
  if (n || o)
    return n && o ? e.getTime() === t.getTime() : !1;
  if (n = Ta(e), o = Ta(t), n || o)
    return e === t;
  if (n = We(e), o = We(t), n || o)
    return n && o ? pX(e, t) : !1;
  if (n = Mt(e), o = Mt(t), n || o) {
    if (!n || !o)
      return !1;
    const l = Object.keys(e).length, r = Object.keys(t).length;
    if (l !== r)
      return !1;
    for (const a in e) {
      const i = e.hasOwnProperty(a), s = t.hasOwnProperty(a);
      if (i && !s || !i && s || !kf(e[a], t[a]))
        return !1;
    }
  }
  return String(e) === String(t);
}
function LD(e, t) {
  return e.findIndex((n) => kf(n, t));
}
const BD = (e) => !!(e && e.__v_isRef === !0), qe = (e) => rt(e) ? e : e == null ? "" : We(e) || Mt(e) && (e.toString === RD || !it(e.toString)) ? BD(e) ? qe(e.value) : JSON.stringify(e, FD, 2) : String(e), FD = (e, t) => BD(t) ? FD(e, t.value) : yu(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce(
    (n, [o, l], r) => (n[pC(o, r) + " =>"] = l, n),
    {}
  )
} : Zy(t) ? {
  [`Set(${t.size})`]: [...t.values()].map((n) => pC(n))
} : Ta(t) ? pC(t) : Mt(t) && !We(t) && !Gv(t) ? String(t) : t, pC = (e, t = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Ta(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e
  );
};
/**
* @vue/reactivity v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Rr(e, ...t) {
  console.warn(`[Vue warn] ${e}`, ...t);
}
let Ol;
class VD {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Ol, !t && Ol && (this.index = (Ol.scopes || (Ol.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let t, n;
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++)
          this.scopes[t].pause();
      for (t = 0, n = this.effects.length; t < n; t++)
        this.effects[t].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let t, n;
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++)
          this.scopes[t].resume();
      for (t = 0, n = this.effects.length; t < n; t++)
        this.effects[t].resume();
    }
  }
  run(t) {
    if (this._active) {
      const n = Ol;
      try {
        return Ol = this, t();
      } finally {
        Ol = n;
      }
    } else process.env.NODE_ENV !== "production" && Rr("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Ol, Ol = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Ol = this.prevScope, this.prevScope = void 0);
  }
  stop(t) {
    if (this._active) {
      this._active = !1;
      let n, o;
      for (n = 0, o = this.effects.length; n < o; n++)
        this.effects[n].stop();
      for (this.effects.length = 0, n = 0, o = this.cleanups.length; n < o; n++)
        this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, o = this.scopes.length; n < o; n++)
          this.scopes[n].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !t) {
        const l = this.parent.scopes.pop();
        l && l !== this && (this.parent.scopes[this.index] = l, l.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function kE(e) {
  return new VD(e);
}
function NE() {
  return Ol;
}
function ME(e, t = !1) {
  Ol ? Ol.cleanups.push(e) : process.env.NODE_ENV !== "production" && !t && Rr(
    "onScopeDispose() is called when there is no active effect scope to be associated with."
  );
}
let Qn;
const vC = /* @__PURE__ */ new WeakSet();
class zD {
  constructor(t) {
    this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Ol && Ol.active && Ol.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, vC.has(this) && (vC.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || jD(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, ZP(this), WD(this);
    const t = Qn, n = Ca;
    Qn = this, Ca = !0;
    try {
      return this.fn();
    } finally {
      process.env.NODE_ENV !== "production" && Qn !== this && Rr(
        "Active effect was not restored correctly - this is likely a Vue internal bug."
      ), KD(this), Qn = t, Ca = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let t = this.deps; t; t = t.nextDep)
        DE(t);
      this.deps = this.depsTail = void 0, ZP(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? vC.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    w$(this) && this.run();
  }
  get dirty() {
    return w$(this);
  }
}
let HD = 0, wv, $v;
function jD(e, t = !1) {
  if (e.flags |= 8, t) {
    e.next = $v, $v = e;
    return;
  }
  e.next = wv, wv = e;
}
function AE() {
  HD++;
}
function RE() {
  if (--HD > 0)
    return;
  if ($v) {
    let t = $v;
    for ($v = void 0; t; ) {
      const n = t.next;
      t.next = void 0, t.flags &= -9, t = n;
    }
  }
  let e;
  for (; wv; ) {
    let t = wv;
    for (wv = void 0; t; ) {
      const n = t.next;
      if (t.next = void 0, t.flags &= -9, t.flags & 1)
        try {
          t.trigger();
        } catch (o) {
          e || (e = o);
        }
      t = n;
    }
  }
  if (e) throw e;
}
function WD(e) {
  for (let t = e.deps; t; t = t.nextDep)
    t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t;
}
function KD(e) {
  let t, n = e.depsTail, o = n;
  for (; o; ) {
    const l = o.prevDep;
    o.version === -1 ? (o === n && (n = l), DE(o), vX(o)) : t = o, o.dep.activeLink = o.prevActiveLink, o.prevActiveLink = void 0, o = l;
  }
  e.deps = t, e.depsTail = n;
}
function w$(e) {
  for (let t = e.deps; t; t = t.nextDep)
    if (t.dep.version !== t.version || t.dep.computed && (UD(t.dep.computed) || t.dep.version !== t.version))
      return !0;
  return !!e._dirty;
}
function UD(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === Yv) || (e.globalVersion = Yv, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !w$(e))))
    return;
  e.flags |= 2;
  const t = e.dep, n = Qn, o = Ca;
  Qn = e, Ca = !0;
  try {
    WD(e);
    const l = e.fn(e._value);
    (t.version === 0 || ac(l, e._value)) && (e.flags |= 128, e._value = l, t.version++);
  } catch (l) {
    throw t.version++, l;
  } finally {
    Qn = n, Ca = o, KD(e), e.flags &= -3;
  }
}
function DE(e, t = !1) {
  const { dep: n, prevSub: o, nextSub: l } = e;
  if (o && (o.nextSub = l, e.prevSub = void 0), l && (l.prevSub = o, e.nextSub = void 0), process.env.NODE_ENV !== "production" && n.subsHead === e && (n.subsHead = l), n.subs === e && (n.subs = o, !o && n.computed)) {
    n.computed.flags &= -5;
    for (let r = n.computed.deps; r; r = r.nextDep)
      DE(r, !0);
  }
  !t && !--n.sc && n.map && n.map.delete(n.key);
}
function vX(e) {
  const { prevDep: t, nextDep: n } = e;
  t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0);
}
let Ca = !0;
const GD = [];
function Pa() {
  GD.push(Ca), Ca = !1;
}
function ka() {
  const e = GD.pop();
  Ca = e === void 0 ? !0 : e;
}
function ZP(e) {
  const { cleanup: t } = e;
  if (e.cleanup = void 0, t) {
    const n = Qn;
    Qn = void 0;
    try {
      t();
    } finally {
      Qn = n;
    }
  }
}
let Yv = 0, mX = class {
  constructor(t, n) {
    this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
};
class LE {
  // TODO isolatedDeclarations "__v_skip"
  constructor(t) {
    this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0, process.env.NODE_ENV !== "production" && (this.subsHead = void 0);
  }
  track(t) {
    if (!Qn || !Ca || Qn === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== Qn)
      n = this.activeLink = new mX(Qn, this), Qn.deps ? (n.prevDep = Qn.depsTail, Qn.depsTail.nextDep = n, Qn.depsTail = n) : Qn.deps = Qn.depsTail = n, YD(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const o = n.nextDep;
      o.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = o), n.prevDep = Qn.depsTail, n.nextDep = void 0, Qn.depsTail.nextDep = n, Qn.depsTail = n, Qn.deps === n && (Qn.deps = o);
    }
    return process.env.NODE_ENV !== "production" && Qn.onTrack && Qn.onTrack(
      _o(
        {
          effect: Qn
        },
        t
      )
    ), n;
  }
  trigger(t) {
    this.version++, Yv++, this.notify(t);
  }
  notify(t) {
    AE();
    try {
      if (process.env.NODE_ENV !== "production")
        for (let n = this.subsHead; n; n = n.nextSub)
          n.sub.onTrigger && !(n.sub.flags & 8) && n.sub.onTrigger(
            _o(
              {
                effect: n.sub
              },
              t
            )
          );
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      RE();
    }
  }
}
function YD(e) {
  if (e.dep.sc++, e.sub.flags & 4) {
    const t = e.dep.computed;
    if (t && !e.dep.subs) {
      t.flags |= 20;
      for (let o = t.deps; o; o = o.nextDep)
        YD(o);
    }
    const n = e.dep.subs;
    n !== e && (e.prevSub = n, n && (n.nextSub = e)), process.env.NODE_ENV !== "production" && e.dep.subsHead === void 0 && (e.dep.subsHead = e), e.dep.subs = e;
  }
}
const u0 = /* @__PURE__ */ new WeakMap(), Su = /* @__PURE__ */ Symbol(
  process.env.NODE_ENV !== "production" ? "Object iterate" : ""
), $$ = /* @__PURE__ */ Symbol(
  process.env.NODE_ENV !== "production" ? "Map keys iterate" : ""
), Xv = /* @__PURE__ */ Symbol(
  process.env.NODE_ENV !== "production" ? "Array iterate" : ""
);
function tl(e, t, n) {
  if (Ca && Qn) {
    let o = u0.get(e);
    o || u0.set(e, o = /* @__PURE__ */ new Map());
    let l = o.get(n);
    l || (o.set(n, l = new LE()), l.map = o, l.key = n), process.env.NODE_ENV !== "production" ? l.track({
      target: e,
      type: t,
      key: n
    }) : l.track();
  }
}
function si(e, t, n, o, l, r) {
  const a = u0.get(e);
  if (!a) {
    Yv++;
    return;
  }
  const i = (s) => {
    s && (process.env.NODE_ENV !== "production" ? s.trigger({
      target: e,
      type: t,
      key: n,
      newValue: o,
      oldValue: l,
      oldTarget: r
    }) : s.trigger());
  };
  if (AE(), t === "clear")
    a.forEach(i);
  else {
    const s = We(e), c = s && Qy(n);
    if (s && n === "length") {
      const u = Number(o);
      a.forEach((d, f) => {
        (f === "length" || f === Xv || !Ta(f) && f >= u) && i(d);
      });
    } else
      switch ((n !== void 0 || a.has(void 0)) && i(a.get(n)), c && i(a.get(Xv)), t) {
        case "add":
          s ? c && i(a.get("length")) : (i(a.get(Su)), yu(e) && i(a.get($$)));
          break;
        case "delete":
          s || (i(a.get(Su)), yu(e) && i(a.get($$)));
          break;
        case "set":
          yu(e) && i(a.get(Su));
          break;
      }
  }
  RE();
}
function hX(e, t) {
  const n = u0.get(e);
  return n && n.get(t);
}
function Sd(e) {
  const t = /* @__PURE__ */ Wt(e);
  return t === e ? t : (tl(t, "iterate", Xv), /* @__PURE__ */ Ml(e) ? t : t.map(Ma));
}
function t1(e) {
  return tl(e = /* @__PURE__ */ Wt(e), "iterate", Xv), e;
}
function Hs(e, t) {
  return /* @__PURE__ */ Na(e) ? Mf(/* @__PURE__ */ ic(e) ? Ma(t) : t) : Ma(t);
}
const gX = {
  __proto__: null,
  [Symbol.iterator]() {
    return mC(this, Symbol.iterator, (e) => Hs(this, e));
  },
  concat(...e) {
    return Sd(this).concat(
      ...e.map((t) => We(t) ? Sd(t) : t)
    );
  },
  entries() {
    return mC(this, "entries", (e) => (e[1] = Hs(this, e[1]), e));
  },
  every(e, t) {
    return Li(this, "every", e, t, void 0, arguments);
  },
  filter(e, t) {
    return Li(
      this,
      "filter",
      e,
      t,
      (n) => n.map((o) => Hs(this, o)),
      arguments
    );
  },
  find(e, t) {
    return Li(
      this,
      "find",
      e,
      t,
      (n) => Hs(this, n),
      arguments
    );
  },
  findIndex(e, t) {
    return Li(this, "findIndex", e, t, void 0, arguments);
  },
  findLast(e, t) {
    return Li(
      this,
      "findLast",
      e,
      t,
      (n) => Hs(this, n),
      arguments
    );
  },
  findLastIndex(e, t) {
    return Li(this, "findLastIndex", e, t, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e, t) {
    return Li(this, "forEach", e, t, void 0, arguments);
  },
  includes(...e) {
    return hC(this, "includes", e);
  },
  indexOf(...e) {
    return hC(this, "indexOf", e);
  },
  join(e) {
    return Sd(this).join(e);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...e) {
    return hC(this, "lastIndexOf", e);
  },
  map(e, t) {
    return Li(this, "map", e, t, void 0, arguments);
  },
  pop() {
    return Up(this, "pop");
  },
  push(...e) {
    return Up(this, "push", e);
  },
  reduce(e, ...t) {
    return QP(this, "reduce", e, t);
  },
  reduceRight(e, ...t) {
    return QP(this, "reduceRight", e, t);
  },
  shift() {
    return Up(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e, t) {
    return Li(this, "some", e, t, void 0, arguments);
  },
  splice(...e) {
    return Up(this, "splice", e);
  },
  toReversed() {
    return Sd(this).toReversed();
  },
  toSorted(e) {
    return Sd(this).toSorted(e);
  },
  toSpliced(...e) {
    return Sd(this).toSpliced(...e);
  },
  unshift(...e) {
    return Up(this, "unshift", e);
  },
  values() {
    return mC(this, "values", (e) => Hs(this, e));
  }
};
function mC(e, t, n) {
  const o = t1(e), l = o[t]();
  return o !== e && !/* @__PURE__ */ Ml(e) && (l._next = l.next, l.next = () => {
    const r = l._next();
    return r.done || (r.value = n(r.value)), r;
  }), l;
}
const bX = Array.prototype;
function Li(e, t, n, o, l, r) {
  const a = t1(e), i = a !== e && !/* @__PURE__ */ Ml(e), s = a[t];
  if (s !== bX[t]) {
    const d = s.apply(e, r);
    return i ? Ma(d) : d;
  }
  let c = n;
  a !== e && (i ? c = function(d, f) {
    return n.call(this, Hs(e, d), f, e);
  } : n.length > 2 && (c = function(d, f) {
    return n.call(this, d, f, e);
  }));
  const u = s.call(a, c, o);
  return i && l ? l(u) : u;
}
function QP(e, t, n, o) {
  const l = t1(e);
  let r = n;
  return l !== e && (/* @__PURE__ */ Ml(e) ? n.length > 3 && (r = function(a, i, s) {
    return n.call(this, a, i, s, e);
  }) : r = function(a, i, s) {
    return n.call(this, a, Hs(e, i), s, e);
  }), l[t](r, ...o);
}
function hC(e, t, n) {
  const o = /* @__PURE__ */ Wt(e);
  tl(o, "iterate", Xv);
  const l = o[t](...n);
  return (l === -1 || l === !1) && /* @__PURE__ */ Nf(n[0]) ? (n[0] = /* @__PURE__ */ Wt(n[0]), o[t](...n)) : l;
}
function Up(e, t, n = []) {
  Pa(), AE();
  const o = (/* @__PURE__ */ Wt(e))[t].apply(e, n);
  return RE(), ka(), o;
}
const yX = /* @__PURE__ */ Cs("__proto__,__v_isRef,__isVue"), XD = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(Ta)
);
function SX(e) {
  Ta(e) || (e = String(e));
  const t = /* @__PURE__ */ Wt(this);
  return tl(t, "has", e), t.hasOwnProperty(e);
}
class qD {
  constructor(t = !1, n = !1) {
    this._isReadonly = t, this._isShallow = n;
  }
  get(t, n, o) {
    if (n === "__v_skip") return t.__v_skip;
    const l = this._isReadonly, r = this._isShallow;
    if (n === "__v_isReactive")
      return !l;
    if (n === "__v_isReadonly")
      return l;
    if (n === "__v_isShallow")
      return r;
    if (n === "__v_raw")
      return o === (l ? r ? n5 : t5 : r ? e5 : QD).get(t) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(t) === Object.getPrototypeOf(o) ? t : void 0;
    const a = We(t);
    if (!l) {
      let s;
      if (a && (s = gX[n]))
        return s;
      if (n === "hasOwnProperty")
        return SX;
    }
    const i = Reflect.get(
      t,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      /* @__PURE__ */ kn(t) ? t : o
    );
    if ((Ta(n) ? XD.has(n) : yX(n)) || (l || tl(t, "get", n), r))
      return i;
    if (/* @__PURE__ */ kn(i)) {
      const s = a && Qy(n) ? i : i.value;
      return l && Mt(s) ? /* @__PURE__ */ Du(s) : s;
    }
    return Mt(i) ? l ? /* @__PURE__ */ Du(i) : /* @__PURE__ */ kt(i) : i;
  }
}
class JD extends qD {
  constructor(t = !1) {
    super(!1, t);
  }
  set(t, n, o, l) {
    let r = t[n];
    const a = We(t) && Qy(n);
    if (!this._isShallow) {
      const c = /* @__PURE__ */ Na(r);
      if (!/* @__PURE__ */ Ml(o) && !/* @__PURE__ */ Na(o) && (r = /* @__PURE__ */ Wt(r), o = /* @__PURE__ */ Wt(o)), !a && /* @__PURE__ */ kn(r) && !/* @__PURE__ */ kn(o))
        return c ? (process.env.NODE_ENV !== "production" && Rr(
          `Set operation on key "${String(n)}" failed: target is readonly.`,
          t[n]
        ), !0) : (r.value = o, !0);
    }
    const i = a ? Number(n) < t.length : hn(t, n), s = Reflect.set(
      t,
      n,
      o,
      /* @__PURE__ */ kn(t) ? t : l
    );
    return t === /* @__PURE__ */ Wt(l) && (i ? ac(o, r) && si(t, "set", n, o, r) : si(t, "add", n, o)), s;
  }
  deleteProperty(t, n) {
    const o = hn(t, n), l = t[n], r = Reflect.deleteProperty(t, n);
    return r && o && si(t, "delete", n, void 0, l), r;
  }
  has(t, n) {
    const o = Reflect.has(t, n);
    return (!Ta(n) || !XD.has(n)) && tl(t, "has", n), o;
  }
  ownKeys(t) {
    return tl(
      t,
      "iterate",
      We(t) ? "length" : Su
    ), Reflect.ownKeys(t);
  }
}
class ZD extends qD {
  constructor(t = !1) {
    super(!0, t);
  }
  set(t, n) {
    return process.env.NODE_ENV !== "production" && Rr(
      `Set operation on key "${String(n)}" failed: target is readonly.`,
      t
    ), !0;
  }
  deleteProperty(t, n) {
    return process.env.NODE_ENV !== "production" && Rr(
      `Delete operation on key "${String(n)}" failed: target is readonly.`,
      t
    ), !0;
  }
}
const CX = /* @__PURE__ */ new JD(), wX = /* @__PURE__ */ new ZD(), $X = /* @__PURE__ */ new JD(!0), xX = /* @__PURE__ */ new ZD(!0), x$ = (e) => e, Yh = (e) => Reflect.getPrototypeOf(e);
function EX(e, t, n) {
  return function(...o) {
    const l = this.__v_raw, r = /* @__PURE__ */ Wt(l), a = yu(r), i = e === "entries" || e === Symbol.iterator && a, s = e === "keys" && a, c = l[e](...o), u = n ? x$ : t ? Mf : Ma;
    return !t && tl(
      r,
      "iterate",
      s ? $$ : Su
    ), _o(
      // inheriting all iterator properties
      Object.create(c),
      {
        // iterator protocol
        next() {
          const { value: d, done: f } = c.next();
          return f ? { value: d, done: f } : {
            value: i ? [u(d[0]), u(d[1])] : u(d),
            done: f
          };
        }
      }
    );
  };
}
function Xh(e) {
  return function(...t) {
    if (process.env.NODE_ENV !== "production") {
      const n = t[0] ? `on key "${t[0]}" ` : "";
      Rr(
        `${hc(e)} operation ${n}failed: target is readonly.`,
        /* @__PURE__ */ Wt(this)
      );
    }
    return e === "delete" ? !1 : e === "clear" ? void 0 : this;
  };
}
function OX(e, t) {
  const n = {
    get(l) {
      const r = this.__v_raw, a = /* @__PURE__ */ Wt(r), i = /* @__PURE__ */ Wt(l);
      e || (ac(l, i) && tl(a, "get", l), tl(a, "get", i));
      const { has: s } = Yh(a), c = t ? x$ : e ? Mf : Ma;
      if (s.call(a, l))
        return c(r.get(l));
      if (s.call(a, i))
        return c(r.get(i));
      r !== a && r.get(l);
    },
    get size() {
      const l = this.__v_raw;
      return !e && tl(/* @__PURE__ */ Wt(l), "iterate", Su), l.size;
    },
    has(l) {
      const r = this.__v_raw, a = /* @__PURE__ */ Wt(r), i = /* @__PURE__ */ Wt(l);
      return e || (ac(l, i) && tl(a, "has", l), tl(a, "has", i)), l === i ? r.has(l) : r.has(l) || r.has(i);
    },
    forEach(l, r) {
      const a = this, i = a.__v_raw, s = /* @__PURE__ */ Wt(i), c = t ? x$ : e ? Mf : Ma;
      return !e && tl(s, "iterate", Su), i.forEach((u, d) => l.call(r, c(u), c(d), a));
    }
  };
  return _o(
    n,
    e ? {
      add: Xh("add"),
      set: Xh("set"),
      delete: Xh("delete"),
      clear: Xh("clear")
    } : {
      add(l) {
        !t && !/* @__PURE__ */ Ml(l) && !/* @__PURE__ */ Na(l) && (l = /* @__PURE__ */ Wt(l));
        const r = /* @__PURE__ */ Wt(this);
        return Yh(r).has.call(r, l) || (r.add(l), si(r, "add", l, l)), this;
      },
      set(l, r) {
        !t && !/* @__PURE__ */ Ml(r) && !/* @__PURE__ */ Na(r) && (r = /* @__PURE__ */ Wt(r));
        const a = /* @__PURE__ */ Wt(this), { has: i, get: s } = Yh(a);
        let c = i.call(a, l);
        c ? process.env.NODE_ENV !== "production" && ek(a, i, l) : (l = /* @__PURE__ */ Wt(l), c = i.call(a, l));
        const u = s.call(a, l);
        return a.set(l, r), c ? ac(r, u) && si(a, "set", l, r, u) : si(a, "add", l, r), this;
      },
      delete(l) {
        const r = /* @__PURE__ */ Wt(this), { has: a, get: i } = Yh(r);
        let s = a.call(r, l);
        s ? process.env.NODE_ENV !== "production" && ek(r, a, l) : (l = /* @__PURE__ */ Wt(l), s = a.call(r, l));
        const c = i ? i.call(r, l) : void 0, u = r.delete(l);
        return s && si(r, "delete", l, void 0, c), u;
      },
      clear() {
        const l = /* @__PURE__ */ Wt(this), r = l.size !== 0, a = process.env.NODE_ENV !== "production" ? yu(l) ? new Map(l) : new Set(l) : void 0, i = l.clear();
        return r && si(
          l,
          "clear",
          void 0,
          void 0,
          a
        ), i;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((l) => {
    n[l] = EX(l, e, t);
  }), n;
}
function n1(e, t) {
  const n = OX(e, t);
  return (o, l, r) => l === "__v_isReactive" ? !e : l === "__v_isReadonly" ? e : l === "__v_raw" ? o : Reflect.get(
    hn(n, l) && l in o ? n : o,
    l,
    r
  );
}
const _X = {
  get: /* @__PURE__ */ n1(!1, !1)
}, IX = {
  get: /* @__PURE__ */ n1(!1, !0)
}, TX = {
  get: /* @__PURE__ */ n1(!0, !1)
}, PX = {
  get: /* @__PURE__ */ n1(!0, !0)
};
function ek(e, t, n) {
  const o = /* @__PURE__ */ Wt(n);
  if (o !== n && t.call(e, o)) {
    const l = TE(e);
    Rr(
      `Reactive ${l} contains both the raw and reactive versions of the same object${l === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const QD = /* @__PURE__ */ new WeakMap(), e5 = /* @__PURE__ */ new WeakMap(), t5 = /* @__PURE__ */ new WeakMap(), n5 = /* @__PURE__ */ new WeakMap();
function kX(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function NX(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : kX(TE(e));
}
// @__NO_SIDE_EFFECTS__
function kt(e) {
  return /* @__PURE__ */ Na(e) ? e : l1(
    e,
    !1,
    CX,
    _X,
    QD
  );
}
// @__NO_SIDE_EFFECTS__
function o1(e) {
  return l1(
    e,
    !1,
    $X,
    IX,
    e5
  );
}
// @__NO_SIDE_EFFECTS__
function Du(e) {
  return l1(
    e,
    !0,
    wX,
    TX,
    t5
  );
}
// @__NO_SIDE_EFFECTS__
function ci(e) {
  return l1(
    e,
    !0,
    xX,
    PX,
    n5
  );
}
function l1(e, t, n, o, l) {
  if (!Mt(e))
    return process.env.NODE_ENV !== "production" && Rr(
      `value cannot be made ${t ? "readonly" : "reactive"}: ${String(
        e
      )}`
    ), e;
  if (e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const r = NX(e);
  if (r === 0)
    return e;
  const a = l.get(e);
  if (a)
    return a;
  const i = new Proxy(
    e,
    r === 2 ? o : n
  );
  return l.set(e, i), i;
}
// @__NO_SIDE_EFFECTS__
function ic(e) {
  return /* @__PURE__ */ Na(e) ? /* @__PURE__ */ ic(e.__v_raw) : !!(e && e.__v_isReactive);
}
// @__NO_SIDE_EFFECTS__
function Na(e) {
  return !!(e && e.__v_isReadonly);
}
// @__NO_SIDE_EFFECTS__
function Ml(e) {
  return !!(e && e.__v_isShallow);
}
// @__NO_SIDE_EFFECTS__
function Nf(e) {
  return e ? !!e.__v_raw : !1;
}
// @__NO_SIDE_EFFECTS__
function Wt(e) {
  const t = e && e.__v_raw;
  return t ? /* @__PURE__ */ Wt(t) : e;
}
function wa(e) {
  return !hn(e, "__v_skip") && Object.isExtensible(e) && c0(e, "__v_skip", !0), e;
}
const Ma = (e) => Mt(e) ? /* @__PURE__ */ kt(e) : e, Mf = (e) => Mt(e) ? /* @__PURE__ */ Du(e) : e;
// @__NO_SIDE_EFFECTS__
function kn(e) {
  return e ? e.__v_isRef === !0 : !1;
}
// @__NO_SIDE_EFFECTS__
function H(e) {
  return o5(e, !1);
}
// @__NO_SIDE_EFFECTS__
function Ce(e) {
  return o5(e, !0);
}
function o5(e, t) {
  return /* @__PURE__ */ kn(e) ? e : new MX(e, t);
}
class MX {
  constructor(t, n) {
    this.dep = new LE(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : /* @__PURE__ */ Wt(t), this._value = n ? t : Ma(t), this.__v_isShallow = n;
  }
  get value() {
    return process.env.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track(), this._value;
  }
  set value(t) {
    const n = this._rawValue, o = this.__v_isShallow || /* @__PURE__ */ Ml(t) || /* @__PURE__ */ Na(t);
    t = o ? t : /* @__PURE__ */ Wt(t), ac(t, n) && (this._rawValue = t, this._value = o ? t : Ma(t), process.env.NODE_ENV !== "production" ? this.dep.trigger({
      target: this,
      type: "set",
      key: "value",
      newValue: t,
      oldValue: n
    }) : this.dep.trigger());
  }
}
function lf(e) {
  e.dep && (process.env.NODE_ENV !== "production" ? e.dep.trigger({
    target: e,
    type: "set",
    key: "value",
    newValue: e._value
  }) : e.dep.trigger());
}
function S(e) {
  return /* @__PURE__ */ kn(e) ? e.value : e;
}
const AX = {
  get: (e, t, n) => t === "__v_raw" ? e : S(Reflect.get(e, t, n)),
  set: (e, t, n, o) => {
    const l = e[t];
    return /* @__PURE__ */ kn(l) && !/* @__PURE__ */ kn(n) ? (l.value = n, !0) : Reflect.set(e, t, n, o);
  }
};
function l5(e) {
  return /* @__PURE__ */ ic(e) ? e : new Proxy(e, AX);
}
// @__NO_SIDE_EFFECTS__
function to(e) {
  process.env.NODE_ENV !== "production" && !/* @__PURE__ */ Nf(e) && Rr("toRefs() expects a reactive object but received a plain one.");
  const t = We(e) ? new Array(e.length) : {};
  for (const n in e)
    t[n] = r5(e, n);
  return t;
}
class RX {
  constructor(t, n, o) {
    this._object = t, this._key = n, this._defaultValue = o, this.__v_isRef = !0, this._value = void 0, this._raw = /* @__PURE__ */ Wt(t);
    let l = !0, r = t;
    if (!We(t) || !Qy(String(n)))
      do
        l = !/* @__PURE__ */ Nf(r) || /* @__PURE__ */ Ml(r);
      while (l && (r = r.__v_raw));
    this._shallow = l;
  }
  get value() {
    let t = this._object[this._key];
    return this._shallow && (t = S(t)), this._value = t === void 0 ? this._defaultValue : t;
  }
  set value(t) {
    if (this._shallow && /* @__PURE__ */ kn(this._raw[this._key])) {
      const n = this._object[this._key];
      if (/* @__PURE__ */ kn(n)) {
        n.value = t;
        return;
      }
    }
    this._object[this._key] = t;
  }
  get dep() {
    return hX(this._raw, this._key);
  }
}
class DX {
  constructor(t) {
    this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
// @__NO_SIDE_EFFECTS__
function ft(e, t, n) {
  return /* @__PURE__ */ kn(e) ? e : it(e) ? new DX(e) : Mt(e) && arguments.length > 1 ? r5(e, t, n) : /* @__PURE__ */ H(e);
}
function r5(e, t, n) {
  return new RX(e, t, n);
}
class LX {
  constructor(t, n, o) {
    this.fn = t, this.setter = n, this._value = void 0, this.dep = new LE(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Yv - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = o;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Qn !== this)
      return jD(this, !0), !0;
    process.env.NODE_ENV;
  }
  get value() {
    const t = process.env.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track();
    return UD(this), t && (t.version = this.dep.version), this._value;
  }
  set value(t) {
    this.setter ? this.setter(t) : process.env.NODE_ENV !== "production" && Rr("Write operation failed: computed value is readonly");
  }
}
// @__NO_SIDE_EFFECTS__
function BX(e, t, n = !1) {
  let o, l;
  it(e) ? o = e : (o = e.get, l = e.set);
  const r = new LX(o, l, n);
  return process.env.NODE_ENV, r;
}
const qh = {}, d0 = /* @__PURE__ */ new WeakMap();
let Jc;
function FX(e, t = !1, n = Jc) {
  if (n) {
    let o = d0.get(n);
    o || d0.set(n, o = []), o.push(e);
  } else process.env.NODE_ENV !== "production" && !t && Rr(
    "onWatcherCleanup() was called when there was no active watcher to associate with."
  );
}
function VX(e, t, n = eo) {
  const { immediate: o, deep: l, once: r, scheduler: a, augmentJob: i, call: s } = n, c = (w) => {
    (n.onWarn || Rr)(
      "Invalid watch source: ",
      w,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, u = (w) => l ? w : /* @__PURE__ */ Ml(w) || l === !1 || l === 0 ? Qi(w, 1) : Qi(w);
  let d, f, p, m, v = !1, h = !1;
  if (/* @__PURE__ */ kn(e) ? (f = () => e.value, v = /* @__PURE__ */ Ml(e)) : /* @__PURE__ */ ic(e) ? (f = () => u(e), v = !0) : We(e) ? (h = !0, v = e.some((w) => /* @__PURE__ */ ic(w) || /* @__PURE__ */ Ml(w)), f = () => e.map((w) => {
    if (/* @__PURE__ */ kn(w))
      return w.value;
    if (/* @__PURE__ */ ic(w))
      return u(w);
    if (it(w))
      return s ? s(w, 2) : w();
    process.env.NODE_ENV !== "production" && c(w);
  })) : it(e) ? t ? f = s ? () => s(e, 2) : e : f = () => {
    if (p) {
      Pa();
      try {
        p();
      } finally {
        ka();
      }
    }
    const w = Jc;
    Jc = d;
    try {
      return s ? s(e, 3, [m]) : e(m);
    } finally {
      Jc = w;
    }
  } : (f = gn, process.env.NODE_ENV !== "production" && c(e)), t && l) {
    const w = f, x = l === !0 ? 1 / 0 : l;
    f = () => Qi(w(), x);
  }
  const g = NE(), y = () => {
    d.stop(), g && g.active && IE(g.effects, d);
  };
  if (r && t) {
    const w = t;
    t = (...x) => {
      w(...x), y();
    };
  }
  let b = h ? new Array(e.length).fill(qh) : qh;
  const C = (w) => {
    if (!(!(d.flags & 1) || !d.dirty && !w))
      if (t) {
        const x = d.run();
        if (l || v || (h ? x.some((E, I) => ac(E, b[I])) : ac(x, b))) {
          p && p();
          const E = Jc;
          Jc = d;
          try {
            const I = [
              x,
              // pass undefined as the old value when it's changed for the first time
              b === qh ? void 0 : h && b[0] === qh ? [] : b,
              m
            ];
            b = x, s ? s(t, 3, I) : (
              // @ts-expect-error
              t(...I)
            );
          } finally {
            Jc = E;
          }
        }
      } else
        d.run();
  };
  return i && i(C), d = new zD(f), d.scheduler = a ? () => a(C, !1) : C, m = (w) => FX(w, !1, d), p = d.onStop = () => {
    const w = d0.get(d);
    if (w) {
      if (s)
        s(w, 4);
      else
        for (const x of w) x();
      d0.delete(d);
    }
  }, process.env.NODE_ENV !== "production" && (d.onTrack = n.onTrack, d.onTrigger = n.onTrigger), t ? o ? C(!0) : b = d.run() : a ? a(C.bind(null, !0), !0) : d.run(), y.pause = d.pause.bind(d), y.resume = d.resume.bind(d), y.stop = y, y;
}
function Qi(e, t = 1 / 0, n) {
  if (t <= 0 || !Mt(e) || e.__v_skip || (n = n || /* @__PURE__ */ new Map(), (n.get(e) || 0) >= t))
    return e;
  if (n.set(e, t), t--, /* @__PURE__ */ kn(e))
    Qi(e.value, t, n);
  else if (We(e))
    for (let o = 0; o < e.length; o++)
      Qi(e[o], t, n);
  else if (Zy(e) || yu(e))
    e.forEach((o) => {
      Qi(o, t, n);
    });
  else if (Gv(e)) {
    for (const o in e)
      Qi(e[o], t, n);
    for (const o of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, o) && Qi(e[o], t, n);
  }
  return e;
}
/**
* @vue/runtime-core v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const Cu = [];
function Jg(e) {
  Cu.push(e);
}
function Zg() {
  Cu.pop();
}
let gC = !1;
function $t(e, ...t) {
  if (gC) return;
  gC = !0, Pa();
  const n = Cu.length ? Cu[Cu.length - 1].component : null, o = n && n.appContext.config.warnHandler, l = zX();
  if (o)
    pp(
      o,
      n,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        e + t.map((r) => {
          var a, i;
          return (i = (a = r.toString) == null ? void 0 : a.call(r)) != null ? i : JSON.stringify(r);
        }).join(""),
        n && n.proxy,
        l.map(
          ({ vnode: r }) => `at <${Zm(n, r.type)}>`
        ).join(`
`),
        l
      ]
    );
  else {
    const r = [`[Vue warn]: ${e}`, ...t];
    l.length && r.push(`
`, ...HX(l)), console.warn(...r);
  }
  ka(), gC = !1;
}
function zX() {
  let e = Cu[Cu.length - 1];
  if (!e)
    return [];
  const t = [];
  for (; e; ) {
    const n = t[0];
    n && n.vnode === e ? n.recurseCount++ : t.push({
      vnode: e,
      recurseCount: 0
    });
    const o = e.component && e.component.parent;
    e = o && o.vnode;
  }
  return t;
}
function HX(e) {
  const t = [];
  return e.forEach((n, o) => {
    t.push(...o === 0 ? [] : [`
`], ...jX(n));
  }), t;
}
function jX({ vnode: e, recurseCount: t }) {
  const n = t > 0 ? `... (${t} recursive calls)` : "", o = e.component ? e.component.parent == null : !1, l = ` at <${Zm(
    e.component,
    e.type,
    o
  )}`, r = ">" + n;
  return e.props ? [l, ...WX(e.props), r] : [l + r];
}
function WX(e) {
  const t = [], n = Object.keys(e);
  return n.slice(0, 3).forEach((o) => {
    t.push(...a5(o, e[o]));
  }), n.length > 3 && t.push(" ..."), t;
}
function a5(e, t, n) {
  return rt(t) ? (t = JSON.stringify(t), n ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? n ? t : [`${e}=${t}`] : /* @__PURE__ */ kn(t) ? (t = a5(e, /* @__PURE__ */ Wt(t.value), !0), n ? t : [`${e}=Ref<`, t, ">"]) : it(t) ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`] : (t = /* @__PURE__ */ Wt(t), n ? t : [`${e}=`, t]);
}
function KX(e, t) {
  process.env.NODE_ENV !== "production" && e !== void 0 && (typeof e != "number" ? $t(`${t} is not a valid number - got ${JSON.stringify(e)}.`) : isNaN(e) && $t(`${t} is NaN - the duration expression might be incorrect.`));
}
const BE = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function pp(e, t, n, o) {
  try {
    return o ? e(...o) : e();
  } catch (l) {
    Ym(l, t, n);
  }
}
function Aa(e, t, n, o) {
  if (it(e)) {
    const l = pp(e, t, n, o);
    return l && mc(l) && l.catch((r) => {
      Ym(r, t, n);
    }), l;
  }
  if (We(e)) {
    const l = [];
    for (let r = 0; r < e.length; r++)
      l.push(Aa(e[r], t, n, o));
    return l;
  } else process.env.NODE_ENV !== "production" && $t(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof e}`
  );
}
function Ym(e, t, n, o = !0) {
  const l = t ? t.vnode : null, { errorHandler: r, throwUnhandledErrorInProduction: a } = t && t.appContext.config || eo;
  if (t) {
    let i = t.parent;
    const s = t.proxy, c = process.env.NODE_ENV !== "production" ? BE[n] : `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; i; ) {
      const u = i.ec;
      if (u) {
        for (let d = 0; d < u.length; d++)
          if (u[d](e, s, c) === !1)
            return;
      }
      i = i.parent;
    }
    if (r) {
      Pa(), pp(r, null, 10, [
        e,
        s,
        c
      ]), ka();
      return;
    }
  }
  UX(e, n, l, o, a);
}
function UX(e, t, n, o = !0, l = !1) {
  if (process.env.NODE_ENV !== "production") {
    const r = BE[t];
    if (n && Jg(n), $t(`Unhandled error${r ? ` during execution of ${r}` : ""}`), n && Zg(), o)
      throw e;
    console.error(e);
  } else {
    if (l)
      throw e;
    console.error(e);
  }
}
const Zl = [];
let li = -1;
const rf = [];
let js = null, Bd = 0;
const i5 = /* @__PURE__ */ Promise.resolve();
let f0 = null;
const GX = 100;
function Ke(e) {
  const t = f0 || i5;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function YX(e) {
  let t = li + 1, n = Zl.length;
  for (; t < n; ) {
    const o = t + n >>> 1, l = Zl[o], r = qv(l);
    r < e || r === e && l.flags & 2 ? t = o + 1 : n = o;
  }
  return t;
}
function r1(e) {
  if (!(e.flags & 1)) {
    const t = qv(e), n = Zl[Zl.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(e.flags & 2) && t >= qv(n) ? Zl.push(e) : Zl.splice(YX(t), 0, e), e.flags |= 1, s5();
  }
}
function s5() {
  f0 || (f0 = i5.then(d5));
}
function c5(e) {
  We(e) ? rf.push(...e) : js && e.id === -1 ? js.splice(Bd + 1, 0, e) : e.flags & 1 || (rf.push(e), e.flags |= 1), s5();
}
function tk(e, t, n = li + 1) {
  for (process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()); n < Zl.length; n++) {
    const o = Zl[n];
    if (o && o.flags & 2) {
      if (e && o.id !== e.uid || process.env.NODE_ENV !== "production" && FE(t, o))
        continue;
      Zl.splice(n, 1), n--, o.flags & 4 && (o.flags &= -2), o(), o.flags & 4 || (o.flags &= -2);
    }
  }
}
function u5(e) {
  if (rf.length) {
    const t = [...new Set(rf)].sort(
      (n, o) => qv(n) - qv(o)
    );
    if (rf.length = 0, js) {
      js.push(...t);
      return;
    }
    for (js = t, process.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()), Bd = 0; Bd < js.length; Bd++) {
      const n = js[Bd];
      process.env.NODE_ENV !== "production" && FE(e, n) || (n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2);
    }
    js = null, Bd = 0;
  }
}
const qv = (e) => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;
function d5(e) {
  process.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map());
  const t = process.env.NODE_ENV !== "production" ? (n) => FE(e, n) : gn;
  try {
    for (li = 0; li < Zl.length; li++) {
      const n = Zl[li];
      if (n && !(n.flags & 8)) {
        if (process.env.NODE_ENV !== "production" && t(n))
          continue;
        n.flags & 4 && (n.flags &= -2), pp(
          n,
          n.i,
          n.i ? 15 : 14
        ), n.flags & 4 || (n.flags &= -2);
      }
    }
  } finally {
    for (; li < Zl.length; li++) {
      const n = Zl[li];
      n && (n.flags &= -2);
    }
    li = -1, Zl.length = 0, u5(e), f0 = null, (Zl.length || rf.length) && d5(e);
  }
}
function FE(e, t) {
  const n = e.get(t) || 0;
  if (n > GX) {
    const o = t.i, l = o && JE(o.type);
    return Ym(
      `Maximum recursive updates exceeded${l ? ` in component <${l}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    ), !0;
  }
  return e.set(t, n + 1), !1;
}
let Jr = !1;
const Qg = /* @__PURE__ */ new Map();
process.env.NODE_ENV !== "production" && (Gm().__VUE_HMR_RUNTIME__ = {
  createRecord: bC(f5),
  rerender: bC(JX),
  reload: bC(ZX)
});
const Lu = /* @__PURE__ */ new Map();
function XX(e) {
  const t = e.type.__hmrId;
  let n = Lu.get(t);
  n || (f5(t, e.type), n = Lu.get(t)), n.instances.add(e);
}
function qX(e) {
  Lu.get(e.type.__hmrId).instances.delete(e);
}
function f5(e, t) {
  return Lu.has(e) ? !1 : (Lu.set(e, {
    initialDef: p0(t),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function p0(e) {
  return nL(e) ? e.__vccOpts : e;
}
function JX(e, t) {
  const n = Lu.get(e);
  n && (n.initialDef.render = t, [...n.instances].forEach((o) => {
    t && (o.render = t, p0(o.type).render = t), o.renderCache = [], Jr = !0, o.job.flags & 8 || o.update(), Jr = !1;
  }));
}
function ZX(e, t) {
  const n = Lu.get(e);
  if (!n) return;
  t = p0(t), nk(n.initialDef, t);
  const o = [...n.instances];
  for (let l = 0; l < o.length; l++) {
    const r = o[l], a = p0(r.type);
    let i = Qg.get(a);
    i || (a !== n.initialDef && nk(a, t), Qg.set(a, i = /* @__PURE__ */ new Set())), i.add(r), r.appContext.propsCache.delete(r.type), r.appContext.emitsCache.delete(r.type), r.appContext.optionsCache.delete(r.type), r.ceReload ? (i.add(r), r.ceReload(t.styles), i.delete(r)) : r.parent ? r1(() => {
      r.job.flags & 8 || (Jr = !0, r.parent.update(), Jr = !1, i.delete(r));
    }) : r.appContext.reload ? r.appContext.reload() : typeof window != "undefined" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    ), r.root.ce && r !== r.root && r.root.ce._removeChildStyle(a);
  }
  c5(() => {
    Qg.clear();
  });
}
function nk(e, t) {
  _o(e, t);
  for (const n in e)
    n !== "__file" && !(n in t) && delete e[n];
}
function bC(e) {
  return (t, n) => {
    try {
      return e(t, n);
    } catch (o) {
      console.error(o), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let ba, dv = [], E$ = !1;
function Xm(e, ...t) {
  ba ? ba.emit(e, ...t) : E$ || dv.push({ event: e, args: t });
}
function VE(e, t) {
  var n, o;
  ba = e, ba ? (ba.enabled = !0, dv.forEach(({ event: l, args: r }) => ba.emit(l, ...r)), dv = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window != "undefined" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((o = (n = window.navigator) == null ? void 0 : n.userAgent) != null && o.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((r) => {
    VE(r, t);
  }), setTimeout(() => {
    ba || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, E$ = !0, dv = []);
  }, 3e3)) : (E$ = !0, dv = []);
}
function QX(e, t) {
  Xm("app:init", e, t, {
    Fragment: Ge,
    Text: Vr,
    Comment: qn,
    Static: tb
  });
}
function eq(e) {
  Xm("app:unmount", e);
}
const tq = /* @__PURE__ */ zE(
  "component:added"
  /* COMPONENT_ADDED */
), p5 = /* @__PURE__ */ zE(
  "component:updated"
  /* COMPONENT_UPDATED */
), nq = /* @__PURE__ */ zE(
  "component:removed"
  /* COMPONENT_REMOVED */
), oq = (e) => {
  ba && typeof ba.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !ba.cleanupBuffer(e) && nq(e);
};
// @__NO_SIDE_EFFECTS__
function zE(e) {
  return (t) => {
    Xm(
      e,
      t.appContext.app,
      t.uid,
      t.parent ? t.parent.uid : void 0,
      t
    );
  };
}
const lq = /* @__PURE__ */ v5(
  "perf:start"
  /* PERFORMANCE_START */
), rq = /* @__PURE__ */ v5(
  "perf:end"
  /* PERFORMANCE_END */
);
function v5(e) {
  return (t, n, o) => {
    Xm(e, t.appContext.app, t.uid, t, n, o);
  };
}
function aq(e, t, n) {
  Xm(
    "component:emit",
    e.appContext.app,
    e,
    t,
    n
  );
}
let Zo = null, m5 = null;
function v0(e) {
  const t = Zo;
  return Zo = e, m5 = e && e.type.__scopeId || null, t;
}
function Ee(e, t = Zo, n) {
  if (!t || e._n)
    return e;
  const o = (...l) => {
    o._d && S0(-1);
    const r = v0(t);
    let a;
    try {
      a = e(...l);
    } finally {
      v0(r), o._d && S0(1);
    }
    return process.env.NODE_ENV !== "production" && p5(t), a;
  };
  return o._n = !0, o._c = !0, o._d = !0, o;
}
function h5(e) {
  JY(e) && $t("Do not use built-in directive ids as custom directive id: " + e);
}
function _t(e, t) {
  if (Zo === null)
    return process.env.NODE_ENV !== "production" && $t("withDirectives can only be used inside render functions."), e;
  const n = u1(Zo), o = e.dirs || (e.dirs = []);
  for (let l = 0; l < t.length; l++) {
    let [r, a, i, s = eo] = t[l];
    r && (it(r) && (r = {
      mounted: r,
      updated: r
    }), r.deep && Qi(a), o.push({
      dir: r,
      instance: n,
      value: a,
      oldValue: void 0,
      arg: i,
      modifiers: s
    }));
  }
  return e;
}
function Fc(e, t, n, o) {
  const l = e.dirs, r = t && t.dirs;
  for (let a = 0; a < l.length; a++) {
    const i = l[a];
    r && (i.oldValue = r[a].value);
    let s = i.dir[o];
    s && (Pa(), Aa(s, n, 8, [
      e.el,
      i,
      e,
      t
    ]), ka());
  }
}
function at(e, t) {
  if (process.env.NODE_ENV !== "production" && (!Xo || Xo.isMounted) && $t("provide() can only be used inside setup()."), Xo) {
    let n = Xo.provides;
    const o = Xo.parent && Xo.parent.provides;
    o === n && (n = Xo.provides = Object.create(o)), n[e] = t;
  }
}
function ze(e, t, n = !1) {
  const o = xt();
  if (o || sf) {
    let l = sf ? sf._context.provides : o ? o.parent == null || o.ce ? o.vnode.appContext && o.vnode.appContext.provides : o.parent.provides : void 0;
    if (l && e in l)
      return l[e];
    if (arguments.length > 1)
      return n && it(t) ? t.call(o && o.proxy) : t;
    process.env.NODE_ENV !== "production" && $t(`injection "${String(e)}" not found.`);
  } else process.env.NODE_ENV !== "production" && $t("inject() can only be used inside setup() or functional components.");
}
const iq = /* @__PURE__ */ Symbol.for("v-scx"), sq = () => {
  {
    const e = ze(iq);
    return e || process.env.NODE_ENV !== "production" && $t(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), e;
  }
};
function Ot(e, t) {
  return HE(e, null, t);
}
function pe(e, t, n) {
  return process.env.NODE_ENV !== "production" && !it(t) && $t(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), HE(e, t, n);
}
function HE(e, t, n = eo) {
  const { immediate: o, deep: l, flush: r, once: a } = n;
  process.env.NODE_ENV !== "production" && !t && (o !== void 0 && $t(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), l !== void 0 && $t(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), a !== void 0 && $t(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const i = _o({}, n);
  process.env.NODE_ENV !== "production" && (i.onWarn = $t);
  const s = t && o || !t && r !== "post";
  let c;
  if (Qv) {
    if (r === "sync") {
      const p = sq();
      c = p.__watcherHandles || (p.__watcherHandles = []);
    } else if (!s) {
      const p = () => {
      };
      return p.stop = gn, p.resume = gn, p.pause = gn, p;
    }
  }
  const u = Xo;
  i.call = (p, m, v) => Aa(p, u, m, v);
  let d = !1;
  r === "post" ? i.scheduler = (p) => {
    Yl(p, u && u.suspense);
  } : r !== "sync" && (d = !0, i.scheduler = (p, m) => {
    m ? p() : r1(p);
  }), i.augmentJob = (p) => {
    t && (p.flags |= 4), d && (p.flags |= 2, u && (p.id = u.uid, p.i = u));
  };
  const f = VX(e, t, i);
  return Qv && (c ? c.push(f) : s && f()), f;
}
function cq(e, t, n) {
  const o = this.proxy, l = rt(e) ? e.includes(".") ? g5(o, e) : () => o[e] : e.bind(o, o);
  let r;
  it(t) ? r = t : (r = t.handler, n = t);
  const a = Jm(this), i = HE(l, r.bind(o), n);
  return a(), i;
}
function g5(e, t) {
  const n = t.split(".");
  return () => {
    let o = e;
    for (let l = 0; l < n.length && o; l++)
      o = o[n[l]];
    return o;
  };
}
const b5 = /* @__PURE__ */ Symbol("_vte"), y5 = (e) => e.__isTeleport, wu = (e) => e && (e.disabled || e.disabled === ""), ok = (e) => e && (e.defer || e.defer === ""), lk = (e) => typeof SVGElement != "undefined" && e instanceof SVGElement, rk = (e) => typeof MathMLElement == "function" && e instanceof MathMLElement, O$ = (e, t) => {
  const n = e && e.to;
  if (rt(n))
    if (t) {
      const o = t(n);
      return process.env.NODE_ENV !== "production" && !o && !wu(e) && $t(
        `Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), o;
    } else
      return process.env.NODE_ENV !== "production" && $t(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return process.env.NODE_ENV !== "production" && !n && !wu(e) && $t(`Invalid Teleport target: ${n}`), n;
}, S5 = {
  name: "Teleport",
  __isTeleport: !0,
  process(e, t, n, o, l, r, a, i, s, c) {
    const {
      mc: u,
      pc: d,
      pbc: f,
      o: { insert: p, querySelector: m, createText: v, createComment: h }
    } = c, g = wu(t.props);
    let { shapeFlag: y, children: b, dynamicChildren: C } = t;
    if (process.env.NODE_ENV !== "production" && Jr && (s = !1, C = null), e == null) {
      const w = t.el = process.env.NODE_ENV !== "production" ? h("teleport start") : v(""), x = t.anchor = process.env.NODE_ENV !== "production" ? h("teleport end") : v("");
      p(w, n, o), p(x, n, o);
      const E = (T, P) => {
        y & 16 && u(
          b,
          T,
          P,
          l,
          r,
          a,
          i,
          s
        );
      }, I = () => {
        const T = t.target = O$(t.props, m), P = C5(T, t, v, p);
        T ? (a !== "svg" && lk(T) ? a = "svg" : a !== "mathml" && rk(T) && (a = "mathml"), l && l.isCE && (l.ce._teleportTargets || (l.ce._teleportTargets = /* @__PURE__ */ new Set())).add(T), g || (E(T, P), eb(t, !1))) : process.env.NODE_ENV !== "production" && !g && $t(
          "Invalid Teleport target on mount:",
          T,
          `(${typeof T})`
        );
      };
      g && (E(n, x), eb(t, !0)), ok(t.props) ? (t.el.__isMounted = !1, Yl(() => {
        I(), delete t.el.__isMounted;
      }, r)) : I();
    } else {
      if (ok(t.props) && e.el.__isMounted === !1) {
        Yl(() => {
          S5.process(
            e,
            t,
            n,
            o,
            l,
            r,
            a,
            i,
            s,
            c
          );
        }, r);
        return;
      }
      t.el = e.el, t.targetStart = e.targetStart;
      const w = t.anchor = e.anchor, x = t.target = e.target, E = t.targetAnchor = e.targetAnchor, I = wu(e.props), T = I ? n : x, P = I ? w : E;
      if (a === "svg" || lk(x) ? a = "svg" : (a === "mathml" || rk(x)) && (a = "mathml"), C ? (f(
        e.dynamicChildren,
        C,
        T,
        l,
        r,
        a,
        i
      ), Ev(e, t, process.env.NODE_ENV === "production")) : s || d(
        e,
        t,
        T,
        P,
        l,
        r,
        a,
        i,
        !1
      ), g)
        I ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : Jh(
          t,
          n,
          w,
          c,
          1
        );
      else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
        const k = t.target = O$(
          t.props,
          m
        );
        k ? Jh(
          t,
          k,
          null,
          c,
          0
        ) : process.env.NODE_ENV !== "production" && $t(
          "Invalid Teleport target on update:",
          x,
          `(${typeof x})`
        );
      } else I && Jh(
        t,
        x,
        E,
        c,
        1
      );
      eb(t, g);
    }
  },
  remove(e, t, n, { um: o, o: { remove: l } }, r) {
    const {
      shapeFlag: a,
      children: i,
      anchor: s,
      targetStart: c,
      targetAnchor: u,
      target: d,
      props: f
    } = e;
    if (d && (l(c), l(u)), r && l(s), a & 16) {
      const p = r || !wu(f);
      for (let m = 0; m < i.length; m++) {
        const v = i[m];
        o(
          v,
          t,
          n,
          p,
          !!v.dynamicChildren
        );
      }
    }
  },
  move: Jh,
  hydrate: uq
};
function Jh(e, t, n, { o: { insert: o }, m: l }, r = 2) {
  r === 0 && o(e.targetAnchor, t, n);
  const { el: a, anchor: i, shapeFlag: s, children: c, props: u } = e, d = r === 2;
  if (d && o(a, t, n), (!d || wu(u)) && s & 16)
    for (let f = 0; f < c.length; f++)
      l(
        c[f],
        t,
        n,
        2
      );
  d && o(i, t, n);
}
function uq(e, t, n, o, l, r, {
  o: { nextSibling: a, parentNode: i, querySelector: s, insert: c, createText: u }
}, d) {
  function f(v, h, g, y) {
    h.anchor = d(
      a(v),
      h,
      i(v),
      n,
      o,
      l,
      r
    ), h.targetStart = g, h.targetAnchor = y;
  }
  const p = t.target = O$(
    t.props,
    s
  ), m = wu(t.props);
  if (p) {
    const v = p._lpa || p.firstChild;
    if (t.shapeFlag & 16)
      if (m)
        f(
          e,
          t,
          v,
          v && a(v)
        );
      else {
        t.anchor = a(e);
        let h = v;
        for (; h; ) {
          if (h && h.nodeType === 8) {
            if (h.data === "teleport start anchor")
              t.targetStart = h;
            else if (h.data === "teleport anchor") {
              t.targetAnchor = h, p._lpa = t.targetAnchor && a(t.targetAnchor);
              break;
            }
          }
          h = a(h);
        }
        t.targetAnchor || C5(p, t, u, c), d(
          v && a(v),
          t,
          p,
          n,
          o,
          l,
          r
        );
      }
    eb(t, m);
  } else m && t.shapeFlag & 16 && f(e, t, e, a(e));
  return t.anchor && a(t.anchor);
}
const a1 = S5;
function eb(e, t) {
  const n = e.ctx;
  if (n && n.ut) {
    let o, l;
    for (t ? (o = e.el, l = e.anchor) : (o = e.targetStart, l = e.targetAnchor); o && o !== l; )
      o.nodeType === 1 && o.setAttribute("data-v-owner", n.uid), o = o.nextSibling;
    n.ut();
  }
}
function C5(e, t, n, o) {
  const l = t.targetStart = n(""), r = t.targetAnchor = n("");
  return l[b5] = r, e && (o(l, e), o(r, e)), r;
}
const Xi = /* @__PURE__ */ Symbol("_leaveCb"), Zh = /* @__PURE__ */ Symbol("_enterCb");
function w5() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return nt(() => {
    e.isMounted = !0;
  }), yt(() => {
    e.isUnmounting = !0;
  }), e;
}
const jr = [Function, Array], $5 = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: jr,
  onEnter: jr,
  onAfterEnter: jr,
  onEnterCancelled: jr,
  // leave
  onBeforeLeave: jr,
  onLeave: jr,
  onAfterLeave: jr,
  onLeaveCancelled: jr,
  // appear
  onBeforeAppear: jr,
  onAppear: jr,
  onAfterAppear: jr,
  onAppearCancelled: jr
}, x5 = (e) => {
  const t = e.subTree;
  return t.component ? x5(t.component) : t;
}, dq = {
  name: "BaseTransition",
  props: $5,
  setup(e, { slots: t }) {
    const n = xt(), o = w5();
    return () => {
      const l = t.default && jE(t.default(), !0);
      if (!l || !l.length)
        return;
      const r = E5(l), a = /* @__PURE__ */ Wt(e), { mode: i } = a;
      if (process.env.NODE_ENV !== "production" && i && i !== "in-out" && i !== "out-in" && i !== "default" && $t(`invalid <transition> mode: ${i}`), o.isLeaving)
        return yC(r);
      const s = ak(r);
      if (!s)
        return yC(r);
      let c = Jv(
        s,
        a,
        o,
        n,
        // #11061, ensure enterHooks is fresh after clone
        (d) => c = d
      );
      s.type !== qn && Bu(s, c);
      let u = n.subTree && ak(n.subTree);
      if (u && u.type !== qn && !tu(u, s) && x5(n).type !== qn) {
        let d = Jv(
          u,
          a,
          o,
          n
        );
        if (Bu(u, d), i === "out-in" && s.type !== qn)
          return o.isLeaving = !0, d.afterLeave = () => {
            o.isLeaving = !1, n.job.flags & 8 || n.update(), delete d.afterLeave, u = void 0;
          }, yC(r);
        i === "in-out" && s.type !== qn ? d.delayLeave = (f, p, m) => {
          const v = O5(
            o,
            u
          );
          v[String(u.key)] = u, f[Xi] = () => {
            p(), f[Xi] = void 0, delete c.delayedLeave, u = void 0;
          }, c.delayedLeave = () => {
            m(), delete c.delayedLeave, u = void 0;
          };
        } : u = void 0;
      } else u && (u = void 0);
      return r;
    };
  }
};
function E5(e) {
  let t = e[0];
  if (e.length > 1) {
    let n = !1;
    for (const o of e)
      if (o.type !== qn) {
        if (process.env.NODE_ENV !== "production" && n) {
          $t(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        if (t = o, n = !0, process.env.NODE_ENV === "production") break;
      }
  }
  return t;
}
const fq = dq;
function O5(e, t) {
  const { leavingVNodes: n } = e;
  let o = n.get(t.type);
  return o || (o = /* @__PURE__ */ Object.create(null), n.set(t.type, o)), o;
}
function Jv(e, t, n, o, l) {
  const {
    appear: r,
    mode: a,
    persisted: i = !1,
    onBeforeEnter: s,
    onEnter: c,
    onAfterEnter: u,
    onEnterCancelled: d,
    onBeforeLeave: f,
    onLeave: p,
    onAfterLeave: m,
    onLeaveCancelled: v,
    onBeforeAppear: h,
    onAppear: g,
    onAfterAppear: y,
    onAppearCancelled: b
  } = t, C = String(e.key), w = O5(n, e), x = (T, P) => {
    T && Aa(
      T,
      o,
      9,
      P
    );
  }, E = (T, P) => {
    const k = P[1];
    x(T, P), We(T) ? T.every((N) => N.length <= 1) && k() : T.length <= 1 && k();
  }, I = {
    mode: a,
    persisted: i,
    beforeEnter(T) {
      let P = s;
      if (!n.isMounted)
        if (r)
          P = h || s;
        else
          return;
      T[Xi] && T[Xi](
        !0
        /* cancelled */
      );
      const k = w[C];
      k && tu(e, k) && k.el[Xi] && k.el[Xi](), x(P, [T]);
    },
    enter(T) {
      let P = c, k = u, N = d;
      if (!n.isMounted)
        if (r)
          P = g || c, k = y || u, N = b || d;
        else
          return;
      let R = !1;
      const z = T[Zh] = (D) => {
        R || (R = !0, D ? x(N, [T]) : x(k, [T]), I.delayedLeave && I.delayedLeave(), T[Zh] = void 0);
      };
      P ? E(P, [T, z]) : z();
    },
    leave(T, P) {
      const k = String(e.key);
      if (T[Zh] && T[Zh](
        !0
        /* cancelled */
      ), n.isUnmounting)
        return P();
      x(f, [T]);
      let N = !1;
      const R = T[Xi] = (z) => {
        N || (N = !0, P(), z ? x(v, [T]) : x(m, [T]), T[Xi] = void 0, w[k] === e && delete w[k]);
      };
      w[k] = e, p ? E(p, [T, R]) : R();
    },
    clone(T) {
      const P = Jv(
        T,
        t,
        n,
        o,
        l
      );
      return l && l(P), P;
    }
  };
  return I;
}
function yC(e) {
  if (qm(e))
    return e = No(e), e.children = null, e;
}
function ak(e) {
  if (!qm(e))
    return y5(e.type) && e.children ? E5(e.children) : e;
  if (e.component)
    return e.component.subTree;
  const { shapeFlag: t, children: n } = e;
  if (n) {
    if (t & 16)
      return n[0];
    if (t & 32 && it(n.default))
      return n.default();
  }
}
function Bu(e, t) {
  e.shapeFlag & 6 && e.component ? (e.transition = t, Bu(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
}
function jE(e, t = !1, n) {
  let o = [], l = 0;
  for (let r = 0; r < e.length; r++) {
    let a = e[r];
    const i = n == null ? a.key : String(n) + String(a.key != null ? a.key : r);
    a.type === Ge ? (a.patchFlag & 128 && l++, o = o.concat(
      jE(a.children, t, i)
    )) : (t || a.type !== qn) && o.push(i != null ? No(a, { key: i }) : a);
  }
  if (l > 1)
    for (let r = 0; r < o.length; r++)
      o[r].patchFlag = -2;
  return o;
}
// @__NO_SIDE_EFFECTS__
function le(e, t) {
  return it(e) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    _o({ name: e.name }, t, { setup: e })
  ) : e;
}
function _5(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
const ik = /* @__PURE__ */ new WeakSet(), m0 = /* @__PURE__ */ new WeakMap();
function xv(e, t, n, o, l = !1) {
  if (We(e)) {
    e.forEach(
      (v, h) => xv(
        v,
        t && (We(t) ? t[h] : t),
        n,
        o,
        l
      )
    );
    return;
  }
  if (af(o) && !l) {
    o.shapeFlag & 512 && o.type.__asyncResolved && o.component.subTree.component && xv(e, t, n, o.component.subTree);
    return;
  }
  const r = o.shapeFlag & 4 ? u1(o.component) : o.el, a = l ? null : r, { i, r: s } = e;
  if (process.env.NODE_ENV !== "production" && !i) {
    $t(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const c = t && t.r, u = i.refs === eo ? i.refs = {} : i.refs, d = i.setupState, f = /* @__PURE__ */ Wt(d), p = d === eo ? AD : (v) => process.env.NODE_ENV !== "production" && (hn(f, v) && !/* @__PURE__ */ kn(f[v]) && $t(
    `Template ref "${v}" used on a non-ref value. It will not work in the production build.`
  ), ik.has(f[v])) ? !1 : hn(f, v), m = (v) => process.env.NODE_ENV === "production" || !ik.has(v);
  if (c != null && c !== s) {
    if (sk(t), rt(c))
      u[c] = null, p(c) && (d[c] = null);
    else if (/* @__PURE__ */ kn(c)) {
      m(c) && (c.value = null);
      const v = t;
      v.k && (u[v.k] = null);
    }
  }
  if (it(s))
    pp(s, i, 12, [a, u]);
  else {
    const v = rt(s), h = /* @__PURE__ */ kn(s);
    if (v || h) {
      const g = () => {
        if (e.f) {
          const y = v ? p(s) ? d[s] : u[s] : m(s) || !e.k ? s.value : u[e.k];
          if (l)
            We(y) && IE(y, r);
          else if (We(y))
            y.includes(r) || y.push(r);
          else if (v)
            u[s] = [r], p(s) && (d[s] = u[s]);
          else {
            const b = [r];
            m(s) && (s.value = b), e.k && (u[e.k] = b);
          }
        } else v ? (u[s] = a, p(s) && (d[s] = a)) : h ? (m(s) && (s.value = a), e.k && (u[e.k] = a)) : process.env.NODE_ENV !== "production" && $t("Invalid template ref type:", s, `(${typeof s})`);
      };
      if (a) {
        const y = () => {
          g(), m0.delete(e);
        };
        y.id = -1, m0.set(e, y), Yl(y, n);
      } else
        sk(e), g();
    } else process.env.NODE_ENV !== "production" && $t("Invalid template ref type:", s, `(${typeof s})`);
  }
}
function sk(e) {
  const t = m0.get(e);
  t && (t.flags |= 8, m0.delete(e));
}
Gm().requestIdleCallback;
Gm().cancelIdleCallback;
const af = (e) => !!e.type.__asyncLoader, qm = (e) => e.type.__isKeepAlive;
function nd(e, t) {
  I5(e, "a", t);
}
function WE(e, t) {
  I5(e, "da", t);
}
function I5(e, t, n = Xo) {
  const o = e.__wdc || (e.__wdc = () => {
    let l = n;
    for (; l; ) {
      if (l.isDeactivated)
        return;
      l = l.parent;
    }
    return e();
  });
  if (i1(t, o, n), n) {
    let l = n.parent;
    for (; l && l.parent; )
      qm(l.parent.vnode) && pq(o, t, n, l), l = l.parent;
  }
}
function pq(e, t, n, o) {
  const l = i1(
    t,
    e,
    o,
    !0
    /* prepend */
  );
  Uo(() => {
    IE(o[t], l);
  }, n);
}
function i1(e, t, n = Xo, o = !1) {
  if (n) {
    const l = n[e] || (n[e] = []), r = t.__weh || (t.__weh = (...a) => {
      Pa();
      const i = Jm(n), s = Aa(t, n, e, a);
      return i(), ka(), s;
    });
    return o ? l.unshift(r) : l.push(r), r;
  } else if (process.env.NODE_ENV !== "production") {
    const l = Yi(BE[e].replace(/ hook$/, ""));
    $t(
      `${l} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const ws = (e) => (t, n = Xo) => {
  (!Qv || e === "sp") && i1(e, (...o) => t(...o), n);
}, _c = ws("bm"), nt = ws("m"), vp = ws(
  "bu"
), $o = ws("u"), yt = ws(
  "bum"
), Uo = ws("um"), vq = ws(
  "sp"
), mq = ws("rtg"), hq = ws("rtc");
function gq(e, t = Xo) {
  i1("ec", e, t);
}
const h0 = "components", bq = "directives";
function yn(e, t) {
  return KE(h0, e, !0, t) || e;
}
const T5 = /* @__PURE__ */ Symbol.for("v-ndc");
function Ht(e) {
  return rt(e) ? KE(h0, e, !1) || e : e || T5;
}
function s1(e) {
  return KE(bq, e);
}
function KE(e, t, n = !0, o = !1) {
  const l = Zo || Xo;
  if (l) {
    const r = l.type;
    if (e === h0) {
      const i = JE(
        r,
        !1
      );
      if (i && (i === t || i === vl(t) || i === hc(vl(t))))
        return r;
    }
    const a = (
      // local registration
      // check instance[type] first which is resolved for options API
      ck(l[e] || r[e], t) || // global registration
      ck(l.appContext[e], t)
    );
    if (!a && o)
      return r;
    if (process.env.NODE_ENV !== "production" && n && !a) {
      const i = e === h0 ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      $t(`Failed to resolve ${e.slice(0, -1)}: ${t}${i}`);
    }
    return a;
  } else process.env.NODE_ENV !== "production" && $t(
    `resolve${hc(e.slice(0, -1))} can only be used in render() or setup().`
  );
}
function ck(e, t) {
  return e && (e[t] || e[vl(t)] || e[hc(vl(t))]);
}
function on(e, t, n, o) {
  let l;
  const r = n, a = We(e);
  if (a || rt(e)) {
    const i = a && /* @__PURE__ */ ic(e);
    let s = !1, c = !1;
    i && (s = !/* @__PURE__ */ Ml(e), c = /* @__PURE__ */ Na(e), e = t1(e)), l = new Array(e.length);
    for (let u = 0, d = e.length; u < d; u++)
      l[u] = t(
        s ? c ? Mf(Ma(e[u])) : Ma(e[u]) : e[u],
        u,
        void 0,
        r
      );
  } else if (typeof e == "number") {
    process.env.NODE_ENV !== "production" && !Number.isInteger(e) && $t(`The v-for range expect an integer value but got ${e}.`), l = new Array(e);
    for (let i = 0; i < e; i++)
      l[i] = t(i + 1, i, void 0, r);
  } else if (Mt(e))
    if (e[Symbol.iterator])
      l = Array.from(
        e,
        (i, s) => t(i, s, void 0, r)
      );
    else {
      const i = Object.keys(e);
      l = new Array(i.length);
      for (let s = 0, c = i.length; s < c; s++) {
        const u = i[s];
        l[s] = t(e[u], u, s, r);
      }
    }
  else
    l = [];
  return l;
}
function or(e, t) {
  for (let n = 0; n < t.length; n++) {
    const o = t[n];
    if (We(o))
      for (let l = 0; l < o.length; l++)
        e[o[l].name] = o[l].fn;
    else o && (e[o.name] = o.key ? (...l) => {
      const r = o.fn(...l);
      return r && (r.key = o.key), r;
    } : o.fn);
  }
  return e;
}
function Oe(e, t, n = {}, o, l) {
  if (Zo.ce || Zo.parent && af(Zo.parent) && Zo.parent.ce) {
    const c = Object.keys(n).length > 0;
    return t !== "default" && (n.name = t), G(), Me(
      Ge,
      null,
      [$("slot", n, o && o())],
      c ? -2 : 64
    );
  }
  let r = e[t];
  process.env.NODE_ENV !== "production" && r && r.length > 1 && ($t(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), r = () => []), r && r._c && (r._d = !1), G();
  const a = r && P5(r(n)), i = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  a && a.key, s = Me(
    Ge,
    {
      key: (i && !Ta(i) ? i : `_${t}`) + // #7256 force differentiate fallback content from actual content
      (!a && o ? "_fb" : "")
    },
    a || (o ? o() : []),
    a && e._ === 1 ? 64 : -2
  );
  return s.scopeId && (s.slotScopeIds = [s.scopeId + "-s"]), r && r._c && (r._d = !0), s;
}
function P5(e) {
  return e.some((t) => dn(t) ? !(t.type === qn || t.type === Ge && !P5(t.children)) : !0) ? e : null;
}
function yq(e, t) {
  const n = {};
  if (process.env.NODE_ENV !== "production" && !Mt(e))
    return $t("v-on with no argument expects an object value."), n;
  for (const o in e)
    n[Yi(o)] = e[o];
  return n;
}
const _$ = (e) => e ? Q5(e) ? u1(e) : _$(e.parent) : null, $u = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ _o(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => process.env.NODE_ENV !== "production" ? /* @__PURE__ */ ci(e.props) : e.props,
    $attrs: (e) => process.env.NODE_ENV !== "production" ? /* @__PURE__ */ ci(e.attrs) : e.attrs,
    $slots: (e) => process.env.NODE_ENV !== "production" ? /* @__PURE__ */ ci(e.slots) : e.slots,
    $refs: (e) => process.env.NODE_ENV !== "production" ? /* @__PURE__ */ ci(e.refs) : e.refs,
    $parent: (e) => _$(e.parent),
    $root: (e) => _$(e.root),
    $host: (e) => e.ce,
    $emit: (e) => e.emit,
    $options: (e) => A5(e),
    $forceUpdate: (e) => e.f || (e.f = () => {
      r1(e.update);
    }),
    $nextTick: (e) => e.n || (e.n = Ke.bind(e.proxy)),
    $watch: (e) => cq.bind(e)
  })
), UE = (e) => e === "_" || e === "$", SC = (e, t) => e !== eo && !e.__isScriptSetup && hn(e, t), k5 = {
  get({ _: e }, t) {
    if (t === "__v_skip")
      return !0;
    const { ctx: n, setupState: o, data: l, props: r, accessCache: a, type: i, appContext: s } = e;
    if (process.env.NODE_ENV !== "production" && t === "__isVue")
      return !0;
    if (t[0] !== "$") {
      const f = a[t];
      if (f !== void 0)
        switch (f) {
          case 1:
            return o[t];
          case 2:
            return l[t];
          case 4:
            return n[t];
          case 3:
            return r[t];
        }
      else {
        if (SC(o, t))
          return a[t] = 1, o[t];
        if (l !== eo && hn(l, t))
          return a[t] = 2, l[t];
        if (hn(r, t))
          return a[t] = 3, r[t];
        if (n !== eo && hn(n, t))
          return a[t] = 4, n[t];
        I$ && (a[t] = 0);
      }
    }
    const c = $u[t];
    let u, d;
    if (c)
      return t === "$attrs" ? (tl(e.attrs, "get", ""), process.env.NODE_ENV !== "production" && b0()) : process.env.NODE_ENV !== "production" && t === "$slots" && tl(e, "get", t), c(e);
    if (
      // css module (injected by vue-loader)
      (u = i.__cssModules) && (u = u[t])
    )
      return u;
    if (n !== eo && hn(n, t))
      return a[t] = 4, n[t];
    if (
      // global properties
      d = s.config.globalProperties, hn(d, t)
    )
      return d[t];
    process.env.NODE_ENV !== "production" && Zo && (!rt(t) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    t.indexOf("__v") !== 0) && (l !== eo && UE(t[0]) && hn(l, t) ? $t(
      `Property ${JSON.stringify(
        t
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : e === Zo && $t(
      `Property ${JSON.stringify(t)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: e }, t, n) {
    const { data: o, setupState: l, ctx: r } = e;
    return SC(l, t) ? (l[t] = n, !0) : process.env.NODE_ENV !== "production" && l.__isScriptSetup && hn(l, t) ? ($t(`Cannot mutate <script setup> binding "${t}" from Options API.`), !1) : o !== eo && hn(o, t) ? (o[t] = n, !0) : hn(e.props, t) ? (process.env.NODE_ENV !== "production" && $t(`Attempting to mutate prop "${t}". Props are readonly.`), !1) : t[0] === "$" && t.slice(1) in e ? (process.env.NODE_ENV !== "production" && $t(
      `Attempting to mutate public property "${t}". Properties starting with $ are reserved and readonly.`
    ), !1) : (process.env.NODE_ENV !== "production" && t in e.appContext.config.globalProperties ? Object.defineProperty(r, t, {
      enumerable: !0,
      configurable: !0,
      value: n
    }) : r[t] = n, !0);
  },
  has({
    _: { data: e, setupState: t, accessCache: n, ctx: o, appContext: l, props: r, type: a }
  }, i) {
    let s;
    return !!(n[i] || e !== eo && i[0] !== "$" && hn(e, i) || SC(t, i) || hn(r, i) || hn(o, i) || hn($u, i) || hn(l.config.globalProperties, i) || (s = a.__cssModules) && s[i]);
  },
  defineProperty(e, t, n) {
    return n.get != null ? e._.accessCache[t] = 0 : hn(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n);
  }
};
process.env.NODE_ENV !== "production" && (k5.ownKeys = (e) => ($t(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(e)));
function Sq(e) {
  const t = {};
  return Object.defineProperty(t, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => e
  }), Object.keys($u).forEach((n) => {
    Object.defineProperty(t, n, {
      configurable: !0,
      enumerable: !1,
      get: () => $u[n](e),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: gn
    });
  }), t;
}
function Cq(e) {
  const {
    ctx: t,
    propsOptions: [n]
  } = e;
  n && Object.keys(n).forEach((o) => {
    Object.defineProperty(t, o, {
      enumerable: !0,
      configurable: !0,
      get: () => e.props[o],
      set: gn
    });
  });
}
function wq(e) {
  const { ctx: t, setupState: n } = e;
  Object.keys(/* @__PURE__ */ Wt(n)).forEach((o) => {
    if (!n.__isScriptSetup) {
      if (UE(o[0])) {
        $t(
          `setup() return property ${JSON.stringify(
            o
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(t, o, {
        enumerable: !0,
        configurable: !0,
        get: () => n[o],
        set: gn
      });
    }
  });
}
function So() {
  return N5("useSlots").slots;
}
function Ti() {
  return N5("useAttrs").attrs;
}
function N5(e) {
  const t = xt();
  return process.env.NODE_ENV !== "production" && !t && $t(`${e}() called without active instance.`), t.setupContext || (t.setupContext = tL(t));
}
function uk(e) {
  return We(e) ? e.reduce(
    (t, n) => (t[n] = null, t),
    {}
  ) : e;
}
function $q() {
  const e = /* @__PURE__ */ Object.create(null);
  return (t, n) => {
    e[n] ? $t(`${t} property "${n}" is already defined in ${e[n]}.`) : e[n] = t;
  };
}
let I$ = !0;
function xq(e) {
  const t = A5(e), n = e.proxy, o = e.ctx;
  I$ = !1, t.beforeCreate && dk(t.beforeCreate, e, "bc");
  const {
    // state
    data: l,
    computed: r,
    methods: a,
    watch: i,
    provide: s,
    inject: c,
    // lifecycle
    created: u,
    beforeMount: d,
    mounted: f,
    beforeUpdate: p,
    updated: m,
    activated: v,
    deactivated: h,
    beforeDestroy: g,
    beforeUnmount: y,
    destroyed: b,
    unmounted: C,
    render: w,
    renderTracked: x,
    renderTriggered: E,
    errorCaptured: I,
    serverPrefetch: T,
    // public API
    expose: P,
    inheritAttrs: k,
    // assets
    components: N,
    directives: R,
    filters: z
  } = t, D = process.env.NODE_ENV !== "production" ? $q() : null;
  if (process.env.NODE_ENV !== "production") {
    const [M] = e.propsOptions;
    if (M)
      for (const A in M)
        D("Props", A);
  }
  if (c && Eq(c, o, D), a)
    for (const M in a) {
      const A = a[M];
      it(A) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(o, M, {
        value: A.bind(n),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : o[M] = A.bind(n), process.env.NODE_ENV !== "production" && D("Methods", M)) : process.env.NODE_ENV !== "production" && $t(
        `Method "${M}" has type "${typeof A}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (l) {
    process.env.NODE_ENV !== "production" && !it(l) && $t(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const M = l.call(n, n);
    if (process.env.NODE_ENV !== "production" && mc(M) && $t(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !Mt(M))
      process.env.NODE_ENV !== "production" && $t("data() should return an object.");
    else if (e.data = /* @__PURE__ */ kt(M), process.env.NODE_ENV !== "production")
      for (const A in M)
        D("Data", A), UE(A[0]) || Object.defineProperty(o, A, {
          configurable: !0,
          enumerable: !0,
          get: () => M[A],
          set: gn
        });
  }
  if (I$ = !0, r)
    for (const M in r) {
      const A = r[M], L = it(A) ? A.bind(n, n) : it(A.get) ? A.get.bind(n, n) : gn;
      process.env.NODE_ENV !== "production" && L === gn && $t(`Computed property "${M}" has no getter.`);
      const B = !it(A) && it(A.set) ? A.set.bind(n) : process.env.NODE_ENV !== "production" ? () => {
        $t(
          `Write operation failed: computed property "${M}" is readonly.`
        );
      } : gn, V = O({
        get: L,
        set: B
      });
      Object.defineProperty(o, M, {
        enumerable: !0,
        configurable: !0,
        get: () => V.value,
        set: (j) => V.value = j
      }), process.env.NODE_ENV !== "production" && D("Computed", M);
    }
  if (i)
    for (const M in i)
      M5(i[M], o, n, M);
  if (s) {
    const M = it(s) ? s.call(n) : s;
    Reflect.ownKeys(M).forEach((A) => {
      at(A, M[A]);
    });
  }
  u && dk(u, e, "c");
  function F(M, A) {
    We(A) ? A.forEach((L) => M(L.bind(n))) : A && M(A.bind(n));
  }
  if (F(_c, d), F(nt, f), F(vp, p), F($o, m), F(nd, v), F(WE, h), F(gq, I), F(hq, x), F(mq, E), F(yt, y), F(Uo, C), F(vq, T), We(P))
    if (P.length) {
      const M = e.exposed || (e.exposed = {});
      P.forEach((A) => {
        Object.defineProperty(M, A, {
          get: () => n[A],
          set: (L) => n[A] = L,
          enumerable: !0
        });
      });
    } else e.exposed || (e.exposed = {});
  w && e.render === gn && (e.render = w), k != null && (e.inheritAttrs = k), N && (e.components = N), R && (e.directives = R), T && _5(e);
}
function Eq(e, t, n = gn) {
  We(e) && (e = T$(e));
  for (const o in e) {
    const l = e[o];
    let r;
    Mt(l) ? "default" in l ? r = ze(
      l.from || o,
      l.default,
      !0
    ) : r = ze(l.from || o) : r = ze(l), /* @__PURE__ */ kn(r) ? Object.defineProperty(t, o, {
      enumerable: !0,
      configurable: !0,
      get: () => r.value,
      set: (a) => r.value = a
    }) : t[o] = r, process.env.NODE_ENV !== "production" && n("Inject", o);
  }
}
function dk(e, t, n) {
  Aa(
    We(e) ? e.map((o) => o.bind(t.proxy)) : e.bind(t.proxy),
    t,
    n
  );
}
function M5(e, t, n, o) {
  let l = o.includes(".") ? g5(n, o) : () => n[o];
  if (rt(e)) {
    const r = t[e];
    it(r) ? pe(l, r) : process.env.NODE_ENV !== "production" && $t(`Invalid watch handler specified by key "${e}"`, r);
  } else if (it(e))
    pe(l, e.bind(n));
  else if (Mt(e))
    if (We(e))
      e.forEach((r) => M5(r, t, n, o));
    else {
      const r = it(e.handler) ? e.handler.bind(n) : t[e.handler];
      it(r) ? pe(l, r, e) : process.env.NODE_ENV !== "production" && $t(`Invalid watch handler specified by key "${e.handler}"`, r);
    }
  else process.env.NODE_ENV !== "production" && $t(`Invalid watch option: "${o}"`, e);
}
function A5(e) {
  const t = e.type, { mixins: n, extends: o } = t, {
    mixins: l,
    optionsCache: r,
    config: { optionMergeStrategies: a }
  } = e.appContext, i = r.get(t);
  let s;
  return i ? s = i : !l.length && !n && !o ? s = t : (s = {}, l.length && l.forEach(
    (c) => g0(s, c, a, !0)
  ), g0(s, t, a)), Mt(t) && r.set(t, s), s;
}
function g0(e, t, n, o = !1) {
  const { mixins: l, extends: r } = t;
  r && g0(e, r, n, !0), l && l.forEach(
    (a) => g0(e, a, n, !0)
  );
  for (const a in t)
    if (o && a === "expose")
      process.env.NODE_ENV !== "production" && $t(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const i = Oq[a] || n && n[a];
      e[a] = i ? i(e[a], t[a]) : t[a];
    }
  return e;
}
const Oq = {
  data: fk,
  props: pk,
  emits: pk,
  // objects
  methods: fv,
  computed: fv,
  // lifecycle
  beforeCreate: Ul,
  created: Ul,
  beforeMount: Ul,
  mounted: Ul,
  beforeUpdate: Ul,
  updated: Ul,
  beforeDestroy: Ul,
  beforeUnmount: Ul,
  destroyed: Ul,
  unmounted: Ul,
  activated: Ul,
  deactivated: Ul,
  errorCaptured: Ul,
  serverPrefetch: Ul,
  // assets
  components: fv,
  directives: fv,
  // watch
  watch: Iq,
  // provide / inject
  provide: fk,
  inject: _q
};
function fk(e, t) {
  return t ? e ? function() {
    return _o(
      it(e) ? e.call(this, this) : e,
      it(t) ? t.call(this, this) : t
    );
  } : t : e;
}
function _q(e, t) {
  return fv(T$(e), T$(t));
}
function T$(e) {
  if (We(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++)
      t[e[n]] = e[n];
    return t;
  }
  return e;
}
function Ul(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function fv(e, t) {
  return e ? _o(/* @__PURE__ */ Object.create(null), e, t) : t;
}
function pk(e, t) {
  return e ? We(e) && We(t) ? [.../* @__PURE__ */ new Set([...e, ...t])] : _o(
    /* @__PURE__ */ Object.create(null),
    uk(e),
    uk(t != null ? t : {})
  ) : t;
}
function Iq(e, t) {
  if (!e) return t;
  if (!t) return e;
  const n = _o(/* @__PURE__ */ Object.create(null), e);
  for (const o in t)
    n[o] = Ul(e[o], t[o]);
  return n;
}
function R5() {
  return {
    app: null,
    config: {
      isNativeTag: AD,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Tq = 0;
function Pq(e, t) {
  return function(o, l = null) {
    it(o) || (o = _o({}, o)), l != null && !Mt(l) && (process.env.NODE_ENV !== "production" && $t("root props passed to app.mount() must be an object."), l = null);
    const r = R5(), a = /* @__PURE__ */ new WeakSet(), i = [];
    let s = !1;
    const c = r.app = {
      _uid: Tq++,
      _component: o,
      _props: l,
      _container: null,
      _context: r,
      _instance: null,
      version: xk,
      get config() {
        return r.config;
      },
      set config(u) {
        process.env.NODE_ENV !== "production" && $t(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(u, ...d) {
        return a.has(u) ? process.env.NODE_ENV !== "production" && $t("Plugin has already been applied to target app.") : u && it(u.install) ? (a.add(u), u.install(c, ...d)) : it(u) ? (a.add(u), u(c, ...d)) : process.env.NODE_ENV !== "production" && $t(
          'A plugin must either be a function or an object with an "install" function.'
        ), c;
      },
      mixin(u) {
        return r.mixins.includes(u) ? process.env.NODE_ENV !== "production" && $t(
          "Mixin has already been applied to target app" + (u.name ? `: ${u.name}` : "")
        ) : r.mixins.push(u), c;
      },
      component(u, d) {
        return process.env.NODE_ENV !== "production" && A$(u, r.config), d ? (process.env.NODE_ENV !== "production" && r.components[u] && $t(`Component "${u}" has already been registered in target app.`), r.components[u] = d, c) : r.components[u];
      },
      directive(u, d) {
        return process.env.NODE_ENV !== "production" && h5(u), d ? (process.env.NODE_ENV !== "production" && r.directives[u] && $t(`Directive "${u}" has already been registered in target app.`), r.directives[u] = d, c) : r.directives[u];
      },
      mount(u, d, f) {
        if (s)
          process.env.NODE_ENV !== "production" && $t(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          process.env.NODE_ENV !== "production" && u.__vue_app__ && $t(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const p = c._ceVNode || $(o, l);
          return p.appContext = r, f === !0 ? f = "svg" : f === !1 && (f = void 0), process.env.NODE_ENV !== "production" && (r.reload = () => {
            const m = No(p);
            m.el = null, e(m, u, f);
          }), e(p, u, f), s = !0, c._container = u, u.__vue_app__ = c, process.env.NODE_ENV !== "production" && (c._instance = p.component, QX(c, xk)), u1(p.component);
        }
      },
      onUnmount(u) {
        process.env.NODE_ENV !== "production" && typeof u != "function" && $t(
          `Expected function as first argument to app.onUnmount(), but got ${typeof u}`
        ), i.push(u);
      },
      unmount() {
        s ? (Aa(
          i,
          c._instance,
          16
        ), e(null, c._container), process.env.NODE_ENV !== "production" && (c._instance = null, eq(c)), delete c._container.__vue_app__) : process.env.NODE_ENV !== "production" && $t("Cannot unmount an app that is not mounted.");
      },
      provide(u, d) {
        return process.env.NODE_ENV !== "production" && u in r.provides && (hn(r.provides, u) ? $t(
          `App already provides property with key "${String(u)}". It will be overwritten with the new value.`
        ) : $t(
          `App already provides property with key "${String(u)}" inherited from its parent element. It will be overwritten with the new value.`
        )), r.provides[u] = d, c;
      },
      runWithContext(u) {
        const d = sf;
        sf = c;
        try {
          return u();
        } finally {
          sf = d;
        }
      }
    };
    return c;
  };
}
let sf = null;
const kq = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${vl(t)}Modifiers`] || e[`${Si(t)}Modifiers`];
function Nq(e, t, ...n) {
  if (e.isUnmounted) return;
  const o = e.vnode.props || eo;
  if (process.env.NODE_ENV !== "production") {
    const {
      emitsOptions: u,
      propsOptions: [d]
    } = e;
    if (u)
      if (!(t in u))
        (!d || !(Yi(vl(t)) in d)) && $t(
          `Component emitted event "${t}" but it is neither declared in the emits option nor as an "${Yi(vl(t))}" prop.`
        );
      else {
        const f = u[t];
        it(f) && (f(...n) || $t(
          `Invalid event arguments: event validation failed for event "${t}".`
        ));
      }
  }
  let l = n;
  const r = t.startsWith("update:"), a = r && kq(o, t.slice(7));
  if (a && (a.trim && (l = n.map((u) => rt(u) ? u.trim() : u)), a.number && (l = n.map(PE))), process.env.NODE_ENV !== "production" && aq(e, t, l), process.env.NODE_ENV !== "production") {
    const u = t.toLowerCase();
    u !== t && o[Yi(u)] && $t(
      `Event "${u}" is emitted in component ${Zm(
        e,
        e.type
      )} but the handler is registered for "${t}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Si(
        t
      )}" instead of "${t}".`
    );
  }
  let i, s = o[i = Yi(t)] || // also try camelCase event handler (#2249)
  o[i = Yi(vl(t))];
  !s && r && (s = o[i = Yi(Si(t))]), s && Aa(
    s,
    e,
    6,
    l
  );
  const c = o[i + "Once"];
  if (c) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[i])
      return;
    e.emitted[i] = !0, Aa(
      c,
      e,
      6,
      l
    );
  }
}
const Mq = /* @__PURE__ */ new WeakMap();
function D5(e, t, n = !1) {
  const o = n ? Mq : t.emitsCache, l = o.get(e);
  if (l !== void 0)
    return l;
  const r = e.emits;
  let a = {}, i = !1;
  if (!it(e)) {
    const s = (c) => {
      const u = D5(c, t, !0);
      u && (i = !0, _o(a, u));
    };
    !n && t.mixins.length && t.mixins.forEach(s), e.extends && s(e.extends), e.mixins && e.mixins.forEach(s);
  }
  return !r && !i ? (Mt(e) && o.set(e, null), null) : (We(r) ? r.forEach((s) => a[s] = null) : _o(a, r), Mt(e) && o.set(e, a), a);
}
function c1(e, t) {
  return !e || !Km(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), hn(e, t[0].toLowerCase() + t.slice(1)) || hn(e, Si(t)) || hn(e, t));
}
let P$ = !1;
function b0() {
  P$ = !0;
}
function vk(e) {
  const {
    type: t,
    vnode: n,
    proxy: o,
    withProxy: l,
    propsOptions: [r],
    slots: a,
    attrs: i,
    emit: s,
    render: c,
    renderCache: u,
    props: d,
    data: f,
    setupState: p,
    ctx: m,
    inheritAttrs: v
  } = e, h = v0(e);
  let g, y;
  process.env.NODE_ENV !== "production" && (P$ = !1);
  try {
    if (n.shapeFlag & 4) {
      const w = l || o, x = process.env.NODE_ENV !== "production" && p.__isScriptSetup ? new Proxy(w, {
        get(E, I, T) {
          return $t(
            `Property '${String(
              I
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(E, I, T);
        }
      }) : w;
      g = ga(
        c.call(
          x,
          w,
          u,
          process.env.NODE_ENV !== "production" ? /* @__PURE__ */ ci(d) : d,
          p,
          f,
          m
        )
      ), y = i;
    } else {
      const w = t;
      process.env.NODE_ENV !== "production" && i === d && b0(), g = ga(
        w.length > 1 ? w(
          process.env.NODE_ENV !== "production" ? /* @__PURE__ */ ci(d) : d,
          process.env.NODE_ENV !== "production" ? {
            get attrs() {
              return b0(), /* @__PURE__ */ ci(i);
            },
            slots: a,
            emit: s
          } : { attrs: i, slots: a, emit: s }
        ) : w(
          process.env.NODE_ENV !== "production" ? /* @__PURE__ */ ci(d) : d,
          null
        )
      ), y = t.props ? i : Aq(i);
    }
  } catch (w) {
    Ov.length = 0, Ym(w, e, 1), g = $(qn);
  }
  let b = g, C;
  if (process.env.NODE_ENV !== "production" && g.patchFlag > 0 && g.patchFlag & 2048 && ([b, C] = L5(g)), y && v !== !1) {
    const w = Object.keys(y), { shapeFlag: x } = b;
    if (w.length) {
      if (x & 7)
        r && w.some(s0) && (y = Rq(
          y,
          r
        )), b = No(b, y, !1, !0);
      else if (process.env.NODE_ENV !== "production" && !P$ && b.type !== qn) {
        const E = Object.keys(i), I = [], T = [];
        for (let P = 0, k = E.length; P < k; P++) {
          const N = E[P];
          Km(N) ? s0(N) || I.push(N[2].toLowerCase() + N.slice(3)) : T.push(N);
        }
        T.length && $t(
          `Extraneous non-props attributes (${T.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
        ), I.length && $t(
          `Extraneous non-emits event listeners (${I.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return n.dirs && (process.env.NODE_ENV !== "production" && !mk(b) && $t(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), b = No(b, null, !1, !0), b.dirs = b.dirs ? b.dirs.concat(n.dirs) : n.dirs), n.transition && (process.env.NODE_ENV !== "production" && !mk(b) && $t(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), Bu(b, n.transition)), process.env.NODE_ENV !== "production" && C ? C(b) : g = b, v0(h), g;
}
const L5 = (e) => {
  const t = e.children, n = e.dynamicChildren, o = GE(t, !1);
  if (o) {
    if (process.env.NODE_ENV !== "production" && o.patchFlag > 0 && o.patchFlag & 2048)
      return L5(o);
  } else return [e, void 0];
  const l = t.indexOf(o), r = n ? n.indexOf(o) : -1, a = (i) => {
    t[l] = i, n && (r > -1 ? n[r] = i : i.patchFlag > 0 && (e.dynamicChildren = [...n, i]));
  };
  return [ga(o), a];
};
function GE(e, t = !0) {
  let n;
  for (let o = 0; o < e.length; o++) {
    const l = e[o];
    if (dn(l)) {
      if (l.type !== qn || l.children === "v-if") {
        if (n)
          return;
        if (n = l, process.env.NODE_ENV !== "production" && t && n.patchFlag > 0 && n.patchFlag & 2048)
          return GE(n.children);
      }
    } else
      return;
  }
  return n;
}
const Aq = (e) => {
  let t;
  for (const n in e)
    (n === "class" || n === "style" || Km(n)) && ((t || (t = {}))[n] = e[n]);
  return t;
}, Rq = (e, t) => {
  const n = {};
  for (const o in e)
    (!s0(o) || !(o.slice(9) in t)) && (n[o] = e[o]);
  return n;
}, mk = (e) => e.shapeFlag & 7 || e.type === qn;
function Dq(e, t, n) {
  const { props: o, children: l, component: r } = e, { props: a, children: i, patchFlag: s } = t, c = r.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (l || i) && Jr || t.dirs || t.transition)
    return !0;
  if (n && s >= 0) {
    if (s & 1024)
      return !0;
    if (s & 16)
      return o ? hk(o, a, c) : !!a;
    if (s & 8) {
      const u = t.dynamicProps;
      for (let d = 0; d < u.length; d++) {
        const f = u[d];
        if (a[f] !== o[f] && !c1(c, f))
          return !0;
      }
    }
  } else
    return (l || i) && (!i || !i.$stable) ? !0 : o === a ? !1 : o ? a ? hk(o, a, c) : !0 : !!a;
  return !1;
}
function hk(e, t, n) {
  const o = Object.keys(t);
  if (o.length !== Object.keys(e).length)
    return !0;
  for (let l = 0; l < o.length; l++) {
    const r = o[l];
    if (t[r] !== e[r] && !c1(n, r))
      return !0;
  }
  return !1;
}
function Lq({ vnode: e, parent: t }, n) {
  for (; t; ) {
    const o = t.subTree;
    if (o.suspense && o.suspense.activeBranch === e && (o.el = e.el), o === e)
      (e = t.vnode).el = n, t = t.parent;
    else
      break;
  }
}
const B5 = {}, F5 = () => Object.create(B5), V5 = (e) => Object.getPrototypeOf(e) === B5;
function Bq(e, t, n, o = !1) {
  const l = {}, r = F5();
  e.propsDefaults = /* @__PURE__ */ Object.create(null), z5(e, t, l, r);
  for (const a in e.propsOptions[0])
    a in l || (l[a] = void 0);
  process.env.NODE_ENV !== "production" && j5(t || {}, l, e), n ? e.props = o ? l : /* @__PURE__ */ o1(l) : e.type.props ? e.props = l : e.props = r, e.attrs = r;
}
function Fq(e) {
  for (; e; ) {
    if (e.type.__hmrId) return !0;
    e = e.parent;
  }
}
function Vq(e, t, n, o) {
  const {
    props: l,
    attrs: r,
    vnode: { patchFlag: a }
  } = e, i = /* @__PURE__ */ Wt(l), [s] = e.propsOptions;
  let c = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(process.env.NODE_ENV !== "production" && Fq(e)) && (o || a > 0) && !(a & 16)
  ) {
    if (a & 8) {
      const u = e.vnode.dynamicProps;
      for (let d = 0; d < u.length; d++) {
        let f = u[d];
        if (c1(e.emitsOptions, f))
          continue;
        const p = t[f];
        if (s)
          if (hn(r, f))
            p !== r[f] && (r[f] = p, c = !0);
          else {
            const m = vl(f);
            l[m] = k$(
              s,
              i,
              m,
              p,
              e,
              !1
            );
          }
        else
          p !== r[f] && (r[f] = p, c = !0);
      }
    }
  } else {
    z5(e, t, l, r) && (c = !0);
    let u;
    for (const d in i)
      (!t || // for camelCase
      !hn(t, d) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((u = Si(d)) === d || !hn(t, u))) && (s ? n && // for camelCase
      (n[d] !== void 0 || // for kebab-case
      n[u] !== void 0) && (l[d] = k$(
        s,
        i,
        d,
        void 0,
        e,
        !0
      )) : delete l[d]);
    if (r !== i)
      for (const d in r)
        (!t || !hn(t, d)) && (delete r[d], c = !0);
  }
  c && si(e.attrs, "set", ""), process.env.NODE_ENV !== "production" && j5(t || {}, l, e);
}
function z5(e, t, n, o) {
  const [l, r] = e.propsOptions;
  let a = !1, i;
  if (t)
    for (let s in t) {
      if (Cv(s))
        continue;
      const c = t[s];
      let u;
      l && hn(l, u = vl(s)) ? !r || !r.includes(u) ? n[u] = c : (i || (i = {}))[u] = c : c1(e.emitsOptions, s) || (!(s in o) || c !== o[s]) && (o[s] = c, a = !0);
    }
  if (r) {
    const s = /* @__PURE__ */ Wt(n), c = i || eo;
    for (let u = 0; u < r.length; u++) {
      const d = r[u];
      n[d] = k$(
        l,
        s,
        d,
        c[d],
        e,
        !hn(c, d)
      );
    }
  }
  return a;
}
function k$(e, t, n, o, l, r) {
  const a = e[n];
  if (a != null) {
    const i = hn(a, "default");
    if (i && o === void 0) {
      const s = a.default;
      if (a.type !== Function && !a.skipFactory && it(s)) {
        const { propsDefaults: c } = l;
        if (n in c)
          o = c[n];
        else {
          const u = Jm(l);
          o = c[n] = s.call(
            null,
            t
          ), u();
        }
      } else
        o = s;
      l.ce && l.ce._setProp(n, o);
    }
    a[
      0
      /* shouldCast */
    ] && (r && !i ? o = !1 : a[
      1
      /* shouldCastTrue */
    ] && (o === "" || o === Si(n)) && (o = !0));
  }
  return o;
}
const zq = /* @__PURE__ */ new WeakMap();
function H5(e, t, n = !1) {
  const o = n ? zq : t.propsCache, l = o.get(e);
  if (l)
    return l;
  const r = e.props, a = {}, i = [];
  let s = !1;
  if (!it(e)) {
    const u = (d) => {
      s = !0;
      const [f, p] = H5(d, t, !0);
      _o(a, f), p && i.push(...p);
    };
    !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u);
  }
  if (!r && !s)
    return Mt(e) && o.set(e, of), of;
  if (We(r))
    for (let u = 0; u < r.length; u++) {
      process.env.NODE_ENV !== "production" && !rt(r[u]) && $t("props must be strings when using array syntax.", r[u]);
      const d = vl(r[u]);
      gk(d) && (a[d] = eo);
    }
  else if (r) {
    process.env.NODE_ENV !== "production" && !Mt(r) && $t("invalid props options", r);
    for (const u in r) {
      const d = vl(u);
      if (gk(d)) {
        const f = r[u], p = a[d] = We(f) || it(f) ? { type: f } : _o({}, f), m = p.type;
        let v = !1, h = !0;
        if (We(m))
          for (let g = 0; g < m.length; ++g) {
            const y = m[g], b = it(y) && y.name;
            if (b === "Boolean") {
              v = !0;
              break;
            } else b === "String" && (h = !1);
          }
        else
          v = it(m) && m.name === "Boolean";
        p[
          0
          /* shouldCast */
        ] = v, p[
          1
          /* shouldCastTrue */
        ] = h, (v || hn(p, "default")) && i.push(d);
      }
    }
  }
  const c = [a, i];
  return Mt(e) && o.set(e, c), c;
}
function gk(e) {
  return e[0] !== "$" && !Cv(e) ? !0 : (process.env.NODE_ENV !== "production" && $t(`Invalid prop name: "${e}" is a reserved property.`), !1);
}
function Hq(e) {
  return e === null ? "null" : typeof e == "function" ? e.name || "" : typeof e == "object" && e.constructor && e.constructor.name || "";
}
function j5(e, t, n) {
  const o = /* @__PURE__ */ Wt(t), l = n.propsOptions[0], r = Object.keys(e).map((a) => vl(a));
  for (const a in l) {
    let i = l[a];
    i != null && jq(
      a,
      o[a],
      i,
      process.env.NODE_ENV !== "production" ? /* @__PURE__ */ ci(o) : o,
      !r.includes(a)
    );
  }
}
function jq(e, t, n, o, l) {
  const { type: r, required: a, validator: i, skipCheck: s } = n;
  if (a && l) {
    $t('Missing required prop: "' + e + '"');
    return;
  }
  if (!(t == null && !a)) {
    if (r != null && r !== !0 && !s) {
      let c = !1;
      const u = We(r) ? r : [r], d = [];
      for (let f = 0; f < u.length && !c; f++) {
        const { valid: p, expectedType: m } = Kq(t, u[f]);
        d.push(m || ""), c = p;
      }
      if (!c) {
        $t(Uq(e, t, d));
        return;
      }
    }
    i && !i(t, o) && $t('Invalid prop: custom validator check failed for prop "' + e + '".');
  }
}
const Wq = /* @__PURE__ */ Cs(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function Kq(e, t) {
  let n;
  const o = Hq(t);
  if (o === "null")
    n = e === null;
  else if (Wq(o)) {
    const l = typeof e;
    n = l === o.toLowerCase(), !n && l === "object" && (n = e instanceof t);
  } else o === "Object" ? n = Mt(e) : o === "Array" ? n = We(e) : n = e instanceof t;
  return {
    valid: n,
    expectedType: o
  };
}
function Uq(e, t, n) {
  if (n.length === 0)
    return `Prop type [] for prop "${e}" won't match anything. Did you mean to use type Array instead?`;
  let o = `Invalid prop: type check failed for prop "${e}". Expected ${n.map(hc).join(" | ")}`;
  const l = n[0], r = TE(t), a = bk(t, l), i = bk(t, r);
  return n.length === 1 && yk(l) && !Gq(l, r) && (o += ` with value ${a}`), o += `, got ${r} `, yk(r) && (o += `with value ${i}.`), o;
}
function bk(e, t) {
  return t === "String" ? `"${e}"` : t === "Number" ? `${Number(e)}` : `${e}`;
}
function yk(e) {
  return ["string", "number", "boolean"].some((n) => e.toLowerCase() === n);
}
function Gq(...e) {
  return e.some((t) => t.toLowerCase() === "boolean");
}
const YE = (e) => e === "_" || e === "_ctx" || e === "$stable", XE = (e) => We(e) ? e.map(ga) : [ga(e)], Yq = (e, t, n) => {
  if (t._n)
    return t;
  const o = Ee((...l) => (process.env.NODE_ENV !== "production" && Xo && !(n === null && Zo) && !(n && n.root !== Xo.root) && $t(
    `Slot "${e}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), XE(t(...l))), n);
  return o._c = !1, o;
}, W5 = (e, t, n) => {
  const o = e._ctx;
  for (const l in e) {
    if (YE(l)) continue;
    const r = e[l];
    if (it(r))
      t[l] = Yq(l, r, o);
    else if (r != null) {
      process.env.NODE_ENV !== "production" && $t(
        `Non-function value encountered for slot "${l}". Prefer function slots for better performance.`
      );
      const a = XE(r);
      t[l] = () => a;
    }
  }
}, K5 = (e, t) => {
  process.env.NODE_ENV !== "production" && !qm(e.vnode) && $t(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const n = XE(t);
  e.slots.default = () => n;
}, N$ = (e, t, n) => {
  for (const o in t)
    (n || !YE(o)) && (e[o] = t[o]);
}, Xq = (e, t, n) => {
  const o = e.slots = F5();
  if (e.vnode.shapeFlag & 32) {
    const l = t._;
    l ? (N$(o, t, n), n && c0(o, "_", l, !0)) : W5(t, o);
  } else t && K5(e, t);
}, qq = (e, t, n) => {
  const { vnode: o, slots: l } = e;
  let r = !0, a = eo;
  if (o.shapeFlag & 32) {
    const i = t._;
    i ? process.env.NODE_ENV !== "production" && Jr ? (N$(l, t, n), si(e, "set", "$slots")) : n && i === 1 ? r = !1 : N$(l, t, n) : (r = !t.$stable, W5(t, l)), a = t;
  } else t && (K5(e, t), a = { default: 1 });
  if (r)
    for (const i in l)
      !YE(i) && a[i] == null && delete l[i];
};
let Gp, qi;
function Cd(e, t) {
  e.appContext.config.performance && y0() && qi.mark(`vue-${t}-${e.uid}`), process.env.NODE_ENV !== "production" && lq(e, t, y0() ? qi.now() : Date.now());
}
function wd(e, t) {
  if (e.appContext.config.performance && y0()) {
    const n = `vue-${t}-${e.uid}`, o = n + ":end", l = `<${Zm(e, e.type)}> ${t}`;
    qi.mark(o), qi.measure(l, n, o), qi.clearMeasures(l), qi.clearMarks(n), qi.clearMarks(o);
  }
  process.env.NODE_ENV !== "production" && rq(e, t, y0() ? qi.now() : Date.now());
}
function y0() {
  return Gp !== void 0 || (typeof window != "undefined" && window.performance ? (Gp = !0, qi = window.performance) : Gp = !1), Gp;
}
function Jq() {
  const e = [];
  if (process.env.NODE_ENV !== "production" && e.length) {
    const t = e.length > 1;
    console.warn(
      `Feature flag${t ? "s" : ""} ${e.join(", ")} ${t ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const Yl = nJ;
function Zq(e) {
  return Qq(e);
}
function Qq(e, t) {
  Jq();
  const n = Gm();
  n.__VUE__ = !0, process.env.NODE_ENV !== "production" && VE(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
  const {
    insert: o,
    remove: l,
    patchProp: r,
    createElement: a,
    createText: i,
    createComment: s,
    setText: c,
    setElementText: u,
    parentNode: d,
    nextSibling: f,
    setScopeId: p = gn,
    insertStaticContent: m
  } = e, v = (Z, ee, fe, me = null, ge = null, he = null, $e = void 0, ne = null, ae = process.env.NODE_ENV !== "production" && Jr ? !1 : !!ee.dynamicChildren) => {
    if (Z === ee)
      return;
    Z && !tu(Z, ee) && (me = re(Z), W(Z, ge, he, !0), Z = null), ee.patchFlag === -2 && (ae = !1, ee.dynamicChildren = null);
    const { type: ce, ref: xe, shapeFlag: Te } = ee;
    switch (ce) {
      case Vr:
        h(Z, ee, fe, me);
        break;
      case qn:
        g(Z, ee, fe, me);
        break;
      case tb:
        Z == null ? y(ee, fe, me, $e) : process.env.NODE_ENV !== "production" && b(Z, ee, fe, $e);
        break;
      case Ge:
        R(
          Z,
          ee,
          fe,
          me,
          ge,
          he,
          $e,
          ne,
          ae
        );
        break;
      default:
        Te & 1 ? x(
          Z,
          ee,
          fe,
          me,
          ge,
          he,
          $e,
          ne,
          ae
        ) : Te & 6 ? z(
          Z,
          ee,
          fe,
          me,
          ge,
          he,
          $e,
          ne,
          ae
        ) : Te & 64 || Te & 128 ? ce.process(
          Z,
          ee,
          fe,
          me,
          ge,
          he,
          $e,
          ne,
          ae,
          K
        ) : process.env.NODE_ENV !== "production" && $t("Invalid VNode type:", ce, `(${typeof ce})`);
    }
    xe != null && ge ? xv(xe, Z && Z.ref, he, ee || Z, !ee) : xe == null && Z && Z.ref != null && xv(Z.ref, null, he, Z, !0);
  }, h = (Z, ee, fe, me) => {
    if (Z == null)
      o(
        ee.el = i(ee.children),
        fe,
        me
      );
    else {
      const ge = ee.el = Z.el;
      if (ee.children !== Z.children)
        if (process.env.NODE_ENV !== "production" && Jr && ee.patchFlag === -1 && "__elIndex" in Z) {
          const he = fe.childNodes, $e = i(ee.children), ne = he[ee.__elIndex = Z.__elIndex];
          o($e, fe, ne), l(ne);
        } else
          c(ge, ee.children);
    }
  }, g = (Z, ee, fe, me) => {
    Z == null ? o(
      ee.el = s(ee.children || ""),
      fe,
      me
    ) : ee.el = Z.el;
  }, y = (Z, ee, fe, me) => {
    [Z.el, Z.anchor] = m(
      Z.children,
      ee,
      fe,
      me,
      Z.el,
      Z.anchor
    );
  }, b = (Z, ee, fe, me) => {
    if (ee.children !== Z.children) {
      const ge = f(Z.anchor);
      w(Z), [ee.el, ee.anchor] = m(
        ee.children,
        fe,
        ge,
        me
      );
    } else
      ee.el = Z.el, ee.anchor = Z.anchor;
  }, C = ({ el: Z, anchor: ee }, fe, me) => {
    let ge;
    for (; Z && Z !== ee; )
      ge = f(Z), o(Z, fe, me), Z = ge;
    o(ee, fe, me);
  }, w = ({ el: Z, anchor: ee }) => {
    let fe;
    for (; Z && Z !== ee; )
      fe = f(Z), l(Z), Z = fe;
    l(ee);
  }, x = (Z, ee, fe, me, ge, he, $e, ne, ae) => {
    if (ee.type === "svg" ? $e = "svg" : ee.type === "math" && ($e = "mathml"), Z == null)
      E(
        ee,
        fe,
        me,
        ge,
        he,
        $e,
        ne,
        ae
      );
    else {
      const ce = Z.el && Z.el._isVueCE ? Z.el : null;
      try {
        ce && ce._beginPatch(), P(
          Z,
          ee,
          ge,
          he,
          $e,
          ne,
          ae
        );
      } finally {
        ce && ce._endPatch();
      }
    }
  }, E = (Z, ee, fe, me, ge, he, $e, ne) => {
    let ae, ce;
    const { props: xe, shapeFlag: Te, transition: Se, dirs: be } = Z;
    if (ae = Z.el = a(
      Z.type,
      he,
      xe && xe.is,
      xe
    ), Te & 8 ? u(ae, Z.children) : Te & 16 && T(
      Z.children,
      ae,
      null,
      me,
      ge,
      CC(Z, he),
      $e,
      ne
    ), be && Fc(Z, null, me, "created"), I(ae, Z, Z.scopeId, $e, me), xe) {
      for (const we in xe)
        we !== "value" && !Cv(we) && r(ae, we, null, xe[we], he, me);
      "value" in xe && r(ae, "value", null, xe.value, he), (ce = xe.onVnodeBeforeMount) && ei(ce, me, Z);
    }
    process.env.NODE_ENV !== "production" && (c0(ae, "__vnode", Z, !0), c0(ae, "__vueParentComponent", me, !0)), be && Fc(Z, null, me, "beforeMount");
    const ie = eJ(ge, Se);
    ie && Se.beforeEnter(ae), o(ae, ee, fe), ((ce = xe && xe.onVnodeMounted) || ie || be) && Yl(() => {
      ce && ei(ce, me, Z), ie && Se.enter(ae), be && Fc(Z, null, me, "mounted");
    }, ge);
  }, I = (Z, ee, fe, me, ge) => {
    if (fe && p(Z, fe), me)
      for (let he = 0; he < me.length; he++)
        p(Z, me[he]);
    if (ge) {
      let he = ge.subTree;
      if (process.env.NODE_ENV !== "production" && he.patchFlag > 0 && he.patchFlag & 2048 && (he = GE(he.children) || he), ee === he || Y5(he.type) && (he.ssContent === ee || he.ssFallback === ee)) {
        const $e = ge.vnode;
        I(
          Z,
          $e,
          $e.scopeId,
          $e.slotScopeIds,
          ge.parent
        );
      }
    }
  }, T = (Z, ee, fe, me, ge, he, $e, ne, ae = 0) => {
    for (let ce = ae; ce < Z.length; ce++) {
      const xe = Z[ce] = ne ? Ws(Z[ce]) : ga(Z[ce]);
      v(
        null,
        xe,
        ee,
        fe,
        me,
        ge,
        he,
        $e,
        ne
      );
    }
  }, P = (Z, ee, fe, me, ge, he, $e) => {
    const ne = ee.el = Z.el;
    process.env.NODE_ENV !== "production" && (ne.__vnode = ee);
    let { patchFlag: ae, dynamicChildren: ce, dirs: xe } = ee;
    ae |= Z.patchFlag & 16;
    const Te = Z.props || eo, Se = ee.props || eo;
    let be;
    if (fe && Vc(fe, !1), (be = Se.onVnodeBeforeUpdate) && ei(be, fe, ee, Z), xe && Fc(ee, Z, fe, "beforeUpdate"), fe && Vc(fe, !0), process.env.NODE_ENV !== "production" && Jr && (ae = 0, $e = !1, ce = null), (Te.innerHTML && Se.innerHTML == null || Te.textContent && Se.textContent == null) && u(ne, ""), ce ? (k(
      Z.dynamicChildren,
      ce,
      ne,
      fe,
      me,
      CC(ee, ge),
      he
    ), process.env.NODE_ENV !== "production" && Ev(Z, ee)) : $e || L(
      Z,
      ee,
      ne,
      null,
      fe,
      me,
      CC(ee, ge),
      he,
      !1
    ), ae > 0) {
      if (ae & 16)
        N(ne, Te, Se, fe, ge);
      else if (ae & 2 && Te.class !== Se.class && r(ne, "class", null, Se.class, ge), ae & 4 && r(ne, "style", Te.style, Se.style, ge), ae & 8) {
        const ie = ee.dynamicProps;
        for (let we = 0; we < ie.length; we++) {
          const Ne = ie[we], tt = Te[Ne], Pe = Se[Ne];
          (Pe !== tt || Ne === "value") && r(ne, Ne, tt, Pe, ge, fe);
        }
      }
      ae & 1 && Z.children !== ee.children && u(ne, ee.children);
    } else !$e && ce == null && N(ne, Te, Se, fe, ge);
    ((be = Se.onVnodeUpdated) || xe) && Yl(() => {
      be && ei(be, fe, ee, Z), xe && Fc(ee, Z, fe, "updated");
    }, me);
  }, k = (Z, ee, fe, me, ge, he, $e) => {
    for (let ne = 0; ne < ee.length; ne++) {
      const ae = Z[ne], ce = ee[ne], xe = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        ae.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (ae.type === Ge || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !tu(ae, ce) || // - In the case of a component, it could contain anything.
        ae.shapeFlag & 198) ? d(ae.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fe
        )
      );
      v(
        ae,
        ce,
        xe,
        null,
        me,
        ge,
        he,
        $e,
        !0
      );
    }
  }, N = (Z, ee, fe, me, ge) => {
    if (ee !== fe) {
      if (ee !== eo)
        for (const he in ee)
          !Cv(he) && !(he in fe) && r(
            Z,
            he,
            ee[he],
            null,
            ge,
            me
          );
      for (const he in fe) {
        if (Cv(he)) continue;
        const $e = fe[he], ne = ee[he];
        $e !== ne && he !== "value" && r(Z, he, ne, $e, ge, me);
      }
      "value" in fe && r(Z, "value", ee.value, fe.value, ge);
    }
  }, R = (Z, ee, fe, me, ge, he, $e, ne, ae) => {
    const ce = ee.el = Z ? Z.el : i(""), xe = ee.anchor = Z ? Z.anchor : i("");
    let { patchFlag: Te, dynamicChildren: Se, slotScopeIds: be } = ee;
    process.env.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (Jr || Te & 2048) && (Te = 0, ae = !1, Se = null), be && (ne = ne ? ne.concat(be) : be), Z == null ? (o(ce, fe, me), o(xe, fe, me), T(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      ee.children || [],
      fe,
      xe,
      ge,
      he,
      $e,
      ne,
      ae
    )) : Te > 0 && Te & 64 && Se && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    Z.dynamicChildren && Z.dynamicChildren.length === Se.length ? (k(
      Z.dynamicChildren,
      Se,
      fe,
      ge,
      he,
      $e,
      ne
    ), process.env.NODE_ENV !== "production" ? Ev(Z, ee) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (ee.key != null || ge && ee === ge.subTree) && Ev(
        Z,
        ee,
        !0
        /* shallow */
      )
    )) : L(
      Z,
      ee,
      fe,
      xe,
      ge,
      he,
      $e,
      ne,
      ae
    );
  }, z = (Z, ee, fe, me, ge, he, $e, ne, ae) => {
    ee.slotScopeIds = ne, Z == null ? ee.shapeFlag & 512 ? ge.ctx.activate(
      ee,
      fe,
      me,
      $e,
      ae
    ) : D(
      ee,
      fe,
      me,
      ge,
      he,
      $e,
      ae
    ) : F(Z, ee, ae);
  }, D = (Z, ee, fe, me, ge, he, $e) => {
    const ne = Z.component = iJ(
      Z,
      me,
      ge
    );
    if (process.env.NODE_ENV !== "production" && ne.type.__hmrId && XX(ne), process.env.NODE_ENV !== "production" && (Jg(Z), Cd(ne, "mount")), qm(Z) && (ne.ctx.renderer = K), process.env.NODE_ENV !== "production" && Cd(ne, "init"), cJ(ne, !1, $e), process.env.NODE_ENV !== "production" && wd(ne, "init"), process.env.NODE_ENV !== "production" && Jr && (Z.el = null), ne.asyncDep) {
      if (ge && ge.registerDep(ne, M, $e), !Z.el) {
        const ae = ne.subTree = $(qn);
        g(null, ae, ee, fe), Z.placeholder = ae.el;
      }
    } else
      M(
        ne,
        Z,
        ee,
        fe,
        ge,
        he,
        $e
      );
    process.env.NODE_ENV !== "production" && (Zg(), wd(ne, "mount"));
  }, F = (Z, ee, fe) => {
    const me = ee.component = Z.component;
    if (Dq(Z, ee, fe))
      if (me.asyncDep && !me.asyncResolved) {
        process.env.NODE_ENV !== "production" && Jg(ee), A(me, ee, fe), process.env.NODE_ENV !== "production" && Zg();
        return;
      } else
        me.next = ee, me.update();
    else
      ee.el = Z.el, me.vnode = ee;
  }, M = (Z, ee, fe, me, ge, he, $e) => {
    const ne = () => {
      if (Z.isMounted) {
        let { next: Te, bu: Se, u: be, parent: ie, vnode: we } = Z;
        {
          const Le = U5(Z);
          if (Le) {
            Te && (Te.el = we.el, A(Z, Te, $e)), Le.asyncDep.then(() => {
              Z.isUnmounted || ne();
            });
            return;
          }
        }
        let Ne = Te, tt;
        process.env.NODE_ENV !== "production" && Jg(Te || Z.vnode), Vc(Z, !1), Te ? (Te.el = we.el, A(Z, Te, $e)) : Te = we, Se && Ld(Se), (tt = Te.props && Te.props.onVnodeBeforeUpdate) && ei(tt, ie, Te, we), Vc(Z, !0), process.env.NODE_ENV !== "production" && Cd(Z, "render");
        const Pe = vk(Z);
        process.env.NODE_ENV !== "production" && wd(Z, "render");
        const Re = Z.subTree;
        Z.subTree = Pe, process.env.NODE_ENV !== "production" && Cd(Z, "patch"), v(
          Re,
          Pe,
          // parent may have changed if it's in a teleport
          d(Re.el),
          // anchor may have changed if it's in a fragment
          re(Re),
          Z,
          ge,
          he
        ), process.env.NODE_ENV !== "production" && wd(Z, "patch"), Te.el = Pe.el, Ne === null && Lq(Z, Pe.el), be && Yl(be, ge), (tt = Te.props && Te.props.onVnodeUpdated) && Yl(
          () => ei(tt, ie, Te, we),
          ge
        ), process.env.NODE_ENV !== "production" && p5(Z), process.env.NODE_ENV !== "production" && Zg();
      } else {
        let Te;
        const { el: Se, props: be } = ee, { bm: ie, m: we, parent: Ne, root: tt, type: Pe } = Z, Re = af(ee);
        Vc(Z, !1), ie && Ld(ie), !Re && (Te = be && be.onVnodeBeforeMount) && ei(Te, Ne, ee), Vc(Z, !0);
        {
          tt.ce && // @ts-expect-error _def is private
          tt.ce._def.shadowRoot !== !1 && tt.ce._injectChildStyle(Pe), process.env.NODE_ENV !== "production" && Cd(Z, "render");
          const Le = Z.subTree = vk(Z);
          process.env.NODE_ENV !== "production" && wd(Z, "render"), process.env.NODE_ENV !== "production" && Cd(Z, "patch"), v(
            null,
            Le,
            fe,
            me,
            Z,
            ge,
            he
          ), process.env.NODE_ENV !== "production" && wd(Z, "patch"), ee.el = Le.el;
        }
        if (we && Yl(we, ge), !Re && (Te = be && be.onVnodeMounted)) {
          const Le = ee;
          Yl(
            () => ei(Te, Ne, Le),
            ge
          );
        }
        (ee.shapeFlag & 256 || Ne && af(Ne.vnode) && Ne.vnode.shapeFlag & 256) && Z.a && Yl(Z.a, ge), Z.isMounted = !0, process.env.NODE_ENV !== "production" && tq(Z), ee = fe = me = null;
      }
    };
    Z.scope.on();
    const ae = Z.effect = new zD(ne);
    Z.scope.off();
    const ce = Z.update = ae.run.bind(ae), xe = Z.job = ae.runIfDirty.bind(ae);
    xe.i = Z, xe.id = Z.uid, ae.scheduler = () => r1(xe), Vc(Z, !0), process.env.NODE_ENV !== "production" && (ae.onTrack = Z.rtc ? (Te) => Ld(Z.rtc, Te) : void 0, ae.onTrigger = Z.rtg ? (Te) => Ld(Z.rtg, Te) : void 0), ce();
  }, A = (Z, ee, fe) => {
    ee.component = Z;
    const me = Z.vnode.props;
    Z.vnode = ee, Z.next = null, Vq(Z, ee.props, me, fe), qq(Z, ee.children, fe), Pa(), tk(Z), ka();
  }, L = (Z, ee, fe, me, ge, he, $e, ne, ae = !1) => {
    const ce = Z && Z.children, xe = Z ? Z.shapeFlag : 0, Te = ee.children, { patchFlag: Se, shapeFlag: be } = ee;
    if (Se > 0) {
      if (Se & 128) {
        V(
          ce,
          Te,
          fe,
          me,
          ge,
          he,
          $e,
          ne,
          ae
        );
        return;
      } else if (Se & 256) {
        B(
          ce,
          Te,
          fe,
          me,
          ge,
          he,
          $e,
          ne,
          ae
        );
        return;
      }
    }
    be & 8 ? (xe & 16 && J(ce, ge, he), Te !== ce && u(fe, Te)) : xe & 16 ? be & 16 ? V(
      ce,
      Te,
      fe,
      me,
      ge,
      he,
      $e,
      ne,
      ae
    ) : J(ce, ge, he, !0) : (xe & 8 && u(fe, ""), be & 16 && T(
      Te,
      fe,
      me,
      ge,
      he,
      $e,
      ne,
      ae
    ));
  }, B = (Z, ee, fe, me, ge, he, $e, ne, ae) => {
    Z = Z || of, ee = ee || of;
    const ce = Z.length, xe = ee.length, Te = Math.min(ce, xe);
    let Se;
    for (Se = 0; Se < Te; Se++) {
      const be = ee[Se] = ae ? Ws(ee[Se]) : ga(ee[Se]);
      v(
        Z[Se],
        be,
        fe,
        null,
        ge,
        he,
        $e,
        ne,
        ae
      );
    }
    ce > xe ? J(
      Z,
      ge,
      he,
      !0,
      !1,
      Te
    ) : T(
      ee,
      fe,
      me,
      ge,
      he,
      $e,
      ne,
      ae,
      Te
    );
  }, V = (Z, ee, fe, me, ge, he, $e, ne, ae) => {
    let ce = 0;
    const xe = ee.length;
    let Te = Z.length - 1, Se = xe - 1;
    for (; ce <= Te && ce <= Se; ) {
      const be = Z[ce], ie = ee[ce] = ae ? Ws(ee[ce]) : ga(ee[ce]);
      if (tu(be, ie))
        v(
          be,
          ie,
          fe,
          null,
          ge,
          he,
          $e,
          ne,
          ae
        );
      else
        break;
      ce++;
    }
    for (; ce <= Te && ce <= Se; ) {
      const be = Z[Te], ie = ee[Se] = ae ? Ws(ee[Se]) : ga(ee[Se]);
      if (tu(be, ie))
        v(
          be,
          ie,
          fe,
          null,
          ge,
          he,
          $e,
          ne,
          ae
        );
      else
        break;
      Te--, Se--;
    }
    if (ce > Te) {
      if (ce <= Se) {
        const be = Se + 1, ie = be < xe ? ee[be].el : me;
        for (; ce <= Se; )
          v(
            null,
            ee[ce] = ae ? Ws(ee[ce]) : ga(ee[ce]),
            fe,
            ie,
            ge,
            he,
            $e,
            ne,
            ae
          ), ce++;
      }
    } else if (ce > Se)
      for (; ce <= Te; )
        W(Z[ce], ge, he, !0), ce++;
    else {
      const be = ce, ie = ce, we = /* @__PURE__ */ new Map();
      for (ce = ie; ce <= Se; ce++) {
        const De = ee[ce] = ae ? Ws(ee[ce]) : ga(ee[ce]);
        De.key != null && (process.env.NODE_ENV !== "production" && we.has(De.key) && $t(
          "Duplicate keys found during update:",
          JSON.stringify(De.key),
          "Make sure keys are unique."
        ), we.set(De.key, ce));
      }
      let Ne, tt = 0;
      const Pe = Se - ie + 1;
      let Re = !1, Le = 0;
      const Ue = new Array(Pe);
      for (ce = 0; ce < Pe; ce++) Ue[ce] = 0;
      for (ce = be; ce <= Te; ce++) {
        const De = Z[ce];
        if (tt >= Pe) {
          W(De, ge, he, !0);
          continue;
        }
        let _e;
        if (De.key != null)
          _e = we.get(De.key);
        else
          for (Ne = ie; Ne <= Se; Ne++)
            if (Ue[Ne - ie] === 0 && tu(De, ee[Ne])) {
              _e = Ne;
              break;
            }
        _e === void 0 ? W(De, ge, he, !0) : (Ue[_e - ie] = ce + 1, _e >= Le ? Le = _e : Re = !0, v(
          De,
          ee[_e],
          fe,
          null,
          ge,
          he,
          $e,
          ne,
          ae
        ), tt++);
      }
      const Ae = Re ? tJ(Ue) : of;
      for (Ne = Ae.length - 1, ce = Pe - 1; ce >= 0; ce--) {
        const De = ie + ce, _e = ee[De], Ze = ee[De + 1], dt = De + 1 < xe ? (
          // #13559, #14173 fallback to el placeholder for unresolved async component
          Ze.el || G5(Ze)
        ) : me;
        Ue[ce] === 0 ? v(
          null,
          _e,
          fe,
          dt,
          ge,
          he,
          $e,
          ne,
          ae
        ) : Re && (Ne < 0 || ce !== Ae[Ne] ? j(_e, fe, dt, 2) : Ne--);
      }
    }
  }, j = (Z, ee, fe, me, ge = null) => {
    const { el: he, type: $e, transition: ne, children: ae, shapeFlag: ce } = Z;
    if (ce & 6) {
      j(Z.component.subTree, ee, fe, me);
      return;
    }
    if (ce & 128) {
      Z.suspense.move(ee, fe, me);
      return;
    }
    if (ce & 64) {
      $e.move(Z, ee, fe, K);
      return;
    }
    if ($e === Ge) {
      o(he, ee, fe);
      for (let Te = 0; Te < ae.length; Te++)
        j(ae[Te], ee, fe, me);
      o(Z.anchor, ee, fe);
      return;
    }
    if ($e === tb) {
      C(Z, ee, fe);
      return;
    }
    if (me !== 2 && ce & 1 && ne)
      if (me === 0)
        ne.beforeEnter(he), o(he, ee, fe), Yl(() => ne.enter(he), ge);
      else {
        const { leave: Te, delayLeave: Se, afterLeave: be } = ne, ie = () => {
          Z.ctx.isUnmounted ? l(he) : o(he, ee, fe);
        }, we = () => {
          he._isLeaving && he[Xi](
            !0
            /* cancelled */
          ), Te(he, () => {
            ie(), be && be();
          });
        };
        Se ? Se(he, ie, we) : we();
      }
    else
      o(he, ee, fe);
  }, W = (Z, ee, fe, me = !1, ge = !1) => {
    const {
      type: he,
      props: $e,
      ref: ne,
      children: ae,
      dynamicChildren: ce,
      shapeFlag: xe,
      patchFlag: Te,
      dirs: Se,
      cacheIndex: be
    } = Z;
    if (Te === -2 && (ge = !1), ne != null && (Pa(), xv(ne, null, fe, Z, !0), ka()), be != null && (ee.renderCache[be] = void 0), xe & 256) {
      ee.ctx.deactivate(Z);
      return;
    }
    const ie = xe & 1 && Se, we = !af(Z);
    let Ne;
    if (we && (Ne = $e && $e.onVnodeBeforeUnmount) && ei(Ne, ee, Z), xe & 6)
      te(Z.component, fe, me);
    else {
      if (xe & 128) {
        Z.suspense.unmount(fe, me);
        return;
      }
      ie && Fc(Z, null, ee, "beforeUnmount"), xe & 64 ? Z.type.remove(
        Z,
        ee,
        fe,
        K,
        me
      ) : ce && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !ce.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (he !== Ge || Te > 0 && Te & 64) ? J(
        ce,
        ee,
        fe,
        !1,
        !0
      ) : (he === Ge && Te & 384 || !ge && xe & 16) && J(ae, ee, fe), me && Y(Z);
    }
    (we && (Ne = $e && $e.onVnodeUnmounted) || ie) && Yl(() => {
      Ne && ei(Ne, ee, Z), ie && Fc(Z, null, ee, "unmounted");
    }, fe);
  }, Y = (Z) => {
    const { type: ee, el: fe, anchor: me, transition: ge } = Z;
    if (ee === Ge) {
      process.env.NODE_ENV !== "production" && Z.patchFlag > 0 && Z.patchFlag & 2048 && ge && !ge.persisted ? Z.children.forEach(($e) => {
        $e.type === qn ? l($e.el) : Y($e);
      }) : U(fe, me);
      return;
    }
    if (ee === tb) {
      w(Z);
      return;
    }
    const he = () => {
      l(fe), ge && !ge.persisted && ge.afterLeave && ge.afterLeave();
    };
    if (Z.shapeFlag & 1 && ge && !ge.persisted) {
      const { leave: $e, delayLeave: ne } = ge, ae = () => $e(fe, he);
      ne ? ne(Z.el, he, ae) : ae();
    } else
      he();
  }, U = (Z, ee) => {
    let fe;
    for (; Z !== ee; )
      fe = f(Z), l(Z), Z = fe;
    l(ee);
  }, te = (Z, ee, fe) => {
    process.env.NODE_ENV !== "production" && Z.type.__hmrId && qX(Z);
    const { bum: me, scope: ge, job: he, subTree: $e, um: ne, m: ae, a: ce } = Z;
    Sk(ae), Sk(ce), me && Ld(me), ge.stop(), he && (he.flags |= 8, W($e, Z, ee, fe)), ne && Yl(ne, ee), Yl(() => {
      Z.isUnmounted = !0;
    }, ee), process.env.NODE_ENV !== "production" && oq(Z);
  }, J = (Z, ee, fe, me = !1, ge = !1, he = 0) => {
    for (let $e = he; $e < Z.length; $e++)
      W(Z[$e], ee, fe, me, ge);
  }, re = (Z) => {
    if (Z.shapeFlag & 6)
      return re(Z.component.subTree);
    if (Z.shapeFlag & 128)
      return Z.suspense.next();
    const ee = f(Z.anchor || Z.el), fe = ee && ee[b5];
    return fe ? f(fe) : ee;
  };
  let oe = !1;
  const q = (Z, ee, fe) => {
    let me;
    Z == null ? ee._vnode && (W(ee._vnode, null, null, !0), me = ee._vnode.component) : v(
      ee._vnode || null,
      Z,
      ee,
      null,
      null,
      null,
      fe
    ), ee._vnode = Z, oe || (oe = !0, tk(me), u5(), oe = !1);
  }, K = {
    p: v,
    um: W,
    m: j,
    r: Y,
    mt: D,
    mc: T,
    pc: L,
    pbc: k,
    n: re,
    o: e
  };
  return {
    render: q,
    hydrate: void 0,
    createApp: Pq(q)
  };
}
function CC({ type: e, props: t }, n) {
  return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n;
}
function Vc({ effect: e, job: t }, n) {
  n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5);
}
function eJ(e, t) {
  return (!e || e && !e.pendingBranch) && t && !t.persisted;
}
function Ev(e, t, n = !1) {
  const o = e.children, l = t.children;
  if (We(o) && We(l))
    for (let r = 0; r < o.length; r++) {
      const a = o[r];
      let i = l[r];
      i.shapeFlag & 1 && !i.dynamicChildren && ((i.patchFlag <= 0 || i.patchFlag === 32) && (i = l[r] = Ws(l[r]), i.el = a.el), !n && i.patchFlag !== -2 && Ev(a, i)), i.type === Vr && (i.patchFlag !== -1 ? i.el = a.el : i.__elIndex = r + // take fragment start anchor into account
      (e.type === Ge ? 1 : 0)), i.type === qn && !i.el && (i.el = a.el), process.env.NODE_ENV !== "production" && i.el && (i.el.__vnode = i);
    }
}
function tJ(e) {
  const t = e.slice(), n = [0];
  let o, l, r, a, i;
  const s = e.length;
  for (o = 0; o < s; o++) {
    const c = e[o];
    if (c !== 0) {
      if (l = n[n.length - 1], e[l] < c) {
        t[o] = l, n.push(o);
        continue;
      }
      for (r = 0, a = n.length - 1; r < a; )
        i = r + a >> 1, e[n[i]] < c ? r = i + 1 : a = i;
      c < e[n[r]] && (r > 0 && (t[o] = n[r - 1]), n[r] = o);
    }
  }
  for (r = n.length, a = n[r - 1]; r-- > 0; )
    n[r] = a, a = t[a];
  return n;
}
function U5(e) {
  const t = e.subTree.component;
  if (t)
    return t.asyncDep && !t.asyncResolved ? t : U5(t);
}
function Sk(e) {
  if (e)
    for (let t = 0; t < e.length; t++)
      e[t].flags |= 8;
}
function G5(e) {
  if (e.placeholder)
    return e.placeholder;
  const t = e.component;
  return t ? G5(t.subTree) : null;
}
const Y5 = (e) => e.__isSuspense;
function nJ(e, t) {
  t && t.pendingBranch ? We(e) ? t.effects.push(...e) : t.effects.push(e) : c5(e);
}
const Ge = /* @__PURE__ */ Symbol.for("v-fgt"), Vr = /* @__PURE__ */ Symbol.for("v-txt"), qn = /* @__PURE__ */ Symbol.for("v-cmt"), tb = /* @__PURE__ */ Symbol.for("v-stc"), Ov = [];
let Tr = null;
function G(e = !1) {
  Ov.push(Tr = e ? null : []);
}
function oJ() {
  Ov.pop(), Tr = Ov[Ov.length - 1] || null;
}
let Zv = 1;
function S0(e, t = !1) {
  Zv += e, e < 0 && Tr && t && (Tr.hasOnce = !0);
}
function X5(e) {
  return e.dynamicChildren = Zv > 0 ? Tr || of : null, oJ(), Zv > 0 && Tr && Tr.push(e), e;
}
function ue(e, t, n, o, l, r) {
  return X5(
    ve(
      e,
      t,
      n,
      o,
      l,
      r,
      !0
    )
  );
}
function Me(e, t, n, o, l) {
  return X5(
    $(
      e,
      t,
      n,
      o,
      l,
      !0
    )
  );
}
function dn(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function tu(e, t) {
  if (process.env.NODE_ENV !== "production" && t.shapeFlag & 6 && e.component) {
    const n = Qg.get(t.type);
    if (n && n.has(e.component))
      return e.shapeFlag &= -257, t.shapeFlag &= -513, !1;
  }
  return e.type === t.type && e.key === t.key;
}
const lJ = (...e) => J5(
  ...e
), q5 = ({ key: e }) => e != null ? e : null, nb = ({
  ref: e,
  ref_key: t,
  ref_for: n
}) => (typeof e == "number" && (e = "" + e), e != null ? rt(e) || /* @__PURE__ */ kn(e) || it(e) ? { i: Zo, r: e, k: t, f: !!n } : e : null);
function ve(e, t = null, n = null, o = 0, l = null, r = e === Ge ? 0 : 1, a = !1, i = !1) {
  const s = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && q5(t),
    ref: t && nb(t),
    scopeId: m5,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: r,
    patchFlag: o,
    dynamicProps: l,
    dynamicChildren: null,
    appContext: null,
    ctx: Zo
  };
  return i ? (qE(s, n), r & 128 && e.normalize(s)) : n && (s.shapeFlag |= rt(n) ? 8 : 16), process.env.NODE_ENV !== "production" && s.key !== s.key && $t("VNode created with invalid key (NaN). VNode type:", s.type), Zv > 0 && // avoid a block node from tracking itself
  !a && // has current parent block
  Tr && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (s.patchFlag > 0 || r & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  s.patchFlag !== 32 && Tr.push(s), s;
}
const $ = process.env.NODE_ENV !== "production" ? lJ : J5;
function J5(e, t = null, n = null, o = 0, l = null, r = !1) {
  if ((!e || e === T5) && (process.env.NODE_ENV !== "production" && !e && $t(`Invalid vnode type when creating vnode: ${e}.`), e = qn), dn(e)) {
    const i = No(
      e,
      t,
      !0
      /* mergeRef: true */
    );
    return n && qE(i, n), Zv > 0 && !r && Tr && (i.shapeFlag & 6 ? Tr[Tr.indexOf(e)] = i : Tr.push(i)), i.patchFlag = -2, i;
  }
  if (nL(e) && (e = e.__vccOpts), t) {
    t = us(t);
    let { class: i, style: s } = t;
    i && !rt(i) && (t.class = X(i)), Mt(s) && (/* @__PURE__ */ Nf(s) && !We(s) && (s = _o({}, s)), t.style = gt(s));
  }
  const a = rt(e) ? 1 : Y5(e) ? 128 : y5(e) ? 64 : Mt(e) ? 4 : it(e) ? 2 : 0;
  return process.env.NODE_ENV !== "production" && a & 4 && /* @__PURE__ */ Nf(e) && (e = /* @__PURE__ */ Wt(e), $t(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    e
  )), ve(
    e,
    t,
    n,
    o,
    l,
    a,
    r,
    !0
  );
}
function us(e) {
  return e ? /* @__PURE__ */ Nf(e) || V5(e) ? _o({}, e) : e : null;
}
function No(e, t, n = !1, o = !1) {
  const { props: l, ref: r, patchFlag: a, children: i, transition: s } = e, c = t ? Ut(l || {}, t) : l, u = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: c,
    key: c && q5(c),
    ref: t && t.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && r ? We(r) ? r.concat(nb(t)) : [r, nb(t)] : nb(t)
    ) : r,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && a === -1 && We(i) ? i.map(Z5) : i,
    target: e.target,
    targetStart: e.targetStart,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t && e.type !== Ge ? a === -1 ? 16 : a | 16 : a,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: s,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && No(e.ssContent),
    ssFallback: e.ssFallback && No(e.ssFallback),
    placeholder: e.placeholder,
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
  return s && o && Bu(
    u,
    s.clone(u)
  ), u;
}
function Z5(e) {
  const t = No(e);
  return We(e.children) && (t.children = e.children.map(Z5)), t;
}
function Ft(e = " ", t = 0) {
  return $(Vr, null, e, t);
}
function Ie(e = "", t = !1) {
  return t ? (G(), Me(qn, null, e)) : $(qn, null, e);
}
function ga(e) {
  return e == null || typeof e == "boolean" ? $(qn) : We(e) ? $(
    Ge,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : dn(e) ? Ws(e) : $(Vr, null, String(e));
}
function Ws(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : No(e);
}
function qE(e, t) {
  let n = 0;
  const { shapeFlag: o } = e;
  if (t == null)
    t = null;
  else if (We(t))
    n = 16;
  else if (typeof t == "object")
    if (o & 65) {
      const l = t.default;
      l && (l._c && (l._d = !1), qE(e, l()), l._c && (l._d = !0));
      return;
    } else {
      n = 32;
      const l = t._;
      !l && !V5(t) ? t._ctx = Zo : l === 3 && Zo && (Zo.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
    }
  else it(t) ? (t = { default: t, _ctx: Zo }, n = 32) : (t = String(t), o & 64 ? (n = 16, t = [Ft(t)]) : n = 8);
  e.children = t, e.shapeFlag |= n;
}
function Ut(...e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const o = e[n];
    for (const l in o)
      if (l === "class")
        t.class !== o.class && (t.class = X([t.class, o.class]));
      else if (l === "style")
        t.style = gt([t.style, o.style]);
      else if (Km(l)) {
        const r = t[l], a = o[l];
        a && r !== a && !(We(r) && r.includes(a)) && (t[l] = r ? [].concat(r, a) : a);
      } else l !== "" && (t[l] = o[l]);
  }
  return t;
}
function ei(e, t, n, o = null) {
  Aa(e, t, 7, [
    n,
    o
  ]);
}
const rJ = R5();
let aJ = 0;
function iJ(e, t, n) {
  const o = e.type, l = (t ? t.appContext : e.appContext) || rJ, r = {
    uid: aJ++,
    vnode: e,
    type: o,
    parent: t,
    appContext: l,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new VD(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(l.provides),
    ids: t ? t.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: H5(o, l),
    emitsOptions: D5(o, l),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: eo,
    // inheritAttrs
    inheritAttrs: o.inheritAttrs,
    // state
    ctx: eo,
    data: eo,
    props: eo,
    attrs: eo,
    slots: eo,
    refs: eo,
    setupState: eo,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return process.env.NODE_ENV !== "production" ? r.ctx = Sq(r) : r.ctx = { _: r }, r.root = t ? t.root : r, r.emit = Nq.bind(null, r), e.ce && e.ce(r), r;
}
let Xo = null;
const xt = () => Xo || Zo;
let C0, M$;
{
  const e = Gm(), t = (n, o) => {
    let l;
    return (l = e[n]) || (l = e[n] = []), l.push(o), (r) => {
      l.length > 1 ? l.forEach((a) => a(r)) : l[0](r);
    };
  };
  C0 = t(
    "__VUE_INSTANCE_SETTERS__",
    (n) => Xo = n
  ), M$ = t(
    "__VUE_SSR_SETTERS__",
    (n) => Qv = n
  );
}
const Jm = (e) => {
  const t = Xo;
  return C0(e), e.scope.on(), () => {
    e.scope.off(), C0(t);
  };
}, Ck = () => {
  Xo && Xo.scope.off(), C0(null);
}, sJ = /* @__PURE__ */ Cs("slot,component");
function A$(e, { isNativeTag: t }) {
  (sJ(e) || t(e)) && $t(
    "Do not use built-in or reserved HTML elements as component id: " + e
  );
}
function Q5(e) {
  return e.vnode.shapeFlag & 4;
}
let Qv = !1;
function cJ(e, t = !1, n = !1) {
  t && M$(t);
  const { props: o, children: l } = e.vnode, r = Q5(e);
  Bq(e, o, r, t), Xq(e, l, n || t);
  const a = r ? uJ(e, t) : void 0;
  return t && M$(!1), a;
}
function uJ(e, t) {
  const n = e.type;
  if (process.env.NODE_ENV !== "production") {
    if (n.name && A$(n.name, e.appContext.config), n.components) {
      const l = Object.keys(n.components);
      for (let r = 0; r < l.length; r++)
        A$(l[r], e.appContext.config);
    }
    if (n.directives) {
      const l = Object.keys(n.directives);
      for (let r = 0; r < l.length; r++)
        h5(l[r]);
    }
    n.compilerOptions && dJ() && $t(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = new Proxy(e.ctx, k5), process.env.NODE_ENV !== "production" && Cq(e);
  const { setup: o } = n;
  if (o) {
    Pa();
    const l = e.setupContext = o.length > 1 ? tL(e) : null, r = Jm(e), a = pp(
      o,
      e,
      0,
      [
        process.env.NODE_ENV !== "production" ? /* @__PURE__ */ ci(e.props) : e.props,
        l
      ]
    ), i = mc(a);
    if (ka(), r(), (i || e.sp) && !af(e) && _5(e), i) {
      if (a.then(Ck, Ck), t)
        return a.then((s) => {
          wk(e, s, t);
        }).catch((s) => {
          Ym(s, e, 0);
        });
      if (e.asyncDep = a, process.env.NODE_ENV !== "production" && !e.suspense) {
        const s = Zm(e, n);
        $t(
          `Component <${s}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      wk(e, a, t);
  } else
    eL(e, t);
}
function wk(e, t, n) {
  it(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : Mt(t) ? (process.env.NODE_ENV !== "production" && dn(t) && $t(
    "setup() should not return VNodes directly - return a render function instead."
  ), process.env.NODE_ENV !== "production" && (e.devtoolsRawSetupState = t), e.setupState = l5(t), process.env.NODE_ENV !== "production" && wq(e)) : process.env.NODE_ENV !== "production" && t !== void 0 && $t(
    `setup() should return an object. Received: ${t === null ? "null" : typeof t}`
  ), eL(e, n);
}
const dJ = () => !0;
function eL(e, t, n) {
  const o = e.type;
  e.render || (e.render = o.render || gn);
  {
    const l = Jm(e);
    Pa();
    try {
      xq(e);
    } finally {
      ka(), l();
    }
  }
  process.env.NODE_ENV !== "production" && !o.render && e.render === gn && !t && (o.template ? $t(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  ) : $t("Component is missing template or render function: ", o));
}
const $k = process.env.NODE_ENV !== "production" ? {
  get(e, t) {
    return b0(), tl(e, "get", ""), e[t];
  },
  set() {
    return $t("setupContext.attrs is readonly."), !1;
  },
  deleteProperty() {
    return $t("setupContext.attrs is readonly."), !1;
  }
} : {
  get(e, t) {
    return tl(e, "get", ""), e[t];
  }
};
function fJ(e) {
  return new Proxy(e.slots, {
    get(t, n) {
      return tl(e, "get", "$slots"), t[n];
    }
  });
}
function tL(e) {
  const t = (n) => {
    if (process.env.NODE_ENV !== "production" && (e.exposed && $t("expose() should be called only once per setup()."), n != null)) {
      let o = typeof n;
      o === "object" && (We(n) ? o = "array" : /* @__PURE__ */ kn(n) && (o = "ref")), o !== "object" && $t(
        `expose() should be passed a plain object, received ${o}.`
      );
    }
    e.exposed = n || {};
  };
  if (process.env.NODE_ENV !== "production") {
    let n, o;
    return Object.freeze({
      get attrs() {
        return n || (n = new Proxy(e.attrs, $k));
      },
      get slots() {
        return o || (o = fJ(e));
      },
      get emit() {
        return (l, ...r) => e.emit(l, ...r);
      },
      expose: t
    });
  } else
    return {
      attrs: new Proxy(e.attrs, $k),
      slots: e.slots,
      emit: e.emit,
      expose: t
    };
}
function u1(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(l5(wa(e.exposed)), {
    get(t, n) {
      if (n in t)
        return t[n];
      if (n in $u)
        return $u[n](e);
    },
    has(t, n) {
      return n in t || n in $u;
    }
  })) : e.proxy;
}
const pJ = /(?:^|[-_])\w/g, vJ = (e) => e.replace(pJ, (t) => t.toUpperCase()).replace(/[-_]/g, "");
function JE(e, t = !0) {
  return it(e) ? e.displayName || e.name : e.name || t && e.__name;
}
function Zm(e, t, n = !1) {
  let o = JE(t);
  if (!o && t.__file) {
    const l = t.__file.match(/([^/\\]+)\.\w+$/);
    l && (o = l[1]);
  }
  if (!o && e) {
    const l = (r) => {
      for (const a in r)
        if (r[a] === t)
          return a;
    };
    o = l(e.components) || e.parent && l(
      e.parent.type.components
    ) || l(e.appContext.components);
  }
  return o ? vJ(o) : n ? "App" : "Anonymous";
}
function nL(e) {
  return it(e) && "__vccOpts" in e;
}
const O = (e, t) => {
  const n = /* @__PURE__ */ BX(e, t, Qv);
  if (process.env.NODE_ENV !== "production") {
    const o = xt();
    o && o.appContext.config.warnRecursiveComputed && (n._warnRecursive = !0);
  }
  return n;
};
function ht(e, t, n) {
  try {
    S0(-1);
    const o = arguments.length;
    return o === 2 ? Mt(t) && !We(t) ? dn(t) ? $(e, null, [t]) : $(e, t) : $(e, null, t) : (o > 3 ? n = Array.prototype.slice.call(arguments, 2) : o === 3 && dn(n) && (n = [n]), $(e, t, n));
  } finally {
    S0(1);
  }
}
function mJ() {
  if (process.env.NODE_ENV === "production" || typeof window == "undefined")
    return;
  const e = { style: "color:#3ba776" }, t = { style: "color:#1677ff" }, n = { style: "color:#f5222d" }, o = { style: "color:#eb2f96" }, l = {
    __vue_custom_formatter: !0,
    header(d) {
      if (!Mt(d))
        return null;
      if (d.__isVue)
        return ["div", e, "VueInstance"];
      if (/* @__PURE__ */ kn(d)) {
        Pa();
        const f = d.value;
        return ka(), [
          "div",
          {},
          ["span", e, u(d)],
          "<",
          i(f),
          ">"
        ];
      } else {
        if (/* @__PURE__ */ ic(d))
          return [
            "div",
            {},
            ["span", e, /* @__PURE__ */ Ml(d) ? "ShallowReactive" : "Reactive"],
            "<",
            i(d),
            `>${/* @__PURE__ */ Na(d) ? " (readonly)" : ""}`
          ];
        if (/* @__PURE__ */ Na(d))
          return [
            "div",
            {},
            ["span", e, /* @__PURE__ */ Ml(d) ? "ShallowReadonly" : "Readonly"],
            "<",
            i(d),
            ">"
          ];
      }
      return null;
    },
    hasBody(d) {
      return d && d.__isVue;
    },
    body(d) {
      if (d && d.__isVue)
        return [
          "div",
          {},
          ...r(d.$)
        ];
    }
  };
  function r(d) {
    const f = [];
    d.type.props && d.props && f.push(a("props", /* @__PURE__ */ Wt(d.props))), d.setupState !== eo && f.push(a("setup", d.setupState)), d.data !== eo && f.push(a("data", /* @__PURE__ */ Wt(d.data)));
    const p = s(d, "computed");
    p && f.push(a("computed", p));
    const m = s(d, "inject");
    return m && f.push(a("injected", m)), f.push([
      "div",
      {},
      [
        "span",
        {
          style: o.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: d }]
    ]), f;
  }
  function a(d, f) {
    return f = _o({}, f), Object.keys(f).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        d
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(f).map((p) => [
          "div",
          {},
          ["span", o, p + ": "],
          i(f[p], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function i(d, f = !0) {
    return typeof d == "number" ? ["span", t, d] : typeof d == "string" ? ["span", n, JSON.stringify(d)] : typeof d == "boolean" ? ["span", o, d] : Mt(d) ? ["object", { object: f ? /* @__PURE__ */ Wt(d) : d }] : ["span", n, String(d)];
  }
  function s(d, f) {
    const p = d.type;
    if (it(p))
      return;
    const m = {};
    for (const v in d.ctx)
      c(p, v, f) && (m[v] = d.ctx[v]);
    return m;
  }
  function c(d, f, p) {
    const m = d[p];
    if (We(m) && m.includes(f) || Mt(m) && f in m || d.extends && c(d.extends, f, p) || d.mixins && d.mixins.some((v) => c(v, f, p)))
      return !0;
  }
  function u(d) {
    return /* @__PURE__ */ Ml(d) ? "ShallowRef" : d.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(l) : window.devtoolsFormatters = [l];
}
const xk = "3.5.27", $a = process.env.NODE_ENV !== "production" ? $t : gn;
process.env.NODE_ENV;
process.env.NODE_ENV;
/**
* @vue/runtime-dom v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let R$;
const Ek = typeof window != "undefined" && window.trustedTypes;
if (Ek)
  try {
    R$ = /* @__PURE__ */ Ek.createPolicy("vue", {
      createHTML: (e) => e
    });
  } catch (e) {
    process.env.NODE_ENV !== "production" && $a(`Error creating trusted types policy: ${e}`);
  }
const oL = R$ ? (e) => R$.createHTML(e) : (e) => e, hJ = "http://www.w3.org/2000/svg", gJ = "http://www.w3.org/1998/Math/MathML", Ui = typeof document != "undefined" ? document : null, Ok = Ui && /* @__PURE__ */ Ui.createElement("template"), bJ = {
  insert: (e, t, n) => {
    t.insertBefore(e, n || null);
  },
  remove: (e) => {
    const t = e.parentNode;
    t && t.removeChild(e);
  },
  createElement: (e, t, n, o) => {
    const l = t === "svg" ? Ui.createElementNS(hJ, e) : t === "mathml" ? Ui.createElementNS(gJ, e) : n ? Ui.createElement(e, { is: n }) : Ui.createElement(e);
    return e === "select" && o && o.multiple != null && l.setAttribute("multiple", o.multiple), l;
  },
  createText: (e) => Ui.createTextNode(e),
  createComment: (e) => Ui.createComment(e),
  setText: (e, t) => {
    e.nodeValue = t;
  },
  setElementText: (e, t) => {
    e.textContent = t;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => Ui.querySelector(e),
  setScopeId(e, t) {
    e.setAttribute(t, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, t, n, o, l, r) {
    const a = n ? n.previousSibling : t.lastChild;
    if (l && (l === r || l.nextSibling))
      for (; t.insertBefore(l.cloneNode(!0), n), !(l === r || !(l = l.nextSibling)); )
        ;
    else {
      Ok.innerHTML = oL(
        o === "svg" ? `<svg>${e}</svg>` : o === "mathml" ? `<math>${e}</math>` : e
      );
      const i = Ok.content;
      if (o === "svg" || o === "mathml") {
        const s = i.firstChild;
        for (; s.firstChild; )
          i.appendChild(s.firstChild);
        i.removeChild(s);
      }
      t.insertBefore(i, n);
    }
    return [
      // first
      a ? a.nextSibling : t.firstChild,
      // last
      n ? n.previousSibling : t.lastChild
    ];
  }
}, Ns = "transition", Yp = "animation", Af = /* @__PURE__ */ Symbol("_vtc"), lL = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, rL = /* @__PURE__ */ _o(
  {},
  $5,
  lL
), yJ = (e) => (e.displayName = "Transition", e.props = rL, e), Vn = /* @__PURE__ */ yJ(
  (e, { slots: t }) => ht(fq, aL(e), t)
), zc = (e, t = []) => {
  We(e) ? e.forEach((n) => n(...t)) : e && e(...t);
}, _k = (e) => e ? We(e) ? e.some((t) => t.length > 1) : e.length > 1 : !1;
function aL(e) {
  const t = {};
  for (const N in e)
    N in lL || (t[N] = e[N]);
  if (e.css === !1)
    return t;
  const {
    name: n = "v",
    type: o,
    duration: l,
    enterFromClass: r = `${n}-enter-from`,
    enterActiveClass: a = `${n}-enter-active`,
    enterToClass: i = `${n}-enter-to`,
    appearFromClass: s = r,
    appearActiveClass: c = a,
    appearToClass: u = i,
    leaveFromClass: d = `${n}-leave-from`,
    leaveActiveClass: f = `${n}-leave-active`,
    leaveToClass: p = `${n}-leave-to`
  } = e, m = SJ(l), v = m && m[0], h = m && m[1], {
    onBeforeEnter: g,
    onEnter: y,
    onEnterCancelled: b,
    onLeave: C,
    onLeaveCancelled: w,
    onBeforeAppear: x = g,
    onAppear: E = y,
    onAppearCancelled: I = b
  } = t, T = (N, R, z, D) => {
    N._enterCancelled = D, Ls(N, R ? u : i), Ls(N, R ? c : a), z && z();
  }, P = (N, R) => {
    N._isLeaving = !1, Ls(N, d), Ls(N, p), Ls(N, f), R && R();
  }, k = (N) => (R, z) => {
    const D = N ? E : y, F = () => T(R, N, z);
    zc(D, [R, F]), Ik(() => {
      Ls(R, N ? s : r), ti(R, N ? u : i), _k(D) || Tk(R, o, v, F);
    });
  };
  return _o(t, {
    onBeforeEnter(N) {
      zc(g, [N]), ti(N, r), ti(N, a);
    },
    onBeforeAppear(N) {
      zc(x, [N]), ti(N, s), ti(N, c);
    },
    onEnter: k(!1),
    onAppear: k(!0),
    onLeave(N, R) {
      N._isLeaving = !0;
      const z = () => P(N, R);
      ti(N, d), N._enterCancelled ? (ti(N, f), D$(N)) : (D$(N), ti(N, f)), Ik(() => {
        N._isLeaving && (Ls(N, d), ti(N, p), _k(C) || Tk(N, o, h, z));
      }), zc(C, [N, z]);
    },
    onEnterCancelled(N) {
      T(N, !1, void 0, !0), zc(b, [N]);
    },
    onAppearCancelled(N) {
      T(N, !0, void 0, !0), zc(I, [N]);
    },
    onLeaveCancelled(N) {
      P(N), zc(w, [N]);
    }
  });
}
function SJ(e) {
  if (e == null)
    return null;
  if (Mt(e))
    return [wC(e.enter), wC(e.leave)];
  {
    const t = wC(e);
    return [t, t];
  }
}
function wC(e) {
  const t = eX(e);
  return process.env.NODE_ENV !== "production" && KX(t, "<transition> explicit duration"), t;
}
function ti(e, t) {
  t.split(/\s+/).forEach((n) => n && e.classList.add(n)), (e[Af] || (e[Af] = /* @__PURE__ */ new Set())).add(t);
}
function Ls(e, t) {
  t.split(/\s+/).forEach((o) => o && e.classList.remove(o));
  const n = e[Af];
  n && (n.delete(t), n.size || (e[Af] = void 0));
}
function Ik(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
let CJ = 0;
function Tk(e, t, n, o) {
  const l = e._endId = ++CJ, r = () => {
    l === e._endId && o();
  };
  if (n != null)
    return setTimeout(r, n);
  const { type: a, timeout: i, propCount: s } = iL(e, t);
  if (!a)
    return o();
  const c = a + "end";
  let u = 0;
  const d = () => {
    e.removeEventListener(c, f), r();
  }, f = (p) => {
    p.target === e && ++u >= s && d();
  };
  setTimeout(() => {
    u < s && d();
  }, i + 1), e.addEventListener(c, f);
}
function iL(e, t) {
  const n = window.getComputedStyle(e), o = (m) => (n[m] || "").split(", "), l = o(`${Ns}Delay`), r = o(`${Ns}Duration`), a = Pk(l, r), i = o(`${Yp}Delay`), s = o(`${Yp}Duration`), c = Pk(i, s);
  let u = null, d = 0, f = 0;
  t === Ns ? a > 0 && (u = Ns, d = a, f = r.length) : t === Yp ? c > 0 && (u = Yp, d = c, f = s.length) : (d = Math.max(a, c), u = d > 0 ? a > c ? Ns : Yp : null, f = u ? u === Ns ? r.length : s.length : 0);
  const p = u === Ns && /\b(?:transform|all)(?:,|$)/.test(
    o(`${Ns}Property`).toString()
  );
  return {
    type: u,
    timeout: d,
    propCount: f,
    hasTransform: p
  };
}
function Pk(e, t) {
  for (; e.length < t.length; )
    e = e.concat(e);
  return Math.max(...t.map((n, o) => kk(n) + kk(e[o])));
}
function kk(e) {
  return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function D$(e) {
  return (e ? e.ownerDocument : document).body.offsetHeight;
}
function wJ(e, t, n) {
  const o = e[Af];
  o && (t = (t ? [t, ...o] : [...o]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t;
}
const w0 = /* @__PURE__ */ Symbol("_vod"), sL = /* @__PURE__ */ Symbol("_vsh"), Jt = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(e, { value: t }, { transition: n }) {
    e[w0] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : Xp(e, t);
  },
  mounted(e, { value: t }, { transition: n }) {
    n && t && n.enter(e);
  },
  updated(e, { value: t, oldValue: n }, { transition: o }) {
    !t != !n && (o ? t ? (o.beforeEnter(e), Xp(e, !0), o.enter(e)) : o.leave(e, () => {
      Xp(e, !1);
    }) : Xp(e, t));
  },
  beforeUnmount(e, { value: t }) {
    Xp(e, t);
  }
};
function Xp(e, t) {
  e.style.display = t ? e[w0] : "none", e[sL] = !t;
}
const $J = /* @__PURE__ */ Symbol(process.env.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : ""), xJ = /(?:^|;)\s*display\s*:/;
function EJ(e, t, n) {
  const o = e.style, l = rt(n);
  let r = !1;
  if (n && !l) {
    if (t)
      if (rt(t))
        for (const a of t.split(";")) {
          const i = a.slice(0, a.indexOf(":")).trim();
          n[i] == null && ob(o, i, "");
        }
      else
        for (const a in t)
          n[a] == null && ob(o, a, "");
    for (const a in n)
      a === "display" && (r = !0), ob(o, a, n[a]);
  } else if (l) {
    if (t !== n) {
      const a = o[$J];
      a && (n += ";" + a), o.cssText = n, r = xJ.test(n);
    }
  } else t && e.removeAttribute("style");
  w0 in e && (e[w0] = r ? o.display : "", e[sL] && (o.display = "none"));
}
const OJ = /[^\\];\s*$/, Nk = /\s*!important$/;
function ob(e, t, n) {
  if (We(n))
    n.forEach((o) => ob(e, t, o));
  else if (n == null && (n = ""), process.env.NODE_ENV !== "production" && OJ.test(n) && $a(
    `Unexpected semicolon at the end of '${t}' style value: '${n}'`
  ), t.startsWith("--"))
    e.setProperty(t, n);
  else {
    const o = _J(e, t);
    Nk.test(n) ? e.setProperty(
      Si(o),
      n.replace(Nk, ""),
      "important"
    ) : e[o] = n;
  }
}
const Mk = ["Webkit", "Moz", "ms"], $C = {};
function _J(e, t) {
  const n = $C[t];
  if (n)
    return n;
  let o = vl(t);
  if (o !== "filter" && o in e)
    return $C[t] = o;
  o = hc(o);
  for (let l = 0; l < Mk.length; l++) {
    const r = Mk[l] + o;
    if (r in e)
      return $C[t] = r;
  }
  return t;
}
const Ak = "http://www.w3.org/1999/xlink";
function Rk(e, t, n, o, l, r = fX(t)) {
  o && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(Ak, t.slice(6, t.length)) : e.setAttributeNS(Ak, t, n) : n == null || r && !DD(n) ? e.removeAttribute(t) : e.setAttribute(
    t,
    r ? "" : Ta(n) ? String(n) : n
  );
}
function Dk(e, t, n, o, l) {
  if (t === "innerHTML" || t === "textContent") {
    n != null && (e[t] = t === "innerHTML" ? oL(n) : n);
    return;
  }
  const r = e.tagName;
  if (t === "value" && r !== "PROGRESS" && // custom elements may use _value internally
  !r.includes("-")) {
    const i = r === "OPTION" ? e.getAttribute("value") || "" : e.value, s = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      e.type === "checkbox" ? "on" : ""
    ) : String(n);
    (i !== s || !("_value" in e)) && (e.value = s), n == null && e.removeAttribute(t), e._value = n;
    return;
  }
  let a = !1;
  if (n === "" || n == null) {
    const i = typeof e[t];
    i === "boolean" ? n = DD(n) : n == null && i === "string" ? (n = "", a = !0) : i === "number" && (n = 0, a = !0);
  }
  try {
    e[t] = n;
  } catch (i) {
    process.env.NODE_ENV !== "production" && !a && $a(
      `Failed setting prop "${t}" on <${r.toLowerCase()}>: value ${n} is invalid.`,
      i
    );
  }
  a && e.removeAttribute(l || t);
}
function Us(e, t, n, o) {
  e.addEventListener(t, n, o);
}
function IJ(e, t, n, o) {
  e.removeEventListener(t, n, o);
}
const Lk = /* @__PURE__ */ Symbol("_vei");
function TJ(e, t, n, o, l = null) {
  const r = e[Lk] || (e[Lk] = {}), a = r[t];
  if (o && a)
    a.value = process.env.NODE_ENV !== "production" ? Fk(o, t) : o;
  else {
    const [i, s] = PJ(t);
    if (o) {
      const c = r[t] = MJ(
        process.env.NODE_ENV !== "production" ? Fk(o, t) : o,
        l
      );
      Us(e, i, c, s);
    } else a && (IJ(e, i, a, s), r[t] = void 0);
  }
}
const Bk = /(?:Once|Passive|Capture)$/;
function PJ(e) {
  let t;
  if (Bk.test(e)) {
    t = {};
    let o;
    for (; o = e.match(Bk); )
      e = e.slice(0, e.length - o[0].length), t[o[0].toLowerCase()] = !0;
  }
  return [e[2] === ":" ? e.slice(3) : Si(e.slice(2)), t];
}
let xC = 0;
const kJ = /* @__PURE__ */ Promise.resolve(), NJ = () => xC || (kJ.then(() => xC = 0), xC = Date.now());
function MJ(e, t) {
  const n = (o) => {
    if (!o._vts)
      o._vts = Date.now();
    else if (o._vts <= n.attached)
      return;
    Aa(
      AJ(o, n.value),
      t,
      5,
      [o]
    );
  };
  return n.value = e, n.attached = NJ(), n;
}
function Fk(e, t) {
  return it(e) || We(e) ? e : ($a(
    `Wrong type passed as event handler to ${t} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof e}.`
  ), gn);
}
function AJ(e, t) {
  if (We(t)) {
    const n = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      n.call(e), e._stopped = !0;
    }, t.map(
      (o) => (l) => !l._stopped && o && o(l)
    );
  } else
    return t;
}
const Vk = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // lowercase letter
e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, RJ = (e, t, n, o, l, r) => {
  const a = l === "svg";
  t === "class" ? wJ(e, o, a) : t === "style" ? EJ(e, n, o) : Km(t) ? s0(t) || TJ(e, t, n, o, r) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : DJ(e, t, o, a)) ? (Dk(e, t, o), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && Rk(e, t, o, a, r, t !== "value")) : /* #11081 force set props for possible async custom element */ e._isVueCE && (/[A-Z]/.test(t) || !rt(o)) ? Dk(e, vl(t), o, r, t) : (t === "true-value" ? e._trueValue = o : t === "false-value" && (e._falseValue = o), Rk(e, t, o, a));
};
function DJ(e, t, n, o) {
  if (o)
    return !!(t === "innerHTML" || t === "textContent" || t in e && Vk(t) && it(n));
  if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "sandbox" && e.tagName === "IFRAME" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
    return !1;
  if (t === "width" || t === "height") {
    const l = e.tagName;
    if (l === "IMG" || l === "VIDEO" || l === "CANVAS" || l === "SOURCE")
      return !1;
  }
  return Vk(t) && rt(n) ? !1 : t in e;
}
const cL = /* @__PURE__ */ new WeakMap(), uL = /* @__PURE__ */ new WeakMap(), $0 = /* @__PURE__ */ Symbol("_moveCb"), zk = /* @__PURE__ */ Symbol("_enterCb"), LJ = (e) => (delete e.props.mode, e), BJ = /* @__PURE__ */ LJ({
  name: "TransitionGroup",
  props: /* @__PURE__ */ _o({}, rL, {
    tag: String,
    moveClass: String
  }),
  setup(e, { slots: t }) {
    const n = xt(), o = w5();
    let l, r;
    return $o(() => {
      if (!l.length)
        return;
      const a = e.moveClass || `${e.name || "v"}-move`;
      if (!HJ(
        l[0].el,
        n.vnode.el,
        a
      )) {
        l = [];
        return;
      }
      l.forEach(FJ), l.forEach(VJ);
      const i = l.filter(zJ);
      D$(n.vnode.el), i.forEach((s) => {
        const c = s.el, u = c.style;
        ti(c, a), u.transform = u.webkitTransform = u.transitionDuration = "";
        const d = c[$0] = (f) => {
          f && f.target !== c || (!f || f.propertyName.endsWith("transform")) && (c.removeEventListener("transitionend", d), c[$0] = null, Ls(c, a));
        };
        c.addEventListener("transitionend", d);
      }), l = [];
    }), () => {
      const a = /* @__PURE__ */ Wt(e), i = aL(a);
      let s = a.tag || Ge;
      if (l = [], r)
        for (let c = 0; c < r.length; c++) {
          const u = r[c];
          u.el && u.el instanceof Element && (l.push(u), Bu(
            u,
            Jv(
              u,
              i,
              o,
              n
            )
          ), cL.set(u, {
            left: u.el.offsetLeft,
            top: u.el.offsetTop
          }));
        }
      r = t.default ? jE(t.default()) : [];
      for (let c = 0; c < r.length; c++) {
        const u = r[c];
        u.key != null ? Bu(
          u,
          Jv(u, i, o, n)
        ) : process.env.NODE_ENV !== "production" && u.type !== Vr && $a("<TransitionGroup> children must be keyed.");
      }
      return $(s, null, r);
    };
  }
}), mp = BJ;
function FJ(e) {
  const t = e.el;
  t[$0] && t[$0](), t[zk] && t[zk]();
}
function VJ(e) {
  uL.set(e, {
    left: e.el.offsetLeft,
    top: e.el.offsetTop
  });
}
function zJ(e) {
  const t = cL.get(e), n = uL.get(e), o = t.left - n.left, l = t.top - n.top;
  if (o || l) {
    const r = e.el.style;
    return r.transform = r.webkitTransform = `translate(${o}px,${l}px)`, r.transitionDuration = "0s", e;
  }
}
function HJ(e, t, n) {
  const o = e.cloneNode(), l = e[Af];
  l && l.forEach((i) => {
    i.split(/\s+/).forEach((s) => s && o.classList.remove(s));
  }), n.split(/\s+/).forEach((i) => i && o.classList.add(i)), o.style.display = "none";
  const r = t.nodeType === 1 ? t : t.parentNode;
  r.appendChild(o);
  const { hasTransform: a } = iL(o);
  return r.removeChild(o), a;
}
const Rf = (e) => {
  const t = e.props["onUpdate:modelValue"] || !1;
  return We(t) ? (n) => Ld(t, n) : t;
};
function jJ(e) {
  e.target.composing = !0;
}
function Hk(e) {
  const t = e.target;
  t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")));
}
const ds = /* @__PURE__ */ Symbol("_assign");
function jk(e, t, n) {
  return t && (e = e.trim()), n && (e = PE(e)), e;
}
const d1 = {
  created(e, { modifiers: { lazy: t, trim: n, number: o } }, l) {
    e[ds] = Rf(l);
    const r = o || l.props && l.props.type === "number";
    Us(e, t ? "change" : "input", (a) => {
      a.target.composing || e[ds](jk(e.value, n, r));
    }), (n || r) && Us(e, "change", () => {
      e.value = jk(e.value, n, r);
    }), t || (Us(e, "compositionstart", jJ), Us(e, "compositionend", Hk), Us(e, "change", Hk));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e, { value: t }) {
    e.value = t == null ? "" : t;
  },
  beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: o, trim: l, number: r } }, a) {
    if (e[ds] = Rf(a), e.composing) return;
    const i = (r || e.type === "number") && !/^0\d/.test(e.value) ? PE(e.value) : e.value, s = t == null ? "" : t;
    i !== s && (document.activeElement === e && e.type !== "range" && (o && t === n || l && e.value.trim() === s) || (e.value = s));
  }
}, dL = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(e, t, n) {
    e[ds] = Rf(n), Us(e, "change", () => {
      const o = e._modelValue, l = pL(e), r = e.checked, a = e[ds];
      if (We(o)) {
        const i = LD(o, l), s = i !== -1;
        if (r && !s)
          a(o.concat(l));
        else if (!r && s) {
          const c = [...o];
          c.splice(i, 1), a(c);
        }
      } else if (Zy(o)) {
        const i = new Set(o);
        r ? i.add(l) : i.delete(l), a(i);
      } else
        a(vL(e, r));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Wk,
  beforeUpdate(e, t, n) {
    e[ds] = Rf(n), Wk(e, t, n);
  }
};
function Wk(e, { value: t, oldValue: n }, o) {
  e._modelValue = t;
  let l;
  if (We(t))
    l = LD(t, o.props.value) > -1;
  else if (Zy(t))
    l = t.has(o.props.value);
  else {
    if (t === n) return;
    l = kf(t, vL(e, !0));
  }
  e.checked !== l && (e.checked = l);
}
const fL = {
  created(e, { value: t }, n) {
    e.checked = kf(t, n.props.value), e[ds] = Rf(n), Us(e, "change", () => {
      e[ds](pL(e));
    });
  },
  beforeUpdate(e, { value: t, oldValue: n }, o) {
    e[ds] = Rf(o), t !== n && (e.checked = kf(t, o.props.value));
  }
};
function pL(e) {
  return "_value" in e ? e._value : e.value;
}
function vL(e, t) {
  const n = t ? "_trueValue" : "_falseValue";
  return n in e ? e[n] : t;
}
const WJ = ["ctrl", "shift", "alt", "meta"], KJ = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, t) => WJ.some((n) => e[`${n}Key`] && !t.includes(n))
}, Et = (e, t) => {
  const n = e._withMods || (e._withMods = {}), o = t.join(".");
  return n[o] || (n[o] = (l, ...r) => {
    for (let a = 0; a < t.length; a++) {
      const i = KJ[t[a]];
      if (i && i(l, t)) return;
    }
    return e(l, ...r);
  });
}, UJ = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, uo = (e, t) => {
  const n = e._withKeys || (e._withKeys = {}), o = t.join(".");
  return n[o] || (n[o] = (l) => {
    if (!("key" in l))
      return;
    const r = Si(l.key);
    if (t.some(
      (a) => a === r || UJ[a] === r
    ))
      return e(l);
  });
}, GJ = /* @__PURE__ */ _o({ patchProp: RJ }, bJ);
let Kk;
function mL() {
  return Kk || (Kk = Zq(GJ));
}
const Bl = (...e) => {
  mL().render(...e);
}, ZE = (...e) => {
  const t = mL().createApp(...e);
  process.env.NODE_ENV !== "production" && (XJ(t), qJ(t));
  const { mount: n } = t;
  return t.mount = (o) => {
    const l = JJ(o);
    if (!l) return;
    const r = t._component;
    !it(r) && !r.render && !r.template && (r.template = l.innerHTML), l.nodeType === 1 && (l.textContent = "");
    const a = n(l, !1, YJ(l));
    return l instanceof Element && (l.removeAttribute("v-cloak"), l.setAttribute("data-v-app", "")), a;
  }, t;
};
function YJ(e) {
  if (e instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement)
    return "mathml";
}
function XJ(e) {
  Object.defineProperty(e.config, "isNativeTag", {
    value: (t) => sX(t) || cX(t) || uX(t),
    writable: !1
  });
}
function qJ(e) {
  {
    const t = e.config.isCustomElement;
    Object.defineProperty(e.config, "isCustomElement", {
      get() {
        return t;
      },
      set() {
        $a(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const n = e.config.compilerOptions, o = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(e.config, "compilerOptions", {
      get() {
        return $a(o), n;
      },
      set() {
        $a(o);
      }
    });
  }
}
function JJ(e) {
  if (rt(e)) {
    const t = document.querySelector(e);
    return process.env.NODE_ENV !== "production" && !t && $a(
      `Failed to mount app: mount target selector "${e}" returned null.`
    ), t;
  }
  return process.env.NODE_ENV !== "production" && window.ShadowRoot && e instanceof window.ShadowRoot && e.mode === "closed" && $a(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), e;
}
/**
* vue v3.5.27
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function ZJ() {
  mJ();
}
process.env.NODE_ENV !== "production" && ZJ();
function QJ() {
  return hL().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function hL() {
  return typeof navigator != "undefined" && typeof window != "undefined" ? window : typeof globalThis != "undefined" ? globalThis : {};
}
const eZ = typeof Proxy == "function", tZ = "devtools-plugin:setup", nZ = "plugin:settings:set";
let $d, L$;
function oZ() {
  var e;
  return $d !== void 0 || (typeof window != "undefined" && window.performance ? ($d = !0, L$ = window.performance) : typeof globalThis != "undefined" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? ($d = !0, L$ = globalThis.perf_hooks.performance) : $d = !1), $d;
}
function lZ() {
  return oZ() ? L$.now() : Date.now();
}
class rZ {
  constructor(t, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;
    const o = {};
    if (t.settings)
      for (const a in t.settings) {
        const i = t.settings[a];
        o[a] = i.defaultValue;
      }
    const l = `__vue-devtools-plugin-settings__${t.id}`;
    let r = Object.assign({}, o);
    try {
      const a = localStorage.getItem(l), i = JSON.parse(a);
      Object.assign(r, i);
    } catch (a) {
    }
    this.fallbacks = {
      getSettings() {
        return r;
      },
      setSettings(a) {
        try {
          localStorage.setItem(l, JSON.stringify(a));
        } catch (i) {
        }
        r = a;
      },
      now() {
        return lZ();
      }
    }, n && n.on(nZ, (a, i) => {
      a === this.plugin.id && this.fallbacks.setSettings(i);
    }), this.proxiedOn = new Proxy({}, {
      get: (a, i) => this.target ? this.target.on[i] : (...s) => {
        this.onQueue.push({
          method: i,
          args: s
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (a, i) => this.target ? this.target[i] : i === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(i) ? (...s) => (this.targetQueue.push({
        method: i,
        args: s,
        resolve: () => {
        }
      }), this.fallbacks[i](...s)) : (...s) => new Promise((c) => {
        this.targetQueue.push({
          method: i,
          args: s,
          resolve: c
        });
      })
    });
  }
  setRealTarget(t) {
    return Rt(this, null, function* () {
      this.target = t;
      for (const n of this.onQueue)
        this.target.on[n.method](...n.args);
      for (const n of this.targetQueue)
        n.resolve(yield this.target[n.method](...n.args));
    });
  }
}
function f1(e, t) {
  const n = e, o = hL(), l = QJ(), r = eZ && n.enableEarlyProxy;
  if (l && (o.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !r))
    l.emit(tZ, e, t);
  else {
    const a = r ? new rZ(n, l) : null;
    (o.__VUE_DEVTOOLS_PLUGINS__ = o.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: t,
      proxy: a
    }), a && t(a.proxiedTarget);
  }
}
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
const aZ = process.env.NODE_ENV !== "production" ? Symbol("pinia") : (
  /* istanbul ignore next */
  Symbol()
);
var xu;
(function(e) {
  e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function";
})(xu || (xu = {}));
const B$ = typeof window != "undefined", Uk = typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : { HTMLElement: null };
function iZ(e, { autoBom: t = !1 } = {}) {
  return t && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type) ? new Blob(["\uFEFF", e], { type: e.type }) : e;
}
function QE(e, t, n) {
  const o = new XMLHttpRequest();
  o.open("GET", e), o.responseType = "blob", o.onload = function() {
    yL(o.response, t, n);
  }, o.onerror = function() {
    console.error("could not download file");
  }, o.send();
}
function gL(e) {
  const t = new XMLHttpRequest();
  t.open("HEAD", e, !1);
  try {
    t.send();
  } catch (n) {
  }
  return t.status >= 200 && t.status <= 299;
}
function lb(e) {
  try {
    e.dispatchEvent(new MouseEvent("click"));
  } catch (t) {
    const n = document.createEvent("MouseEvents");
    n.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), e.dispatchEvent(n);
  }
}
const rb = typeof navigator == "object" ? navigator : { userAgent: "" }, bL = /Macintosh/.test(rb.userAgent) && /AppleWebKit/.test(rb.userAgent) && !/Safari/.test(rb.userAgent), yL = B$ ? (
  // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
  typeof HTMLAnchorElement != "undefined" && "download" in HTMLAnchorElement.prototype && !bL ? sZ : (
    // Use msSaveOrOpenBlob as a second approach
    "msSaveOrOpenBlob" in rb ? cZ : (
      // Fallback to using FileReader and a popup
      uZ
    )
  )
) : () => {
};
function sZ(e, t = "download", n) {
  const o = document.createElement("a");
  o.download = t, o.rel = "noopener", typeof e == "string" ? (o.href = e, o.origin !== location.origin ? gL(o.href) ? QE(e, t, n) : (o.target = "_blank", lb(o)) : lb(o)) : (o.href = URL.createObjectURL(e), setTimeout(function() {
    URL.revokeObjectURL(o.href);
  }, 4e4), setTimeout(function() {
    lb(o);
  }, 0));
}
function cZ(e, t = "download", n) {
  if (typeof e == "string")
    if (gL(e))
      QE(e, t, n);
    else {
      const o = document.createElement("a");
      o.href = e, o.target = "_blank", setTimeout(function() {
        lb(o);
      });
    }
  else
    navigator.msSaveOrOpenBlob(iZ(e, n), t);
}
function uZ(e, t, n, o) {
  if (o = o || open("", "_blank"), o && (o.document.title = o.document.body.innerText = "downloading..."), typeof e == "string")
    return QE(e, t, n);
  const l = e.type === "application/octet-stream", r = /constructor/i.test(String(Uk.HTMLElement)) || "safari" in Uk, a = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((a || l && r || bL) && typeof FileReader != "undefined") {
    const i = new FileReader();
    i.onloadend = function() {
      let s = i.result;
      if (typeof s != "string")
        throw o = null, new Error("Wrong reader.result type");
      s = a ? s : s.replace(/^data:[^;]*;/, "data:attachment/file;"), o ? o.location.href = s : location.assign(s), o = null;
    }, i.readAsDataURL(e);
  } else {
    const i = URL.createObjectURL(e);
    o ? o.location.assign(i) : location.href = i, o = null, setTimeout(function() {
      URL.revokeObjectURL(i);
    }, 4e4);
  }
}
function dl(e, t) {
  const n = " " + e;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(n, t) : t === "error" ? console.error(n) : t === "warn" ? console.warn(n) : console.log(n);
}
function eO(e) {
  return "_a" in e && "install" in e;
}
function SL() {
  if (!("clipboard" in navigator))
    return dl("Your browser doesn't support the Clipboard API", "error"), !0;
}
function CL(e) {
  return e instanceof Error && e.message.toLowerCase().includes("document is not focused") ? (dl('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"), !0) : !1;
}
function dZ(e) {
  return Rt(this, null, function* () {
    if (!SL())
      try {
        yield navigator.clipboard.writeText(JSON.stringify(e.state.value)), dl("Global state copied to clipboard.");
      } catch (t) {
        if (CL(t))
          return;
        dl("Failed to serialize the state. Check the console for more details.", "error"), console.error(t);
      }
  });
}
function fZ(e) {
  return Rt(this, null, function* () {
    if (!SL())
      try {
        wL(e, JSON.parse(yield navigator.clipboard.readText())), dl("Global state pasted from clipboard.");
      } catch (t) {
        if (CL(t))
          return;
        dl("Failed to deserialize the state from clipboard. Check the console for more details.", "error"), console.error(t);
      }
  });
}
function pZ(e) {
  return Rt(this, null, function* () {
    try {
      yL(new Blob([JSON.stringify(e.state.value)], {
        type: "text/plain;charset=utf-8"
      }), "pinia-state.json");
    } catch (t) {
      dl("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(t);
    }
  });
}
let Bi;
function vZ() {
  Bi || (Bi = document.createElement("input"), Bi.type = "file", Bi.accept = ".json");
  function e() {
    return new Promise((t, n) => {
      Bi.onchange = () => Rt(this, null, function* () {
        const o = Bi.files;
        if (!o)
          return t(null);
        const l = o.item(0);
        return t(l ? { text: yield l.text(), file: l } : null);
      }), Bi.oncancel = () => t(null), Bi.onerror = n, Bi.click();
    });
  }
  return e;
}
function mZ(e) {
  return Rt(this, null, function* () {
    try {
      const n = yield vZ()();
      if (!n)
        return;
      const { text: o, file: l } = n;
      wL(e, JSON.parse(o)), dl(`Global state imported from "${l.name}".`);
    } catch (t) {
      dl("Failed to import the state from JSON. Check the console for more details.", "error"), console.error(t);
    }
  });
}
function wL(e, t) {
  for (const n in t) {
    const o = e.state.value[n];
    o ? Object.assign(o, t[n]) : e.state.value[n] = t[n];
  }
}
function ma(e) {
  return {
    _custom: {
      display: e
    }
  };
}
const $L = " Pinia (root)", ab = "_root";
function hZ(e) {
  return eO(e) ? {
    id: ab,
    label: $L
  } : {
    id: e.$id,
    label: e.$id
  };
}
function gZ(e) {
  if (eO(e)) {
    const n = Array.from(e._s.keys()), o = e._s;
    return {
      state: n.map((r) => ({
        editable: !0,
        key: r,
        value: e.state.value[r]
      })),
      getters: n.filter((r) => o.get(r)._getters).map((r) => {
        const a = o.get(r);
        return {
          editable: !1,
          key: r,
          value: a._getters.reduce((i, s) => (i[s] = a[s], i), {})
        };
      })
    };
  }
  const t = {
    state: Object.keys(e.$state).map((n) => ({
      editable: !0,
      key: n,
      value: e.$state[n]
    }))
  };
  return e._getters && e._getters.length && (t.getters = e._getters.map((n) => ({
    editable: !1,
    key: n,
    value: e[n]
  }))), e._customProperties.size && (t.customProperties = Array.from(e._customProperties).map((n) => ({
    editable: !0,
    key: n,
    value: e[n]
  }))), t;
}
function bZ(e) {
  return e ? Array.isArray(e) ? e.reduce((t, n) => (t.keys.push(n.key), t.operations.push(n.type), t.oldValue[n.key] = n.oldValue, t.newValue[n.key] = n.newValue, t), {
    oldValue: {},
    keys: [],
    operations: [],
    newValue: {}
  }) : {
    operation: ma(e.type),
    key: ma(e.key),
    oldValue: e.oldValue,
    newValue: e.newValue
  } : {};
}
function yZ(e) {
  switch (e) {
    case xu.direct:
      return "mutation";
    case xu.patchFunction:
      return "$patch";
    case xu.patchObject:
      return "$patch";
    default:
      return "unknown";
  }
}
let Gd = !0;
const ib = [], Zc = "pinia:mutations", Il = "pinia", { assign: SZ } = Object, x0 = (e) => " " + e;
function CZ(e, t) {
  f1({
    id: "dev.esm.pinia",
    label: "Pinia ",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: ib,
    app: e
  }, (n) => {
    typeof n.now != "function" && dl("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), n.addTimelineLayer({
      id: Zc,
      label: "Pinia ",
      color: 15064968
    }), n.addInspector({
      id: Il,
      label: "Pinia ",
      icon: "storage",
      treeFilterPlaceholder: "Search stores",
      actions: [
        {
          icon: "content_copy",
          action: () => {
            dZ(t);
          },
          tooltip: "Serialize and copy the state"
        },
        {
          icon: "content_paste",
          action: () => Rt(this, null, function* () {
            yield fZ(t), n.sendInspectorTree(Il), n.sendInspectorState(Il);
          }),
          tooltip: "Replace the state with the content of your clipboard"
        },
        {
          icon: "save",
          action: () => {
            pZ(t);
          },
          tooltip: "Save the state as a JSON file"
        },
        {
          icon: "folder_open",
          action: () => Rt(this, null, function* () {
            yield mZ(t), n.sendInspectorTree(Il), n.sendInspectorState(Il);
          }),
          tooltip: "Import the state from a JSON file"
        }
      ],
      nodeActions: [
        {
          icon: "restore",
          tooltip: 'Reset the state (with "$reset")',
          action: (o) => {
            const l = t._s.get(o);
            l ? typeof l.$reset != "function" ? dl(`Cannot reset "${o}" store because it doesn't have a "$reset" method implemented.`, "warn") : (l.$reset(), dl(`Store "${o}" reset.`)) : dl(`Cannot reset "${o}" store because it wasn't found.`, "warn");
          }
        }
      ]
    }), n.on.inspectComponent((o, l) => {
      const r = o.componentInstance && o.componentInstance.proxy;
      if (r && r._pStores) {
        const a = o.componentInstance.proxy._pStores;
        Object.values(a).forEach((i) => {
          o.instanceData.state.push({
            type: x0(i.$id),
            key: "state",
            editable: !0,
            value: i._isOptionsAPI ? {
              _custom: {
                value: /* @__PURE__ */ Wt(i.$state),
                actions: [
                  {
                    icon: "restore",
                    tooltip: "Reset the state of this store",
                    action: () => i.$reset()
                  }
                ]
              }
            } : (
              // NOTE: workaround to unwrap transferred refs
              Object.keys(i.$state).reduce((s, c) => (s[c] = i.$state[c], s), {})
            )
          }), i._getters && i._getters.length && o.instanceData.state.push({
            type: x0(i.$id),
            key: "getters",
            editable: !1,
            value: i._getters.reduce((s, c) => {
              try {
                s[c] = i[c];
              } catch (u) {
                s[c] = u;
              }
              return s;
            }, {})
          });
        });
      }
    }), n.on.getInspectorTree((o) => {
      if (o.app === e && o.inspectorId === Il) {
        let l = [t];
        l = l.concat(Array.from(t._s.values())), o.rootNodes = (o.filter ? l.filter((r) => "$id" in r ? r.$id.toLowerCase().includes(o.filter.toLowerCase()) : $L.toLowerCase().includes(o.filter.toLowerCase())) : l).map(hZ);
      }
    }), globalThis.$pinia = t, n.on.getInspectorState((o) => {
      if (o.app === e && o.inspectorId === Il) {
        const l = o.nodeId === ab ? t : t._s.get(o.nodeId);
        if (!l)
          return;
        l && (o.nodeId !== ab && (globalThis.$store = /* @__PURE__ */ Wt(l)), o.state = gZ(l));
      }
    }), n.on.editInspectorState((o, l) => {
      if (o.app === e && o.inspectorId === Il) {
        const r = o.nodeId === ab ? t : t._s.get(o.nodeId);
        if (!r)
          return dl(`store "${o.nodeId}" not found`, "error");
        const { path: a } = o;
        eO(r) ? a.unshift("state") : (a.length !== 1 || !r._customProperties.has(a[0]) || a[0] in r.$state) && a.unshift("$state"), Gd = !1, o.set(r, a, o.state.value), Gd = !0;
      }
    }), n.on.editComponentState((o) => {
      if (o.type.startsWith("")) {
        const l = o.type.replace(/^\s*/, ""), r = t._s.get(l);
        if (!r)
          return dl(`store "${l}" not found`, "error");
        const { path: a } = o;
        if (a[0] !== "state")
          return dl(`Invalid path for store "${l}":
${a}
Only state can be modified.`);
        a[0] = "$state", Gd = !1, o.set(r, a, o.state.value), Gd = !0;
      }
    });
  });
}
function wZ(e, t) {
  ib.includes(x0(t.$id)) || ib.push(x0(t.$id)), f1({
    id: "dev.esm.pinia",
    label: "Pinia ",
    logo: "https://pinia.vuejs.org/logo.svg",
    packageName: "pinia",
    homepage: "https://pinia.vuejs.org",
    componentStateTypes: ib,
    app: e,
    settings: {
      logStoreChanges: {
        label: "Notify about new/deleted stores",
        type: "boolean",
        defaultValue: !0
      }
      // useEmojis: {
      //   label: 'Use emojis in messages ',
      //   type: 'boolean',
      //   defaultValue: true,
      // },
    }
  }, (n) => {
    const o = typeof n.now == "function" ? n.now.bind(n) : Date.now;
    t.$onAction(({ after: a, onError: i, name: s, args: c }) => {
      const u = xL++;
      n.addTimelineEvent({
        layerId: Zc,
        event: {
          time: o(),
          title: " " + s,
          subtitle: "start",
          data: {
            store: ma(t.$id),
            action: ma(s),
            args: c
          },
          groupId: u
        }
      }), a((d) => {
        Zs = void 0, n.addTimelineEvent({
          layerId: Zc,
          event: {
            time: o(),
            title: " " + s,
            subtitle: "end",
            data: {
              store: ma(t.$id),
              action: ma(s),
              args: c,
              result: d
            },
            groupId: u
          }
        });
      }), i((d) => {
        Zs = void 0, n.addTimelineEvent({
          layerId: Zc,
          event: {
            time: o(),
            logType: "error",
            title: " " + s,
            subtitle: "end",
            data: {
              store: ma(t.$id),
              action: ma(s),
              args: c,
              error: d
            },
            groupId: u
          }
        });
      });
    }, !0), t._customProperties.forEach((a) => {
      pe(() => S(t[a]), (i, s) => {
        n.notifyComponentUpdate(), n.sendInspectorState(Il), Gd && n.addTimelineEvent({
          layerId: Zc,
          event: {
            time: o(),
            title: "Change",
            subtitle: a,
            data: {
              newValue: i,
              oldValue: s
            },
            groupId: Zs
          }
        });
      }, { deep: !0 });
    }), t.$subscribe(({ events: a, type: i }, s) => {
      if (n.notifyComponentUpdate(), n.sendInspectorState(Il), !Gd)
        return;
      const c = {
        time: o(),
        title: yZ(i),
        data: SZ({ store: ma(t.$id) }, bZ(a)),
        groupId: Zs
      };
      i === xu.patchFunction ? c.subtitle = "" : i === xu.patchObject ? c.subtitle = "" : a && !Array.isArray(a) && (c.subtitle = a.type), a && (c.data["rawEvent(s)"] = {
        _custom: {
          display: "DebuggerEvent",
          type: "object",
          tooltip: "raw DebuggerEvent[]",
          value: a
        }
      }), n.addTimelineEvent({
        layerId: Zc,
        event: c
      });
    }, { detached: !0, flush: "sync" });
    const l = t._hotUpdate;
    t._hotUpdate = wa((a) => {
      l(a), n.addTimelineEvent({
        layerId: Zc,
        event: {
          time: o(),
          title: " " + t.$id,
          subtitle: "HMR update",
          data: {
            store: ma(t.$id),
            info: ma("HMR update")
          }
        }
      }), n.notifyComponentUpdate(), n.sendInspectorTree(Il), n.sendInspectorState(Il);
    });
    const { $dispose: r } = t;
    t.$dispose = () => {
      r(), n.notifyComponentUpdate(), n.sendInspectorTree(Il), n.sendInspectorState(Il), n.getSettings().logStoreChanges && dl(`Disposed "${t.$id}" store `);
    }, n.notifyComponentUpdate(), n.sendInspectorTree(Il), n.sendInspectorState(Il), n.getSettings().logStoreChanges && dl(`"${t.$id}" store installed `);
  });
}
let xL = 0, Zs;
function Gk(e, t, n) {
  const o = t.reduce((l, r) => (l[r] = (/* @__PURE__ */ Wt(e))[r], l), {});
  for (const l in o)
    e[l] = function() {
      const r = xL, a = n ? new Proxy(e, {
        get(...s) {
          return Zs = r, Reflect.get(...s);
        },
        set(...s) {
          return Zs = r, Reflect.set(...s);
        }
      }) : e;
      Zs = r;
      const i = o[l].apply(a, arguments);
      return Zs = void 0, i;
    };
}
function $Z({ app: e, store: t, options: n }) {
  if (!t.$id.startsWith("__hot:")) {
    if (t._isOptionsAPI = !!n.state, !t._p._testing) {
      Gk(t, Object.keys(n.actions), t._isOptionsAPI);
      const o = t._hotUpdate;
      (/* @__PURE__ */ Wt(t))._hotUpdate = function(l) {
        o.apply(this, arguments), Gk(t, Object.keys(l._hmrPayload.actions), !!t._isOptionsAPI);
      };
    }
    wZ(
      e,
      // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
      t
    );
  }
}
function xZ() {
  const e = kE(!0), t = e.run(() => /* @__PURE__ */ H({}));
  let n = [], o = [];
  const l = wa({
    install(r) {
      l._a = r, r.provide(aZ, l), r.config.globalProperties.$pinia = l, process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && B$ && CZ(r, l), o.forEach((a) => n.push(a)), o = [];
    },
    use(r) {
      return this._a ? n.push(r) : o.push(r), this;
    },
    _p: n,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: e,
    _s: /* @__PURE__ */ new Map(),
    state: t
  });
  return process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && B$ && typeof Proxy != "undefined" && l.use($Z), l;
}
process.env.NODE_ENV !== "production" ? Symbol("pinia:skipHydration") : (
  /* istanbul ignore next */
  Symbol()
);
/*!
  * shared v9.14.4
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
const Ra = typeof window != "undefined";
let Pr, Fu;
if (process.env.NODE_ENV !== "production") {
  const e = Ra && window.performance;
  e && e.mark && e.measure && e.clearMarks && // @ts-ignore browser compat
  e.clearMeasures && (Pr = (t) => {
    e.mark(t);
  }, Fu = (t, n, o) => {
    e.measure(t, n, o), e.clearMarks(n), e.clearMarks(o);
  });
}
const EZ = /\{([0-9a-zA-Z]+)\}/g;
function tO(e, ...t) {
  return t.length === 1 && Kn(t[0]) && (t = t[0]), (!t || !t.hasOwnProperty) && (t = {}), e.replace(EZ, (n, o) => t.hasOwnProperty(o) ? t[o] : "");
}
const Pi = (e, t = !1) => t ? Symbol.for(e) : Symbol(e), OZ = (e, t, n) => _Z({ l: e, k: t, s: n }), _Z = (e) => JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), jo = (e) => typeof e == "number" && isFinite(e), IZ = (e) => OL(e) === "[object Date]", gc = (e) => OL(e) === "[object RegExp]", p1 = (e) => En(e) && Object.keys(e).length === 0, Sl = Object.assign, TZ = Object.create, fo = (e = null) => TZ(e);
let Yk;
const es = () => Yk || (Yk = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : typeof window != "undefined" ? window : typeof global != "undefined" ? global : fo());
function Xk(e) {
  return e.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const PZ = Object.prototype.hasOwnProperty;
function Sa(e, t) {
  return PZ.call(e, t);
}
const yo = Array.isArray, co = (e) => typeof e == "function", Bt = (e) => typeof e == "string", Dn = (e) => typeof e == "boolean", Kn = (e) => e !== null && typeof e == "object", kZ = (e) => Kn(e) && co(e.then) && co(e.catch), EL = Object.prototype.toString, OL = (e) => EL.call(e), En = (e) => {
  if (!Kn(e))
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t.constructor === Object;
}, NZ = (e) => e == null ? "" : yo(e) || En(e) && e.toString === EL ? JSON.stringify(e, null, 2) : String(e);
function MZ(e, t = "") {
  return e.reduce((n, o, l) => l === 0 ? n + o : n + t + o, "");
}
const qk = 2;
function AZ(e, t = 0, n = e.length) {
  const o = e.split(/\r?\n/);
  let l = 0;
  const r = [];
  for (let a = 0; a < o.length; a++)
    if (l += o[a].length + 1, l >= t) {
      for (let i = a - qk; i <= a + qk || n > l; i++) {
        if (i < 0 || i >= o.length)
          continue;
        const s = i + 1;
        r.push(`${s}${" ".repeat(3 - String(s).length)}|  ${o[i]}`);
        const c = o[i].length;
        if (i === a) {
          const u = t - (l - c) + 1, d = Math.max(1, n > l ? c - u : n - t);
          r.push("   |  " + " ".repeat(u) + "^".repeat(d));
        } else if (i > a) {
          if (n > l) {
            const u = Math.max(Math.min(n - l, c), 1);
            r.push("   |  " + "^".repeat(u));
          }
          l += c + 1;
        }
      }
      break;
    }
  return r.join(`
`);
}
function v1(e) {
  let t = e;
  return () => ++t;
}
function ol(e, t) {
  typeof console != "undefined" && (console.warn("[intlify] " + e), t && console.warn(t.stack));
}
const Jk = {};
function _L(e) {
  Jk[e] || (Jk[e] = !0, ol(e));
}
function nO() {
  const e = /* @__PURE__ */ new Map();
  return {
    events: e,
    on(n, o) {
      const l = e.get(n);
      l && l.push(o) || e.set(n, [o]);
    },
    off(n, o) {
      const l = e.get(n);
      l && l.splice(l.indexOf(o) >>> 0, 1);
    },
    emit(n, o) {
      (e.get(n) || []).slice().map((l) => l(o)), (e.get("*") || []).slice().map((l) => l(n, o));
    }
  };
}
const Qh = (e) => !Kn(e) || yo(e);
function sb(e, t) {
  if (Qh(e) || Qh(t))
    throw new Error("Invalid value");
  const n = [{ src: e, des: t }];
  for (; n.length; ) {
    const { src: o, des: l } = n.pop();
    Object.keys(o).forEach((r) => {
      r !== "__proto__" && (Kn(o[r]) && !Kn(l[r]) && (l[r] = Array.isArray(o[r]) ? [] : fo()), Qh(l[r]) || Qh(o[r]) ? l[r] = o[r] : n.push({ src: o[r], des: l[r] }));
    });
  }
}
/*!
  * message-compiler v9.14.4
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function RZ(e, t, n) {
  return { line: e, column: t, offset: n };
}
function E0(e, t, n) {
  return { start: e, end: t };
}
const DZ = /\{([0-9a-zA-Z]+)\}/g;
function IL(e, ...t) {
  return t.length === 1 && LZ(t[0]) && (t = t[0]), (!t || !t.hasOwnProperty) && (t = {}), e.replace(DZ, (n, o) => t.hasOwnProperty(o) ? t[o] : "");
}
const TL = Object.assign, Zk = (e) => typeof e == "string", LZ = (e) => e !== null && typeof e == "object";
function PL(e, t = "") {
  return e.reduce((n, o, l) => l === 0 ? n + o : n + t + o, "");
}
const m1 = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
}, BZ = {
  [m1.USE_MODULO_SYNTAX]: "Use modulo before '{{0}}'."
};
function FZ(e, t, ...n) {
  const o = IL(BZ[e], ...n || []), l = { message: String(o), code: e };
  return t && (l.location = t), l;
}
const Cn = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
}, VZ = {
  // tokenizer error messages
  [Cn.EXPECTED_TOKEN]: "Expected token: '{0}'",
  [Cn.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
  [Cn.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
  [Cn.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
  [Cn.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
  [Cn.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
  [Cn.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
  [Cn.EMPTY_PLACEHOLDER]: "Empty placeholder",
  [Cn.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
  [Cn.INVALID_LINKED_FORMAT]: "Invalid linked format",
  // parser error messages
  [Cn.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
  [Cn.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
  [Cn.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
  [Cn.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
  // generator error messages
  [Cn.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
  // minimizer error messages
  [Cn.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
};
function hp(e, t, n = {}) {
  const { domain: o, messages: l, args: r } = n, a = IL((l || VZ)[e] || "", ...r || []), i = new SyntaxError(String(a));
  return i.code = e, t && (i.location = t), i.domain = o, i;
}
function zZ(e) {
  throw e;
}
const HZ = /<\/?[\w\s="/.':;#-\/]+>/, jZ = (e) => HZ.test(e), Fi = " ", WZ = "\r", Gl = `
`, KZ = "\u2028", UZ = "\u2029";
function GZ(e) {
  const t = e;
  let n = 0, o = 1, l = 1, r = 0;
  const a = (E) => t[E] === WZ && t[E + 1] === Gl, i = (E) => t[E] === Gl, s = (E) => t[E] === UZ, c = (E) => t[E] === KZ, u = (E) => a(E) || i(E) || s(E) || c(E), d = () => n, f = () => o, p = () => l, m = () => r, v = (E) => a(E) || s(E) || c(E) ? Gl : t[E], h = () => v(n), g = () => v(n + r);
  function y() {
    return r = 0, u(n) && (o++, l = 0), a(n) && n++, n++, l++, t[n];
  }
  function b() {
    return a(n + r) && r++, r++, t[n + r];
  }
  function C() {
    n = 0, o = 1, l = 1, r = 0;
  }
  function w(E = 0) {
    r = E;
  }
  function x() {
    const E = n + r;
    for (; E !== n; )
      y();
    r = 0;
  }
  return {
    index: d,
    line: f,
    column: p,
    peekOffset: m,
    charAt: v,
    currentChar: h,
    currentPeek: g,
    next: y,
    peek: b,
    reset: C,
    resetPeek: w,
    skipToPeek: x
  };
}
const Ms = void 0, YZ = ".", Qk = "'", XZ = "tokenizer";
function qZ(e, t = {}) {
  const n = t.location !== !1, o = GZ(e), l = () => o.index(), r = () => RZ(o.line(), o.column(), o.index()), a = r(), i = l(), s = {
    currentType: 14,
    offset: i,
    startLoc: a,
    endLoc: a,
    lastType: 14,
    lastOffset: i,
    lastStartLoc: a,
    lastEndLoc: a,
    braceNest: 0,
    inLinked: !1,
    text: ""
  }, c = () => s, { onError: u } = t;
  function d(ne, ae, ce, ...xe) {
    const Te = c();
    if (ae.column += ce, ae.offset += ce, u) {
      const Se = n ? E0(Te.startLoc, ae) : null, be = hp(ne, Se, {
        domain: XZ,
        args: xe
      });
      u(be);
    }
  }
  function f(ne, ae, ce) {
    ne.endLoc = r(), ne.currentType = ae;
    const xe = { type: ae };
    return n && (xe.loc = E0(ne.startLoc, ne.endLoc)), ce != null && (xe.value = ce), xe;
  }
  const p = (ne) => f(
    ne,
    14
    /* TokenTypes.EOF */
  );
  function m(ne, ae) {
    return ne.currentChar() === ae ? (ne.next(), ae) : (d(Cn.EXPECTED_TOKEN, r(), 0, ae), "");
  }
  function v(ne) {
    let ae = "";
    for (; ne.currentPeek() === Fi || ne.currentPeek() === Gl; )
      ae += ne.currentPeek(), ne.peek();
    return ae;
  }
  function h(ne) {
    const ae = v(ne);
    return ne.skipToPeek(), ae;
  }
  function g(ne) {
    if (ne === Ms)
      return !1;
    const ae = ne.charCodeAt(0);
    return ae >= 97 && ae <= 122 || // a-z
    ae >= 65 && ae <= 90 || // A-Z
    ae === 95;
  }
  function y(ne) {
    if (ne === Ms)
      return !1;
    const ae = ne.charCodeAt(0);
    return ae >= 48 && ae <= 57;
  }
  function b(ne, ae) {
    const { currentType: ce } = ae;
    if (ce !== 2)
      return !1;
    v(ne);
    const xe = g(ne.currentPeek());
    return ne.resetPeek(), xe;
  }
  function C(ne, ae) {
    const { currentType: ce } = ae;
    if (ce !== 2)
      return !1;
    v(ne);
    const xe = ne.currentPeek() === "-" ? ne.peek() : ne.currentPeek(), Te = y(xe);
    return ne.resetPeek(), Te;
  }
  function w(ne, ae) {
    const { currentType: ce } = ae;
    if (ce !== 2)
      return !1;
    v(ne);
    const xe = ne.currentPeek() === Qk;
    return ne.resetPeek(), xe;
  }
  function x(ne, ae) {
    const { currentType: ce } = ae;
    if (ce !== 8)
      return !1;
    v(ne);
    const xe = ne.currentPeek() === ".";
    return ne.resetPeek(), xe;
  }
  function E(ne, ae) {
    const { currentType: ce } = ae;
    if (ce !== 9)
      return !1;
    v(ne);
    const xe = g(ne.currentPeek());
    return ne.resetPeek(), xe;
  }
  function I(ne, ae) {
    const { currentType: ce } = ae;
    if (!(ce === 8 || ce === 12))
      return !1;
    v(ne);
    const xe = ne.currentPeek() === ":";
    return ne.resetPeek(), xe;
  }
  function T(ne, ae) {
    const { currentType: ce } = ae;
    if (ce !== 10)
      return !1;
    const xe = () => {
      const Se = ne.currentPeek();
      return Se === "{" ? g(ne.peek()) : Se === "@" || Se === "%" || Se === "|" || Se === ":" || Se === "." || Se === Fi || !Se ? !1 : Se === Gl ? (ne.peek(), xe()) : N(ne, !1);
    }, Te = xe();
    return ne.resetPeek(), Te;
  }
  function P(ne) {
    v(ne);
    const ae = ne.currentPeek() === "|";
    return ne.resetPeek(), ae;
  }
  function k(ne) {
    const ae = v(ne), ce = ne.currentPeek() === "%" && ne.peek() === "{";
    return ne.resetPeek(), {
      isModulo: ce,
      hasSpace: ae.length > 0
    };
  }
  function N(ne, ae = !0) {
    const ce = (Te = !1, Se = "", be = !1) => {
      const ie = ne.currentPeek();
      return ie === "{" ? Se === "%" ? !1 : Te : ie === "@" || !ie ? Se === "%" ? !0 : Te : ie === "%" ? (ne.peek(), ce(Te, "%", !0)) : ie === "|" ? Se === "%" || be ? !0 : !(Se === Fi || Se === Gl) : ie === Fi ? (ne.peek(), ce(!0, Fi, be)) : ie === Gl ? (ne.peek(), ce(!0, Gl, be)) : !0;
    }, xe = ce();
    return ae && ne.resetPeek(), xe;
  }
  function R(ne, ae) {
    const ce = ne.currentChar();
    return ce === Ms ? Ms : ae(ce) ? (ne.next(), ce) : null;
  }
  function z(ne) {
    const ae = ne.charCodeAt(0);
    return ae >= 97 && ae <= 122 || // a-z
    ae >= 65 && ae <= 90 || // A-Z
    ae >= 48 && ae <= 57 || // 0-9
    ae === 95 || // _
    ae === 36;
  }
  function D(ne) {
    return R(ne, z);
  }
  function F(ne) {
    const ae = ne.charCodeAt(0);
    return ae >= 97 && ae <= 122 || // a-z
    ae >= 65 && ae <= 90 || // A-Z
    ae >= 48 && ae <= 57 || // 0-9
    ae === 95 || // _
    ae === 36 || // $
    ae === 45;
  }
  function M(ne) {
    return R(ne, F);
  }
  function A(ne) {
    const ae = ne.charCodeAt(0);
    return ae >= 48 && ae <= 57;
  }
  function L(ne) {
    return R(ne, A);
  }
  function B(ne) {
    const ae = ne.charCodeAt(0);
    return ae >= 48 && ae <= 57 || // 0-9
    ae >= 65 && ae <= 70 || // A-F
    ae >= 97 && ae <= 102;
  }
  function V(ne) {
    return R(ne, B);
  }
  function j(ne) {
    let ae = "", ce = "";
    for (; ae = L(ne); )
      ce += ae;
    return ce;
  }
  function W(ne) {
    h(ne);
    const ae = ne.currentChar();
    return ae !== "%" && d(Cn.EXPECTED_TOKEN, r(), 0, ae), ne.next(), "%";
  }
  function Y(ne) {
    let ae = "";
    for (; ; ) {
      const ce = ne.currentChar();
      if (ce === "{" || ce === "}" || ce === "@" || ce === "|" || !ce)
        break;
      if (ce === "%")
        if (N(ne))
          ae += ce, ne.next();
        else
          break;
      else if (ce === Fi || ce === Gl)
        if (N(ne))
          ae += ce, ne.next();
        else {
          if (P(ne))
            break;
          ae += ce, ne.next();
        }
      else
        ae += ce, ne.next();
    }
    return ae;
  }
  function U(ne) {
    h(ne);
    let ae = "", ce = "";
    for (; ae = M(ne); )
      ce += ae;
    return ne.currentChar() === Ms && d(Cn.UNTERMINATED_CLOSING_BRACE, r(), 0), ce;
  }
  function te(ne) {
    h(ne);
    let ae = "";
    return ne.currentChar() === "-" ? (ne.next(), ae += `-${j(ne)}`) : ae += j(ne), ne.currentChar() === Ms && d(Cn.UNTERMINATED_CLOSING_BRACE, r(), 0), ae;
  }
  function J(ne) {
    return ne !== Qk && ne !== Gl;
  }
  function re(ne) {
    h(ne), m(ne, "'");
    let ae = "", ce = "";
    for (; ae = R(ne, J); )
      ae === "\\" ? ce += oe(ne) : ce += ae;
    const xe = ne.currentChar();
    return xe === Gl || xe === Ms ? (d(Cn.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, r(), 0), xe === Gl && (ne.next(), m(ne, "'")), ce) : (m(ne, "'"), ce);
  }
  function oe(ne) {
    const ae = ne.currentChar();
    switch (ae) {
      case "\\":
      case "'":
        return ne.next(), `\\${ae}`;
      case "u":
        return q(ne, ae, 4);
      case "U":
        return q(ne, ae, 6);
      default:
        return d(Cn.UNKNOWN_ESCAPE_SEQUENCE, r(), 0, ae), "";
    }
  }
  function q(ne, ae, ce) {
    m(ne, ae);
    let xe = "";
    for (let Te = 0; Te < ce; Te++) {
      const Se = V(ne);
      if (!Se) {
        d(Cn.INVALID_UNICODE_ESCAPE_SEQUENCE, r(), 0, `\\${ae}${xe}${ne.currentChar()}`);
        break;
      }
      xe += Se;
    }
    return `\\${ae}${xe}`;
  }
  function K(ne) {
    return ne !== "{" && ne !== "}" && ne !== Fi && ne !== Gl;
  }
  function se(ne) {
    h(ne);
    let ae = "", ce = "";
    for (; ae = R(ne, K); )
      ce += ae;
    return ce;
  }
  function Z(ne) {
    let ae = "", ce = "";
    for (; ae = D(ne); )
      ce += ae;
    return ce;
  }
  function ee(ne) {
    const ae = (ce) => {
      const xe = ne.currentChar();
      return xe === "{" || xe === "%" || xe === "@" || xe === "|" || xe === "(" || xe === ")" || !xe || xe === Fi ? ce : (ce += xe, ne.next(), ae(ce));
    };
    return ae("");
  }
  function fe(ne) {
    h(ne);
    const ae = m(
      ne,
      "|"
      /* TokenChars.Pipe */
    );
    return h(ne), ae;
  }
  function me(ne, ae) {
    let ce = null;
    switch (ne.currentChar()) {
      case "{":
        return ae.braceNest >= 1 && d(Cn.NOT_ALLOW_NEST_PLACEHOLDER, r(), 0), ne.next(), ce = f(
          ae,
          2,
          "{"
          /* TokenChars.BraceLeft */
        ), h(ne), ae.braceNest++, ce;
      case "}":
        return ae.braceNest > 0 && ae.currentType === 2 && d(Cn.EMPTY_PLACEHOLDER, r(), 0), ne.next(), ce = f(
          ae,
          3,
          "}"
          /* TokenChars.BraceRight */
        ), ae.braceNest--, ae.braceNest > 0 && h(ne), ae.inLinked && ae.braceNest === 0 && (ae.inLinked = !1), ce;
      case "@":
        return ae.braceNest > 0 && d(Cn.UNTERMINATED_CLOSING_BRACE, r(), 0), ce = ge(ne, ae) || p(ae), ae.braceNest = 0, ce;
      default: {
        let Te = !0, Se = !0, be = !0;
        if (P(ne))
          return ae.braceNest > 0 && d(Cn.UNTERMINATED_CLOSING_BRACE, r(), 0), ce = f(ae, 1, fe(ne)), ae.braceNest = 0, ae.inLinked = !1, ce;
        if (ae.braceNest > 0 && (ae.currentType === 5 || ae.currentType === 6 || ae.currentType === 7))
          return d(Cn.UNTERMINATED_CLOSING_BRACE, r(), 0), ae.braceNest = 0, he(ne, ae);
        if (Te = b(ne, ae))
          return ce = f(ae, 5, U(ne)), h(ne), ce;
        if (Se = C(ne, ae))
          return ce = f(ae, 6, te(ne)), h(ne), ce;
        if (be = w(ne, ae))
          return ce = f(ae, 7, re(ne)), h(ne), ce;
        if (!Te && !Se && !be)
          return ce = f(ae, 13, se(ne)), d(Cn.INVALID_TOKEN_IN_PLACEHOLDER, r(), 0, ce.value), h(ne), ce;
        break;
      }
    }
    return ce;
  }
  function ge(ne, ae) {
    const { currentType: ce } = ae;
    let xe = null;
    const Te = ne.currentChar();
    switch ((ce === 8 || ce === 9 || ce === 12 || ce === 10) && (Te === Gl || Te === Fi) && d(Cn.INVALID_LINKED_FORMAT, r(), 0), Te) {
      case "@":
        return ne.next(), xe = f(
          ae,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        ), ae.inLinked = !0, xe;
      case ".":
        return h(ne), ne.next(), f(
          ae,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        return h(ne), ne.next(), f(
          ae,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        return P(ne) ? (xe = f(ae, 1, fe(ne)), ae.braceNest = 0, ae.inLinked = !1, xe) : x(ne, ae) || I(ne, ae) ? (h(ne), ge(ne, ae)) : E(ne, ae) ? (h(ne), f(ae, 12, Z(ne))) : T(ne, ae) ? (h(ne), Te === "{" ? me(ne, ae) || xe : f(ae, 11, ee(ne))) : (ce === 8 && d(Cn.INVALID_LINKED_FORMAT, r(), 0), ae.braceNest = 0, ae.inLinked = !1, he(ne, ae));
    }
  }
  function he(ne, ae) {
    let ce = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (ae.braceNest > 0)
      return me(ne, ae) || p(ae);
    if (ae.inLinked)
      return ge(ne, ae) || p(ae);
    switch (ne.currentChar()) {
      case "{":
        return me(ne, ae) || p(ae);
      case "}":
        return d(Cn.UNBALANCED_CLOSING_BRACE, r(), 0), ne.next(), f(
          ae,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return ge(ne, ae) || p(ae);
      default: {
        if (P(ne))
          return ce = f(ae, 1, fe(ne)), ae.braceNest = 0, ae.inLinked = !1, ce;
        const { isModulo: Te, hasSpace: Se } = k(ne);
        if (Te)
          return Se ? f(ae, 0, Y(ne)) : f(ae, 4, W(ne));
        if (N(ne))
          return f(ae, 0, Y(ne));
        break;
      }
    }
    return ce;
  }
  function $e() {
    const { currentType: ne, offset: ae, startLoc: ce, endLoc: xe } = s;
    return s.lastType = ne, s.lastOffset = ae, s.lastStartLoc = ce, s.lastEndLoc = xe, s.offset = l(), s.startLoc = r(), o.currentChar() === Ms ? f(
      s,
      14
      /* TokenTypes.EOF */
    ) : he(o, s);
  }
  return {
    nextToken: $e,
    currentOffset: l,
    currentPosition: r,
    context: c
  };
}
const JZ = "parser", ZZ = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function QZ(e, t, n) {
  switch (e) {
    case "\\\\":
      return "\\";
    case "\\'":
      return "'";
    default: {
      const o = parseInt(t || n, 16);
      return o <= 55295 || o >= 57344 ? String.fromCodePoint(o) : "";
    }
  }
}
function eQ(e = {}) {
  const t = e.location !== !1, { onError: n, onWarn: o } = e;
  function l(b, C, w, x, ...E) {
    const I = b.currentPosition();
    if (I.offset += x, I.column += x, n) {
      const T = t ? E0(w, I) : null, P = hp(C, T, {
        domain: JZ,
        args: E
      });
      n(P);
    }
  }
  function r(b, C, w, x, ...E) {
    const I = b.currentPosition();
    if (I.offset += x, I.column += x, o) {
      const T = t ? E0(w, I) : null;
      o(FZ(C, T, E));
    }
  }
  function a(b, C, w) {
    const x = { type: b };
    return t && (x.start = C, x.end = C, x.loc = { start: w, end: w }), x;
  }
  function i(b, C, w, x) {
    t && (b.end = C, b.loc && (b.loc.end = w));
  }
  function s(b, C) {
    const w = b.context(), x = a(3, w.offset, w.startLoc);
    return x.value = C, i(x, b.currentOffset(), b.currentPosition()), x;
  }
  function c(b, C) {
    const w = b.context(), { lastOffset: x, lastStartLoc: E } = w, I = a(5, x, E);
    return I.index = parseInt(C, 10), b.nextToken(), i(I, b.currentOffset(), b.currentPosition()), I;
  }
  function u(b, C, w) {
    const x = b.context(), { lastOffset: E, lastStartLoc: I } = x, T = a(4, E, I);
    return T.key = C, w === !0 && (T.modulo = !0), b.nextToken(), i(T, b.currentOffset(), b.currentPosition()), T;
  }
  function d(b, C) {
    const w = b.context(), { lastOffset: x, lastStartLoc: E } = w, I = a(9, x, E);
    return I.value = C.replace(ZZ, QZ), b.nextToken(), i(I, b.currentOffset(), b.currentPosition()), I;
  }
  function f(b) {
    const C = b.nextToken(), w = b.context(), { lastOffset: x, lastStartLoc: E } = w, I = a(8, x, E);
    return C.type !== 12 ? (l(b, Cn.UNEXPECTED_EMPTY_LINKED_MODIFIER, w.lastStartLoc, 0), I.value = "", i(I, x, E), {
      nextConsumeToken: C,
      node: I
    }) : (C.value == null && l(b, Cn.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, pa(C)), I.value = C.value || "", i(I, b.currentOffset(), b.currentPosition()), {
      node: I
    });
  }
  function p(b, C) {
    const w = b.context(), x = a(7, w.offset, w.startLoc);
    return x.value = C, i(x, b.currentOffset(), b.currentPosition()), x;
  }
  function m(b) {
    const C = b.context(), w = a(6, C.offset, C.startLoc);
    let x = b.nextToken();
    if (x.type === 9) {
      const E = f(b);
      w.modifier = E.node, x = E.nextConsumeToken || b.nextToken();
    }
    switch (x.type !== 10 && l(b, Cn.UNEXPECTED_LEXICAL_ANALYSIS, C.lastStartLoc, 0, pa(x)), x = b.nextToken(), x.type === 2 && (x = b.nextToken()), x.type) {
      case 11:
        x.value == null && l(b, Cn.UNEXPECTED_LEXICAL_ANALYSIS, C.lastStartLoc, 0, pa(x)), w.key = p(b, x.value || "");
        break;
      case 5:
        x.value == null && l(b, Cn.UNEXPECTED_LEXICAL_ANALYSIS, C.lastStartLoc, 0, pa(x)), w.key = u(b, x.value || "");
        break;
      case 6:
        x.value == null && l(b, Cn.UNEXPECTED_LEXICAL_ANALYSIS, C.lastStartLoc, 0, pa(x)), w.key = c(b, x.value || "");
        break;
      case 7:
        x.value == null && l(b, Cn.UNEXPECTED_LEXICAL_ANALYSIS, C.lastStartLoc, 0, pa(x)), w.key = d(b, x.value || "");
        break;
      default: {
        l(b, Cn.UNEXPECTED_EMPTY_LINKED_KEY, C.lastStartLoc, 0);
        const E = b.context(), I = a(7, E.offset, E.startLoc);
        return I.value = "", i(I, E.offset, E.startLoc), w.key = I, i(w, E.offset, E.startLoc), {
          nextConsumeToken: x,
          node: w
        };
      }
    }
    return i(w, b.currentOffset(), b.currentPosition()), {
      node: w
    };
  }
  function v(b) {
    const C = b.context(), w = C.currentType === 1 ? b.currentOffset() : C.offset, x = C.currentType === 1 ? C.endLoc : C.startLoc, E = a(2, w, x);
    E.items = [];
    let I = null, T = null;
    do {
      const N = I || b.nextToken();
      switch (I = null, N.type) {
        case 0:
          N.value == null && l(b, Cn.UNEXPECTED_LEXICAL_ANALYSIS, C.lastStartLoc, 0, pa(N)), E.items.push(s(b, N.value || ""));
          break;
        case 6:
          N.value == null && l(b, Cn.UNEXPECTED_LEXICAL_ANALYSIS, C.lastStartLoc, 0, pa(N)), E.items.push(c(b, N.value || ""));
          break;
        case 4:
          T = !0;
          break;
        case 5:
          N.value == null && l(b, Cn.UNEXPECTED_LEXICAL_ANALYSIS, C.lastStartLoc, 0, pa(N)), E.items.push(u(b, N.value || "", !!T)), T && (r(b, m1.USE_MODULO_SYNTAX, C.lastStartLoc, 0, pa(N)), T = null);
          break;
        case 7:
          N.value == null && l(b, Cn.UNEXPECTED_LEXICAL_ANALYSIS, C.lastStartLoc, 0, pa(N)), E.items.push(d(b, N.value || ""));
          break;
        case 8: {
          const R = m(b);
          E.items.push(R.node), I = R.nextConsumeToken || null;
          break;
        }
      }
    } while (C.currentType !== 14 && C.currentType !== 1);
    const P = C.currentType === 1 ? C.lastOffset : b.currentOffset(), k = C.currentType === 1 ? C.lastEndLoc : b.currentPosition();
    return i(E, P, k), E;
  }
  function h(b, C, w, x) {
    const E = b.context();
    let I = x.items.length === 0;
    const T = a(1, C, w);
    T.cases = [], T.cases.push(x);
    do {
      const P = v(b);
      I || (I = P.items.length === 0), T.cases.push(P);
    } while (E.currentType !== 14);
    return I && l(b, Cn.MUST_HAVE_MESSAGES_IN_PLURAL, w, 0), i(T, b.currentOffset(), b.currentPosition()), T;
  }
  function g(b) {
    const C = b.context(), { offset: w, startLoc: x } = C, E = v(b);
    return C.currentType === 14 ? E : h(b, w, x, E);
  }
  function y(b) {
    const C = qZ(b, TL({}, e)), w = C.context(), x = a(0, w.offset, w.startLoc);
    return t && x.loc && (x.loc.source = b), x.body = g(C), e.onCacheKey && (x.cacheKey = e.onCacheKey(b)), w.currentType !== 14 && l(C, Cn.UNEXPECTED_LEXICAL_ANALYSIS, w.lastStartLoc, 0, b[w.offset] || ""), i(x, C.currentOffset(), C.currentPosition()), x;
  }
  return { parse: y };
}
function pa(e) {
  if (e.type === 14)
    return "EOF";
  const t = (e.value || "").replace(/\r?\n/gu, "\\n");
  return t.length > 10 ? t.slice(0, 9) + "" : t;
}
function tQ(e, t = {}) {
  const n = {
    ast: e,
    helpers: /* @__PURE__ */ new Set()
  };
  return { context: () => n, helper: (r) => (n.helpers.add(r), r) };
}
function e4(e, t) {
  for (let n = 0; n < e.length; n++)
    oO(e[n], t);
}
function oO(e, t) {
  switch (e.type) {
    case 1:
      e4(e.cases, t), t.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      e4(e.items, t);
      break;
    case 6: {
      oO(e.key, t), t.helper(
        "linked"
        /* HelperNameMap.LINKED */
      ), t.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      t.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), t.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      t.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      ), t.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function nQ(e, t = {}) {
  const n = tQ(e);
  n.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  ), e.body && oO(e.body, n);
  const o = n.context();
  e.helpers = Array.from(o.helpers);
}
function oQ(e) {
  const t = e.body;
  return t.type === 2 ? t4(t) : t.cases.forEach((n) => t4(n)), e;
}
function t4(e) {
  if (e.items.length === 1) {
    const t = e.items[0];
    (t.type === 3 || t.type === 9) && (e.static = t.value, delete t.value);
  } else {
    const t = [];
    for (let n = 0; n < e.items.length; n++) {
      const o = e.items[n];
      if (!(o.type === 3 || o.type === 9) || o.value == null)
        break;
      t.push(o.value);
    }
    if (t.length === e.items.length) {
      e.static = PL(t);
      for (let n = 0; n < e.items.length; n++) {
        const o = e.items[n];
        (o.type === 3 || o.type === 9) && delete o.value;
      }
    }
  }
}
const lQ = "minifier";
function Fd(e) {
  switch (e.t = e.type, e.type) {
    case 0: {
      const t = e;
      Fd(t.body), t.b = t.body, delete t.body;
      break;
    }
    case 1: {
      const t = e, n = t.cases;
      for (let o = 0; o < n.length; o++)
        Fd(n[o]);
      t.c = n, delete t.cases;
      break;
    }
    case 2: {
      const t = e, n = t.items;
      for (let o = 0; o < n.length; o++)
        Fd(n[o]);
      t.i = n, delete t.items, t.static && (t.s = t.static, delete t.static);
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const t = e;
      t.value && (t.v = t.value, delete t.value);
      break;
    }
    case 6: {
      const t = e;
      Fd(t.key), t.k = t.key, delete t.key, t.modifier && (Fd(t.modifier), t.m = t.modifier, delete t.modifier);
      break;
    }
    case 5: {
      const t = e;
      t.i = t.index, delete t.index;
      break;
    }
    case 4: {
      const t = e;
      t.k = t.key, delete t.key;
      break;
    }
    default:
      throw hp(Cn.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: lQ,
        args: [e.type]
      });
  }
  delete e.type;
}
const rQ = "parser";
function aQ(e, t) {
  const { filename: n, breakLineCode: o, needIndent: l } = t, r = t.location !== !1, a = {
    filename: n,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: o,
    needIndent: l,
    indentLevel: 0
  };
  r && e.loc && (a.source = e.loc.source);
  const i = () => a;
  function s(v, h) {
    a.code += v;
  }
  function c(v, h = !0) {
    const g = h ? o : "";
    s(l ? g + "  ".repeat(v) : g);
  }
  function u(v = !0) {
    const h = ++a.indentLevel;
    v && c(h);
  }
  function d(v = !0) {
    const h = --a.indentLevel;
    v && c(h);
  }
  function f() {
    c(a.indentLevel);
  }
  return {
    context: i,
    push: s,
    indent: u,
    deindent: d,
    newline: f,
    helper: (v) => `_${v}`,
    needIndent: () => a.needIndent
  };
}
function iQ(e, t) {
  const { helper: n } = e;
  e.push(`${n(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`), Df(e, t.key), t.modifier ? (e.push(", "), Df(e, t.modifier), e.push(", _type")) : e.push(", undefined, _type"), e.push(")");
}
function sQ(e, t) {
  const { helper: n, needIndent: o } = e;
  e.push(`${n(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`), e.indent(o());
  const l = t.items.length;
  for (let r = 0; r < l && (Df(e, t.items[r]), r !== l - 1); r++)
    e.push(", ");
  e.deindent(o()), e.push("])");
}
function cQ(e, t) {
  const { helper: n, needIndent: o } = e;
  if (t.cases.length > 1) {
    e.push(`${n(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`), e.indent(o());
    const l = t.cases.length;
    for (let r = 0; r < l && (Df(e, t.cases[r]), r !== l - 1); r++)
      e.push(", ");
    e.deindent(o()), e.push("])");
  }
}
function uQ(e, t) {
  t.body ? Df(e, t.body) : e.push("null");
}
function Df(e, t) {
  const { helper: n } = e;
  switch (t.type) {
    case 0:
      uQ(e, t);
      break;
    case 1:
      cQ(e, t);
      break;
    case 2:
      sQ(e, t);
      break;
    case 6:
      iQ(e, t);
      break;
    case 8:
      e.push(JSON.stringify(t.value), t);
      break;
    case 7:
      e.push(JSON.stringify(t.value), t);
      break;
    case 5:
      e.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "list"
        /* HelperNameMap.LIST */
      )}(${t.index}))`, t);
      break;
    case 4:
      e.push(`${n(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${n(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(t.key)}))`, t);
      break;
    case 9:
      e.push(JSON.stringify(t.value), t);
      break;
    case 3:
      e.push(JSON.stringify(t.value), t);
      break;
    default:
      throw hp(Cn.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: rQ,
        args: [t.type]
      });
  }
}
const dQ = (e, t = {}) => {
  const n = Zk(t.mode) ? t.mode : "normal", o = Zk(t.filename) ? t.filename : "message.intl";
  t.sourceMap;
  const l = t.breakLineCode != null ? t.breakLineCode : n === "arrow" ? ";" : `
`, r = t.needIndent ? t.needIndent : n !== "arrow", a = e.helpers || [], i = aQ(e, {
    filename: o,
    breakLineCode: l,
    needIndent: r
  });
  i.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), i.indent(r), a.length > 0 && (i.push(`const { ${PL(a.map((u) => `${u}: _${u}`), ", ")} } = ctx`), i.newline()), i.push("return "), Df(i, e), i.deindent(r), i.push("}"), delete e.helpers;
  const { code: s, map: c } = i.context();
  return {
    ast: e,
    code: s,
    map: c ? c.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function fQ(e, t = {}) {
  const n = TL({}, t), o = !!n.jit, l = !!n.minify, r = n.optimize == null ? !0 : n.optimize, i = eQ(n).parse(e);
  return o ? (r && oQ(i), l && Fd(i), { ast: i, code: "" }) : (nQ(i, n), dQ(i, n));
}
/*!
  * core-base v9.14.4
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
function pQ() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (es().__INTLIFY_PROD_DEVTOOLS__ = !1), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (es().__INTLIFY_JIT_COMPILATION__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (es().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1);
}
function ta(e) {
  return Kn(e) && lO(e) === 0 && (Sa(e, "b") || Sa(e, "body"));
}
const kL = ["b", "body"];
function vQ(e) {
  return Ic(e, kL);
}
const NL = ["c", "cases"];
function mQ(e) {
  return Ic(e, NL, []);
}
const ML = ["s", "static"];
function hQ(e) {
  return Ic(e, ML);
}
const AL = ["i", "items"];
function gQ(e) {
  return Ic(e, AL, []);
}
const RL = ["t", "type"];
function lO(e) {
  return Ic(e, RL);
}
const DL = ["v", "value"];
function eg(e, t) {
  const n = Ic(e, DL);
  if (n != null)
    return n;
  throw em(t);
}
const LL = ["m", "modifier"];
function bQ(e) {
  return Ic(e, LL);
}
const BL = ["k", "key"];
function yQ(e) {
  const t = Ic(e, BL);
  if (t)
    return t;
  throw em(
    6
    /* NodeTypes.Linked */
  );
}
function Ic(e, t, n) {
  for (let o = 0; o < t.length; o++) {
    const l = t[o];
    if (Sa(e, l) && e[l] != null)
      return e[l];
  }
  return n;
}
const FL = [
  ...kL,
  ...NL,
  ...ML,
  ...AL,
  ...BL,
  ...LL,
  ...DL,
  ...RL
];
function em(e) {
  return new Error(`unhandled node type: ${e}`);
}
const Tc = [];
Tc[
  0
  /* States.BEFORE_PATH */
] = {
  w: [
    0
    /* States.BEFORE_PATH */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
Tc[
  1
  /* States.IN_PATH */
] = {
  w: [
    1
    /* States.IN_PATH */
  ],
  ".": [
    2
    /* States.BEFORE_IDENT */
  ],
  "[": [
    4
    /* States.IN_SUB_PATH */
  ],
  o: [
    7
    /* States.AFTER_PATH */
  ]
};
Tc[
  2
  /* States.BEFORE_IDENT */
] = {
  w: [
    2
    /* States.BEFORE_IDENT */
  ],
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ]
};
Tc[
  3
  /* States.IN_IDENT */
] = {
  i: [
    3,
    0
    /* Actions.APPEND */
  ],
  0: [
    3,
    0
    /* Actions.APPEND */
  ],
  w: [
    1,
    1
    /* Actions.PUSH */
  ],
  ".": [
    2,
    1
    /* Actions.PUSH */
  ],
  "[": [
    4,
    1
    /* Actions.PUSH */
  ],
  o: [
    7,
    1
    /* Actions.PUSH */
  ]
};
Tc[
  4
  /* States.IN_SUB_PATH */
] = {
  "'": [
    5,
    0
    /* Actions.APPEND */
  ],
  '"': [
    6,
    0
    /* Actions.APPEND */
  ],
  "[": [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  "]": [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  o: 8,
  l: [
    4,
    0
    /* Actions.APPEND */
  ]
};
Tc[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  "'": [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    5,
    0
    /* Actions.APPEND */
  ]
};
Tc[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  '"': [
    4,
    0
    /* Actions.APPEND */
  ],
  o: 8,
  l: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const SQ = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function CQ(e) {
  return SQ.test(e);
}
function wQ(e) {
  const t = e.charCodeAt(0), n = e.charCodeAt(e.length - 1);
  return t === n && (t === 34 || t === 39) ? e.slice(1, -1) : e;
}
function $Q(e) {
  if (e == null)
    return "o";
  switch (e.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return e;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function xQ(e) {
  const t = e.trim();
  return e.charAt(0) === "0" && isNaN(parseInt(e)) ? !1 : CQ(t) ? wQ(t) : "*" + t;
}
function EQ(e) {
  const t = [];
  let n = -1, o = 0, l = 0, r, a, i, s, c, u, d;
  const f = [];
  f[
    0
    /* Actions.APPEND */
  ] = () => {
    a === void 0 ? a = i : a += i;
  }, f[
    1
    /* Actions.PUSH */
  ] = () => {
    a !== void 0 && (t.push(a), a = void 0);
  }, f[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    f[
      0
      /* Actions.APPEND */
    ](), l++;
  }, f[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (l > 0)
      l--, o = 4, f[
        0
        /* Actions.APPEND */
      ]();
    else {
      if (l = 0, a === void 0 || (a = xQ(a), a === !1))
        return !1;
      f[
        1
        /* Actions.PUSH */
      ]();
    }
  };
  function p() {
    const m = e[n + 1];
    if (o === 5 && m === "'" || o === 6 && m === '"')
      return n++, i = "\\" + m, f[
        0
        /* Actions.APPEND */
      ](), !0;
  }
  for (; o !== null; )
    if (n++, r = e[n], !(r === "\\" && p())) {
      if (s = $Q(r), d = Tc[o], c = d[s] || d.l || 8, c === 8 || (o = c[0], c[1] !== void 0 && (u = f[c[1]], u && (i = r, u() === !1))))
        return;
      if (o === 7)
        return t;
    }
}
const n4 = /* @__PURE__ */ new Map();
function OQ(e, t) {
  return Kn(e) ? e[t] : null;
}
function _Q(e, t) {
  if (!Kn(e))
    return null;
  let n = n4.get(t);
  if (n || (n = EQ(t), n && n4.set(t, n)), !n)
    return null;
  const o = n.length;
  let l = e, r = 0;
  for (; r < o; ) {
    const a = n[r];
    if (FL.includes(a) && ta(l))
      return null;
    const i = l[a];
    if (i === void 0 || co(l))
      return null;
    l = i, r++;
  }
  return l;
}
const IQ = (e) => e, TQ = (e) => "", PQ = "text", kQ = (e) => e.length === 0 ? "" : MZ(e), NQ = NZ;
function o4(e, t) {
  return e = Math.abs(e), t === 2 ? e ? e > 1 ? 1 : 0 : 1 : e ? Math.min(e, 2) : 0;
}
function MQ(e) {
  const t = jo(e.pluralIndex) ? e.pluralIndex : -1;
  return e.named && (jo(e.named.count) || jo(e.named.n)) ? jo(e.named.count) ? e.named.count : jo(e.named.n) ? e.named.n : t : t;
}
function AQ(e, t) {
  t.count || (t.count = e), t.n || (t.n = e);
}
function RQ(e = {}) {
  const t = e.locale, n = MQ(e), o = Kn(e.pluralRules) && Bt(t) && co(e.pluralRules[t]) ? e.pluralRules[t] : o4, l = Kn(e.pluralRules) && Bt(t) && co(e.pluralRules[t]) ? o4 : void 0, r = (g) => g[o(n, g.length, l)], a = e.list || [], i = (g) => a[g], s = e.named || fo();
  jo(e.pluralIndex) && AQ(n, s);
  const c = (g) => s[g];
  function u(g) {
    const y = co(e.messages) ? e.messages(g) : Kn(e.messages) ? e.messages[g] : !1;
    return y || (e.parent ? e.parent.message(g) : TQ);
  }
  const d = (g) => e.modifiers ? e.modifiers[g] : IQ, f = En(e.processor) && co(e.processor.normalize) ? e.processor.normalize : kQ, p = En(e.processor) && co(e.processor.interpolate) ? e.processor.interpolate : NQ, m = En(e.processor) && Bt(e.processor.type) ? e.processor.type : PQ, h = {
    list: i,
    named: c,
    plural: r,
    linked: (g, ...y) => {
      const [b, C] = y;
      let w = "text", x = "";
      y.length === 1 ? Kn(b) ? (x = b.modifier || x, w = b.type || w) : Bt(b) && (x = b || x) : y.length === 2 && (Bt(b) && (x = b || x), Bt(C) && (w = C || w));
      const E = u(g)(h), I = (
        // The message in vnode resolved with linked are returned as an array by processor.nomalize
        w === "vnode" && yo(E) && x ? E[0] : E
      );
      return x ? d(x)(I, w) : I;
    },
    message: u,
    type: m,
    interpolate: p,
    normalize: f,
    values: Sl(fo(), a, s)
  };
  return h;
}
let tm = null;
function DQ(e) {
  tm = e;
}
function LQ(e, t, n) {
  tm && tm.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: e,
    version: t,
    meta: n
  });
}
const BQ = /* @__PURE__ */ FQ(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function FQ(e) {
  return (t) => tm && tm.emit(e, t);
}
const VL = m1.__EXTEND_POINT__, Hc = v1(VL), ql = {
  NOT_FOUND_KEY: VL,
  // 2
  FALLBACK_TO_TRANSLATE: Hc(),
  // 3
  CANNOT_FORMAT_NUMBER: Hc(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: Hc(),
  // 5
  CANNOT_FORMAT_DATE: Hc(),
  // 6
  FALLBACK_TO_DATE_FORMAT: Hc(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: Hc(),
  // 8
  __EXTEND_POINT__: Hc()
  // 9
}, VQ = {
  [ql.NOT_FOUND_KEY]: "Not found '{key}' key in '{locale}' locale messages.",
  [ql.FALLBACK_TO_TRANSLATE]: "Fall back to translate '{key}' key with '{target}' locale.",
  [ql.CANNOT_FORMAT_NUMBER]: "Cannot format a number value due to not supported Intl.NumberFormat.",
  [ql.FALLBACK_TO_NUMBER_FORMAT]: "Fall back to number format '{key}' key with '{target}' locale.",
  [ql.CANNOT_FORMAT_DATE]: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
  [ql.FALLBACK_TO_DATE_FORMAT]: "Fall back to datetime format '{key}' key with '{target}' locale.",
  [ql.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: "This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future."
};
function Vu(e, ...t) {
  return tO(VQ[e], ...t);
}
const zL = Cn.__EXTEND_POINT__, jc = v1(zL), fl = {
  INVALID_ARGUMENT: zL,
  // 17
  INVALID_DATE_ARGUMENT: jc(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: jc(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: jc(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: jc(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: jc(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: jc(),
  // 23
  __EXTEND_POINT__: jc()
  // 24
};
function ui(e) {
  return hp(e, null, process.env.NODE_ENV !== "production" ? { messages: zQ } : void 0);
}
const zQ = {
  [fl.INVALID_ARGUMENT]: "Invalid arguments",
  [fl.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [fl.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [fl.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [fl.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [fl.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [fl.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function rO(e, t) {
  return t.locale != null ? l4(t.locale) : l4(e.locale);
}
let EC;
function l4(e) {
  if (Bt(e))
    return e;
  if (co(e)) {
    if (e.resolvedOnce && EC != null)
      return EC;
    if (e.constructor.name === "Function") {
      const t = e();
      if (kZ(t))
        throw ui(fl.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return EC = t;
    } else
      throw ui(fl.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
  } else
    throw ui(fl.NOT_SUPPORT_LOCALE_TYPE);
}
function HQ(e, t, n) {
  return [.../* @__PURE__ */ new Set([
    n,
    ...yo(t) ? t : Kn(t) ? Object.keys(t) : Bt(t) ? [t] : [n]
  ])];
}
function HL(e, t, n) {
  const o = Bt(n) ? n : Lf, l = e;
  l.__localeChainCache || (l.__localeChainCache = /* @__PURE__ */ new Map());
  let r = l.__localeChainCache.get(o);
  if (!r) {
    r = [];
    let a = [n];
    for (; yo(a); )
      a = r4(r, a, t);
    const i = yo(t) || !En(t) ? t : t.default ? t.default : null;
    a = Bt(i) ? [i] : i, yo(a) && r4(r, a, !1), l.__localeChainCache.set(o, r);
  }
  return r;
}
function r4(e, t, n) {
  let o = !0;
  for (let l = 0; l < t.length && Dn(o); l++) {
    const r = t[l];
    Bt(r) && (o = jQ(e, t[l], n));
  }
  return o;
}
function jQ(e, t, n) {
  let o;
  const l = t.split("-");
  do {
    const r = l.join("-");
    o = WQ(e, r, n), l.splice(-1, 1);
  } while (l.length && o === !0);
  return o;
}
function WQ(e, t, n) {
  let o = !1;
  if (!e.includes(t) && (o = !0, t)) {
    o = t[t.length - 1] !== "!";
    const l = t.replace(/!/g, "");
    e.push(l), (yo(n) || En(n)) && n[l] && (o = n[l]);
  }
  return o;
}
const KQ = "9.14.4", h1 = -1, Lf = "en-US", O0 = "", a4 = (e) => `${e.charAt(0).toLocaleUpperCase()}${e.substr(1)}`;
function UQ() {
  return {
    upper: (e, t) => t === "text" && Bt(e) ? e.toUpperCase() : t === "vnode" && Kn(e) && "__v_isVNode" in e ? e.children.toUpperCase() : e,
    lower: (e, t) => t === "text" && Bt(e) ? e.toLowerCase() : t === "vnode" && Kn(e) && "__v_isVNode" in e ? e.children.toLowerCase() : e,
    capitalize: (e, t) => t === "text" && Bt(e) ? a4(e) : t === "vnode" && Kn(e) && "__v_isVNode" in e ? a4(e.children) : e
  };
}
let jL;
function i4(e) {
  jL = e;
}
let WL;
function GQ(e) {
  WL = e;
}
let KL;
function YQ(e) {
  KL = e;
}
let UL = null;
const XQ = /* @__NO_SIDE_EFFECTS__ */ (e) => {
  UL = e;
}, qQ = /* @__NO_SIDE_EFFECTS__ */ () => UL;
let GL = null;
const s4 = (e) => {
  GL = e;
}, JQ = () => GL;
let c4 = 0;
function ZQ(e = {}) {
  const t = co(e.onWarn) ? e.onWarn : ol, n = Bt(e.version) ? e.version : KQ, o = Bt(e.locale) || co(e.locale) ? e.locale : Lf, l = co(o) ? Lf : o, r = yo(e.fallbackLocale) || En(e.fallbackLocale) || Bt(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : l, a = En(e.messages) ? e.messages : OC(l), i = En(e.datetimeFormats) ? e.datetimeFormats : OC(l), s = En(e.numberFormats) ? e.numberFormats : OC(l), c = Sl(fo(), e.modifiers, UQ()), u = e.pluralRules || fo(), d = co(e.missing) ? e.missing : null, f = Dn(e.missingWarn) || gc(e.missingWarn) ? e.missingWarn : !0, p = Dn(e.fallbackWarn) || gc(e.fallbackWarn) ? e.fallbackWarn : !0, m = !!e.fallbackFormat, v = !!e.unresolving, h = co(e.postTranslation) ? e.postTranslation : null, g = En(e.processor) ? e.processor : null, y = Dn(e.warnHtmlMessage) ? e.warnHtmlMessage : !0, b = !!e.escapeParameter, C = co(e.messageCompiler) ? e.messageCompiler : jL;
  process.env.NODE_ENV !== "production" && co(e.messageCompiler) && _L(Vu(ql.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  const w = co(e.messageResolver) ? e.messageResolver : WL || OQ, x = co(e.localeFallbacker) ? e.localeFallbacker : KL || HQ, E = Kn(e.fallbackContext) ? e.fallbackContext : void 0, I = e, T = Kn(I.__datetimeFormatters) ? I.__datetimeFormatters : /* @__PURE__ */ new Map(), P = Kn(I.__numberFormatters) ? I.__numberFormatters : /* @__PURE__ */ new Map(), k = Kn(I.__meta) ? I.__meta : {};
  c4++;
  const N = {
    version: n,
    cid: c4,
    locale: o,
    fallbackLocale: r,
    messages: a,
    modifiers: c,
    pluralRules: u,
    missing: d,
    missingWarn: f,
    fallbackWarn: p,
    fallbackFormat: m,
    unresolving: v,
    postTranslation: h,
    processor: g,
    warnHtmlMessage: y,
    escapeParameter: b,
    messageCompiler: C,
    messageResolver: w,
    localeFallbacker: x,
    fallbackContext: E,
    onWarn: t,
    __meta: k
  };
  return N.datetimeFormats = i, N.numberFormats = s, N.__datetimeFormatters = T, N.__numberFormatters = P, process.env.NODE_ENV !== "production" && (N.__v_emitter = I.__v_emitter != null ? I.__v_emitter : void 0), (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) && LQ(N, n, k), N;
}
const OC = (e) => ({ [e]: fo() });
function g1(e, t) {
  return e instanceof RegExp ? e.test(t) : e;
}
function YL(e, t) {
  return e instanceof RegExp ? e.test(t) : e;
}
function aO(e, t, n, o, l) {
  const { missing: r, onWarn: a } = e;
  if (process.env.NODE_ENV !== "production") {
    const i = e.__v_emitter;
    i && i.emit("missing", {
      locale: n,
      key: t,
      type: l,
      groupId: `${l}:${t}`
    });
  }
  if (r !== null) {
    const i = r(e, n, t, l);
    return Bt(i) ? i : t;
  } else
    return process.env.NODE_ENV !== "production" && YL(o, t) && a(Vu(ql.NOT_FOUND_KEY, { key: t, locale: n })), t;
}
function qp(e, t, n) {
  const o = e;
  o.__localeChainCache = /* @__PURE__ */ new Map(), e.localeFallbacker(e, n, t);
}
function XL(e, t) {
  return e === t ? !1 : e.split("-")[0] === t.split("-")[0];
}
function QQ(e, t) {
  const n = t.indexOf(e);
  if (n === -1)
    return !1;
  for (let o = n + 1; o < t.length; o++)
    if (XL(e, t[o]))
      return !0;
  return !1;
}
function _C(e) {
  return (n) => eee(n, e);
}
function eee(e, t) {
  const n = vQ(t);
  if (n == null)
    throw em(
      0
      /* NodeTypes.Resource */
    );
  if (lO(n) === 1) {
    const r = mQ(n);
    return e.plural(r.reduce((a, i) => [
      ...a,
      u4(e, i)
    ], []));
  } else
    return u4(e, n);
}
function u4(e, t) {
  const n = hQ(t);
  if (n != null)
    return e.type === "text" ? n : e.normalize([n]);
  {
    const o = gQ(t).reduce((l, r) => [...l, F$(e, r)], []);
    return e.normalize(o);
  }
}
function F$(e, t) {
  const n = lO(t);
  switch (n) {
    case 3:
      return eg(t, n);
    case 9:
      return eg(t, n);
    case 4: {
      const o = t;
      if (Sa(o, "k") && o.k)
        return e.interpolate(e.named(o.k));
      if (Sa(o, "key") && o.key)
        return e.interpolate(e.named(o.key));
      throw em(n);
    }
    case 5: {
      const o = t;
      if (Sa(o, "i") && jo(o.i))
        return e.interpolate(e.list(o.i));
      if (Sa(o, "index") && jo(o.index))
        return e.interpolate(e.list(o.index));
      throw em(n);
    }
    case 6: {
      const o = t, l = bQ(o), r = yQ(o);
      return e.linked(F$(e, r), l ? F$(e, l) : void 0, e.type);
    }
    case 7:
      return eg(t, n);
    case 8:
      return eg(t, n);
    default:
      throw new Error(`unhandled node on format message part: ${n}`);
  }
}
const tee = "Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.";
function qL(e, t) {
  t && jZ(e) && ol(tO(tee, { source: e }));
}
const JL = (e) => e;
let Yd = fo();
function ZL(e) {
  e.code === m1.USE_MODULO_SYNTAX && ol(`The use of named interpolation with modulo syntax is deprecated. It will be removed in v10.
reference: https://vue-i18n.intlify.dev/guide/essentials/syntax#rails-i18n-format 
(message compiler warning message: ${e.message})`);
}
function QL(e, t = {}) {
  let n = !1;
  const o = t.onError || zZ;
  return t.onError = (l) => {
    n = !0, o(l);
  }, vt(Be({}, fQ(e, t)), { detectError: n });
}
const nee = /* @__NO_SIDE_EFFECTS__ */ (e, t) => {
  if (!Bt(e))
    throw ui(fl.NOT_SUPPORT_NON_STRING_MESSAGE);
  process.env.NODE_ENV !== "production" && (t.onWarn = ZL);
  {
    const n = Dn(t.warnHtmlMessage) ? t.warnHtmlMessage : !0;
    process.env.NODE_ENV !== "production" && qL(e, n);
    const l = (t.onCacheKey || JL)(e), r = Yd[l];
    if (r)
      return r;
    const { code: a, detectError: i } = QL(e, t), s = new Function(`return ${a}`)();
    return i ? s : Yd[l] = s;
  }
};
function oee(e, t) {
  if (process.env.NODE_ENV !== "production" && (t.onWarn = ZL), __INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && Bt(e)) {
    const n = Dn(t.warnHtmlMessage) ? t.warnHtmlMessage : !0;
    process.env.NODE_ENV !== "production" && qL(e, n);
    const l = (t.onCacheKey || JL)(e), r = Yd[l];
    if (r)
      return r;
    const { ast: a, detectError: i } = QL(e, vt(Be({}, t), {
      location: process.env.NODE_ENV !== "production",
      jit: !0
    })), s = _C(a);
    return i ? s : Yd[l] = s;
  } else {
    if (process.env.NODE_ENV !== "production" && !ta(e))
      return ol(`the message that is resolve with key '${t.key}' is not supported for jit compilation`), () => e;
    const n = e.cacheKey;
    if (n) {
      const o = Yd[n];
      return o || (Yd[n] = _C(e));
    } else
      return _C(e);
  }
}
const d4 = () => "", Xr = (e) => co(e);
function f4(e, ...t) {
  const { fallbackFormat: n, postTranslation: o, unresolving: l, messageCompiler: r, fallbackLocale: a, messages: i } = e, [s, c] = V$(...t), u = Dn(c.missingWarn) ? c.missingWarn : e.missingWarn, d = Dn(c.fallbackWarn) ? c.fallbackWarn : e.fallbackWarn, f = Dn(c.escapeParameter) ? c.escapeParameter : e.escapeParameter, p = !!c.resolvedMessage, m = Bt(c.default) || Dn(c.default) ? Dn(c.default) ? r ? s : () => s : c.default : n ? r ? s : () => s : "", v = n || m !== "", h = rO(e, c);
  f && lee(c);
  let [g, y, b] = p ? [
    s,
    h,
    i[h] || fo()
  ] : eB(e, s, h, a, d, u), C = g, w = s;
  if (!p && !(Bt(C) || ta(C) || Xr(C)) && v && (C = m, w = C), !p && (!(Bt(C) || ta(C) || Xr(C)) || !Bt(y)))
    return l ? h1 : s;
  if (process.env.NODE_ENV !== "production" && Bt(C) && e.messageCompiler == null)
    return ol(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${s}'.`), s;
  let x = !1;
  const E = () => {
    x = !0;
  }, I = Xr(C) ? C : tB(e, s, y, C, w, E);
  if (x)
    return C;
  const T = see(e, y, b, c), P = RQ(T), k = ree(e, I, P), N = o ? o(k, s) : k;
  if (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
    const R = {
      timestamp: Date.now(),
      key: Bt(s) ? s : Xr(C) ? C.key : "",
      locale: y || (Xr(C) ? C.locale : ""),
      format: Bt(C) ? C : Xr(C) ? C.source : "",
      message: N
    };
    R.meta = Sl({}, e.__meta, /* @__PURE__ */ qQ() || {}), BQ(R);
  }
  return N;
}
function lee(e) {
  yo(e.list) ? e.list = e.list.map((t) => Bt(t) ? Xk(t) : t) : Kn(e.named) && Object.keys(e.named).forEach((t) => {
    Bt(e.named[t]) && (e.named[t] = Xk(e.named[t]));
  });
}
function eB(e, t, n, o, l, r) {
  const { messages: a, onWarn: i, messageResolver: s, localeFallbacker: c } = e, u = c(e, o, n);
  let d = fo(), f, p = null, m = n, v = null;
  const h = "translate";
  for (let g = 0; g < u.length; g++) {
    if (f = v = u[g], process.env.NODE_ENV !== "production" && n !== f && !XL(n, f) && g1(l, t) && i(Vu(ql.FALLBACK_TO_TRANSLATE, {
      key: t,
      target: f
    })), process.env.NODE_ENV !== "production" && n !== f) {
      const w = e.__v_emitter;
      w && w.emit("fallback", {
        type: h,
        key: t,
        from: m,
        to: v,
        groupId: `${h}:${t}`
      });
    }
    d = a[f] || fo();
    let y = null, b, C;
    if (process.env.NODE_ENV !== "production" && Ra && (y = window.performance.now(), b = "intlify-message-resolve-start", C = "intlify-message-resolve-end", Pr && Pr(b)), (p = s(d, t)) === null && (p = d[t]), process.env.NODE_ENV !== "production" && Ra) {
      const w = window.performance.now(), x = e.__v_emitter;
      x && y && p && x.emit("message-resolve", {
        type: "message-resolve",
        key: t,
        message: p,
        time: w - y,
        groupId: `${h}:${t}`
      }), b && C && Pr && Fu && (Pr(C), Fu("intlify message resolve", b, C));
    }
    if (Bt(p) || ta(p) || Xr(p))
      break;
    if (!QQ(f, u)) {
      const w = aO(
        e,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        t,
        f,
        r,
        h
      );
      w !== t && (p = w);
    }
    m = v;
  }
  return [p, f, d];
}
function tB(e, t, n, o, l, r) {
  const { messageCompiler: a, warnHtmlMessage: i } = e;
  if (Xr(o)) {
    const f = o;
    return f.locale = f.locale || n, f.key = f.key || t, f;
  }
  if (a == null) {
    const f = () => o;
    return f.locale = n, f.key = t, f;
  }
  let s = null, c, u;
  process.env.NODE_ENV !== "production" && Ra && (s = window.performance.now(), c = "intlify-message-compilation-start", u = "intlify-message-compilation-end", Pr && Pr(c));
  const d = a(o, aee(e, n, l, o, i, r));
  if (process.env.NODE_ENV !== "production" && Ra) {
    const f = window.performance.now(), p = e.__v_emitter;
    p && s && p.emit("message-compilation", {
      type: "message-compilation",
      message: o,
      time: f - s,
      groupId: `translate:${t}`
    }), c && u && Pr && Fu && (Pr(u), Fu("intlify message compilation", c, u));
  }
  return d.locale = n, d.key = t, d.source = o, d;
}
function ree(e, t, n) {
  let o = null, l, r;
  process.env.NODE_ENV !== "production" && Ra && (o = window.performance.now(), l = "intlify-message-evaluation-start", r = "intlify-message-evaluation-end", Pr && Pr(l));
  const a = t(n);
  if (process.env.NODE_ENV !== "production" && Ra) {
    const i = window.performance.now(), s = e.__v_emitter;
    s && o && s.emit("message-evaluation", {
      type: "message-evaluation",
      value: a,
      time: i - o,
      groupId: `translate:${t.key}`
    }), l && r && Pr && Fu && (Pr(r), Fu("intlify message evaluation", l, r));
  }
  return a;
}
function V$(...e) {
  const [t, n, o] = e, l = fo();
  if (!Bt(t) && !jo(t) && !Xr(t) && !ta(t))
    throw ui(fl.INVALID_ARGUMENT);
  const r = jo(t) ? String(t) : (Xr(t), t);
  return jo(n) ? l.plural = n : Bt(n) ? l.default = n : En(n) && !p1(n) ? l.named = n : yo(n) && (l.list = n), jo(o) ? l.plural = o : Bt(o) ? l.default = o : En(o) && Sl(l, o), [r, l];
}
function aee(e, t, n, o, l, r) {
  return {
    locale: t,
    key: n,
    warnHtmlMessage: l,
    onError: (a) => {
      if (r && r(a), process.env.NODE_ENV !== "production") {
        const i = iee(o), s = `Message compilation error: ${a.message}`, c = a.location && i && AZ(i, a.location.start.offset, a.location.end.offset), u = e.__v_emitter;
        u && i && u.emit("compile-error", {
          message: i,
          error: a.message,
          start: a.location && a.location.start.offset,
          end: a.location && a.location.end.offset,
          groupId: `translate:${n}`
        }), console.error(c ? `${s}
${c}` : s);
      } else
        throw a;
    },
    onCacheKey: (a) => OZ(t, n, a)
  };
}
function iee(e) {
  if (Bt(e))
    return e;
  if (e.loc && e.loc.source)
    return e.loc.source;
}
function see(e, t, n, o) {
  const { modifiers: l, pluralRules: r, messageResolver: a, fallbackLocale: i, fallbackWarn: s, missingWarn: c, fallbackContext: u } = e, f = {
    locale: t,
    modifiers: l,
    pluralRules: r,
    messages: (p) => {
      let m = a(n, p);
      if (m == null && u) {
        const [, , v] = eB(u, p, t, i, s, c);
        m = a(v, p);
      }
      if (Bt(m) || ta(m)) {
        let v = !1;
        const g = tB(e, p, t, m, p, () => {
          v = !0;
        });
        return v ? d4 : g;
      } else return Xr(m) ? m : d4;
    }
  };
  return e.processor && (f.processor = e.processor), o.list && (f.list = o.list), o.named && (f.named = o.named), jo(o.plural) && (f.pluralIndex = o.plural), f;
}
const p4 = typeof Intl != "undefined", nB = {
  dateTimeFormat: p4 && typeof Intl.DateTimeFormat != "undefined",
  numberFormat: p4 && typeof Intl.NumberFormat != "undefined"
};
function v4(e, ...t) {
  const { datetimeFormats: n, unresolving: o, fallbackLocale: l, onWarn: r, localeFallbacker: a } = e, { __datetimeFormatters: i } = e;
  if (process.env.NODE_ENV !== "production" && !nB.dateTimeFormat)
    return r(Vu(ql.CANNOT_FORMAT_DATE)), O0;
  const [s, c, u, d] = z$(...t), f = Dn(u.missingWarn) ? u.missingWarn : e.missingWarn, p = Dn(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn, m = !!u.part, v = rO(e, u), h = a(
    e,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    l,
    v
  );
  if (!Bt(s) || s === "")
    return new Intl.DateTimeFormat(v, d).format(c);
  let g = {}, y, b = null, C = v, w = null;
  const x = "datetime format";
  for (let T = 0; T < h.length; T++) {
    if (y = w = h[T], process.env.NODE_ENV !== "production" && v !== y && g1(p, s) && r(Vu(ql.FALLBACK_TO_DATE_FORMAT, {
      key: s,
      target: y
    })), process.env.NODE_ENV !== "production" && v !== y) {
      const P = e.__v_emitter;
      P && P.emit("fallback", {
        type: x,
        key: s,
        from: C,
        to: w,
        groupId: `${x}:${s}`
      });
    }
    if (g = n[y] || {}, b = g[s], En(b))
      break;
    aO(e, s, y, f, x), C = w;
  }
  if (!En(b) || !Bt(y))
    return o ? h1 : s;
  let E = `${y}__${s}`;
  p1(d) || (E = `${E}__${JSON.stringify(d)}`);
  let I = i.get(E);
  return I || (I = new Intl.DateTimeFormat(y, Sl({}, b, d)), i.set(E, I)), m ? I.formatToParts(c) : I.format(c);
}
const oB = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function z$(...e) {
  const [t, n, o, l] = e, r = fo();
  let a = fo(), i;
  if (Bt(t)) {
    const s = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!s)
      throw ui(fl.INVALID_ISO_DATE_ARGUMENT);
    const c = s[3] ? s[3].trim().startsWith("T") ? `${s[1].trim()}${s[3].trim()}` : `${s[1].trim()}T${s[3].trim()}` : s[1].trim();
    i = new Date(c);
    try {
      i.toISOString();
    } catch (u) {
      throw ui(fl.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (IZ(t)) {
    if (isNaN(t.getTime()))
      throw ui(fl.INVALID_DATE_ARGUMENT);
    i = t;
  } else if (jo(t))
    i = t;
  else
    throw ui(fl.INVALID_ARGUMENT);
  return Bt(n) ? r.key = n : En(n) && Object.keys(n).forEach((s) => {
    oB.includes(s) ? a[s] = n[s] : r[s] = n[s];
  }), Bt(o) ? r.locale = o : En(o) && (a = o), En(l) && (a = l), [r.key || "", i, r, a];
}
function m4(e, t, n) {
  const o = e;
  for (const l in n) {
    const r = `${t}__${l}`;
    o.__datetimeFormatters.has(r) && o.__datetimeFormatters.delete(r);
  }
}
function h4(e, ...t) {
  const { numberFormats: n, unresolving: o, fallbackLocale: l, onWarn: r, localeFallbacker: a } = e, { __numberFormatters: i } = e;
  if (process.env.NODE_ENV !== "production" && !nB.numberFormat)
    return r(Vu(ql.CANNOT_FORMAT_NUMBER)), O0;
  const [s, c, u, d] = H$(...t), f = Dn(u.missingWarn) ? u.missingWarn : e.missingWarn, p = Dn(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn, m = !!u.part, v = rO(e, u), h = a(
    e,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    l,
    v
  );
  if (!Bt(s) || s === "")
    return new Intl.NumberFormat(v, d).format(c);
  let g = {}, y, b = null, C = v, w = null;
  const x = "number format";
  for (let T = 0; T < h.length; T++) {
    if (y = w = h[T], process.env.NODE_ENV !== "production" && v !== y && g1(p, s) && r(Vu(ql.FALLBACK_TO_NUMBER_FORMAT, {
      key: s,
      target: y
    })), process.env.NODE_ENV !== "production" && v !== y) {
      const P = e.__v_emitter;
      P && P.emit("fallback", {
        type: x,
        key: s,
        from: C,
        to: w,
        groupId: `${x}:${s}`
      });
    }
    if (g = n[y] || {}, b = g[s], En(b))
      break;
    aO(e, s, y, f, x), C = w;
  }
  if (!En(b) || !Bt(y))
    return o ? h1 : s;
  let E = `${y}__${s}`;
  p1(d) || (E = `${E}__${JSON.stringify(d)}`);
  let I = i.get(E);
  return I || (I = new Intl.NumberFormat(y, Sl({}, b, d)), i.set(E, I)), m ? I.formatToParts(c) : I.format(c);
}
const lB = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function H$(...e) {
  const [t, n, o, l] = e, r = fo();
  let a = fo();
  if (!jo(t))
    throw ui(fl.INVALID_ARGUMENT);
  const i = t;
  return Bt(n) ? r.key = n : En(n) && Object.keys(n).forEach((s) => {
    lB.includes(s) ? a[s] = n[s] : r[s] = n[s];
  }), Bt(o) ? r.locale = o : En(o) && (a = o), En(l) && (a = l), [r.key || "", i, r, a];
}
function g4(e, t, n) {
  const o = e;
  for (const l in n) {
    const r = `${t}__${l}`;
    o.__numberFormatters.has(r) && o.__numberFormatters.delete(r);
  }
}
pQ();
/*!
  * vue-i18n v9.14.4
  * (c) 2025 kazuya kawaguchi
  * Released under the MIT License.
  */
const cee = "9.14.4";
function uee() {
  typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (es().__VUE_I18N_FULL_INSTALL__ = !0), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (es().__VUE_I18N_LEGACY_API__ = !0), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (es().__INTLIFY_JIT_COMPILATION__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (es().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (es().__INTLIFY_PROD_DEVTOOLS__ = !1);
}
const rB = ql.__EXTEND_POINT__, Vi = v1(rB), Eo = {
  FALLBACK_TO_ROOT: rB,
  // 9
  NOT_SUPPORTED_PRESERVE: Vi(),
  // 10
  NOT_SUPPORTED_FORMATTER: Vi(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: Vi(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: Vi(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: Vi(),
  // 14
  NOT_FOUND_PARENT_SCOPE: Vi(),
  // 15
  IGNORE_OBJ_FLATTEN: Vi(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: Vi(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: Vi()
  // 18
}, dee = {
  [Eo.FALLBACK_TO_ROOT]: "Fall back to {type} '{key}' with root locale.",
  [Eo.NOT_SUPPORTED_PRESERVE]: "Not supported 'preserve'.",
  [Eo.NOT_SUPPORTED_FORMATTER]: "Not supported 'formatter'.",
  [Eo.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: "Not supported 'preserveDirectiveContent'.",
  [Eo.NOT_SUPPORTED_GET_CHOICE_INDEX]: "Not supported 'getChoiceIndex'.",
  [Eo.COMPONENT_NAME_LEGACY_COMPATIBLE]: "Component name legacy compatible: '{name}' -> 'i18n'",
  [Eo.NOT_FOUND_PARENT_SCOPE]: "Not found parent scope. use the global scope.",
  [Eo.IGNORE_OBJ_FLATTEN]: "Ignore object flatten: '{key}' key has an string value",
  [Eo.NOTICE_DROP_ALLOW_COMPOSITION]: "'allowComposition' option will be dropped in the next major version. For more information, please see  https://tinyurl.com/2p97mcze",
  [Eo.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG]: "'translateExistCompatible' option will be dropped in the next major version."
};
function mr(e, ...t) {
  return tO(dee[e], ...t);
}
const aB = fl.__EXTEND_POINT__, cr = v1(aB), Un = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: aB,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: cr(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: cr(),
  // 26
  NOT_INSTALLED: cr(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: cr(),
  // 28
  // directive module errors
  REQUIRED_VALUE: cr(),
  // 29
  INVALID_VALUE: cr(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: cr(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: cr(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: cr(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: cr(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: cr(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: cr(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: cr(),
  // 37
  // for enhancement
  __EXTEND_POINT__: cr()
  // 38
};
function rl(e, ...t) {
  return hp(e, null, process.env.NODE_ENV !== "production" ? { messages: fee, args: t } : void 0);
}
const fee = {
  [Un.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [Un.INVALID_ARGUMENT]: "Invalid argument",
  [Un.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [Un.NOT_INSTALLED]: "Need to install with `app.use` function",
  [Un.UNEXPECTED_ERROR]: "Unexpected error",
  [Un.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
  [Un.REQUIRED_VALUE]: "Required in value: {0}",
  [Un.INVALID_VALUE]: "Invalid value",
  [Un.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: "Cannot setup vue-devtools plugin",
  [Un.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [Un.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [Un.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
  [Un.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define i18n option or custom block in Composition API with using local scope in Legacy API mode",
  [Un.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
}, j$ = /* @__PURE__ */ Pi("__translateVNode"), W$ = /* @__PURE__ */ Pi("__datetimeParts"), K$ = /* @__PURE__ */ Pi("__numberParts"), zu = /* @__PURE__ */ Pi("__enableEmitter"), nm = /* @__PURE__ */ Pi("__disableEmitter"), iB = Pi("__setPluralRules"), sB = /* @__PURE__ */ Pi("__injectWithOption"), U$ = /* @__PURE__ */ Pi("__dispose");
function om(e) {
  if (!Kn(e) || ta(e))
    return e;
  for (const t in e)
    if (Sa(e, t))
      if (!t.includes("."))
        Kn(e[t]) && om(e[t]);
      else {
        const n = t.split("."), o = n.length - 1;
        let l = e, r = !1;
        for (let a = 0; a < o; a++) {
          if (n[a] === "__proto__")
            throw new Error(`unsafe key: ${n[a]}`);
          if (n[a] in l || (l[n[a]] = fo()), !Kn(l[n[a]])) {
            process.env.NODE_ENV !== "production" && ol(mr(Eo.IGNORE_OBJ_FLATTEN, {
              key: n[a]
            })), r = !0;
            break;
          }
          l = l[n[a]];
        }
        if (r || (ta(l) ? FL.includes(n[o]) || delete e[t] : (l[n[o]] = e[t], delete e[t])), !ta(l)) {
          const a = l[n[o]];
          Kn(a) && om(a);
        }
      }
  return e;
}
function b1(e, t) {
  const { messages: n, __i18n: o, messageResolver: l, flatJson: r } = t, a = En(n) ? n : yo(o) ? fo() : { [e]: fo() };
  if (yo(o) && o.forEach((i) => {
    if ("locale" in i && "resource" in i) {
      const { locale: s, resource: c } = i;
      s ? (a[s] = a[s] || fo(), sb(c, a[s])) : sb(c, a);
    } else
      Bt(i) && sb(JSON.parse(i), a);
  }), l == null && r)
    for (const i in a)
      Sa(a, i) && om(a[i]);
  return a;
}
function cB(e) {
  return e.type;
}
function uB(e, t, n) {
  let o = Kn(t.messages) ? t.messages : fo();
  "__i18nGlobal" in n && (o = b1(e.locale.value, {
    messages: o,
    __i18n: n.__i18nGlobal
  }));
  const l = Object.keys(o);
  l.length && l.forEach((r) => {
    e.mergeLocaleMessage(r, o[r]);
  });
  {
    if (Kn(t.datetimeFormats)) {
      const r = Object.keys(t.datetimeFormats);
      r.length && r.forEach((a) => {
        e.mergeDateTimeFormat(a, t.datetimeFormats[a]);
      });
    }
    if (Kn(t.numberFormats)) {
      const r = Object.keys(t.numberFormats);
      r.length && r.forEach((a) => {
        e.mergeNumberFormat(a, t.numberFormats[a]);
      });
    }
  }
}
function b4(e) {
  return $(Vr, null, e, 0);
}
const y4 = "__INTLIFY_META__", S4 = () => [], pee = () => !1;
let C4 = 0;
function w4(e) {
  return (t, n, o, l) => e(n, o, xt() || void 0, l);
}
const vee = /* @__NO_SIDE_EFFECTS__ */ () => {
  const e = xt();
  let t = null;
  return e && (t = cB(e)[y4]) ? { [y4]: t } : null;
};
function iO(e = {}, t) {
  const { __root: n, __injectWithOption: o } = e, l = n === void 0, r = e.flatJson, a = Ra ? H : Ce, i = !!e.translateExistCompatible;
  process.env.NODE_ENV !== "production" && i && _L(mr(Eo.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG));
  let s = Dn(e.inheritLocale) ? e.inheritLocale : !0;
  const c = a(
    // prettier-ignore
    n && s ? n.locale.value : Bt(e.locale) ? e.locale : Lf
  ), u = a(
    // prettier-ignore
    n && s ? n.fallbackLocale.value : Bt(e.fallbackLocale) || yo(e.fallbackLocale) || En(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : c.value
  ), d = a(b1(c.value, e)), f = a(En(e.datetimeFormats) ? e.datetimeFormats : { [c.value]: {} }), p = a(En(e.numberFormats) ? e.numberFormats : { [c.value]: {} });
  let m = n ? n.missingWarn : Dn(e.missingWarn) || gc(e.missingWarn) ? e.missingWarn : !0, v = n ? n.fallbackWarn : Dn(e.fallbackWarn) || gc(e.fallbackWarn) ? e.fallbackWarn : !0, h = n ? n.fallbackRoot : Dn(e.fallbackRoot) ? e.fallbackRoot : !0, g = !!e.fallbackFormat, y = co(e.missing) ? e.missing : null, b = co(e.missing) ? w4(e.missing) : null, C = co(e.postTranslation) ? e.postTranslation : null, w = n ? n.warnHtmlMessage : Dn(e.warnHtmlMessage) ? e.warnHtmlMessage : !0, x = !!e.escapeParameter;
  const E = n ? n.modifiers : En(e.modifiers) ? e.modifiers : {};
  let I = e.pluralRules || n && n.pluralRules, T;
  T = (() => {
    l && s4(null);
    const ie = {
      version: cee,
      locale: c.value,
      fallbackLocale: u.value,
      messages: d.value,
      modifiers: E,
      pluralRules: I,
      missing: b === null ? void 0 : b,
      missingWarn: m,
      fallbackWarn: v,
      fallbackFormat: g,
      unresolving: !0,
      postTranslation: C === null ? void 0 : C,
      warnHtmlMessage: w,
      escapeParameter: x,
      messageResolver: e.messageResolver,
      messageCompiler: e.messageCompiler,
      __meta: { framework: "vue" }
    };
    ie.datetimeFormats = f.value, ie.numberFormats = p.value, ie.__datetimeFormatters = En(T) ? T.__datetimeFormatters : void 0, ie.__numberFormatters = En(T) ? T.__numberFormatters : void 0, process.env.NODE_ENV !== "production" && (ie.__v_emitter = En(T) ? T.__v_emitter : void 0);
    const we = ZQ(ie);
    return l && s4(we), we;
  })(), qp(T, c.value, u.value);
  function k() {
    return [
      c.value,
      u.value,
      d.value,
      f.value,
      p.value
    ];
  }
  const N = O({
    get: () => c.value,
    set: (ie) => {
      c.value = ie, T.locale = c.value;
    }
  }), R = O({
    get: () => u.value,
    set: (ie) => {
      u.value = ie, T.fallbackLocale = u.value, qp(T, c.value, ie);
    }
  }), z = O(() => d.value), D = /* @__PURE__ */ O(() => f.value), F = /* @__PURE__ */ O(() => p.value);
  function M() {
    return co(C) ? C : null;
  }
  function A(ie) {
    C = ie, T.postTranslation = ie;
  }
  function L() {
    return y;
  }
  function B(ie) {
    ie !== null && (b = w4(ie)), y = ie, T.missing = b;
  }
  function V(ie, we) {
    return ie !== "translate" || !we.resolvedMessage;
  }
  const j = (ie, we, Ne, tt, Pe, Re) => {
    k();
    let Le;
    try {
      process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, l || (T.fallbackContext = n ? JQ() : void 0), Le = ie(T);
    } finally {
      process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__, l || (T.fallbackContext = void 0);
    }
    if (Ne !== "translate exists" && // for not `te` (e.g `t`)
    jo(Le) && Le === h1 || Ne === "translate exists" && !Le) {
      const [Ue, Ae] = we();
      if (process.env.NODE_ENV !== "production" && n && Bt(Ue) && V(Ne, Ae) && (h && (g1(v, Ue) || YL(m, Ue)) && ol(mr(Eo.FALLBACK_TO_ROOT, {
        key: Ue,
        type: Ne
      })), process.env.NODE_ENV !== "production")) {
        const { __v_emitter: De } = T;
        De && h && De.emit("fallback", {
          type: Ne,
          key: Ue,
          to: "global",
          groupId: `${Ne}:${Ue}`
        });
      }
      return n && h ? tt(n) : Pe(Ue);
    } else {
      if (Re(Le))
        return Le;
      throw rl(Un.UNEXPECTED_RETURN_TYPE);
    }
  };
  function W(...ie) {
    return j((we) => Reflect.apply(f4, null, [we, ...ie]), () => V$(...ie), "translate", (we) => Reflect.apply(we.t, we, [...ie]), (we) => we, (we) => Bt(we));
  }
  function Y(...ie) {
    const [we, Ne, tt] = ie;
    if (tt && !Kn(tt))
      throw rl(Un.INVALID_ARGUMENT);
    return W(we, Ne, Sl({ resolvedMessage: !0 }, tt || {}));
  }
  function U(...ie) {
    return j((we) => Reflect.apply(v4, null, [we, ...ie]), () => z$(...ie), "datetime format", (we) => Reflect.apply(we.d, we, [...ie]), () => O0, (we) => Bt(we));
  }
  function te(...ie) {
    return j((we) => Reflect.apply(h4, null, [we, ...ie]), () => H$(...ie), "number format", (we) => Reflect.apply(we.n, we, [...ie]), () => O0, (we) => Bt(we));
  }
  function J(ie) {
    return ie.map((we) => Bt(we) || jo(we) || Dn(we) ? b4(String(we)) : we);
  }
  const oe = {
    normalize: J,
    interpolate: (ie) => ie,
    type: "vnode"
  };
  function q(...ie) {
    return j(
      (we) => {
        let Ne;
        const tt = we;
        try {
          tt.processor = oe, Ne = Reflect.apply(f4, null, [tt, ...ie]);
        } finally {
          tt.processor = null;
        }
        return Ne;
      },
      () => V$(...ie),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (we) => we[j$](...ie),
      (we) => [b4(we)],
      (we) => yo(we)
    );
  }
  function K(...ie) {
    return j(
      (we) => Reflect.apply(h4, null, [we, ...ie]),
      () => H$(...ie),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (we) => we[K$](...ie),
      S4,
      (we) => Bt(we) || yo(we)
    );
  }
  function se(...ie) {
    return j(
      (we) => Reflect.apply(v4, null, [we, ...ie]),
      () => z$(...ie),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (we) => we[W$](...ie),
      S4,
      (we) => Bt(we) || yo(we)
    );
  }
  function Z(ie) {
    I = ie, T.pluralRules = I;
  }
  function ee(ie, we) {
    return j(() => {
      if (!ie)
        return !1;
      const Ne = Bt(we) ? we : c.value, tt = ge(Ne), Pe = T.messageResolver(tt, ie);
      return i ? Pe != null : ta(Pe) || Xr(Pe) || Bt(Pe);
    }, () => [ie], "translate exists", (Ne) => Reflect.apply(Ne.te, Ne, [ie, we]), pee, (Ne) => Dn(Ne));
  }
  function fe(ie) {
    let we = null;
    const Ne = HL(T, u.value, c.value);
    for (let tt = 0; tt < Ne.length; tt++) {
      const Pe = d.value[Ne[tt]] || {}, Re = T.messageResolver(Pe, ie);
      if (Re != null) {
        we = Re;
        break;
      }
    }
    return we;
  }
  function me(ie) {
    const we = fe(ie);
    return we != null ? we : n ? n.tm(ie) || {} : {};
  }
  function ge(ie) {
    return d.value[ie] || {};
  }
  function he(ie, we) {
    if (r) {
      const Ne = { [ie]: we };
      for (const tt in Ne)
        Sa(Ne, tt) && om(Ne[tt]);
      we = Ne[ie];
    }
    d.value[ie] = we, T.messages = d.value;
  }
  function $e(ie, we) {
    d.value[ie] = d.value[ie] || {};
    const Ne = { [ie]: we };
    if (r)
      for (const tt in Ne)
        Sa(Ne, tt) && om(Ne[tt]);
    we = Ne[ie], sb(we, d.value[ie]), T.messages = d.value;
  }
  function ne(ie) {
    return f.value[ie] || {};
  }
  function ae(ie, we) {
    f.value[ie] = we, T.datetimeFormats = f.value, m4(T, ie, we);
  }
  function ce(ie, we) {
    f.value[ie] = Sl(f.value[ie] || {}, we), T.datetimeFormats = f.value, m4(T, ie, we);
  }
  function xe(ie) {
    return p.value[ie] || {};
  }
  function Te(ie, we) {
    p.value[ie] = we, T.numberFormats = p.value, g4(T, ie, we);
  }
  function Se(ie, we) {
    p.value[ie] = Sl(p.value[ie] || {}, we), T.numberFormats = p.value, g4(T, ie, we);
  }
  C4++, n && Ra && (pe(n.locale, (ie) => {
    s && (c.value = ie, T.locale = ie, qp(T, c.value, u.value));
  }), pe(n.fallbackLocale, (ie) => {
    s && (u.value = ie, T.fallbackLocale = ie, qp(T, c.value, u.value));
  }));
  const be = {
    id: C4,
    locale: N,
    fallbackLocale: R,
    get inheritLocale() {
      return s;
    },
    set inheritLocale(ie) {
      s = ie, ie && n && (c.value = n.locale.value, u.value = n.fallbackLocale.value, qp(T, c.value, u.value));
    },
    get availableLocales() {
      return Object.keys(d.value).sort();
    },
    messages: z,
    get modifiers() {
      return E;
    },
    get pluralRules() {
      return I || {};
    },
    get isGlobal() {
      return l;
    },
    get missingWarn() {
      return m;
    },
    set missingWarn(ie) {
      m = ie, T.missingWarn = m;
    },
    get fallbackWarn() {
      return v;
    },
    set fallbackWarn(ie) {
      v = ie, T.fallbackWarn = v;
    },
    get fallbackRoot() {
      return h;
    },
    set fallbackRoot(ie) {
      h = ie;
    },
    get fallbackFormat() {
      return g;
    },
    set fallbackFormat(ie) {
      g = ie, T.fallbackFormat = g;
    },
    get warnHtmlMessage() {
      return w;
    },
    set warnHtmlMessage(ie) {
      w = ie, T.warnHtmlMessage = ie;
    },
    get escapeParameter() {
      return x;
    },
    set escapeParameter(ie) {
      x = ie, T.escapeParameter = ie;
    },
    t: W,
    getLocaleMessage: ge,
    setLocaleMessage: he,
    mergeLocaleMessage: $e,
    getPostTranslationHandler: M,
    setPostTranslationHandler: A,
    getMissingHandler: L,
    setMissingHandler: B,
    [iB]: Z
  };
  return be.datetimeFormats = D, be.numberFormats = F, be.rt = Y, be.te = ee, be.tm = me, be.d = U, be.n = te, be.getDateTimeFormat = ne, be.setDateTimeFormat = ae, be.mergeDateTimeFormat = ce, be.getNumberFormat = xe, be.setNumberFormat = Te, be.mergeNumberFormat = Se, be[sB] = o, be[j$] = q, be[W$] = se, be[K$] = K, process.env.NODE_ENV !== "production" && (be[zu] = (ie) => {
    T.__v_emitter = ie;
  }, be[nm] = () => {
    T.__v_emitter = void 0;
  }), be;
}
function mee(e) {
  const t = Bt(e.locale) ? e.locale : Lf, n = Bt(e.fallbackLocale) || yo(e.fallbackLocale) || En(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : t, o = co(e.missing) ? e.missing : void 0, l = Dn(e.silentTranslationWarn) || gc(e.silentTranslationWarn) ? !e.silentTranslationWarn : !0, r = Dn(e.silentFallbackWarn) || gc(e.silentFallbackWarn) ? !e.silentFallbackWarn : !0, a = Dn(e.fallbackRoot) ? e.fallbackRoot : !0, i = !!e.formatFallbackMessages, s = En(e.modifiers) ? e.modifiers : {}, c = e.pluralizationRules, u = co(e.postTranslation) ? e.postTranslation : void 0, d = Bt(e.warnHtmlInMessage) ? e.warnHtmlInMessage !== "off" : !0, f = !!e.escapeParameterHtml, p = Dn(e.sync) ? e.sync : !0;
  process.env.NODE_ENV !== "production" && e.formatter && ol(mr(Eo.NOT_SUPPORTED_FORMATTER)), process.env.NODE_ENV !== "production" && e.preserveDirectiveContent && ol(mr(Eo.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
  let m = e.messages;
  if (En(e.sharedMessages)) {
    const x = e.sharedMessages;
    m = Object.keys(x).reduce((I, T) => {
      const P = I[T] || (I[T] = {});
      return Sl(P, x[T]), I;
    }, m || {});
  }
  const { __i18n: v, __root: h, __injectWithOption: g } = e, y = e.datetimeFormats, b = e.numberFormats, C = e.flatJson, w = e.translateExistCompatible;
  return {
    locale: t,
    fallbackLocale: n,
    messages: m,
    flatJson: C,
    datetimeFormats: y,
    numberFormats: b,
    missing: o,
    missingWarn: l,
    fallbackWarn: r,
    fallbackRoot: a,
    fallbackFormat: i,
    modifiers: s,
    pluralRules: c,
    postTranslation: u,
    warnHtmlMessage: d,
    escapeParameter: f,
    messageResolver: e.messageResolver,
    inheritLocale: p,
    translateExistCompatible: w,
    __i18n: v,
    __root: h,
    __injectWithOption: g
  };
}
function G$(e = {}, t) {
  {
    const n = iO(mee(e)), { __extender: o } = e, l = {
      // id
      id: n.id,
      // locale
      get locale() {
        return n.locale.value;
      },
      set locale(r) {
        n.locale.value = r;
      },
      // fallbackLocale
      get fallbackLocale() {
        return n.fallbackLocale.value;
      },
      set fallbackLocale(r) {
        n.fallbackLocale.value = r;
      },
      // messages
      get messages() {
        return n.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return n.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return n.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return n.availableLocales;
      },
      // formatter
      get formatter() {
        return process.env.NODE_ENV !== "production" && ol(mr(Eo.NOT_SUPPORTED_FORMATTER)), {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(r) {
        process.env.NODE_ENV !== "production" && ol(mr(Eo.NOT_SUPPORTED_FORMATTER));
      },
      // missing
      get missing() {
        return n.getMissingHandler();
      },
      set missing(r) {
        n.setMissingHandler(r);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return Dn(n.missingWarn) ? !n.missingWarn : n.missingWarn;
      },
      set silentTranslationWarn(r) {
        n.missingWarn = Dn(r) ? !r : r;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return Dn(n.fallbackWarn) ? !n.fallbackWarn : n.fallbackWarn;
      },
      set silentFallbackWarn(r) {
        n.fallbackWarn = Dn(r) ? !r : r;
      },
      // modifiers
      get modifiers() {
        return n.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return n.fallbackFormat;
      },
      set formatFallbackMessages(r) {
        n.fallbackFormat = r;
      },
      // postTranslation
      get postTranslation() {
        return n.getPostTranslationHandler();
      },
      set postTranslation(r) {
        n.setPostTranslationHandler(r);
      },
      // sync
      get sync() {
        return n.inheritLocale;
      },
      set sync(r) {
        n.inheritLocale = r;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return n.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(r) {
        n.warnHtmlMessage = r !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return n.escapeParameter;
      },
      set escapeParameterHtml(r) {
        n.escapeParameter = r;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        return process.env.NODE_ENV !== "production" && ol(mr(Eo.NOT_SUPPORTED_PRESERVE_DIRECTIVE)), !0;
      },
      set preserveDirectiveContent(r) {
        process.env.NODE_ENV !== "production" && ol(mr(Eo.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
      },
      // pluralizationRules
      get pluralizationRules() {
        return n.pluralRules || {};
      },
      // for internal
      __composer: n,
      // t
      t(...r) {
        const [a, i, s] = r, c = {};
        let u = null, d = null;
        if (!Bt(a))
          throw rl(Un.INVALID_ARGUMENT);
        const f = a;
        return Bt(i) ? c.locale = i : yo(i) ? u = i : En(i) && (d = i), yo(s) ? u = s : En(s) && (d = s), Reflect.apply(n.t, n, [
          f,
          u || d || {},
          c
        ]);
      },
      rt(...r) {
        return Reflect.apply(n.rt, n, [...r]);
      },
      // tc
      tc(...r) {
        const [a, i, s] = r, c = { plural: 1 };
        let u = null, d = null;
        if (!Bt(a))
          throw rl(Un.INVALID_ARGUMENT);
        const f = a;
        return Bt(i) ? c.locale = i : jo(i) ? c.plural = i : yo(i) ? u = i : En(i) && (d = i), Bt(s) ? c.locale = s : yo(s) ? u = s : En(s) && (d = s), Reflect.apply(n.t, n, [
          f,
          u || d || {},
          c
        ]);
      },
      // te
      te(r, a) {
        return n.te(r, a);
      },
      // tm
      tm(r) {
        return n.tm(r);
      },
      // getLocaleMessage
      getLocaleMessage(r) {
        return n.getLocaleMessage(r);
      },
      // setLocaleMessage
      setLocaleMessage(r, a) {
        n.setLocaleMessage(r, a);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(r, a) {
        n.mergeLocaleMessage(r, a);
      },
      // d
      d(...r) {
        return Reflect.apply(n.d, n, [...r]);
      },
      // getDateTimeFormat
      getDateTimeFormat(r) {
        return n.getDateTimeFormat(r);
      },
      // setDateTimeFormat
      setDateTimeFormat(r, a) {
        n.setDateTimeFormat(r, a);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(r, a) {
        n.mergeDateTimeFormat(r, a);
      },
      // n
      n(...r) {
        return Reflect.apply(n.n, n, [...r]);
      },
      // getNumberFormat
      getNumberFormat(r) {
        return n.getNumberFormat(r);
      },
      // setNumberFormat
      setNumberFormat(r, a) {
        n.setNumberFormat(r, a);
      },
      // mergeNumberFormat
      mergeNumberFormat(r, a) {
        n.mergeNumberFormat(r, a);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(r, a) {
        return process.env.NODE_ENV !== "production" && ol(mr(Eo.NOT_SUPPORTED_GET_CHOICE_INDEX)), -1;
      }
    };
    return l.__extender = o, process.env.NODE_ENV !== "production" && (l.__enableEmitter = (r) => {
      const a = n;
      a[zu] && a[zu](r);
    }, l.__disableEmitter = () => {
      const r = n;
      r[nm] && r[nm]();
    }), l;
  }
}
const sO = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (e) => e === "parent" || e === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function hee({ slots: e }, t) {
  return t.length === 1 && t[0] === "default" ? (e.default ? e.default() : []).reduce((o, l) => [
    ...o,
    // prettier-ignore
    ...l.type === Ge ? l.children : [l]
  ], []) : t.reduce((n, o) => {
    const l = e[o];
    return l && (n[o] = l()), n;
  }, fo());
}
function dB(e) {
  return Ge;
}
const gee = /* @__PURE__ */ le({
  /* eslint-disable */
  name: "i18n-t",
  props: Sl({
    keypath: {
      type: String,
      required: !0
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (e) => jo(e) || !isNaN(e)
    }
  }, sO),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(e, t) {
    const { slots: n, attrs: o } = t, l = e.i18n || uO({
      useScope: e.scope,
      __useComponent: !0
    });
    return () => {
      const r = Object.keys(n).filter((d) => d !== "_"), a = fo();
      e.locale && (a.locale = e.locale), e.plural !== void 0 && (a.plural = Bt(e.plural) ? +e.plural : e.plural);
      const i = hee(t, r), s = l[j$](e.keypath, i, a), c = Sl(fo(), o), u = Bt(e.tag) || Kn(e.tag) ? e.tag : dB();
      return ht(u, c, s);
    };
  }
}), IC = gee;
function bee(e) {
  return yo(e) && !Bt(e[0]);
}
function fB(e, t, n, o) {
  const { slots: l, attrs: r } = t;
  return () => {
    const a = { part: !0 };
    let i = fo();
    e.locale && (a.locale = e.locale), Bt(e.format) ? a.key = e.format : Kn(e.format) && (Bt(e.format.key) && (a.key = e.format.key), i = Object.keys(e.format).reduce((f, p) => n.includes(p) ? Sl(fo(), f, { [p]: e.format[p] }) : f, fo()));
    const s = o(e.value, a, i);
    let c = [a.key];
    yo(s) ? c = s.map((f, p) => {
      const m = l[f.type], v = m ? m({ [f.type]: f.value, index: p, parts: s }) : [f.value];
      return bee(v) && (v[0].key = `${f.type}-${p}`), v;
    }) : Bt(s) && (c = [s]);
    const u = Sl(fo(), r), d = Bt(e.tag) || Kn(e.tag) ? e.tag : dB();
    return ht(d, u, c);
  };
}
const yee = /* @__PURE__ */ le({
  /* eslint-disable */
  name: "i18n-n",
  props: Sl({
    value: {
      type: Number,
      required: !0
    },
    format: {
      type: [String, Object]
    }
  }, sO),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(e, t) {
    const n = e.i18n || uO({
      useScope: e.scope,
      __useComponent: !0
    });
    return fB(e, t, lB, (...o) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[K$](...o)
    ));
  }
}), $4 = yee, See = /* @__PURE__ */ le({
  /* eslint-disable */
  name: "i18n-d",
  props: Sl({
    value: {
      type: [Number, Date],
      required: !0
    },
    format: {
      type: [String, Object]
    }
  }, sO),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(e, t) {
    const n = e.i18n || uO({
      useScope: e.scope,
      __useComponent: !0
    });
    return fB(e, t, oB, (...o) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      n[W$](...o)
    ));
  }
}), x4 = See;
function Cee(e, t) {
  const n = e;
  if (e.mode === "composition")
    return n.__getInstance(t) || e.global;
  {
    const o = n.__getInstance(t);
    return o != null ? o.__composer : e.global.__composer;
  }
}
function wee(e) {
  const t = (a) => {
    const { instance: i, modifiers: s, value: c } = a;
    if (!i || !i.$)
      throw rl(Un.UNEXPECTED_ERROR);
    const u = Cee(e, i.$);
    process.env.NODE_ENV !== "production" && s.preserve && ol(mr(Eo.NOT_SUPPORTED_PRESERVE));
    const d = E4(c);
    return [
      Reflect.apply(u.t, u, [...O4(d)]),
      u
    ];
  };
  return {
    created: (a, i) => {
      const [s, c] = t(i);
      Ra && e.global === c && (a.__i18nWatcher = pe(c.locale, () => {
        i.instance && i.instance.$forceUpdate();
      })), a.__composer = c, a.textContent = s;
    },
    unmounted: (a) => {
      Ra && a.__i18nWatcher && (a.__i18nWatcher(), a.__i18nWatcher = void 0, delete a.__i18nWatcher), a.__composer && (a.__composer = void 0, delete a.__composer);
    },
    beforeUpdate: (a, { value: i }) => {
      if (a.__composer) {
        const s = a.__composer, c = E4(i);
        a.textContent = Reflect.apply(s.t, s, [
          ...O4(c)
        ]);
      }
    },
    getSSRProps: (a) => {
      const [i] = t(a);
      return { textContent: i };
    }
  };
}
function E4(e) {
  if (Bt(e))
    return { path: e };
  if (En(e)) {
    if (!("path" in e))
      throw rl(Un.REQUIRED_VALUE, "path");
    return e;
  } else
    throw rl(Un.INVALID_VALUE);
}
function O4(e) {
  const { path: t, locale: n, args: o, choice: l, plural: r } = e, a = {}, i = o || {};
  return Bt(n) && (a.locale = n), jo(l) && (a.plural = l), jo(r) && (a.plural = r), [t, i, a];
}
function $ee(e, t, ...n) {
  const o = En(n[0]) ? n[0] : {}, l = !!o.useI18nComponentName, r = Dn(o.globalInstall) ? o.globalInstall : !0;
  process.env.NODE_ENV !== "production" && r && l && ol(mr(Eo.COMPONENT_NAME_LEGACY_COMPATIBLE, {
    name: IC.name
  })), r && ([l ? "i18n" : IC.name, "I18nT"].forEach((a) => e.component(a, IC)), [$4.name, "I18nN"].forEach((a) => e.component(a, $4)), [x4.name, "I18nD"].forEach((a) => e.component(a, x4))), e.directive("t", wee(t));
}
const TC = {
  "vue-devtools-plugin-vue-i18n": "Vue I18n devtools",
  "vue-i18n-resource-inspector": "I18n Resources",
  "vue-i18n-timeline": "Vue I18n"
}, xee = {
  "vue-i18n-resource-inspector": "Search for scopes ..."
}, Eee = {
  "vue-i18n-timeline": 16764185
}, pB = "vue-i18n: composer properties";
let Y$;
function Oee(e, t) {
  return Rt(this, null, function* () {
    return new Promise((n, o) => {
      try {
        f1({
          id: "vue-devtools-plugin-vue-i18n",
          label: TC[
            "vue-devtools-plugin-vue-i18n"
            /* VueDevToolsIDs.PLUGIN */
          ],
          packageName: "vue-i18n",
          homepage: "https://vue-i18n.intlify.dev",
          logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
          componentStateTypes: [pB],
          app: e
          // eslint-disable-line @typescript-eslint/no-explicit-any
        }, (l) => {
          Y$ = l, l.on.visitComponentTree(({ componentInstance: a, treeNode: i }) => {
            _ee(a, i, t);
          }), l.on.inspectComponent(({ componentInstance: a, instanceData: i }) => {
            a.vnode.el && a.vnode.el.__VUE_I18N__ && i && (t.mode === "legacy" ? a.vnode.el.__VUE_I18N__ !== t.global.__composer && _4(i, a.vnode.el.__VUE_I18N__) : _4(i, a.vnode.el.__VUE_I18N__));
          }), l.addInspector({
            id: "vue-i18n-resource-inspector",
            label: TC[
              "vue-i18n-resource-inspector"
              /* VueDevToolsIDs.CUSTOM_INSPECTOR */
            ],
            icon: "language",
            treeFilterPlaceholder: xee[
              "vue-i18n-resource-inspector"
              /* VueDevToolsIDs.CUSTOM_INSPECTOR */
            ]
          }), l.on.getInspectorTree((a) => {
            a.app === e && a.inspectorId === "vue-i18n-resource-inspector" && Nee(a, t);
          });
          const r = /* @__PURE__ */ new Map();
          l.on.getInspectorState((a) => Rt(this, null, function* () {
            if (a.app === e && a.inspectorId === "vue-i18n-resource-inspector")
              if (l.unhighlightElement(), Aee(a, t), a.nodeId === "global") {
                if (!r.has(a.app)) {
                  const [i] = yield l.getComponentInstances(a.app);
                  r.set(a.app, i);
                }
                l.highlightElement(r.get(a.app));
              } else {
                const i = Mee(a.nodeId, t);
                i && l.highlightElement(i);
              }
          })), l.on.editInspectorState((a) => {
            a.app === e && a.inspectorId === "vue-i18n-resource-inspector" && Dee(a, t);
          }), l.addTimelineLayer({
            id: "vue-i18n-timeline",
            label: TC[
              "vue-i18n-timeline"
              /* VueDevToolsIDs.TIMELINE */
            ],
            color: Eee[
              "vue-i18n-timeline"
              /* VueDevToolsIDs.TIMELINE */
            ]
          }), n(!0);
        });
      } catch (l) {
        console.error(l), o(!1);
      }
    });
  });
}
function vB(e) {
  return e.type.name || e.type.displayName || e.type.__file || "Anonymous";
}
function _ee(e, t, n) {
  const o = n.mode === "composition" ? n.global : n.global.__composer;
  if (e && e.vnode.el && e.vnode.el.__VUE_I18N__ && e.vnode.el.__VUE_I18N__ !== o) {
    const l = {
      label: `i18n (${vB(e)} Scope)`,
      textColor: 0,
      backgroundColor: 16764185
    };
    t.tags.push(l);
  }
}
function _4(e, t) {
  const n = pB;
  e.state.push({
    type: n,
    key: "locale",
    editable: !0,
    value: t.locale.value
  }), e.state.push({
    type: n,
    key: "availableLocales",
    editable: !1,
    value: t.availableLocales
  }), e.state.push({
    type: n,
    key: "fallbackLocale",
    editable: !0,
    value: t.fallbackLocale.value
  }), e.state.push({
    type: n,
    key: "inheritLocale",
    editable: !0,
    value: t.inheritLocale
  }), e.state.push({
    type: n,
    key: "messages",
    editable: !1,
    value: cO(t.messages.value)
  }), e.state.push({
    type: n,
    key: "datetimeFormats",
    editable: !1,
    value: t.datetimeFormats.value
  }), e.state.push({
    type: n,
    key: "numberFormats",
    editable: !1,
    value: t.numberFormats.value
  });
}
function cO(e) {
  const t = {};
  return Object.keys(e).forEach((n) => {
    const o = e[n];
    co(o) && "source" in o ? t[n] = kee(o) : ta(o) && o.loc && o.loc.source ? t[n] = o.loc.source : Kn(o) ? t[n] = cO(o) : t[n] = o;
  }), t;
}
const Iee = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "&": "&amp;"
};
function Tee(e) {
  return e.replace(/[<>"&]/g, Pee);
}
function Pee(e) {
  return Iee[e] || e;
}
function kee(e) {
  return {
    _custom: {
      type: "function",
      display: `<span></span> ${e.source ? `("${Tee(e.source)}")` : "(?)"}`
    }
  };
}
function Nee(e, t) {
  e.rootNodes.push({
    id: "global",
    label: "Global Scope"
  });
  const n = t.mode === "composition" ? t.global : t.global.__composer;
  for (const [o, l] of t.__instances) {
    const r = t.mode === "composition" ? l : l.__composer;
    n !== r && e.rootNodes.push({
      id: r.id.toString(),
      label: `${vB(o)} Scope`
    });
  }
}
function Mee(e, t) {
  let n = null;
  if (e !== "global") {
    for (const [o, l] of t.__instances.entries())
      if (l.id.toString() === e) {
        n = o;
        break;
      }
  }
  return n;
}
function mB(e, t) {
  if (e === "global")
    return t.mode === "composition" ? t.global : t.global.__composer;
  {
    const n = Array.from(t.__instances.values()).find((o) => o.id.toString() === e);
    return n ? t.mode === "composition" ? n : n.__composer : null;
  }
}
function Aee(e, t) {
  const n = mB(e.nodeId, t);
  return n && (e.state = Ree(n)), null;
}
function Ree(e) {
  const t = {}, n = "Locale related info", o = [
    {
      type: n,
      key: "locale",
      editable: !0,
      value: e.locale.value
    },
    {
      type: n,
      key: "fallbackLocale",
      editable: !0,
      value: e.fallbackLocale.value
    },
    {
      type: n,
      key: "availableLocales",
      editable: !1,
      value: e.availableLocales
    },
    {
      type: n,
      key: "inheritLocale",
      editable: !0,
      value: e.inheritLocale
    }
  ];
  t[n] = o;
  const l = "Locale messages info", r = [
    {
      type: l,
      key: "messages",
      editable: !1,
      value: cO(e.messages.value)
    }
  ];
  t[l] = r;
  {
    const a = "Datetime formats info", i = [
      {
        type: a,
        key: "datetimeFormats",
        editable: !1,
        value: e.datetimeFormats.value
      }
    ];
    t[a] = i;
    const s = "Datetime formats info", c = [
      {
        type: s,
        key: "numberFormats",
        editable: !1,
        value: e.numberFormats.value
      }
    ];
    t[s] = c;
  }
  return t;
}
function lm(e, t) {
  if (Y$) {
    let n;
    t && "groupId" in t && (n = t.groupId, delete t.groupId), Y$.addTimelineEvent({
      layerId: "vue-i18n-timeline",
      event: {
        title: e,
        groupId: n,
        time: Date.now(),
        meta: {},
        data: t || {},
        logType: e === "compile-error" ? "error" : e === "fallback" || e === "missing" ? "warning" : "default"
      }
    });
  }
}
function Dee(e, t) {
  const n = mB(e.nodeId, t);
  if (n) {
    const [o] = e.path;
    o === "locale" && Bt(e.state.value) ? n.locale.value = e.state.value : o === "fallbackLocale" && (Bt(e.state.value) || yo(e.state.value) || Kn(e.state.value)) ? n.fallbackLocale.value = e.state.value : o === "inheritLocale" && Dn(e.state.value) && (n.inheritLocale = e.state.value);
  }
}
function Lee(e, t, n) {
  return {
    beforeCreate() {
      const o = xt();
      if (!o)
        throw rl(Un.UNEXPECTED_ERROR);
      const l = this.$options;
      if (l.i18n) {
        const r = l.i18n;
        if (l.__i18n && (r.__i18n = l.__i18n), r.__root = t, this === this.$root)
          this.$i18n = I4(e, r);
        else {
          r.__injectWithOption = !0, r.__extender = n.__vueI18nExtend, this.$i18n = G$(r);
          const a = this.$i18n;
          a.__extender && (a.__disposer = a.__extender(this.$i18n));
        }
      } else if (l.__i18n)
        if (this === this.$root)
          this.$i18n = I4(e, l);
        else {
          this.$i18n = G$({
            __i18n: l.__i18n,
            __injectWithOption: !0,
            __extender: n.__vueI18nExtend,
            __root: t
          });
          const r = this.$i18n;
          r.__extender && (r.__disposer = r.__extender(this.$i18n));
        }
      else
        this.$i18n = e;
      l.__i18nGlobal && uB(t, l, l), this.$t = (...r) => this.$i18n.t(...r), this.$rt = (...r) => this.$i18n.rt(...r), this.$tc = (...r) => this.$i18n.tc(...r), this.$te = (r, a) => this.$i18n.te(r, a), this.$d = (...r) => this.$i18n.d(...r), this.$n = (...r) => this.$i18n.n(...r), this.$tm = (r) => this.$i18n.tm(r), n.__setInstance(o, this.$i18n);
    },
    mounted() {
      if (process.env.NODE_ENV !== "production" && this.$el && this.$i18n) {
        const o = this.$i18n;
        this.$el.__VUE_I18N__ = o.__composer;
        const l = this.__v_emitter = nO();
        o.__enableEmitter && o.__enableEmitter(l), l.on("*", lm);
      }
    },
    unmounted() {
      const o = xt();
      if (!o)
        throw rl(Un.UNEXPECTED_ERROR);
      const l = this.$i18n;
      process.env.NODE_ENV !== "production" && this.$el && this.$el.__VUE_I18N__ && (this.__v_emitter && (this.__v_emitter.off("*", lm), delete this.__v_emitter), this.$i18n && (l.__disableEmitter && l.__disableEmitter(), delete this.$el.__VUE_I18N__)), delete this.$t, delete this.$rt, delete this.$tc, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, l.__disposer && (l.__disposer(), delete l.__disposer, delete l.__extender), n.__deleteInstance(o), delete this.$i18n;
    }
  };
}
function I4(e, t) {
  e.locale = t.locale || e.locale, e.fallbackLocale = t.fallbackLocale || e.fallbackLocale, e.missing = t.missing || e.missing, e.silentTranslationWarn = t.silentTranslationWarn || e.silentFallbackWarn, e.silentFallbackWarn = t.silentFallbackWarn || e.silentFallbackWarn, e.formatFallbackMessages = t.formatFallbackMessages || e.formatFallbackMessages, e.postTranslation = t.postTranslation || e.postTranslation, e.warnHtmlInMessage = t.warnHtmlInMessage || e.warnHtmlInMessage, e.escapeParameterHtml = t.escapeParameterHtml || e.escapeParameterHtml, e.sync = t.sync || e.sync, e.__composer[iB](t.pluralizationRules || e.pluralizationRules);
  const n = b1(e.locale, {
    messages: t.messages,
    __i18n: t.__i18n
  });
  return Object.keys(n).forEach((o) => e.mergeLocaleMessage(o, n[o])), t.datetimeFormats && Object.keys(t.datetimeFormats).forEach((o) => e.mergeDateTimeFormat(o, t.datetimeFormats[o])), t.numberFormats && Object.keys(t.numberFormats).forEach((o) => e.mergeNumberFormat(o, t.numberFormats[o])), e;
}
const Bee = /* @__PURE__ */ Pi("global-vue-i18n");
function Fee(e = {}, t) {
  const n = __VUE_I18N_LEGACY_API__ && Dn(e.legacy) ? e.legacy : __VUE_I18N_LEGACY_API__, o = Dn(e.globalInjection) ? e.globalInjection : !0, l = __VUE_I18N_LEGACY_API__ && n ? !!e.allowComposition : !0, r = /* @__PURE__ */ new Map(), [a, i] = Vee(e, n), s = /* @__PURE__ */ Pi(process.env.NODE_ENV !== "production" ? "vue-i18n" : "");
  process.env.NODE_ENV !== "production" && n && l && ol(mr(Eo.NOTICE_DROP_ALLOW_COMPOSITION));
  function c(f) {
    return r.get(f) || null;
  }
  function u(f, p) {
    r.set(f, p);
  }
  function d(f) {
    r.delete(f);
  }
  {
    let p;
    const f = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && n ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return l;
      },
      // install plugin
      install(m, ...v) {
        return Rt(this, null, function* () {
          if (process.env.NODE_ENV !== "production" && (m.__VUE_I18N__ = f), m.__VUE_I18N_SYMBOL__ = s, m.provide(m.__VUE_I18N_SYMBOL__, f), En(v[0])) {
            const y = v[0];
            f.__composerExtend = y.__composerExtend, f.__vueI18nExtend = y.__vueI18nExtend;
          }
          let h = null;
          !n && o && (h = Xee(m, f.global)), __VUE_I18N_FULL_INSTALL__ && $ee(m, f, ...v), __VUE_I18N_LEGACY_API__ && n && m.mixin(Lee(i, i.__composer, f));
          const g = m.unmount;
          if (m.unmount = () => {
            h && h(), f.dispose(), g();
          }, process.env.NODE_ENV !== "production") {
            if (!(yield Oee(m, f)))
              throw rl(Un.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
            const b = nO();
            if (n) {
              const C = i;
              C.__enableEmitter && C.__enableEmitter(b);
            } else {
              const C = i;
              C[zu] && C[zu](b);
            }
            b.on("*", lm);
          }
        });
      },
      // global accessor
      get global() {
        return i;
      },
      dispose() {
        a.stop();
      },
      // @internal
      __instances: r,
      // @internal
      __getInstance: c,
      // @internal
      __setInstance: u,
      // @internal
      __deleteInstance: d
    };
    return f;
  }
}
function uO(e = {}) {
  const t = xt();
  if (t == null)
    throw rl(Un.MUST_BE_CALL_SETUP_TOP);
  if (!t.isCE && t.appContext.app != null && !t.appContext.app.__VUE_I18N_SYMBOL__)
    throw rl(Un.NOT_INSTALLED);
  const n = zee(t), o = jee(n), l = cB(t), r = Hee(e, l);
  if (__VUE_I18N_LEGACY_API__ && n.mode === "legacy" && !e.__useComponent) {
    if (!n.allowComposition)
      throw rl(Un.NOT_AVAILABLE_IN_LEGACY_MODE);
    return Gee(t, r, o, e);
  }
  if (r === "global")
    return uB(o, e, l), o;
  if (r === "parent") {
    let s = Wee(n, t, e.__useComponent);
    return s == null && (process.env.NODE_ENV !== "production" && ol(mr(Eo.NOT_FOUND_PARENT_SCOPE)), s = o), s;
  }
  const a = n;
  let i = a.__getInstance(t);
  if (i == null) {
    const s = Sl({}, e);
    "__i18n" in l && (s.__i18n = l.__i18n), o && (s.__root = o), i = iO(s), a.__composerExtend && (i[U$] = a.__composerExtend(i)), Uee(a, t, i), a.__setInstance(t, i);
  }
  return i;
}
function Vee(e, t, n) {
  const o = kE();
  {
    const l = __VUE_I18N_LEGACY_API__ && t ? o.run(() => G$(e)) : o.run(() => iO(e));
    if (l == null)
      throw rl(Un.UNEXPECTED_ERROR);
    return [o, l];
  }
}
function zee(e) {
  {
    const t = ze(e.isCE ? Bee : e.appContext.app.__VUE_I18N_SYMBOL__);
    if (!t)
      throw rl(e.isCE ? Un.NOT_INSTALLED_WITH_PROVIDE : Un.UNEXPECTED_ERROR);
    return t;
  }
}
function Hee(e, t) {
  return p1(e) ? "__i18n" in t ? "local" : "global" : e.useScope ? e.useScope : "local";
}
function jee(e) {
  return e.mode === "composition" ? e.global : e.global.__composer;
}
function Wee(e, t, n = !1) {
  let o = null;
  const l = t.root;
  let r = Kee(t, n);
  for (; r != null; ) {
    const a = e;
    if (e.mode === "composition")
      o = a.__getInstance(r);
    else if (__VUE_I18N_LEGACY_API__) {
      const i = a.__getInstance(r);
      i != null && (o = i.__composer, n && o && !o[sB] && (o = null));
    }
    if (o != null || l === r)
      break;
    r = r.parent;
  }
  return o;
}
function Kee(e, t = !1) {
  return e == null ? null : t && e.vnode.ctx || e.parent;
}
function Uee(e, t, n) {
  let o = null;
  nt(() => {
    if (process.env.NODE_ENV !== "production" && t.vnode.el) {
      t.vnode.el.__VUE_I18N__ = n, o = nO();
      const l = n;
      l[zu] && l[zu](o), o.on("*", lm);
    }
  }, t), Uo(() => {
    const l = n;
    process.env.NODE_ENV !== "production" && t.vnode.el && t.vnode.el.__VUE_I18N__ && (o && o.off("*", lm), l[nm] && l[nm](), delete t.vnode.el.__VUE_I18N__), e.__deleteInstance(t);
    const r = l[U$];
    r && (r(), delete l[U$]);
  }, t);
}
function Gee(e, t, n, o = {}) {
  const l = t === "local", r = /* @__PURE__ */ Ce(null);
  if (l && e.proxy && !(e.proxy.$options.i18n || e.proxy.$options.__i18n))
    throw rl(Un.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  const a = Dn(o.inheritLocale) ? o.inheritLocale : !Bt(o.locale), i = /* @__PURE__ */ H(
    // prettier-ignore
    !l || a ? n.locale.value : Bt(o.locale) ? o.locale : Lf
  ), s = /* @__PURE__ */ H(
    // prettier-ignore
    !l || a ? n.fallbackLocale.value : Bt(o.fallbackLocale) || yo(o.fallbackLocale) || En(o.fallbackLocale) || o.fallbackLocale === !1 ? o.fallbackLocale : i.value
  ), c = /* @__PURE__ */ H(b1(i.value, o)), u = /* @__PURE__ */ H(En(o.datetimeFormats) ? o.datetimeFormats : { [i.value]: {} }), d = /* @__PURE__ */ H(En(o.numberFormats) ? o.numberFormats : { [i.value]: {} }), f = l ? n.missingWarn : Dn(o.missingWarn) || gc(o.missingWarn) ? o.missingWarn : !0, p = l ? n.fallbackWarn : Dn(o.fallbackWarn) || gc(o.fallbackWarn) ? o.fallbackWarn : !0, m = l ? n.fallbackRoot : Dn(o.fallbackRoot) ? o.fallbackRoot : !0, v = !!o.fallbackFormat, h = co(o.missing) ? o.missing : null, g = co(o.postTranslation) ? o.postTranslation : null, y = l ? n.warnHtmlMessage : Dn(o.warnHtmlMessage) ? o.warnHtmlMessage : !0, b = !!o.escapeParameter, C = l ? n.modifiers : En(o.modifiers) ? o.modifiers : {}, w = o.pluralRules || l && n.pluralRules;
  function x() {
    return [
      i.value,
      s.value,
      c.value,
      u.value,
      d.value
    ];
  }
  const E = O({
    get: () => r.value ? r.value.locale.value : i.value,
    set: (ee) => {
      r.value && (r.value.locale.value = ee), i.value = ee;
    }
  }), I = O({
    get: () => r.value ? r.value.fallbackLocale.value : s.value,
    set: (ee) => {
      r.value && (r.value.fallbackLocale.value = ee), s.value = ee;
    }
  }), T = O(() => r.value ? r.value.messages.value : c.value), P = O(() => u.value), k = O(() => d.value);
  function N() {
    return r.value ? r.value.getPostTranslationHandler() : g;
  }
  function R(ee) {
    r.value && r.value.setPostTranslationHandler(ee);
  }
  function z() {
    return r.value ? r.value.getMissingHandler() : h;
  }
  function D(ee) {
    r.value && r.value.setMissingHandler(ee);
  }
  function F(ee) {
    return x(), ee();
  }
  function M(...ee) {
    return r.value ? F(() => Reflect.apply(r.value.t, null, [...ee])) : F(() => "");
  }
  function A(...ee) {
    return r.value ? Reflect.apply(r.value.rt, null, [...ee]) : "";
  }
  function L(...ee) {
    return r.value ? F(() => Reflect.apply(r.value.d, null, [...ee])) : F(() => "");
  }
  function B(...ee) {
    return r.value ? F(() => Reflect.apply(r.value.n, null, [...ee])) : F(() => "");
  }
  function V(ee) {
    return r.value ? r.value.tm(ee) : {};
  }
  function j(ee, fe) {
    return r.value ? r.value.te(ee, fe) : !1;
  }
  function W(ee) {
    return r.value ? r.value.getLocaleMessage(ee) : {};
  }
  function Y(ee, fe) {
    r.value && (r.value.setLocaleMessage(ee, fe), c.value[ee] = fe);
  }
  function U(ee, fe) {
    r.value && r.value.mergeLocaleMessage(ee, fe);
  }
  function te(ee) {
    return r.value ? r.value.getDateTimeFormat(ee) : {};
  }
  function J(ee, fe) {
    r.value && (r.value.setDateTimeFormat(ee, fe), u.value[ee] = fe);
  }
  function re(ee, fe) {
    r.value && r.value.mergeDateTimeFormat(ee, fe);
  }
  function oe(ee) {
    return r.value ? r.value.getNumberFormat(ee) : {};
  }
  function q(ee, fe) {
    r.value && (r.value.setNumberFormat(ee, fe), d.value[ee] = fe);
  }
  function K(ee, fe) {
    r.value && r.value.mergeNumberFormat(ee, fe);
  }
  const se = {
    get id() {
      return r.value ? r.value.id : -1;
    },
    locale: E,
    fallbackLocale: I,
    messages: T,
    datetimeFormats: P,
    numberFormats: k,
    get inheritLocale() {
      return r.value ? r.value.inheritLocale : a;
    },
    set inheritLocale(ee) {
      r.value && (r.value.inheritLocale = ee);
    },
    get availableLocales() {
      return r.value ? r.value.availableLocales : Object.keys(c.value);
    },
    get modifiers() {
      return r.value ? r.value.modifiers : C;
    },
    get pluralRules() {
      return r.value ? r.value.pluralRules : w;
    },
    get isGlobal() {
      return r.value ? r.value.isGlobal : !1;
    },
    get missingWarn() {
      return r.value ? r.value.missingWarn : f;
    },
    set missingWarn(ee) {
      r.value && (r.value.missingWarn = ee);
    },
    get fallbackWarn() {
      return r.value ? r.value.fallbackWarn : p;
    },
    set fallbackWarn(ee) {
      r.value && (r.value.missingWarn = ee);
    },
    get fallbackRoot() {
      return r.value ? r.value.fallbackRoot : m;
    },
    set fallbackRoot(ee) {
      r.value && (r.value.fallbackRoot = ee);
    },
    get fallbackFormat() {
      return r.value ? r.value.fallbackFormat : v;
    },
    set fallbackFormat(ee) {
      r.value && (r.value.fallbackFormat = ee);
    },
    get warnHtmlMessage() {
      return r.value ? r.value.warnHtmlMessage : y;
    },
    set warnHtmlMessage(ee) {
      r.value && (r.value.warnHtmlMessage = ee);
    },
    get escapeParameter() {
      return r.value ? r.value.escapeParameter : b;
    },
    set escapeParameter(ee) {
      r.value && (r.value.escapeParameter = ee);
    },
    t: M,
    getPostTranslationHandler: N,
    setPostTranslationHandler: R,
    getMissingHandler: z,
    setMissingHandler: D,
    rt: A,
    d: L,
    n: B,
    tm: V,
    te: j,
    getLocaleMessage: W,
    setLocaleMessage: Y,
    mergeLocaleMessage: U,
    getDateTimeFormat: te,
    setDateTimeFormat: J,
    mergeDateTimeFormat: re,
    getNumberFormat: oe,
    setNumberFormat: q,
    mergeNumberFormat: K
  };
  function Z(ee) {
    ee.locale.value = i.value, ee.fallbackLocale.value = s.value, Object.keys(c.value).forEach((fe) => {
      ee.mergeLocaleMessage(fe, c.value[fe]);
    }), Object.keys(u.value).forEach((fe) => {
      ee.mergeDateTimeFormat(fe, u.value[fe]);
    }), Object.keys(d.value).forEach((fe) => {
      ee.mergeNumberFormat(fe, d.value[fe]);
    }), ee.escapeParameter = b, ee.fallbackFormat = v, ee.fallbackRoot = m, ee.fallbackWarn = p, ee.missingWarn = f, ee.warnHtmlMessage = y;
  }
  return _c(() => {
    if (e.proxy == null || e.proxy.$i18n == null)
      throw rl(Un.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    const ee = r.value = e.proxy.$i18n.__composer;
    t === "global" ? (i.value = ee.locale.value, s.value = ee.fallbackLocale.value, c.value = ee.messages.value, u.value = ee.datetimeFormats.value, d.value = ee.numberFormats.value) : l && Z(ee);
  }), se;
}
const Yee = [
  "locale",
  "fallbackLocale",
  "availableLocales"
], T4 = ["t", "rt", "d", "n", "tm", "te"];
function Xee(e, t) {
  const n = /* @__PURE__ */ Object.create(null);
  return Yee.forEach((l) => {
    const r = Object.getOwnPropertyDescriptor(t, l);
    if (!r)
      throw rl(Un.UNEXPECTED_ERROR);
    const a = /* @__PURE__ */ kn(r.value) ? {
      get() {
        return r.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(i) {
        r.value.value = i;
      }
    } : {
      get() {
        return r.get && r.get();
      }
    };
    Object.defineProperty(n, l, a);
  }), e.config.globalProperties.$i18n = n, T4.forEach((l) => {
    const r = Object.getOwnPropertyDescriptor(t, l);
    if (!r || !r.value)
      throw rl(Un.UNEXPECTED_ERROR);
    Object.defineProperty(e.config.globalProperties, `$${l}`, r);
  }), () => {
    delete e.config.globalProperties.$i18n, T4.forEach((l) => {
      delete e.config.globalProperties[`$${l}`];
    });
  };
}
uee();
__INTLIFY_JIT_COMPILATION__ ? i4(oee) : i4(nee);
GQ(_Q);
YQ(HL);
if (process.env.NODE_ENV !== "production" || __INTLIFY_PROD_DEVTOOLS__) {
  const e = es();
  e.__INTLIFY__ = !0, DQ(e.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
process.env.NODE_ENV;
const qee = "2.13.1", P4 = Symbol("INSTALLED_KEY"), hB = Symbol(), _v = "el", Jee = "is-", Wc = (e, t, n, o, l) => {
  let r = `${e}-${t}`;
  return n && (r += `-${n}`), o && (r += `__${o}`), l && (r += `--${l}`), r;
}, gB = Symbol("namespaceContextKey"), dO = (e) => {
  const t = e || (xt() ? ze(gB, /* @__PURE__ */ H(_v)) : /* @__PURE__ */ H(_v));
  return O(() => S(t) || _v);
}, Ve = (e, t) => {
  const n = dO(t);
  return {
    namespace: n,
    b: (v = "") => Wc(n.value, e, v, "", ""),
    e: (v) => v ? Wc(n.value, e, "", v, "") : "",
    m: (v) => v ? Wc(n.value, e, "", "", v) : "",
    be: (v, h) => v && h ? Wc(n.value, e, v, h, "") : "",
    em: (v, h) => v && h ? Wc(n.value, e, "", v, h) : "",
    bm: (v, h) => v && h ? Wc(n.value, e, v, "", h) : "",
    bem: (v, h, g) => v && h && g ? Wc(n.value, e, v, h, g) : "",
    is: (v, ...h) => {
      const g = h.length >= 1 ? h[0] : !0;
      return v && g ? `${Jee}${v}` : "";
    },
    cssVar: (v) => {
      const h = {};
      for (const g in v)
        v[g] && (h[`--${n.value}-${g}`] = v[g]);
      return h;
    },
    cssVarName: (v) => `--${n.value}-${v}`,
    cssVarBlock: (v) => {
      const h = {};
      for (const g in v)
        v[g] && (h[`--${n.value}-${e}-${g}`] = v[g]);
      return h;
    },
    cssVarBlockName: (v) => `--${n.value}-${e}-${v}`
  };
};
var bB = typeof global == "object" && global && global.Object === Object && global, Zee = typeof self == "object" && self && self.Object === Object && self, Wa = bB || Zee || Function("return this")(), ra = Wa.Symbol, yB = Object.prototype, Qee = yB.hasOwnProperty, ete = yB.toString, Jp = ra ? ra.toStringTag : void 0;
function tte(e) {
  var t = Qee.call(e, Jp), n = e[Jp];
  try {
    e[Jp] = void 0;
    var o = !0;
  } catch (r) {
  }
  var l = ete.call(e);
  return o && (t ? e[Jp] = n : delete e[Jp]), l;
}
var nte = Object.prototype, ote = nte.toString;
function lte(e) {
  return ote.call(e);
}
var rte = "[object Null]", ate = "[object Undefined]", k4 = ra ? ra.toStringTag : void 0;
function Pc(e) {
  return e == null ? e === void 0 ? ate : rte : k4 && k4 in Object(e) ? tte(e) : lte(e);
}
function Da(e) {
  return e != null && typeof e == "object";
}
var ite = "[object Symbol]";
function y1(e) {
  return typeof e == "symbol" || Da(e) && Pc(e) == ite;
}
function S1(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, l = Array(o); ++n < o; )
    l[n] = t(e[n], n, e);
  return l;
}
var wl = Array.isArray, N4 = ra ? ra.prototype : void 0, M4 = N4 ? N4.toString : void 0;
function SB(e) {
  if (typeof e == "string")
    return e;
  if (wl(e))
    return S1(e, SB) + "";
  if (y1(e))
    return M4 ? M4.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
var ste = /\s/;
function cte(e) {
  for (var t = e.length; t-- && ste.test(e.charAt(t)); )
    ;
  return t;
}
var ute = /^\s+/;
function dte(e) {
  return e && e.slice(0, cte(e) + 1).replace(ute, "");
}
function lr(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var A4 = NaN, fte = /^[-+]0x[0-9a-f]+$/i, pte = /^0b[01]+$/i, vte = /^0o[0-7]+$/i, mte = parseInt;
function cf(e) {
  if (typeof e == "number")
    return e;
  if (y1(e))
    return A4;
  if (lr(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = lr(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = dte(e);
  var n = pte.test(e);
  return n || vte.test(e) ? mte(e.slice(2), n ? 2 : 8) : fte.test(e) ? A4 : +e;
}
var R4 = 1 / 0, hte = 17976931348623157e292;
function gte(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = cf(e), e === R4 || e === -R4) {
    var t = e < 0 ? -1 : 1;
    return t * hte;
  }
  return e === e ? e : 0;
}
function bte(e) {
  var t = gte(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
function fO(e) {
  return e;
}
var yte = "[object AsyncFunction]", Ste = "[object Function]", Cte = "[object GeneratorFunction]", wte = "[object Proxy]";
function pO(e) {
  if (!lr(e))
    return !1;
  var t = Pc(e);
  return t == Ste || t == Cte || t == yte || t == wte;
}
var PC = Wa["__core-js_shared__"], D4 = function() {
  var e = /[^.]+$/.exec(PC && PC.keys && PC.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function $te(e) {
  return !!D4 && D4 in e;
}
var xte = Function.prototype, Ete = xte.toString;
function od(e) {
  if (e != null) {
    try {
      return Ete.call(e);
    } catch (t) {
    }
    try {
      return e + "";
    } catch (t) {
    }
  }
  return "";
}
var Ote = /[\\^$.*+?()[\]{}|]/g, _te = /^\[object .+?Constructor\]$/, Ite = Function.prototype, Tte = Object.prototype, Pte = Ite.toString, kte = Tte.hasOwnProperty, Nte = RegExp(
  "^" + Pte.call(kte).replace(Ote, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Mte(e) {
  if (!lr(e) || $te(e))
    return !1;
  var t = pO(e) ? Nte : _te;
  return t.test(od(e));
}
function Ate(e, t) {
  return e == null ? void 0 : e[t];
}
function ld(e, t) {
  var n = Ate(e, t);
  return Mte(n) ? n : void 0;
}
var X$ = ld(Wa, "WeakMap"), L4 = Object.create, Rte = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!lr(t))
      return {};
    if (L4)
      return L4(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function Dte(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function Lte() {
}
function CB(e, t) {
  var n = -1, o = e.length;
  for (t || (t = Array(o)); ++n < o; )
    t[n] = e[n];
  return t;
}
var Bte = 800, Fte = 16, Vte = Date.now;
function zte(e) {
  var t = 0, n = 0;
  return function() {
    var o = Vte(), l = Fte - (o - n);
    if (n = o, l > 0) {
      if (++t >= Bte)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function Hte(e) {
  return function() {
    return e;
  };
}
var _0 = function() {
  try {
    var e = ld(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch (t) {
  }
}(), jte = _0 ? function(e, t) {
  return _0(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Hte(t),
    writable: !0
  });
} : fO, wB = zte(jte);
function Wte(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length; ++n < o && t(e[n], n, e) !== !1; )
    ;
  return e;
}
function vO(e, t, n, o) {
  for (var l = e.length, r = n + (o ? 1 : -1); o ? r-- : ++r < l; )
    if (t(e[r], r, e))
      return r;
  return -1;
}
function Kte(e) {
  return e !== e;
}
function Ute(e, t, n) {
  for (var o = n - 1, l = e.length; ++o < l; )
    if (e[o] === t)
      return o;
  return -1;
}
function Gte(e, t, n) {
  return t === t ? Ute(e, t, n) : vO(e, Kte, n);
}
function $B(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && Gte(e, t, 0) > -1;
}
var Yte = 9007199254740991, Xte = /^(?:0|[1-9]\d*)$/;
function C1(e, t) {
  var n = typeof e;
  return t = t == null ? Yte : t, !!t && (n == "number" || n != "symbol" && Xte.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function mO(e, t, n) {
  t == "__proto__" && _0 ? _0(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function Qm(e, t) {
  return e === t || e !== e && t !== t;
}
var qte = Object.prototype, Jte = qte.hasOwnProperty;
function hO(e, t, n) {
  var o = e[t];
  (!(Jte.call(e, t) && Qm(o, n)) || n === void 0 && !(t in e)) && mO(e, t, n);
}
function gp(e, t, n, o) {
  var l = !n;
  n || (n = {});
  for (var r = -1, a = t.length; ++r < a; ) {
    var i = t[r], s = void 0;
    s === void 0 && (s = e[i]), l ? mO(n, i, s) : hO(n, i, s);
  }
  return n;
}
var B4 = Math.max;
function xB(e, t, n) {
  return t = B4(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var o = arguments, l = -1, r = B4(o.length - t, 0), a = Array(r); ++l < r; )
      a[l] = o[t + l];
    l = -1;
    for (var i = Array(t + 1); ++l < t; )
      i[l] = o[l];
    return i[t] = n(a), Dte(e, this, i);
  };
}
function gO(e, t) {
  return wB(xB(e, t, fO), e + "");
}
var Zte = 9007199254740991;
function bO(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Zte;
}
function kc(e) {
  return e != null && bO(e.length) && !pO(e);
}
function Qte(e, t, n) {
  if (!lr(n))
    return !1;
  var o = typeof t;
  return (o == "number" ? kc(n) && C1(t, n.length) : o == "string" && t in n) ? Qm(n[t], e) : !1;
}
function ene(e) {
  return gO(function(t, n) {
    var o = -1, l = n.length, r = l > 1 ? n[l - 1] : void 0, a = l > 2 ? n[2] : void 0;
    for (r = e.length > 3 && typeof r == "function" ? (l--, r) : void 0, a && Qte(n[0], n[1], a) && (r = l < 3 ? void 0 : r, l = 1), t = Object(t); ++o < l; ) {
      var i = n[o];
      i && e(t, i, o, r);
    }
    return t;
  });
}
var tne = Object.prototype;
function w1(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || tne;
  return e === n;
}
function nne(e, t) {
  for (var n = -1, o = Array(e); ++n < e; )
    o[n] = t(n);
  return o;
}
var one = "[object Arguments]";
function F4(e) {
  return Da(e) && Pc(e) == one;
}
var EB = Object.prototype, lne = EB.hasOwnProperty, rne = EB.propertyIsEnumerable, Bf = F4(/* @__PURE__ */ function() {
  return arguments;
}()) ? F4 : function(e) {
  return Da(e) && lne.call(e, "callee") && !rne.call(e, "callee");
};
function ane() {
  return !1;
}
var OB = typeof exports == "object" && exports && !exports.nodeType && exports, V4 = OB && typeof module == "object" && module && !module.nodeType && module, ine = V4 && V4.exports === OB, z4 = ine ? Wa.Buffer : void 0, sne = z4 ? z4.isBuffer : void 0, Ff = sne || ane, cne = "[object Arguments]", une = "[object Array]", dne = "[object Boolean]", fne = "[object Date]", pne = "[object Error]", vne = "[object Function]", mne = "[object Map]", hne = "[object Number]", gne = "[object Object]", bne = "[object RegExp]", yne = "[object Set]", Sne = "[object String]", Cne = "[object WeakMap]", wne = "[object ArrayBuffer]", $ne = "[object DataView]", xne = "[object Float32Array]", Ene = "[object Float64Array]", One = "[object Int8Array]", _ne = "[object Int16Array]", Ine = "[object Int32Array]", Tne = "[object Uint8Array]", Pne = "[object Uint8ClampedArray]", kne = "[object Uint16Array]", Nne = "[object Uint32Array]", Co = {};
Co[xne] = Co[Ene] = Co[One] = Co[_ne] = Co[Ine] = Co[Tne] = Co[Pne] = Co[kne] = Co[Nne] = !0;
Co[cne] = Co[une] = Co[wne] = Co[dne] = Co[$ne] = Co[fne] = Co[pne] = Co[vne] = Co[mne] = Co[hne] = Co[gne] = Co[bne] = Co[yne] = Co[Sne] = Co[Cne] = !1;
function Mne(e) {
  return Da(e) && bO(e.length) && !!Co[Pc(e)];
}
function yO(e) {
  return function(t) {
    return e(t);
  };
}
var _B = typeof exports == "object" && exports && !exports.nodeType && exports, Iv = _B && typeof module == "object" && module && !module.nodeType && module, Ane = Iv && Iv.exports === _B, kC = Ane && bB.process, Vf = function() {
  try {
    var e = Iv && Iv.require && Iv.require("util").types;
    return e || kC && kC.binding && kC.binding("util");
  } catch (t) {
  }
}(), H4 = Vf && Vf.isTypedArray, $1 = H4 ? yO(H4) : Mne, Rne = Object.prototype, Dne = Rne.hasOwnProperty;
function IB(e, t) {
  var n = wl(e), o = !n && Bf(e), l = !n && !o && Ff(e), r = !n && !o && !l && $1(e), a = n || o || l || r, i = a ? nne(e.length, String) : [], s = i.length;
  for (var c in e)
    (t || Dne.call(e, c)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    l && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    r && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    C1(c, s))) && i.push(c);
  return i;
}
function TB(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var Lne = TB(Object.keys, Object), Bne = Object.prototype, Fne = Bne.hasOwnProperty;
function PB(e) {
  if (!w1(e))
    return Lne(e);
  var t = [];
  for (var n in Object(e))
    Fne.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function bp(e) {
  return kc(e) ? IB(e) : PB(e);
}
function Vne(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var zne = Object.prototype, Hne = zne.hasOwnProperty;
function jne(e) {
  if (!lr(e))
    return Vne(e);
  var t = w1(e), n = [];
  for (var o in e)
    o == "constructor" && (t || !Hne.call(e, o)) || n.push(o);
  return n;
}
function eh(e) {
  return kc(e) ? IB(e, !0) : jne(e);
}
var Wne = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Kne = /^\w*$/;
function SO(e, t) {
  if (wl(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || y1(e) ? !0 : Kne.test(e) || !Wne.test(e) || t != null && e in Object(t);
}
var rm = ld(Object, "create");
function Une() {
  this.__data__ = rm ? rm(null) : {}, this.size = 0;
}
function Gne(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var Yne = "__lodash_hash_undefined__", Xne = Object.prototype, qne = Xne.hasOwnProperty;
function Jne(e) {
  var t = this.__data__;
  if (rm) {
    var n = t[e];
    return n === Yne ? void 0 : n;
  }
  return qne.call(t, e) ? t[e] : void 0;
}
var Zne = Object.prototype, Qne = Zne.hasOwnProperty;
function eoe(e) {
  var t = this.__data__;
  return rm ? t[e] !== void 0 : Qne.call(t, e);
}
var toe = "__lodash_hash_undefined__";
function noe(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = rm && t === void 0 ? toe : t, this;
}
function Hu(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Hu.prototype.clear = Une;
Hu.prototype.delete = Gne;
Hu.prototype.get = Jne;
Hu.prototype.has = eoe;
Hu.prototype.set = noe;
function ooe() {
  this.__data__ = [], this.size = 0;
}
function x1(e, t) {
  for (var n = e.length; n--; )
    if (Qm(e[n][0], t))
      return n;
  return -1;
}
var loe = Array.prototype, roe = loe.splice;
function aoe(e) {
  var t = this.__data__, n = x1(t, e);
  if (n < 0)
    return !1;
  var o = t.length - 1;
  return n == o ? t.pop() : roe.call(t, n, 1), --this.size, !0;
}
function ioe(e) {
  var t = this.__data__, n = x1(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function soe(e) {
  return x1(this.__data__, e) > -1;
}
function coe(e, t) {
  var n = this.__data__, o = x1(n, e);
  return o < 0 ? (++this.size, n.push([e, t])) : n[o][1] = t, this;
}
function $s(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
$s.prototype.clear = ooe;
$s.prototype.delete = aoe;
$s.prototype.get = ioe;
$s.prototype.has = soe;
$s.prototype.set = coe;
var am = ld(Wa, "Map");
function uoe() {
  this.size = 0, this.__data__ = {
    hash: new Hu(),
    map: new (am || $s)(),
    string: new Hu()
  };
}
function doe(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function E1(e, t) {
  var n = e.__data__;
  return doe(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function foe(e) {
  var t = E1(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function poe(e) {
  return E1(this, e).get(e);
}
function voe(e) {
  return E1(this, e).has(e);
}
function moe(e, t) {
  var n = E1(this, e), o = n.size;
  return n.set(e, t), this.size += n.size == o ? 0 : 1, this;
}
function xs(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
xs.prototype.clear = uoe;
xs.prototype.delete = foe;
xs.prototype.get = poe;
xs.prototype.has = voe;
xs.prototype.set = moe;
var hoe = "Expected a function";
function O1(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(hoe);
  var n = function() {
    var o = arguments, l = t ? t.apply(this, o) : o[0], r = n.cache;
    if (r.has(l))
      return r.get(l);
    var a = e.apply(this, o);
    return n.cache = r.set(l, a) || r, a;
  };
  return n.cache = new (O1.Cache || xs)(), n;
}
O1.Cache = xs;
var goe = 500;
function boe(e) {
  var t = O1(e, function(o) {
    return n.size === goe && n.clear(), o;
  }), n = t.cache;
  return t;
}
var yoe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Soe = /\\(\\)?/g, Coe = boe(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(yoe, function(n, o, l, r) {
    t.push(l ? r.replace(Soe, "$1") : o || n);
  }), t;
});
function woe(e) {
  return e == null ? "" : SB(e);
}
function yp(e, t) {
  return wl(e) ? e : SO(e, t) ? [e] : Coe(woe(e));
}
function Sp(e) {
  if (typeof e == "string" || y1(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function _1(e, t) {
  t = yp(t, e);
  for (var n = 0, o = t.length; e != null && n < o; )
    e = e[Sp(t[n++])];
  return n && n == o ? e : void 0;
}
function Oo(e, t, n) {
  var o = e == null ? void 0 : _1(e, t);
  return o === void 0 ? n : o;
}
function CO(e, t) {
  for (var n = -1, o = t.length, l = e.length; ++n < o; )
    e[l + n] = t[n];
  return e;
}
var j4 = ra ? ra.isConcatSpreadable : void 0;
function $oe(e) {
  return wl(e) || Bf(e) || !!(j4 && e && e[j4]);
}
function th(e, t, n, o, l) {
  var r = -1, a = e.length;
  for (n || (n = $oe), l || (l = []); ++r < a; ) {
    var i = e[r];
    t > 0 && n(i) ? t > 1 ? th(i, t - 1, n, o, l) : CO(l, i) : o || (l[l.length] = i);
  }
  return l;
}
function I0(e) {
  var t = e == null ? 0 : e.length;
  return t ? th(e, 1) : [];
}
function kB(e) {
  return wB(xB(e, void 0, I0), e + "");
}
var wO = TB(Object.getPrototypeOf, Object), xoe = "[object Object]", Eoe = Function.prototype, Ooe = Object.prototype, NB = Eoe.toString, _oe = Ooe.hasOwnProperty, Ioe = NB.call(Object);
function I1(e) {
  if (!Da(e) || Pc(e) != xoe)
    return !1;
  var t = wO(e);
  if (t === null)
    return !0;
  var n = _oe.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && NB.call(n) == Ioe;
}
function Toe(e, t, n) {
  var o = -1, l = e.length;
  t < 0 && (t = -t > l ? 0 : l + t), n = n > l ? l : n, n < 0 && (n += l), l = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var r = Array(l); ++o < l; )
    r[o] = e[o + t];
  return r;
}
function ll() {
  if (!arguments.length)
    return [];
  var e = arguments[0];
  return wl(e) ? e : [e];
}
function Poe(e, t, n) {
  return e === e && (n !== void 0 && (e = e <= n ? e : n), t !== void 0 && (e = e >= t ? e : t)), e;
}
function T1(e, t, n) {
  return n === void 0 && (n = t, t = void 0), n !== void 0 && (n = cf(n), n = n === n ? n : 0), t !== void 0 && (t = cf(t), t = t === t ? t : 0), Poe(cf(e), t, n);
}
function koe() {
  this.__data__ = new $s(), this.size = 0;
}
function Noe(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function Moe(e) {
  return this.__data__.get(e);
}
function Aoe(e) {
  return this.__data__.has(e);
}
var Roe = 200;
function Doe(e, t) {
  var n = this.__data__;
  if (n instanceof $s) {
    var o = n.__data__;
    if (!am || o.length < Roe - 1)
      return o.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new xs(o);
  }
  return n.set(e, t), this.size = n.size, this;
}
function xa(e) {
  var t = this.__data__ = new $s(e);
  this.size = t.size;
}
xa.prototype.clear = koe;
xa.prototype.delete = Noe;
xa.prototype.get = Moe;
xa.prototype.has = Aoe;
xa.prototype.set = Doe;
function Loe(e, t) {
  return e && gp(t, bp(t), e);
}
function Boe(e, t) {
  return e && gp(t, eh(t), e);
}
var MB = typeof exports == "object" && exports && !exports.nodeType && exports, W4 = MB && typeof module == "object" && module && !module.nodeType && module, Foe = W4 && W4.exports === MB, K4 = Foe ? Wa.Buffer : void 0, U4 = K4 ? K4.allocUnsafe : void 0;
function AB(e, t) {
  if (t)
    return e.slice();
  var n = e.length, o = U4 ? U4(n) : new e.constructor(n);
  return e.copy(o), o;
}
function Voe(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, l = 0, r = []; ++n < o; ) {
    var a = e[n];
    t(a, n, e) && (r[l++] = a);
  }
  return r;
}
function RB() {
  return [];
}
var zoe = Object.prototype, Hoe = zoe.propertyIsEnumerable, G4 = Object.getOwnPropertySymbols, $O = G4 ? function(e) {
  return e == null ? [] : (e = Object(e), Voe(G4(e), function(t) {
    return Hoe.call(e, t);
  }));
} : RB;
function joe(e, t) {
  return gp(e, $O(e), t);
}
var Woe = Object.getOwnPropertySymbols, DB = Woe ? function(e) {
  for (var t = []; e; )
    CO(t, $O(e)), e = wO(e);
  return t;
} : RB;
function Koe(e, t) {
  return gp(e, DB(e), t);
}
function LB(e, t, n) {
  var o = t(e);
  return wl(e) ? o : CO(o, n(e));
}
function q$(e) {
  return LB(e, bp, $O);
}
function BB(e) {
  return LB(e, eh, DB);
}
var J$ = ld(Wa, "DataView"), Z$ = ld(Wa, "Promise"), uf = ld(Wa, "Set"), Y4 = "[object Map]", Uoe = "[object Object]", X4 = "[object Promise]", q4 = "[object Set]", J4 = "[object WeakMap]", Z4 = "[object DataView]", Goe = od(J$), Yoe = od(am), Xoe = od(Z$), qoe = od(uf), Joe = od(X$), qr = Pc;
(J$ && qr(new J$(new ArrayBuffer(1))) != Z4 || am && qr(new am()) != Y4 || Z$ && qr(Z$.resolve()) != X4 || uf && qr(new uf()) != q4 || X$ && qr(new X$()) != J4) && (qr = function(e) {
  var t = Pc(e), n = t == Uoe ? e.constructor : void 0, o = n ? od(n) : "";
  if (o)
    switch (o) {
      case Goe:
        return Z4;
      case Yoe:
        return Y4;
      case Xoe:
        return X4;
      case qoe:
        return q4;
      case Joe:
        return J4;
    }
  return t;
});
var Zoe = Object.prototype, Qoe = Zoe.hasOwnProperty;
function ele(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && Qoe.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
var T0 = Wa.Uint8Array;
function xO(e) {
  var t = new e.constructor(e.byteLength);
  return new T0(t).set(new T0(e)), t;
}
function tle(e, t) {
  var n = t ? xO(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var nle = /\w*$/;
function ole(e) {
  var t = new e.constructor(e.source, nle.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var Q4 = ra ? ra.prototype : void 0, e3 = Q4 ? Q4.valueOf : void 0;
function lle(e) {
  return e3 ? Object(e3.call(e)) : {};
}
function FB(e, t) {
  var n = t ? xO(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var rle = "[object Boolean]", ale = "[object Date]", ile = "[object Map]", sle = "[object Number]", cle = "[object RegExp]", ule = "[object Set]", dle = "[object String]", fle = "[object Symbol]", ple = "[object ArrayBuffer]", vle = "[object DataView]", mle = "[object Float32Array]", hle = "[object Float64Array]", gle = "[object Int8Array]", ble = "[object Int16Array]", yle = "[object Int32Array]", Sle = "[object Uint8Array]", Cle = "[object Uint8ClampedArray]", wle = "[object Uint16Array]", $le = "[object Uint32Array]";
function xle(e, t, n) {
  var o = e.constructor;
  switch (t) {
    case ple:
      return xO(e);
    case rle:
    case ale:
      return new o(+e);
    case vle:
      return tle(e, n);
    case mle:
    case hle:
    case gle:
    case ble:
    case yle:
    case Sle:
    case Cle:
    case wle:
    case $le:
      return FB(e, n);
    case ile:
      return new o();
    case sle:
    case dle:
      return new o(e);
    case cle:
      return ole(e);
    case ule:
      return new o();
    case fle:
      return lle(e);
  }
}
function VB(e) {
  return typeof e.constructor == "function" && !w1(e) ? Rte(wO(e)) : {};
}
var Ele = "[object Map]";
function Ole(e) {
  return Da(e) && qr(e) == Ele;
}
var t3 = Vf && Vf.isMap, _le = t3 ? yO(t3) : Ole, Ile = "[object Set]";
function Tle(e) {
  return Da(e) && qr(e) == Ile;
}
var n3 = Vf && Vf.isSet, Ple = n3 ? yO(n3) : Tle, kle = 1, Nle = 2, Mle = 4, zB = "[object Arguments]", Ale = "[object Array]", Rle = "[object Boolean]", Dle = "[object Date]", Lle = "[object Error]", HB = "[object Function]", Ble = "[object GeneratorFunction]", Fle = "[object Map]", Vle = "[object Number]", jB = "[object Object]", zle = "[object RegExp]", Hle = "[object Set]", jle = "[object String]", Wle = "[object Symbol]", Kle = "[object WeakMap]", Ule = "[object ArrayBuffer]", Gle = "[object DataView]", Yle = "[object Float32Array]", Xle = "[object Float64Array]", qle = "[object Int8Array]", Jle = "[object Int16Array]", Zle = "[object Int32Array]", Qle = "[object Uint8Array]", ere = "[object Uint8ClampedArray]", tre = "[object Uint16Array]", nre = "[object Uint32Array]", bo = {};
bo[zB] = bo[Ale] = bo[Ule] = bo[Gle] = bo[Rle] = bo[Dle] = bo[Yle] = bo[Xle] = bo[qle] = bo[Jle] = bo[Zle] = bo[Fle] = bo[Vle] = bo[jB] = bo[zle] = bo[Hle] = bo[jle] = bo[Wle] = bo[Qle] = bo[ere] = bo[tre] = bo[nre] = !0;
bo[Lle] = bo[HB] = bo[Kle] = !1;
function df(e, t, n, o, l, r) {
  var a, i = t & kle, s = t & Nle, c = t & Mle;
  if (n && (a = l ? n(e, o, l, r) : n(e)), a !== void 0)
    return a;
  if (!lr(e))
    return e;
  var u = wl(e);
  if (u) {
    if (a = ele(e), !i)
      return CB(e, a);
  } else {
    var d = qr(e), f = d == HB || d == Ble;
    if (Ff(e))
      return AB(e, i);
    if (d == jB || d == zB || f && !l) {
      if (a = s || f ? {} : VB(e), !i)
        return s ? Koe(e, Boe(a, e)) : joe(e, Loe(a, e));
    } else {
      if (!bo[d])
        return l ? e : {};
      a = xle(e, d, i);
    }
  }
  r || (r = new xa());
  var p = r.get(e);
  if (p)
    return p;
  r.set(e, a), Ple(e) ? e.forEach(function(h) {
    a.add(df(h, t, n, h, e, r));
  }) : _le(e) && e.forEach(function(h, g) {
    a.set(g, df(h, t, n, g, e, r));
  });
  var m = c ? s ? BB : q$ : s ? eh : bp, v = u ? void 0 : m(e);
  return Wte(v || e, function(h, g) {
    v && (g = h, h = e[g]), hO(a, g, df(h, t, n, g, e, r));
  }), a;
}
var ore = 4;
function NC(e) {
  return df(e, ore);
}
var lre = 1, rre = 4;
function sc(e) {
  return df(e, lre | rre);
}
var are = "__lodash_hash_undefined__";
function ire(e) {
  return this.__data__.set(e, are), this;
}
function sre(e) {
  return this.__data__.has(e);
}
function zf(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new xs(); ++t < n; )
    this.add(e[t]);
}
zf.prototype.add = zf.prototype.push = ire;
zf.prototype.has = sre;
function cre(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length; ++n < o; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function P0(e, t) {
  return e.has(t);
}
var ure = 1, dre = 2;
function WB(e, t, n, o, l, r) {
  var a = n & ure, i = e.length, s = t.length;
  if (i != s && !(a && s > i))
    return !1;
  var c = r.get(e), u = r.get(t);
  if (c && u)
    return c == t && u == e;
  var d = -1, f = !0, p = n & dre ? new zf() : void 0;
  for (r.set(e, t), r.set(t, e); ++d < i; ) {
    var m = e[d], v = t[d];
    if (o)
      var h = a ? o(v, m, d, t, e, r) : o(m, v, d, e, t, r);
    if (h !== void 0) {
      if (h)
        continue;
      f = !1;
      break;
    }
    if (p) {
      if (!cre(t, function(g, y) {
        if (!P0(p, y) && (m === g || l(m, g, n, o, r)))
          return p.push(y);
      })) {
        f = !1;
        break;
      }
    } else if (!(m === v || l(m, v, n, o, r))) {
      f = !1;
      break;
    }
  }
  return r.delete(e), r.delete(t), f;
}
function fre(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(o, l) {
    n[++t] = [l, o];
  }), n;
}
function EO(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(o) {
    n[++t] = o;
  }), n;
}
var pre = 1, vre = 2, mre = "[object Boolean]", hre = "[object Date]", gre = "[object Error]", bre = "[object Map]", yre = "[object Number]", Sre = "[object RegExp]", Cre = "[object Set]", wre = "[object String]", $re = "[object Symbol]", xre = "[object ArrayBuffer]", Ere = "[object DataView]", o3 = ra ? ra.prototype : void 0, MC = o3 ? o3.valueOf : void 0;
function Ore(e, t, n, o, l, r, a) {
  switch (n) {
    case Ere:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case xre:
      return !(e.byteLength != t.byteLength || !r(new T0(e), new T0(t)));
    case mre:
    case hre:
    case yre:
      return Qm(+e, +t);
    case gre:
      return e.name == t.name && e.message == t.message;
    case Sre:
    case wre:
      return e == t + "";
    case bre:
      var i = fre;
    case Cre:
      var s = o & pre;
      if (i || (i = EO), e.size != t.size && !s)
        return !1;
      var c = a.get(e);
      if (c)
        return c == t;
      o |= vre, a.set(e, t);
      var u = WB(i(e), i(t), o, l, r, a);
      return a.delete(e), u;
    case $re:
      if (MC)
        return MC.call(e) == MC.call(t);
  }
  return !1;
}
var _re = 1, Ire = Object.prototype, Tre = Ire.hasOwnProperty;
function Pre(e, t, n, o, l, r) {
  var a = n & _re, i = q$(e), s = i.length, c = q$(t), u = c.length;
  if (s != u && !a)
    return !1;
  for (var d = s; d--; ) {
    var f = i[d];
    if (!(a ? f in t : Tre.call(t, f)))
      return !1;
  }
  var p = r.get(e), m = r.get(t);
  if (p && m)
    return p == t && m == e;
  var v = !0;
  r.set(e, t), r.set(t, e);
  for (var h = a; ++d < s; ) {
    f = i[d];
    var g = e[f], y = t[f];
    if (o)
      var b = a ? o(y, g, f, t, e, r) : o(g, y, f, e, t, r);
    if (!(b === void 0 ? g === y || l(g, y, n, o, r) : b)) {
      v = !1;
      break;
    }
    h || (h = f == "constructor");
  }
  if (v && !h) {
    var C = e.constructor, w = t.constructor;
    C != w && "constructor" in e && "constructor" in t && !(typeof C == "function" && C instanceof C && typeof w == "function" && w instanceof w) && (v = !1);
  }
  return r.delete(e), r.delete(t), v;
}
var kre = 1, l3 = "[object Arguments]", r3 = "[object Array]", tg = "[object Object]", Nre = Object.prototype, a3 = Nre.hasOwnProperty;
function Mre(e, t, n, o, l, r) {
  var a = wl(e), i = wl(t), s = a ? r3 : qr(e), c = i ? r3 : qr(t);
  s = s == l3 ? tg : s, c = c == l3 ? tg : c;
  var u = s == tg, d = c == tg, f = s == c;
  if (f && Ff(e)) {
    if (!Ff(t))
      return !1;
    a = !0, u = !1;
  }
  if (f && !u)
    return r || (r = new xa()), a || $1(e) ? WB(e, t, n, o, l, r) : Ore(e, t, s, n, o, l, r);
  if (!(n & kre)) {
    var p = u && a3.call(e, "__wrapped__"), m = d && a3.call(t, "__wrapped__");
    if (p || m) {
      var v = p ? e.value() : e, h = m ? t.value() : t;
      return r || (r = new xa()), l(v, h, n, o, r);
    }
  }
  return f ? (r || (r = new xa()), Pre(e, t, n, o, l, r)) : !1;
}
function P1(e, t, n, o, l) {
  return e === t ? !0 : e == null || t == null || !Da(e) && !Da(t) ? e !== e && t !== t : Mre(e, t, n, o, P1, l);
}
var Are = 1, Rre = 2;
function Dre(e, t, n, o) {
  var l = n.length, r = l;
  if (e == null)
    return !r;
  for (e = Object(e); l--; ) {
    var a = n[l];
    if (a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
      return !1;
  }
  for (; ++l < r; ) {
    a = n[l];
    var i = a[0], s = e[i], c = a[1];
    if (a[2]) {
      if (s === void 0 && !(i in e))
        return !1;
    } else {
      var u = new xa(), d;
      if (!(d === void 0 ? P1(c, s, Are | Rre, o, u) : d))
        return !1;
    }
  }
  return !0;
}
function KB(e) {
  return e === e && !lr(e);
}
function Lre(e) {
  for (var t = bp(e), n = t.length; n--; ) {
    var o = t[n], l = e[o];
    t[n] = [o, l, KB(l)];
  }
  return t;
}
function UB(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function Bre(e) {
  var t = Lre(e);
  return t.length == 1 && t[0][2] ? UB(t[0][0], t[0][1]) : function(n) {
    return n === e || Dre(n, e, t);
  };
}
function Fre(e, t) {
  return e != null && t in Object(e);
}
function GB(e, t, n) {
  t = yp(t, e);
  for (var o = -1, l = t.length, r = !1; ++o < l; ) {
    var a = Sp(t[o]);
    if (!(r = e != null && n(e, a)))
      break;
    e = e[a];
  }
  return r || ++o != l ? r : (l = e == null ? 0 : e.length, !!l && bO(l) && C1(a, l) && (wl(e) || Bf(e)));
}
function YB(e, t) {
  return e != null && GB(e, t, Fre);
}
var Vre = 1, zre = 2;
function Hre(e, t) {
  return SO(e) && KB(t) ? UB(Sp(e), t) : function(n) {
    var o = Oo(n, e);
    return o === void 0 && o === t ? YB(n, e) : P1(t, o, Vre | zre);
  };
}
function jre(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function Wre(e) {
  return function(t) {
    return _1(t, e);
  };
}
function Kre(e) {
  return SO(e) ? jre(Sp(e)) : Wre(e);
}
function nh(e) {
  return typeof e == "function" ? e : e == null ? fO : typeof e == "object" ? wl(e) ? Hre(e[0], e[1]) : Bre(e) : Kre(e);
}
function Ure(e, t, n, o) {
  for (var l = -1, r = e == null ? 0 : e.length; ++l < r; ) {
    var a = e[l];
    t(o, a, n(a), e);
  }
  return o;
}
function Gre(e) {
  return function(t, n, o) {
    for (var l = -1, r = Object(t), a = o(t), i = a.length; i--; ) {
      var s = a[++l];
      if (n(r[s], s, r) === !1)
        break;
    }
    return t;
  };
}
var XB = Gre();
function Yre(e, t) {
  return e && XB(e, t, bp);
}
function Xre(e, t) {
  return function(n, o) {
    if (n == null)
      return n;
    if (!kc(n))
      return e(n, o);
    for (var l = n.length, r = -1, a = Object(n); ++r < l && o(a[r], r, a) !== !1; )
      ;
    return n;
  };
}
var qB = Xre(Yre);
function qre(e, t, n, o) {
  return qB(e, function(l, r, a) {
    t(o, l, n(l), a);
  }), o;
}
function Jre(e, t) {
  return function(n, o) {
    var l = wl(n) ? Ure : qre, r = t ? t() : {};
    return l(n, e, nh(o), r);
  };
}
var AC = function() {
  return Wa.Date.now();
}, Zre = "Expected a function", Qre = Math.max, eae = Math.min;
function Dr(e, t, n) {
  var o, l, r, a, i, s, c = 0, u = !1, d = !1, f = !0;
  if (typeof e != "function")
    throw new TypeError(Zre);
  t = cf(t) || 0, lr(n) && (u = !!n.leading, d = "maxWait" in n, r = d ? Qre(cf(n.maxWait) || 0, t) : r, f = "trailing" in n ? !!n.trailing : f);
  function p(x) {
    var E = o, I = l;
    return o = l = void 0, c = x, a = e.apply(I, E), a;
  }
  function m(x) {
    return c = x, i = setTimeout(g, t), u ? p(x) : a;
  }
  function v(x) {
    var E = x - s, I = x - c, T = t - E;
    return d ? eae(T, r - I) : T;
  }
  function h(x) {
    var E = x - s, I = x - c;
    return s === void 0 || E >= t || E < 0 || d && I >= r;
  }
  function g() {
    var x = AC();
    if (h(x))
      return y(x);
    i = setTimeout(g, v(x));
  }
  function y(x) {
    return i = void 0, f && o ? p(x) : (o = l = void 0, a);
  }
  function b() {
    i !== void 0 && clearTimeout(i), c = 0, o = s = l = i = void 0;
  }
  function C() {
    return i === void 0 ? a : y(AC());
  }
  function w() {
    var x = AC(), E = h(x);
    if (o = arguments, l = this, s = x, E) {
      if (i === void 0)
        return m(s);
      if (d)
        return clearTimeout(i), i = setTimeout(g, t), p(s);
    }
    return i === void 0 && (i = setTimeout(g, t)), a;
  }
  return w.cancel = b, w.flush = C, w;
}
function Q$(e, t, n) {
  (n !== void 0 && !Qm(e[t], n) || n === void 0 && !(t in e)) && mO(e, t, n);
}
function OO(e) {
  return Da(e) && kc(e);
}
function ex(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
function tae(e) {
  return gp(e, eh(e));
}
function nae(e, t, n, o, l, r, a) {
  var i = ex(e, n), s = ex(t, n), c = a.get(s);
  if (c) {
    Q$(e, n, c);
    return;
  }
  var u = r ? r(i, s, n + "", e, t, a) : void 0, d = u === void 0;
  if (d) {
    var f = wl(s), p = !f && Ff(s), m = !f && !p && $1(s);
    u = s, f || p || m ? wl(i) ? u = i : OO(i) ? u = CB(i) : p ? (d = !1, u = AB(s, !0)) : m ? (d = !1, u = FB(s, !0)) : u = [] : I1(s) || Bf(s) ? (u = i, Bf(i) ? u = tae(i) : (!lr(i) || pO(i)) && (u = VB(s))) : d = !1;
  }
  d && (a.set(s, u), l(u, s, o, r, a), a.delete(s)), Q$(e, n, u);
}
function JB(e, t, n, o, l) {
  e !== t && XB(t, function(r, a) {
    if (l || (l = new xa()), lr(r))
      nae(e, t, a, n, JB, o, l);
    else {
      var i = o ? o(ex(e, a), r, a + "", e, t, l) : void 0;
      i === void 0 && (i = r), Q$(e, a, i);
    }
  }, eh);
}
function oae(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
function lae(e) {
  return function(t, n, o) {
    var l = Object(t);
    if (!kc(t)) {
      var r = nh(n);
      t = bp(t), n = function(i) {
        return r(l[i], i, l);
      };
    }
    var a = e(t, n, o);
    return a > -1 ? l[r ? t[a] : a] : void 0;
  };
}
var rae = Math.max;
function aae(e, t, n) {
  var o = e == null ? 0 : e.length;
  if (!o)
    return -1;
  var l = n == null ? 0 : bte(n);
  return l < 0 && (l = rae(o + l, 0)), vO(e, nh(t), l);
}
var iae = lae(aae);
function ZB(e, t, n) {
  var o = e == null ? 0 : e.length;
  if (!o)
    return -1;
  var l = o - 1;
  return vO(e, nh(t), l, !0);
}
function sae(e, t) {
  var n = -1, o = kc(e) ? Array(e.length) : [];
  return qB(e, function(l, r, a) {
    o[++n] = t(l, r, a);
  }), o;
}
function cae(e, t) {
  var n = wl(e) ? S1 : sae;
  return n(e, nh(t));
}
function QB(e, t) {
  return th(cae(e, t), 1);
}
var uae = 1 / 0;
function dae(e) {
  var t = e == null ? 0 : e.length;
  return t ? th(e, uae) : [];
}
function Hf(e) {
  for (var t = -1, n = e == null ? 0 : e.length, o = {}; ++t < n; ) {
    var l = e[t];
    o[l[0]] = l[1];
  }
  return o;
}
var fae = Object.prototype, pae = fae.hasOwnProperty;
function vae(e, t) {
  return e != null && pae.call(e, t);
}
function mae(e, t) {
  return e != null && GB(e, t, vae);
}
var hae = Math.min;
function gae(e, t, n) {
  for (var o = $B, l = e[0].length, r = e.length, a = r, i = Array(r), s = 1 / 0, c = []; a--; ) {
    var u = e[a];
    s = hae(u.length, s), i[a] = l >= 120 && u.length >= 120 ? new zf(a && u) : void 0;
  }
  u = e[0];
  var d = -1, f = i[0];
  e:
    for (; ++d < l && c.length < s; ) {
      var p = u[d], m = p;
      if (p = p !== 0 ? p : 0, !(f ? P0(f, m) : o(c, m))) {
        for (a = r; --a; ) {
          var v = i[a];
          if (!(v ? P0(v, m) : o(e[a], m)))
            continue e;
        }
        f && f.push(m), c.push(p);
      }
    }
  return c;
}
function bae(e) {
  return OO(e) ? e : [];
}
var yae = gO(function(e) {
  var t = S1(e, bae);
  return t.length && t[0] === e[0] ? gae(t) : [];
});
function Sae(e, t) {
  return t.length < 2 ? e : _1(e, Toe(t, 0, -1));
}
var Cae = "[object Map]", wae = "[object Set]", $ae = Object.prototype, xae = $ae.hasOwnProperty;
function e7(e) {
  if (e == null)
    return !0;
  if (kc(e) && (wl(e) || typeof e == "string" || typeof e.splice == "function" || Ff(e) || $1(e) || Bf(e)))
    return !e.length;
  var t = qr(e);
  if (t == Cae || t == wae)
    return !e.size;
  if (w1(e))
    return !PB(e).length;
  for (var n in e)
    if (xae.call(e, n))
      return !1;
  return !0;
}
function Jn(e, t) {
  return P1(e, t);
}
var Eae = "[object Number]";
function Oae(e) {
  return typeof e == "number" || Da(e) && Pc(e) == Eae;
}
function wo(e) {
  return e == null;
}
function k1(e) {
  return e === null;
}
function _ae(e) {
  return e === void 0;
}
var t7 = ene(function(e, t, n) {
  JB(e, t, n);
}), Iae = Object.prototype, Tae = Iae.hasOwnProperty;
function Pae(e, t) {
  t = yp(t, e);
  var n = -1, o = t.length;
  if (!o)
    return !0;
  for (var l = e == null || typeof e != "object" && typeof e != "function"; ++n < o; ) {
    var r = t[n];
    if (typeof r == "string") {
      if (r === "__proto__" && !Tae.call(e, "__proto__"))
        return !1;
      if (r === "constructor" && n + 1 < o && typeof t[n + 1] == "string" && t[n + 1] === "prototype") {
        if (l && n === 0)
          continue;
        return !1;
      }
    }
  }
  var a = Sae(e, t);
  return a == null || delete a[Sp(oae(t))];
}
function kae(e) {
  return I1(e) ? void 0 : e;
}
var Nae = 1, Mae = 2, Aae = 4, Cp = kB(function(e, t) {
  var n = {};
  if (e == null)
    return n;
  var o = !1;
  t = S1(t, function(r) {
    return r = yp(r, e), o || (o = r.length > 1), r;
  }), gp(e, BB(e), n), o && (n = df(n, Nae | Mae | Aae, kae));
  for (var l = t.length; l--; )
    Pae(n, t[l]);
  return n;
});
function n7(e, t, n, o) {
  if (!lr(e))
    return e;
  t = yp(t, e);
  for (var l = -1, r = t.length, a = r - 1, i = e; i != null && ++l < r; ) {
    var s = Sp(t[l]), c = n;
    if (s === "__proto__" || s === "constructor" || s === "prototype")
      return e;
    if (l != a) {
      var u = i[s];
      c = void 0, c === void 0 && (c = lr(u) ? u : C1(t[l + 1]) ? [] : {});
    }
    hO(i, s, c), i = i[s];
  }
  return e;
}
function Rae(e, t, n) {
  for (var o = -1, l = t.length, r = {}; ++o < l; ) {
    var a = t[o], i = _1(e, a);
    n(i, a) && n7(r, yp(a, e), i);
  }
  return r;
}
var Dae = Jre(function(e, t, n) {
  e[n ? 0 : 1].push(t);
}, function() {
  return [[], []];
});
function Lae(e, t) {
  return Rae(e, t, function(n, o) {
    return YB(e, o);
  });
}
var La = kB(function(e, t) {
  return e == null ? {} : Lae(e, t);
});
function Bae(e, t, n) {
  return e == null ? e : n7(e, t, n);
}
var Fae = "Expected a function";
function Qs(e, t, n) {
  var o = !0, l = !0;
  if (typeof e != "function")
    throw new TypeError(Fae);
  return lr(n) && (o = "leading" in n ? !!n.leading : o, l = "trailing" in n ? !!n.trailing : l), Dr(e, t, {
    leading: o,
    maxWait: t,
    trailing: l
  });
}
var Vae = 1 / 0, zae = uf && 1 / EO(new uf([, -0]))[1] == Vae ? function(e) {
  return new uf(e);
} : Lte, Hae = 200;
function o7(e, t, n) {
  var o = -1, l = $B, r = e.length, a = !0, i = [], s = i;
  if (r >= Hae) {
    var c = zae(e);
    if (c)
      return EO(c);
    a = !1, l = P0, s = new zf();
  } else
    s = i;
  e:
    for (; ++o < r; ) {
      var u = e[o], d = u;
      if (u = u !== 0 ? u : 0, a && d === d) {
        for (var f = s.length; f--; )
          if (s[f] === d)
            continue e;
        i.push(u);
      } else l(s, d, n) || (s !== i && s.push(d), i.push(u));
    }
  return i;
}
var RC = gO(function(e) {
  return o7(th(e, 1, OO, !0));
});
function DC(e) {
  return e && e.length ? o7(e) : [];
}
const fn = (e) => e === void 0, Tn = (e) => typeof e == "boolean", mt = (e) => typeof e == "number", Ql = (e) => !e && e !== 0 || We(e) && e.length === 0 || Mt(e) && !Object.keys(e).length, tr = (e) => typeof Element == "undefined" ? !1 : e instanceof Element, hr = (e) => wo(e), jae = (e) => rt(e) ? !Number.isNaN(Number(e)) : !1, oh = (e) => e === window;
function l7(e, t) {
  var n;
  const o = /* @__PURE__ */ Ce();
  return Ot(() => {
    o.value = e();
  }, vt(Be({}, t), {
    flush: (n = void 0) != null ? n : "sync"
  })), /* @__PURE__ */ Du(o);
}
function rd(e) {
  return NE() ? (ME(e), !0) : !1;
}
function kr(e) {
  return typeof e == "function" ? e() : S(e);
}
function Wae(e) {
  if (!/* @__PURE__ */ kn(e))
    return /* @__PURE__ */ kt(e);
  const t = new Proxy({}, {
    get(n, o, l) {
      return S(Reflect.get(e.value, o, l));
    },
    set(n, o, l) {
      return /* @__PURE__ */ kn(e.value[o]) && !/* @__PURE__ */ kn(l) ? e.value[o].value = l : e.value[o] = l, !0;
    },
    deleteProperty(n, o) {
      return Reflect.deleteProperty(e.value, o);
    },
    has(n, o) {
      return Reflect.has(e.value, o);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return /* @__PURE__ */ kt(t);
}
function Kae(e) {
  return Wae(O(e));
}
const Sn = typeof window != "undefined" && typeof document != "undefined";
typeof WorkerGlobalScope != "undefined" && globalThis instanceof WorkerGlobalScope;
const Uae = (e) => typeof e != "undefined", r7 = (e) => e != null, Gae = Object.prototype.toString, Yae = (e) => Gae.call(e) === "[object Object]", a7 = (e, t, n) => Math.min(n, Math.max(t, e)), Ea = () => {
}, k0 = /* @__PURE__ */ Xae();
function Xae() {
  var e, t;
  return Sn && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function i7(e, t) {
  function n(...o) {
    return new Promise((l, r) => {
      Promise.resolve(e(() => t.apply(this, o), { fn: t, thisArg: this, args: o })).then(l).catch(r);
    });
  }
  return n;
}
function qae(e, t = {}) {
  let n, o, l = Ea;
  const r = (i) => {
    clearTimeout(i), l(), l = Ea;
  };
  return (i) => {
    const s = kr(e), c = kr(t.maxWait);
    return n && r(n), s <= 0 || c !== void 0 && c <= 0 ? (o && (r(o), o = null), Promise.resolve(i())) : new Promise((u, d) => {
      l = t.rejectOnCancel ? d : u, c && !o && (o = setTimeout(() => {
        n && r(n), o = null, u(i());
      }, c)), n = setTimeout(() => {
        o && r(o), o = null, u(i());
      }, s);
    });
  };
}
function Jae(...e) {
  let t = 0, n, o = !0, l = Ea, r, a, i, s, c;
  !/* @__PURE__ */ kn(e[0]) && typeof e[0] == "object" ? { delay: a, trailing: i = !0, leading: s = !0, rejectOnCancel: c = !1 } = e[0] : [a, i = !0, s = !0, c = !1] = e;
  const u = () => {
    n && (clearTimeout(n), n = void 0, l(), l = Ea);
  };
  return (f) => {
    const p = kr(a), m = Date.now() - t, v = () => r = f();
    return u(), p <= 0 ? (t = Date.now(), v()) : (m > p && (s || !o) ? (t = Date.now(), v()) : i && (r = new Promise((h, g) => {
      l = c ? g : h, n = setTimeout(() => {
        t = Date.now(), o = !0, h(v()), u();
      }, Math.max(0, p - m));
    })), !s && !n && (n = setTimeout(() => o = !0, p)), o = !1, r);
  };
}
function Zae(e) {
  return xt();
}
function lh(e, t = 200, n = {}) {
  return i7(
    qae(t, n),
    e
  );
}
function Qae(e, t = 200, n = {}) {
  const o = /* @__PURE__ */ H(e.value), l = lh(() => {
    o.value = e.value;
  }, t, n);
  return pe(e, () => l()), o;
}
function s7(e, t = 200, n = !1, o = !0, l = !1) {
  return i7(
    Jae(t, n, o, l),
    e
  );
}
function _O(e, t = !0, n) {
  Zae() ? nt(e, n) : t ? e() : Ke(e);
}
function jf(e, t, n = {}) {
  const {
    immediate: o = !0
  } = n, l = /* @__PURE__ */ H(!1);
  let r = null;
  function a() {
    r && (clearTimeout(r), r = null);
  }
  function i() {
    l.value = !1, a();
  }
  function s(...c) {
    a(), l.value = !0, r = setTimeout(() => {
      l.value = !1, r = null, e(...c);
    }, kr(t));
  }
  return o && (l.value = !0, Sn && s()), rd(i), {
    isPending: /* @__PURE__ */ Du(l),
    start: s,
    stop: i
  };
}
function Lo(e) {
  var t;
  const n = kr(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const Ka = Sn ? window : void 0, eie = Sn ? window.document : void 0;
function wn(...e) {
  let t, n, o, l;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([n, o, l] = e, t = Ka) : [t, n, o, l] = e, !t)
    return Ea;
  Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]);
  const r = [], a = () => {
    r.forEach((u) => u()), r.length = 0;
  }, i = (u, d, f, p) => (u.addEventListener(d, f, p), () => u.removeEventListener(d, f, p)), s = pe(
    () => [Lo(t), kr(l)],
    ([u, d]) => {
      if (a(), !u)
        return;
      const f = Yae(d) ? Be({}, d) : d;
      r.push(
        ...n.flatMap((p) => o.map((m) => i(u, p, m, f)))
      );
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    s(), a();
  };
  return rd(c), c;
}
let i3 = !1;
function IO(e, t, n = {}) {
  const { window: o = Ka, ignore: l = [], capture: r = !0, detectIframe: a = !1 } = n;
  if (!o)
    return Ea;
  k0 && !i3 && (i3 = !0, Array.from(o.document.body.children).forEach((f) => f.addEventListener("click", Ea)), o.document.documentElement.addEventListener("click", Ea));
  let i = !0;
  const s = (f) => l.some((p) => {
    if (typeof p == "string")
      return Array.from(o.document.querySelectorAll(p)).some((m) => m === f.target || f.composedPath().includes(m));
    {
      const m = Lo(p);
      return m && (f.target === m || f.composedPath().includes(m));
    }
  }), u = [
    wn(o, "click", (f) => {
      const p = Lo(e);
      if (!(!p || p === f.target || f.composedPath().includes(p))) {
        if (f.detail === 0 && (i = !s(f)), !i) {
          i = !0;
          return;
        }
        t(f);
      }
    }, { passive: !0, capture: r }),
    wn(o, "pointerdown", (f) => {
      const p = Lo(e);
      i = !s(f) && !!(p && !f.composedPath().includes(p));
    }, { passive: !0 }),
    a && wn(o, "blur", (f) => {
      setTimeout(() => {
        var p;
        const m = Lo(e);
        ((p = o.document.activeElement) == null ? void 0 : p.tagName) === "IFRAME" && !(m != null && m.contains(o.document.activeElement)) && t(f);
      }, 0);
    })
  ].filter(Boolean);
  return () => u.forEach((f) => f());
}
function tie() {
  const e = /* @__PURE__ */ H(!1), t = xt();
  return t && nt(() => {
    e.value = !0;
  }, t), e;
}
function N1(e) {
  const t = tie();
  return O(() => (t.value, !!e()));
}
function rh(e, t, n = {}) {
  const f = n, { window: o = Ka } = f, l = Hr(f, ["window"]);
  let r;
  const a = N1(() => o && "MutationObserver" in o), i = () => {
    r && (r.disconnect(), r = void 0);
  }, s = O(() => {
    const p = kr(e), m = (Array.isArray(p) ? p : [p]).map(Lo).filter(r7);
    return new Set(m);
  }), c = pe(
    () => s.value,
    (p) => {
      i(), a.value && p.size && (r = new MutationObserver(t), p.forEach((m) => r.observe(m, l)));
    },
    { immediate: !0, flush: "post" }
  ), u = () => r == null ? void 0 : r.takeRecords(), d = () => {
    i(), c();
  };
  return rd(d), {
    isSupported: a,
    stop: d,
    takeRecords: u
  };
}
function nie(e = {}) {
  var t;
  const {
    window: n = Ka,
    deep: o = !0,
    triggerOnRemoval: l = !1
  } = e, r = (t = e.document) != null ? t : n == null ? void 0 : n.document, a = () => {
    var c;
    let u = r == null ? void 0 : r.activeElement;
    if (o)
      for (; u != null && u.shadowRoot; )
        u = (c = u == null ? void 0 : u.shadowRoot) == null ? void 0 : c.activeElement;
    return u;
  }, i = /* @__PURE__ */ H(), s = () => {
    i.value = a();
  };
  return n && (wn(n, "blur", (c) => {
    c.relatedTarget === null && s();
  }, !0), wn(n, "focus", s, !0)), l && rh(r, (c) => {
    c.filter((u) => u.removedNodes.length).map((u) => Array.from(u.removedNodes)).flat().forEach((u) => {
      u === i.value && s();
    });
  }, {
    childList: !0,
    subtree: !0
  }), s(), i;
}
function oie(e, t = {}) {
  const { window: n = Ka } = t, o = N1(() => n && "matchMedia" in n && typeof n.matchMedia == "function");
  let l;
  const r = /* @__PURE__ */ H(!1), a = (c) => {
    r.value = c.matches;
  }, i = () => {
    l && ("removeEventListener" in l ? l.removeEventListener("change", a) : l.removeListener(a));
  }, s = Ot(() => {
    o.value && (i(), l = n.matchMedia(kr(e)), "addEventListener" in l ? l.addEventListener("change", a) : l.addListener(a), r.value = l.matches);
  });
  return rd(() => {
    s(), i(), l = void 0;
  }), r;
}
function lie(e) {
  return JSON.parse(JSON.stringify(e));
}
function rie(e, t, n = {}) {
  const { window: o = Ka, initialValue: l = "", observe: r = !1 } = n, a = /* @__PURE__ */ H(l), i = O(() => {
    var c;
    return Lo(t) || ((c = o == null ? void 0 : o.document) == null ? void 0 : c.documentElement);
  });
  function s() {
    var c;
    const u = kr(e), d = kr(i);
    if (d && o) {
      const f = (c = o.getComputedStyle(d).getPropertyValue(u)) == null ? void 0 : c.trim();
      a.value = f || l;
    }
  }
  return r && rh(i, s, {
    attributeFilter: ["style", "class"],
    window: o
  }), pe(
    [i, () => kr(e)],
    s,
    { immediate: !0 }
  ), pe(
    a,
    (c) => {
      var u;
      (u = i.value) != null && u.style && i.value.style.setProperty(kr(e), c);
    }
  ), a;
}
function aie(e = {}) {
  const { document: t = eie } = e;
  if (!t)
    return /* @__PURE__ */ H("visible");
  const n = /* @__PURE__ */ H(t.visibilityState);
  return wn(t, "visibilitychange", () => {
    n.value = t.visibilityState;
  }), n;
}
function Xn(e, t, n = {}) {
  const d = n, { window: o = Ka } = d, l = Hr(d, ["window"]);
  let r;
  const a = N1(() => o && "ResizeObserver" in o), i = () => {
    r && (r.disconnect(), r = void 0);
  }, s = O(() => Array.isArray(e) ? e.map((f) => Lo(f)) : [Lo(e)]), c = pe(
    s,
    (f) => {
      if (i(), a.value && o) {
        r = new ResizeObserver(t);
        for (const p of f)
          p && r.observe(p, l);
      }
    },
    { immediate: !0, flush: "post" }
  ), u = () => {
    i(), c();
  };
  return rd(u), {
    isSupported: a,
    stop: u
  };
}
function s3(e, t = {}) {
  const {
    reset: n = !0,
    windowResize: o = !0,
    windowScroll: l = !0,
    immediate: r = !0
  } = t, a = /* @__PURE__ */ H(0), i = /* @__PURE__ */ H(0), s = /* @__PURE__ */ H(0), c = /* @__PURE__ */ H(0), u = /* @__PURE__ */ H(0), d = /* @__PURE__ */ H(0), f = /* @__PURE__ */ H(0), p = /* @__PURE__ */ H(0);
  function m() {
    const v = Lo(e);
    if (!v) {
      n && (a.value = 0, i.value = 0, s.value = 0, c.value = 0, u.value = 0, d.value = 0, f.value = 0, p.value = 0);
      return;
    }
    const h = v.getBoundingClientRect();
    a.value = h.height, i.value = h.bottom, s.value = h.left, c.value = h.right, u.value = h.top, d.value = h.width, f.value = h.x, p.value = h.y;
  }
  return Xn(e, m), pe(() => Lo(e), (v) => !v && m()), rh(e, m, {
    attributeFilter: ["style", "class"]
  }), l && wn("scroll", m, { capture: !0, passive: !0 }), o && wn("resize", m, { passive: !0 }), _O(() => {
    r && m();
  }), {
    height: a,
    bottom: i,
    left: s,
    right: c,
    top: u,
    width: d,
    x: f,
    y: p,
    update: m
  };
}
function tx(e, t = { width: 0, height: 0 }, n = {}) {
  const { window: o = Ka, box: l = "content-box" } = n, r = O(() => {
    var d, f;
    return (f = (d = Lo(e)) == null ? void 0 : d.namespaceURI) == null ? void 0 : f.includes("svg");
  }), a = /* @__PURE__ */ H(t.width), i = /* @__PURE__ */ H(t.height), { stop: s } = Xn(
    e,
    ([d]) => {
      const f = l === "border-box" ? d.borderBoxSize : l === "content-box" ? d.contentBoxSize : d.devicePixelContentBoxSize;
      if (o && r.value) {
        const p = Lo(e);
        if (p) {
          const m = p.getBoundingClientRect();
          a.value = m.width, i.value = m.height;
        }
      } else if (f) {
        const p = Array.isArray(f) ? f : [f];
        a.value = p.reduce((m, { inlineSize: v }) => m + v, 0), i.value = p.reduce((m, { blockSize: v }) => m + v, 0);
      } else
        a.value = d.contentRect.width, i.value = d.contentRect.height;
    },
    n
  );
  _O(() => {
    const d = Lo(e);
    d && (a.value = "offsetWidth" in d ? d.offsetWidth : t.width, i.value = "offsetHeight" in d ? d.offsetHeight : t.height);
  });
  const c = pe(
    () => Lo(e),
    (d) => {
      a.value = d ? t.width : 0, i.value = d ? t.height : 0;
    }
  );
  function u() {
    s(), c();
  }
  return {
    width: a,
    height: i,
    stop: u
  };
}
function iie(e, t, n = {}) {
  const {
    root: o,
    rootMargin: l = "0px",
    threshold: r = 0.1,
    window: a = Ka,
    immediate: i = !0
  } = n, s = N1(() => a && "IntersectionObserver" in a), c = O(() => {
    const m = kr(e);
    return (Array.isArray(m) ? m : [m]).map(Lo).filter(r7);
  });
  let u = Ea;
  const d = /* @__PURE__ */ H(i), f = s.value ? pe(
    () => [c.value, Lo(o), d.value],
    ([m, v]) => {
      if (u(), !d.value || !m.length)
        return;
      const h = new IntersectionObserver(
        t,
        {
          root: Lo(v),
          rootMargin: l,
          threshold: r
        }
      );
      m.forEach((g) => g && h.observe(g)), u = () => {
        h.disconnect(), u = Ea;
      };
    },
    { immediate: i, flush: "post" }
  ) : Ea, p = () => {
    u(), f(), d.value = !1;
  };
  return rd(p), {
    isSupported: s,
    isActive: d,
    pause() {
      u(), d.value = !1;
    },
    resume() {
      d.value = !0;
    },
    stop: p
  };
}
function c7(e, t, n, o = {}) {
  var l, r, a;
  const {
    clone: i = !1,
    passive: s = !1,
    eventName: c,
    deep: u = !1,
    defaultValue: d,
    shouldEmit: f
  } = o, p = xt(), m = n || (p == null ? void 0 : p.emit) || ((l = p == null ? void 0 : p.$emit) == null ? void 0 : l.bind(p)) || ((a = (r = p == null ? void 0 : p.proxy) == null ? void 0 : r.$emit) == null ? void 0 : a.bind(p == null ? void 0 : p.proxy));
  let v = c;
  t || (t = "modelValue"), v = v || `update:${t.toString()}`;
  const h = (b) => i ? typeof i == "function" ? i(b) : lie(b) : b, g = () => Uae(e[t]) ? h(e[t]) : d, y = (b) => {
    f ? f(b) && m(v, b) : m(v, b);
  };
  if (s) {
    const b = g(), C = /* @__PURE__ */ H(b);
    let w = !1;
    return pe(
      () => e[t],
      (x) => {
        w || (w = !0, C.value = h(x), Ke(() => w = !1));
      }
    ), pe(
      C,
      (x) => {
        !w && (x !== e[t] || u) && y(x);
      },
      { deep: u }
    ), C;
  } else
    return O({
      get() {
        return g();
      },
      set(b) {
        y(b);
      }
    });
}
function sie(e = {}) {
  const { window: t = Ka } = e;
  if (!t)
    return /* @__PURE__ */ H(!1);
  const n = /* @__PURE__ */ H(t.document.hasFocus());
  return wn(t, "blur", () => {
    n.value = !1;
  }), wn(t, "focus", () => {
    n.value = !0;
  }), n;
}
function TO(e = {}) {
  const {
    window: t = Ka,
    initialWidth: n = Number.POSITIVE_INFINITY,
    initialHeight: o = Number.POSITIVE_INFINITY,
    listenOrientation: l = !0,
    includeScrollbar: r = !0
  } = e, a = /* @__PURE__ */ H(n), i = /* @__PURE__ */ H(o), s = () => {
    t && (r ? (a.value = t.innerWidth, i.value = t.innerHeight) : (a.value = t.document.documentElement.clientWidth, i.value = t.document.documentElement.clientHeight));
  };
  if (s(), _O(s), wn("resize", s, { passive: !0 }), l) {
    const c = oie("(orientation: portrait)");
    pe(c, () => s());
  }
  return { width: a, height: i };
}
class u7 extends Error {
  constructor(t) {
    super(t), this.name = "ElementPlusError";
  }
}
function no(e, t) {
  throw new u7(`[${e}] ${t}`);
}
function Gt(e, t) {
  if (process.env.NODE_ENV !== "production") {
    const n = rt(e) ? new u7(`[${e}] ${t}`) : e;
    console.warn(n);
  }
}
const c3 = {
  current: 0
}, u3 = /* @__PURE__ */ H(0), d7 = 2e3, d3 = Symbol("elZIndexContextKey"), f7 = Symbol("zIndexContextKey"), ah = (e) => {
  const t = xt() ? ze(d3, c3) : c3, n = e || (xt() ? ze(f7, void 0) : void 0), o = O(() => {
    const a = S(n);
    return mt(a) ? a : d7;
  }), l = O(() => o.value + u3.value), r = () => (t.current++, u3.value = t.current, l.value);
  return !Sn && !ze(d3) && Gt(
    "ZIndexInjection",
    `Looks like you are using server rendering, you must provide a z-index provider to ensure the hydration process to be succeed
usage: app.provide(ZINDEX_INJECTION_KEY, { current: 0 })`
  ), {
    initialZIndex: o,
    currentZIndex: l,
    nextZIndex: r
  };
};
var cie = {
  name: "en",
  el: {
    breadcrumb: {
      label: "Breadcrumb"
    },
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color.",
      alphaLabel: "pick alpha value",
      alphaDescription: "alpha {alpha}, current color is {color}",
      hueLabel: "pick hue value",
      hueDescription: "hue {hue}, current color is {color}",
      svLabel: "pick saturation and brightness value",
      svDescription: "saturation {saturation}, brightness {brightness}, current color is {color}",
      predefineDescription: "select {value} as the color"
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    mention: {
      loading: "Loading"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum",
      selectAllLabel: "Select all rows",
      selectRowLabel: "Select this row",
      expandRowLabel: "Expand this row",
      collapseRowLabel: "Collapse this row",
      sortLabel: "Sort by {column}",
      filterLabel: "Filter by {column}"
    },
    tag: {
      close: "Close this tag"
    },
    tour: {
      next: "Next",
      previous: "Previous",
      finish: "Finish",
      close: "Close this dialog"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    },
    carousel: {
      leftArrow: "Carousel arrow left",
      rightArrow: "Carousel arrow right",
      indicator: "Carousel switch to index {index}"
    }
  }
};
const uie = (e) => (t, n) => die(t, n, S(e)), die = (e, t, n) => Oo(n, e, e).replace(
  /\{(\w+)\}/g,
  (o, l) => {
    var r;
    return `${(r = t == null ? void 0 : t[l]) != null ? r : `{${l}}`}`;
  }
), fie = (e) => ({
  lang: O(() => S(e).name),
  locale: /* @__PURE__ */ kn(e) ? e : /* @__PURE__ */ H(e),
  t: uie(e)
}), p7 = Symbol("localeContextKey"), an = (e) => {
  const t = e || ze(p7, /* @__PURE__ */ H());
  return fie(O(() => t.value || cie));
}, v7 = "__epPropKey", ye = (e) => e, pie = (e) => Mt(e) && !!e[v7], Ua = (e, t) => {
  if (!Mt(e) || pie(e))
    return e;
  const { values: n, required: o, default: l, type: r, validator: a } = e, s = {
    type: r,
    required: !!o,
    validator: n || a ? (c) => {
      let u = !1, d = [];
      if (n && (d = Array.from(n), hn(e, "default") && d.push(l), u || (u = d.includes(c))), a && (u || (u = a(c))), !u && d.length > 0) {
        const f = [...new Set(d)].map((p) => JSON.stringify(p)).join(", ");
        $a(
          `Invalid prop: validation failed${t ? ` for prop "${t}"` : ""}. Expected one of [${f}], got value ${JSON.stringify(
            c
          )}.`
        );
      }
      return u;
    } : void 0,
    [v7]: !0
  };
  return hn(e, "default") && (s.default = l), s;
}, Xe = (e) => Hf(
  Object.entries(e).map(([t, n]) => [
    t,
    Ua(n, t)
  ])
), ki = ["", "default", "small", "large"], Bo = Ua({
  type: String,
  values: ki,
  required: !1
}), m7 = Symbol("size"), h7 = () => {
  const e = ze(m7, {});
  return O(() => S(e.size) || "");
}, g7 = Symbol("emptyValuesContextKey"), vie = "use-empty-values", mie = ["", void 0, null], hie = void 0, ad = Xe({
  emptyValues: Array,
  valueOnClear: {
    type: ye([
      String,
      Number,
      Boolean,
      Function
    ]),
    default: void 0,
    validator: (e) => (e = it(e) ? e() : e, We(e) ? e.every((t) => !t) : !e)
  }
}), ih = (e, t) => {
  const n = xt() ? ze(g7, /* @__PURE__ */ H({})) : /* @__PURE__ */ H({}), o = O(
    () => e.emptyValues || n.value.emptyValues || mie
  ), l = O(() => it(e.valueOnClear) ? e.valueOnClear() : e.valueOnClear !== void 0 ? e.valueOnClear : it(n.value.valueOnClear) ? n.value.valueOnClear() : n.value.valueOnClear !== void 0 ? n.value.valueOnClear : t !== void 0 ? t : hie), r = (a) => {
    let i = !0;
    return We(a) ? i = o.value.some((s) => Jn(a, s)) : i = o.value.includes(a), i;
  };
  return r(l.value) || Gt(vie, "value-on-clear should be a value of empty-values"), {
    emptyValues: o,
    valueOnClear: l,
    isEmptyValue: r
  };
}, im = (e) => Object.keys(e), b7 = (e) => Object.entries(e), ff = (e, t, n) => ({
  get value() {
    return Oo(e, t, n);
  },
  set value(o) {
    Bae(e, t, o);
  }
}), N0 = /* @__PURE__ */ H();
function wp(e, t = void 0) {
  const n = xt() ? ze(hB, N0) : N0;
  return e ? O(() => {
    var o, l;
    return (l = (o = n.value) == null ? void 0 : o[e]) != null ? l : t;
  }) : n;
}
function M1(e, t) {
  const n = wp(), o = Ve(
    e,
    O(() => {
      var i;
      return ((i = n.value) == null ? void 0 : i.namespace) || _v;
    })
  ), l = an(O(() => {
    var i;
    return (i = n.value) == null ? void 0 : i.locale;
  })), r = ah(
    O(() => {
      var i;
      return ((i = n.value) == null ? void 0 : i.zIndex) || d7;
    })
  ), a = O(() => {
    var i;
    return S(t) || ((i = n.value) == null ? void 0 : i.size) || "";
  });
  return PO(O(() => S(n) || {})), {
    ns: o,
    locale: l,
    zIndex: r,
    size: a
  };
}
const PO = (e, t, n = !1) => {
  var o;
  const l = !!xt(), r = l ? wp() : void 0, a = (o = t == null ? void 0 : t.provide) != null ? o : l ? at : void 0;
  if (!a) {
    Gt(
      "provideGlobalConfig",
      "provideGlobalConfig() can only be used inside setup()."
    );
    return;
  }
  const i = O(() => {
    const s = S(e);
    return r != null && r.value ? gie(r.value, s) : s;
  });
  return a(hB, i), a(
    p7,
    O(() => i.value.locale)
  ), a(
    gB,
    O(() => i.value.namespace)
  ), a(
    f7,
    O(() => i.value.zIndex)
  ), a(m7, {
    size: O(() => i.value.size || "")
  }), a(
    g7,
    O(() => ({
      emptyValues: i.value.emptyValues,
      valueOnClear: i.value.valueOnClear
    }))
  ), (n || !N0.value) && (N0.value = i.value), i;
}, gie = (e, t) => {
  const n = [.../* @__PURE__ */ new Set([...im(e), ...im(t)])], o = {};
  for (const l of n)
    o[l] = t[l] !== void 0 ? t[l] : e[l];
  return o;
}, bie = (e = []) => ({
  version: qee,
  install: (n, o) => {
    n[P4] || (n[P4] = !0, e.forEach((l) => n.use(l)), o && PO(o, n, !0));
  }
}), sh = Xe({
  to: {
    type: ye([String, Object]),
    required: !0
  },
  disabled: Boolean
});
var Je = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, l] of t)
    n[o] = l;
  return n;
};
const yie = /* @__PURE__ */ le({
  __name: "teleport",
  props: sh,
  setup(e) {
    return (t, n) => t.disabled ? Oe(t.$slots, "default", { key: 0 }) : (G(), Me(a1, {
      key: 1,
      to: t.to
    }, [
      Oe(t.$slots, "default")
    ], 8, ["to"]));
  }
});
var Sie = /* @__PURE__ */ Je(yie, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/teleport/src/teleport.vue"]]);
const Dt = (e, t) => {
  if (e.install = (n) => {
    for (const o of [e, ...Object.values(t != null ? t : {})])
      n.component(o.name, o);
  }, t)
    for (const [n, o] of Object.entries(t))
      e[n] = o;
  return e;
}, y7 = (e, t) => (e.install = (n) => {
  e._context = n._context, n.config.globalProperties[t] = e;
}, e), Cie = (e, t) => (e.install = (n) => {
  n.directive(t, e);
}, e), oo = (e) => (e.install = gn, e), $p = Dt(Sie), It = "update:modelValue", en = "change", Po = "input", wie = Xe({
  zIndex: {
    type: ye([Number, String]),
    default: 100
  },
  target: {
    type: String,
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  position: {
    type: String,
    values: ["top", "bottom"],
    default: "top"
  },
  teleported: Boolean,
  appendTo: {
    type: sh.to.type,
    default: "body"
  }
}), $ie = {
  scroll: ({ scrollTop: e, fixed: t }) => mt(e) && Tn(t),
  [en]: (e) => Tn(e)
};
function xie(e, t, n, o) {
  const l = n - t;
  return e /= o / 2, e < 1 ? l / 2 * e * e * e + t : l / 2 * ((e -= 2) * e * e + 2) + t;
}
const Ci = (e) => Sn ? window.requestAnimationFrame(e) : setTimeout(e, 16), vs = (e) => Sn ? window.cancelAnimationFrame(e) : clearTimeout(e), Eie = "utils/dom/style", S7 = (e = "") => e.split(" ").filter((t) => !!t.trim()), pi = (e, t) => {
  if (!e || !t)
    return !1;
  if (t.includes(" "))
    throw new Error("className should not contain space.");
  return e.classList.contains(t);
}, Zr = (e, t) => {
  !e || !t.trim() || e.classList.add(...S7(t));
}, Al = (e, t) => {
  !e || !t.trim() || e.classList.remove(...S7(t));
}, ts = (e, t) => {
  var n;
  if (!Sn || !e || !t)
    return "";
  let o = vl(t);
  o === "float" && (o = "cssFloat");
  try {
    const l = e.style[o];
    if (l)
      return l;
    const r = (n = document.defaultView) == null ? void 0 : n.getComputedStyle(e, "");
    return r ? r[o] : "";
  } catch (l) {
    return e.style[o];
  }
}, C7 = (e, t, n) => {
  if (!(!e || !t))
    if (Mt(t))
      b7(t).forEach(
        ([o, l]) => C7(e, o, l)
      );
    else {
      const o = vl(t);
      e.style[o] = n;
    }
};
function ao(e, t = "px") {
  if (!e && e !== 0)
    return "";
  if (mt(e) || jae(e))
    return `${e}${t}`;
  if (rt(e))
    return e;
  Gt(Eie, "binding value must be a string or number");
}
const Oie = (e, t) => {
  if (!Sn)
    return !1;
  const n = {
    undefined: "overflow",
    true: "overflow-y",
    false: "overflow-x"
  }[String(t)], o = ts(e, n);
  return ["scroll", "auto", "overlay"].some((l) => o.includes(l));
}, kO = (e, t) => {
  if (!Sn)
    return;
  let n = e;
  for (; n; ) {
    if ([window, document, document.documentElement].includes(n))
      return window;
    if (Oie(n, t))
      return n;
    n = n.parentNode;
  }
  return n;
};
let ng;
const w7 = (e) => {
  var t;
  if (!Sn)
    return 0;
  if (ng !== void 0)
    return ng;
  const n = document.createElement("div");
  n.className = `${e}-scrollbar__wrap`, n.style.visibility = "hidden", n.style.width = "100px", n.style.position = "absolute", n.style.top = "-9999px", document.body.appendChild(n);
  const o = n.offsetWidth;
  n.style.overflow = "scroll";
  const l = document.createElement("div");
  l.style.width = "100%", n.appendChild(l);
  const r = l.offsetWidth;
  return (t = n.parentNode) == null || t.removeChild(n), ng = o - r, ng;
};
function NO(e, t) {
  if (!Sn)
    return;
  if (!t) {
    e.scrollTop = 0;
    return;
  }
  const n = [];
  let o = t.offsetParent;
  for (; o !== null && e !== o && e.contains(o); )
    n.push(o), o = o.offsetParent;
  const l = t.offsetTop + n.reduce((s, c) => s + c.offsetTop, 0), r = l + t.offsetHeight, a = e.scrollTop, i = a + e.clientHeight;
  l < a ? e.scrollTop = l : r > i && (e.scrollTop = r - e.clientHeight);
}
function _ie(e, t, n, o, l) {
  const r = Date.now();
  let a;
  const i = () => {
    const c = Date.now() - r, u = xie(
      c > o ? o : c,
      t,
      n,
      o
    );
    oh(e) ? e.scrollTo(window.pageXOffset, u) : e.scrollTop = u, c < o ? a = Ci(i) : it(l) && l();
  };
  return i(), () => {
    a && vs(a);
  };
}
const f3 = (e, t) => oh(t) ? e.ownerDocument.documentElement : t, p3 = (e) => oh(e) ? window.scrollY : e.scrollTop, v3 = "ElAffix", Iie = /* @__PURE__ */ le({
  name: v3,
  __name: "affix",
  props: wie,
  emits: $ie,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = Ve("affix"), a = /* @__PURE__ */ Ce(), i = /* @__PURE__ */ Ce(), s = /* @__PURE__ */ Ce(), { height: c } = TO(), {
      height: u,
      width: d,
      top: f,
      bottom: p,
      left: m,
      update: v
    } = s3(i, { windowScroll: !1 }), h = s3(a), g = /* @__PURE__ */ H(!1), y = /* @__PURE__ */ H(0), b = /* @__PURE__ */ H(0), C = O(() => !o.teleported || !g.value), w = O(() => ({
      height: g.value ? `${u.value}px` : "",
      width: g.value ? `${d.value}px` : ""
    })), x = O(() => {
      if (!g.value)
        return {};
      const P = ao(o.offset);
      return {
        height: `${u.value}px`,
        width: `${d.value}px`,
        top: o.position === "top" ? P : "",
        bottom: o.position === "bottom" ? P : "",
        left: o.teleported ? `${m.value}px` : "",
        transform: b.value ? `translateY(${b.value}px)` : "",
        zIndex: o.zIndex
      };
    }), E = () => {
      if (!s.value)
        return;
      y.value = s.value instanceof Window ? document.documentElement.scrollTop : s.value.scrollTop || 0;
      const { position: P, target: k, offset: N } = o, R = N + u.value;
      if (P === "top")
        if (k) {
          const z = h.bottom.value - R;
          g.value = N > f.value && h.bottom.value > 0, b.value = z < 0 ? z : 0;
        } else
          g.value = N > f.value;
      else if (k) {
        const z = c.value - h.top.value - R;
        g.value = c.value - N < p.value && c.value > h.top.value, b.value = z < 0 ? -z : 0;
      } else
        g.value = c.value - N < p.value;
    }, I = () => Rt(this, null, function* () {
      if (!g.value) {
        v();
        return;
      }
      g.value = !1, yield Ke(), v(), g.value = !0;
    }), T = () => Rt(this, null, function* () {
      v(), yield Ke(), l("scroll", {
        scrollTop: y.value,
        fixed: g.value
      });
    });
    return pe(g, (P) => l(en, P)), nt(() => {
      var P;
      o.target ? (a.value = (P = document.querySelector(o.target)) != null ? P : void 0, a.value || no(v3, `Target does not exist: ${o.target}`)) : a.value = document.documentElement, s.value = kO(i.value, !0), v();
    }), wn(s, "scroll", T), Ot(E), t({
      update: E,
      updateRoot: I
    }), (P, k) => (G(), ue(
      "div",
      {
        ref_key: "root",
        ref: i,
        class: X(S(r).b()),
        style: gt(w.value)
      },
      [
        $(S($p), {
          disabled: C.value,
          to: P.appendTo
        }, {
          default: Ee(() => [
            ve(
              "div",
              {
                class: X({ [S(r).m("fixed")]: g.value }),
                style: gt(x.value)
              },
              [
                Oe(P.$slots, "default")
              ],
              6
            )
          ]),
          _: 3
        }, 8, ["disabled", "to"])
      ],
      6
    ));
  }
});
var Tie = /* @__PURE__ */ Je(Iie, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/affix/src/affix.vue"]]);
const Pie = Dt(Tie), kie = Xe({
  size: {
    type: ye([Number, String])
  },
  color: {
    type: String
  }
}), Nie = /* @__PURE__ */ le({
  name: "ElIcon",
  inheritAttrs: !1,
  __name: "icon",
  props: kie,
  setup(e) {
    const t = e, n = Ve("icon"), o = O(() => {
      const { size: l, color: r } = t, a = ao(l);
      return !a && !r ? {} : {
        fontSize: a,
        "--color": r
      };
    });
    return (l, r) => (G(), ue(
      "i",
      Ut({
        class: S(n).b(),
        style: o.value
      }, l.$attrs),
      [
        Oe(l.$slots, "default")
      ],
      16
    ));
  }
});
var Mie = /* @__PURE__ */ Je(Nie, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const ut = Dt(Mie);
/*! Element Plus Icons Vue v2.3.2 */
var Aie = /* @__PURE__ */ le({
  name: "ArrowDown",
  __name: "arrow-down",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M831.872 340.864 512 652.672 192.128 340.864a30.59 30.59 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.59 30.59 0 0 0-42.752 0z"
      })
    ]));
  }
}), Ni = Aie, Rie = /* @__PURE__ */ le({
  name: "ArrowLeft",
  __name: "arrow-left",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.59 30.59 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.59 30.59 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0"
      })
    ]));
  }
}), ms = Rie, Die = /* @__PURE__ */ le({
  name: "ArrowRight",
  __name: "arrow-right",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M340.864 149.312a30.59 30.59 0 0 0 0 42.752L652.736 512 340.864 831.872a30.59 30.59 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
      })
    ]));
  }
}), Rl = Die, Lie = /* @__PURE__ */ le({
  name: "ArrowUp",
  __name: "arrow-up",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
      })
    ]));
  }
}), A1 = Lie, Bie = /* @__PURE__ */ le({
  name: "Back",
  __name: "back",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64"
      }),
      ve("path", {
        fill: "currentColor",
        d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312z"
      })
    ]));
  }
}), Fie = Bie, Vie = /* @__PURE__ */ le({
  name: "Calendar",
  __name: "calendar",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64"
      })
    ]));
  }
}), zie = Vie, Hie = /* @__PURE__ */ le({
  name: "CaretRight",
  __name: "caret-right",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M384 192v640l384-320.064z"
      })
    ]));
  }
}), $7 = Hie, jie = /* @__PURE__ */ le({
  name: "CaretTop",
  __name: "caret-top",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M512 320 192 704h639.936z"
      })
    ]));
  }
}), Wie = jie, Kie = /* @__PURE__ */ le({
  name: "Check",
  __name: "check",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
      })
    ]));
  }
}), ch = Kie, Uie = /* @__PURE__ */ le({
  name: "CircleCheckFilled",
  __name: "circle-check-filled",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.27 38.27 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
      })
    ]));
  }
}), Gie = Uie, Yie = /* @__PURE__ */ le({
  name: "CircleCheck",
  __name: "circle-check",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      }),
      ve("path", {
        fill: "currentColor",
        d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752z"
      })
    ]));
  }
}), MO = Yie, Xie = /* @__PURE__ */ le({
  name: "CircleCloseFilled",
  __name: "circle-close-filled",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
      })
    ]));
  }
}), AO = Xie, qie = /* @__PURE__ */ le({
  name: "CircleClose",
  __name: "circle-close",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
      }),
      ve("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      })
    ]));
  }
}), Es = qie, Jie = /* @__PURE__ */ le({
  name: "Clock",
  __name: "clock",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
      }),
      ve("path", {
        fill: "currentColor",
        d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
      }),
      ve("path", {
        fill: "currentColor",
        d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32"
      })
    ]));
  }
}), x7 = Jie, Zie = /* @__PURE__ */ le({
  name: "Close",
  __name: "close",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
      })
    ]));
  }
}), aa = Zie, Qie = /* @__PURE__ */ le({
  name: "DArrowLeft",
  __name: "d-arrow-left",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.59 30.59 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.59 30.59 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672zm256 0a29.12 29.12 0 0 1 41.728 0 30.59 30.59 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.59 30.59 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672z"
      })
    ]));
  }
}), bc = Qie, ese = /* @__PURE__ */ le({
  name: "DArrowRight",
  __name: "d-arrow-right",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.59 30.59 0 0 1 0-42.752L764.736 512 452.864 192a30.59 30.59 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.59 30.59 0 0 1 0-42.752L508.736 512 196.864 192a30.59 30.59 0 0 1 0-42.688"
      })
    ]));
  }
}), yc = ese, tse = /* @__PURE__ */ le({
  name: "Delete",
  __name: "delete",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
      })
    ]));
  }
}), nse = tse, ose = /* @__PURE__ */ le({
  name: "Document",
  __name: "document",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h160v64H320zm0 384h384v64H320z"
      })
    ]));
  }
}), lse = ose, rse = /* @__PURE__ */ le({
  name: "FullScreen",
  __name: "full-screen",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
      })
    ]));
  }
}), ase = rse, ise = /* @__PURE__ */ le({
  name: "Hide",
  __name: "hide",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4s-12.8-9.6-22.4-9.6-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176S0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4s3.2 16 9.6 22.4 12.8 9.6 22.4 9.6 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4m-646.4 528Q115.2 579.2 76.8 512q43.2-72 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4m140.8-96Q352 555.2 352 512c0-44.8 16-83.2 48-112s67.2-48 112-48c28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6q-43.2 72-153.6 172.8c-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176S1024 528 1024 512s-48.001-73.6-134.401-176"
      }),
      ve("path", {
        fill: "currentColor",
        d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112s-67.2 48-112 48"
      })
    ]));
  }
}), sse = ise, cse = /* @__PURE__ */ le({
  name: "InfoFilled",
  __name: "info-filled",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.99 12.99 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
      })
    ]));
  }
}), sm = cse, use = /* @__PURE__ */ le({
  name: "Loading",
  __name: "loading",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248m452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248M828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0"
      })
    ]));
  }
}), wi = use, dse = /* @__PURE__ */ le({
  name: "Minus",
  __name: "minus",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
      })
    ]));
  }
}), fse = dse, pse = /* @__PURE__ */ le({
  name: "MoreFilled",
  __name: "more-filled",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
      })
    ]));
  }
}), m3 = pse, vse = /* @__PURE__ */ le({
  name: "More",
  __name: "more",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96"
      })
    ]));
  }
}), mse = vse, hse = /* @__PURE__ */ le({
  name: "PictureFilled",
  __name: "picture-filled",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112M256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384"
      })
    ]));
  }
}), gse = hse, bse = /* @__PURE__ */ le({
  name: "Plus",
  __name: "plus",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
      })
    ]));
  }
}), E7 = bse, yse = /* @__PURE__ */ le({
  name: "QuestionFilled",
  __name: "question-filled",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592q0-64.416-42.24-101.376c-28.16-25.344-65.472-37.312-111.232-37.312m-12.672 406.208a54.27 54.27 0 0 0-38.72 14.784 49.4 49.4 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.85 54.85 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.97 51.97 0 0 0-15.488-38.016 55.94 55.94 0 0 0-39.424-14.784"
      })
    ]));
  }
}), Sse = yse, Cse = /* @__PURE__ */ le({
  name: "RefreshLeft",
  __name: "refresh-left",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
      })
    ]));
  }
}), wse = Cse, $se = /* @__PURE__ */ le({
  name: "RefreshRight",
  __name: "refresh-right",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88"
      })
    ]));
  }
}), xse = $se, Ese = /* @__PURE__ */ le({
  name: "ScaleToOriginal",
  __name: "scale-to-original",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.12 30.12 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.12 30.12 0 0 0-30.118-30.118m-361.412 0a30.12 30.12 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.12 30.12 0 0 0-30.118-30.118M512 361.412a30.12 30.12 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.12 30.12 0 0 0 512 361.412M512 512a30.12 30.12 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.12 30.12 0 0 0 512 512"
      })
    ]));
  }
}), Ose = Ese, _se = /* @__PURE__ */ le({
  name: "Search",
  __name: "search",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704"
      })
    ]));
  }
}), Ise = _se, Tse = /* @__PURE__ */ le({
  name: "SortDown",
  __name: "sort-down",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0"
      })
    ]));
  }
}), Pse = Tse, kse = /* @__PURE__ */ le({
  name: "SortUp",
  __name: "sort-up",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248"
      })
    ]));
  }
}), Nse = kse, Mse = /* @__PURE__ */ le({
  name: "StarFilled",
  __name: "star-filled",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M313.6 924.48a70.4 70.4 0 0 1-74.152-5.365 70.4 70.4 0 0 1-27.992-68.875l37.888-220.928L88.96 472.96a70.4 70.4 0 0 1 3.788-104.225A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 100.246-28.595 70.4 70.4 0 0 1 25.962 28.595l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
      })
    ]));
  }
}), og = Mse, Ase = /* @__PURE__ */ le({
  name: "Star",
  __name: "star",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
      })
    ]));
  }
}), Rse = Ase, Dse = /* @__PURE__ */ le({
  name: "SuccessFilled",
  __name: "success-filled",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.27 38.27 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
      })
    ]));
  }
}), O7 = Dse, Lse = /* @__PURE__ */ le({
  name: "View",
  __name: "view",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288m0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.19 160.19 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
      })
    ]));
  }
}), Bse = Lse, Fse = /* @__PURE__ */ le({
  name: "WarningFilled",
  __name: "warning-filled",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.43 58.43 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.43 58.43 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
      })
    ]));
  }
}), R1 = Fse, Vse = /* @__PURE__ */ le({
  name: "ZoomIn",
  __name: "zoom-in",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
      })
    ]));
  }
}), _7 = Vse, zse = /* @__PURE__ */ le({
  name: "ZoomOut",
  __name: "zoom-out",
  setup(e) {
    return (t, n) => (G(), ue("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 1024 1024"
    }, [
      ve("path", {
        fill: "currentColor",
        d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
      })
    ]));
  }
}), Hse = zse;
const Pn = ye([
  String,
  Object,
  Function
]), I7 = {
  Close: aa
}, RO = {
  Close: aa,
  SuccessFilled: O7,
  InfoFilled: sm,
  WarningFilled: R1,
  CircleCloseFilled: AO
}, Sc = {
  primary: sm,
  success: O7,
  warning: R1,
  error: AO,
  info: sm
}, D1 = {
  validating: wi,
  success: MO,
  error: Es
}, jse = ["light", "dark"], Wse = Xe({
  title: {
    type: String,
    default: ""
  },
  description: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: im(Sc),
    default: "info"
  },
  closable: {
    type: Boolean,
    default: !0
  },
  closeText: {
    type: String,
    default: ""
  },
  showIcon: Boolean,
  center: Boolean,
  effect: {
    type: String,
    values: jse,
    default: "light"
  },
  showAfter: Number,
  hideAfter: Number,
  autoClose: Number
}), Kse = {
  close: (e) => e instanceof MouseEvent
}, Use = "utils/vue/vnode";
var Yr = /* @__PURE__ */ ((e) => (e[e.TEXT = 1] = "TEXT", e[e.CLASS = 2] = "CLASS", e[e.STYLE = 4] = "STYLE", e[e.PROPS = 8] = "PROPS", e[e.FULL_PROPS = 16] = "FULL_PROPS", e[e.HYDRATE_EVENTS = 32] = "HYDRATE_EVENTS", e[e.STABLE_FRAGMENT = 64] = "STABLE_FRAGMENT", e[e.KEYED_FRAGMENT = 128] = "KEYED_FRAGMENT", e[e.UNKEYED_FRAGMENT = 256] = "UNKEYED_FRAGMENT", e[e.NEED_PATCH = 512] = "NEED_PATCH", e[e.DYNAMIC_SLOTS = 1024] = "DYNAMIC_SLOTS", e[e.HOISTED = -1] = "HOISTED", e[e.BAIL = -2] = "BAIL", e))(Yr || {});
function nx(e) {
  return dn(e) && e.type === Ge;
}
function T7(e) {
  return dn(e) && e.type === qn;
}
function Gse(e) {
  return dn(e) && !nx(e) && !T7(e);
}
const Yse = (e) => {
  if (!dn(e))
    return Gt(Use, "[getNormalizedProps] must be a VNode"), {};
  const t = e.props || {}, n = (dn(e.type) ? e.type.props : void 0) || {}, o = {};
  return Object.keys(n).forEach((l) => {
    hn(n[l], "default") && (o[l] = n[l].default);
  }), Object.keys(t).forEach((l) => {
    o[vl(l)] = t[l];
  }), o;
}, Nr = (e) => {
  const t = We(e) ? e : [e], n = [];
  return t.forEach((o) => {
    var l;
    We(o) ? n.push(...Nr(o)) : dn(o) && ((l = o.component) != null && l.subTree) ? n.push(o, ...Nr(o.component.subTree)) : dn(o) && We(o.children) ? n.push(...Nr(o.children)) : dn(o) && o.shapeFlag === 2 ? n.push(...Nr(o.type())) : n.push(o);
  }), n;
}, Xse = /* @__PURE__ */ le({
  name: "ElAlert",
  __name: "alert",
  props: Wse,
  emits: Kse,
  setup(e, { emit: t }) {
    const { Close: n } = RO, o = e, l = t, r = So(), a = Ve("alert"), i = /* @__PURE__ */ H(!0), s = O(() => Sc[o.type]), c = O(() => {
      var d;
      if (o.description)
        return !0;
      const f = (d = r.default) == null ? void 0 : d.call(r);
      return f ? Nr(f).some((m) => !T7(m)) : !1;
    }), u = (d) => {
      i.value = !1, l("close", d);
    };
    return (o.showAfter || o.hideAfter || o.autoClose) && Gt(
      "el-alert",
      "The `show-after`, `hide-after`, and `auto-close` attributes were removed after 2.11.8. Please use `v-if` and `v-show` to manually replace them, visit: https://github.com/element-plus/element-plus/pull/22560"
    ), (d, f) => (G(), Me(Vn, {
      name: S(a).b("fade"),
      persisted: ""
    }, {
      default: Ee(() => [
        _t(ve(
          "div",
          {
            class: X([S(a).b(), S(a).m(d.type), S(a).is("center", d.center), S(a).is(d.effect)]),
            role: "alert"
          },
          [
            d.showIcon && (d.$slots.icon || s.value) ? (G(), Me(S(ut), {
              key: 0,
              class: X([S(a).e("icon"), S(a).is("big", c.value)])
            }, {
              default: Ee(() => [
                Oe(d.$slots, "icon", {}, () => [
                  (G(), Me(Ht(s.value)))
                ])
              ]),
              _: 3
            }, 8, ["class"])) : Ie("v-if", !0),
            ve(
              "div",
              {
                class: X(S(a).e("content"))
              },
              [
                d.title || d.$slots.title ? (G(), ue(
                  "span",
                  {
                    key: 0,
                    class: X([S(a).e("title"), { "with-description": c.value }])
                  },
                  [
                    Oe(d.$slots, "title", {}, () => [
                      Ft(
                        qe(d.title),
                        1
                      )
                    ])
                  ],
                  2
                )) : Ie("v-if", !0),
                c.value ? (G(), ue(
                  "p",
                  {
                    key: 1,
                    class: X(S(a).e("description"))
                  },
                  [
                    Oe(d.$slots, "default", {}, () => [
                      Ft(
                        qe(d.description),
                        1
                      )
                    ])
                  ],
                  2
                )) : Ie("v-if", !0),
                d.closable ? (G(), ue(
                  Ge,
                  { key: 2 },
                  [
                    d.closeText ? (G(), ue(
                      "div",
                      {
                        key: 0,
                        class: X([S(a).e("close-btn"), S(a).is("customed")]),
                        onClick: u
                      },
                      qe(d.closeText),
                      3
                    )) : (G(), Me(S(ut), {
                      key: 1,
                      class: X(S(a).e("close-btn")),
                      onClick: u
                    }, {
                      default: Ee(() => [
                        $(S(n))
                      ]),
                      _: 1
                    }, 8, ["class"]))
                  ],
                  64
                )) : Ie("v-if", !0)
              ],
              2
            )
          ],
          2
        ), [
          [Jt, i.value]
        ])
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var qse = /* @__PURE__ */ Je(Xse, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/alert/src/alert.vue"]]);
const Jse = Dt(qse), DO = () => Sn && /firefox/i.test(window.navigator.userAgent), P7 = () => Sn && /android/i.test(window.navigator.userAgent);
let ur;
const Zse = {
  height: "0",
  visibility: "hidden",
  overflow: DO() ? "" : "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0"
}, Qse = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing",
  "word-break"
], h3 = (e) => {
  const t = Number.parseFloat(e);
  return Number.isNaN(t) ? e : t;
};
function ece(e) {
  const t = window.getComputedStyle(e), n = t.getPropertyValue("box-sizing"), o = Number.parseFloat(t.getPropertyValue("padding-bottom")) + Number.parseFloat(t.getPropertyValue("padding-top")), l = Number.parseFloat(t.getPropertyValue("border-bottom-width")) + Number.parseFloat(t.getPropertyValue("border-top-width"));
  return { contextStyle: Qse.map((a) => [
    a,
    t.getPropertyValue(a)
  ]), paddingSize: o, borderSize: l, boxSizing: n };
}
function g3(e, t = 1, n) {
  var o, l;
  ur || (ur = document.createElement("textarea"), ((o = e.parentNode) != null ? o : document.body).appendChild(ur));
  const { paddingSize: r, borderSize: a, boxSizing: i, contextStyle: s } = ece(e);
  s.forEach(
    ([f, p]) => ur == null ? void 0 : ur.style.setProperty(f, p)
  ), Object.entries(Zse).forEach(
    ([f, p]) => ur == null ? void 0 : ur.style.setProperty(f, p, "important")
  ), ur.value = e.value || e.placeholder || "";
  let c = ur.scrollHeight;
  const u = {};
  i === "border-box" ? c = c + a : i === "content-box" && (c = c - r), ur.value = "";
  const d = ur.scrollHeight - r;
  if (mt(t)) {
    let f = d * t;
    i === "border-box" && (f = f + r + a), c = Math.max(f, c), u.minHeight = `${f}px`;
  }
  if (mt(n)) {
    let f = d * n;
    i === "border-box" && (f = f + r + a), c = Math.min(f, c);
  }
  return u.height = `${c}px`, (l = ur.parentNode) == null || l.removeChild(ur), ur = void 0, u;
}
const lo = (e) => e, tce = Xe({
  ariaLabel: String,
  ariaOrientation: {
    type: String,
    values: ["horizontal", "vertical", "undefined"]
  },
  ariaControls: String
}), zl = (e) => La(tce, e), uh = Xe(vt(Be({
  id: {
    type: String,
    default: void 0
  },
  size: Bo,
  disabled: {
    type: Boolean,
    default: void 0
  },
  modelValue: {
    type: ye([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  modelModifiers: {
    type: ye(Object),
    default: () => ({})
  },
  maxlength: {
    type: [String, Number]
  },
  minlength: {
    type: [String, Number]
  },
  type: {
    type: ye(String),
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: ye([Boolean, Object]),
    default: !1
  },
  autocomplete: {
    type: ye(String),
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String
  },
  readonly: Boolean,
  clearable: Boolean,
  clearIcon: {
    type: Pn,
    default: Es
  },
  showPassword: Boolean,
  showWordLimit: Boolean,
  wordLimitPosition: {
    type: String,
    values: ["inside", "outside"],
    default: "inside"
  },
  suffixIcon: {
    type: Pn
  },
  prefixIcon: {
    type: Pn
  },
  containerRole: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  inputStyle: {
    type: ye([Object, Array, String]),
    default: () => lo({})
  },
  autofocus: Boolean,
  rows: {
    type: Number,
    default: 2
  }
}, zl(["ariaLabel"])), {
  inputmode: {
    type: ye(String),
    default: void 0
  },
  name: String
})), nce = {
  [It]: (e) => rt(e),
  input: (e) => rt(e),
  change: (e, t) => rt(e) && (t instanceof Event || t === void 0),
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  clear: () => !0,
  mouseleave: (e) => e instanceof MouseEvent,
  mouseenter: (e) => e instanceof MouseEvent,
  keydown: (e) => e instanceof Event,
  compositionstart: (e) => e instanceof CompositionEvent,
  compositionupdate: (e) => e instanceof CompositionEvent,
  compositionend: (e) => e instanceof CompositionEvent
}, oce = ["class", "style"], lce = /^on[A-Z]/, L1 = (e = {}) => {
  const { excludeListeners: t = !1, excludeKeys: n } = e, o = O(() => ((n == null ? void 0 : n.value) || []).concat(oce)), l = xt();
  return l ? O(
    () => {
      var r;
      return Hf(
        Object.entries((r = l.proxy) == null ? void 0 : r.$attrs).filter(
          ([a]) => !o.value.includes(a) && !(t && lce.test(a))
        )
      );
    }
  ) : (Gt(
    "use-attrs",
    "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"
  ), O(() => ({})));
}, ox = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
}, rce = Symbol("elIdInjection"), LO = () => xt() ? ze(rce, ox) : ox, ml = (e) => {
  const t = LO();
  !Sn && t === ox && Gt(
    "IdInjection",
    `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`
  );
  const n = dO();
  return l7(
    () => S(e) || `${n.value}-id-${t.prefix}-${t.current++}`
  );
}, id = Symbol("formContextKey"), $i = Symbol("formItemContextKey"), cl = () => {
  const e = ze(id, void 0), t = ze($i, void 0);
  return {
    form: e,
    formItem: t
  };
}, zr = (e, {
  formItemContext: t,
  disableIdGeneration: n,
  disableIdManagement: o
}) => {
  n || (n = /* @__PURE__ */ H(!1)), o || (o = /* @__PURE__ */ H(!1));
  const l = xt(), r = () => {
    let c = l == null ? void 0 : l.parent;
    for (; c; ) {
      if (c.type.name === "ElFormItem")
        return !1;
      if (c.type.name === "ElLabelWrap")
        return !0;
      c = c.parent;
    }
    return !1;
  }, a = /* @__PURE__ */ H();
  let i;
  const s = O(() => {
    var c;
    return !!(!(e.label || e.ariaLabel) && t && t.inputIds && ((c = t.inputIds) == null ? void 0 : c.length) <= 1);
  });
  return nt(() => {
    i = pe(
      [/* @__PURE__ */ ft(e, "id"), n],
      ([c, u]) => {
        const d = c != null ? c : u ? void 0 : ml().value;
        d !== a.value && (t != null && t.removeInputId && !r() && (a.value && t.removeInputId(a.value), !(o != null && o.value) && !u && d && t.addInputId(d)), a.value = d);
      },
      { immediate: !0 }
    );
  }), Uo(() => {
    i && i(), t != null && t.removeInputId && a.value && t.removeInputId(a.value);
  }), {
    isLabeledByFormItem: s,
    inputId: a
  };
}, k7 = (e) => {
  const t = xt();
  return O(() => {
    var n, o;
    return (o = (n = t == null ? void 0 : t.proxy) == null ? void 0 : n.$props) == null ? void 0 : o[e];
  });
}, Mo = (e, t = {}) => {
  const n = /* @__PURE__ */ H(void 0), o = t.prop ? n : k7("size"), l = t.global ? n : h7(), r = t.form ? { size: void 0 } : ze(id, void 0), a = t.formItem ? { size: void 0 } : ze($i, void 0);
  return O(
    () => o.value || S(e) || (a == null ? void 0 : a.size) || (r == null ? void 0 : r.size) || l.value || ""
  );
}, io = (e) => {
  const t = k7("disabled"), n = ze(id, void 0);
  return O(() => {
    var o, l, r;
    return (r = (l = (o = t.value) != null ? o : S(e)) != null ? l : n == null ? void 0 : n.disabled) != null ? r : !1;
  });
}, ace = 'a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])', b3 = (e) => typeof Element == "undefined" ? !1 : e instanceof Element, ice = (e) => process.env.NODE_ENV === "test" ? !0 : getComputedStyle(e).position === "fixed" ? !1 : e.offsetParent !== null, y3 = (e) => Array.from(
  e.querySelectorAll(ace)
).filter((t) => cm(t) && ice(t)), cm = (e) => {
  if (e.tabIndex > 0 || e.tabIndex === 0 && e.getAttribute("tabIndex") !== null)
    return !0;
  if (e.tabIndex < 0 || e.hasAttribute("disabled") || e.getAttribute("aria-disabled") === "true")
    return !1;
  switch (e.nodeName) {
    case "A":
      return !!e.href && e.rel !== "ignore";
    case "INPUT":
      return !(e.type === "hidden" || e.type === "file");
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA":
      return !0;
    default:
      return !1;
  }
}, cb = function(e, t, ...n) {
  let o;
  t.includes("mouse") || t.includes("click") ? o = "MouseEvents" : t.includes("key") ? o = "KeyboardEvent" : o = "HTMLEvents";
  const l = document.createEvent(o);
  return l.initEvent(t, ...n), e.dispatchEvent(l), e;
}, N7 = (e) => !e.getAttribute("aria-owns"), M7 = (e, t, n) => {
  const { parentNode: o } = e;
  if (!o)
    return null;
  const l = o.querySelectorAll(n), r = Array.prototype.indexOf.call(l, e);
  return l[r + t] || null;
}, dh = (e, t) => {
  if (!e || !e.focus)
    return;
  let n = !1;
  b3(e) && !cm(e) && !e.getAttribute("tabindex") && (e.setAttribute("tabindex", "-1"), n = !0), e.focus(t), b3(e) && n && e.removeAttribute("tabindex");
}, ub = (e) => {
  e && (dh(e), !N7(e) && e.click());
};
function Os(e, {
  disabled: t,
  beforeFocus: n,
  afterFocus: o,
  beforeBlur: l,
  afterBlur: r
} = {}) {
  const a = xt(), { emit: i } = a, s = /* @__PURE__ */ Ce(), c = /* @__PURE__ */ H(!1), u = (p) => {
    const m = it(n) ? n(p) : !1;
    S(t) || c.value || m || (c.value = !0, i("focus", p), o == null || o());
  }, d = (p) => {
    var m;
    const v = it(l) ? l(p) : !1;
    S(t) || p.relatedTarget && ((m = s.value) != null && m.contains(p.relatedTarget)) || v || (c.value = !1, i("blur", p), r == null || r());
  }, f = (p) => {
    var m, v;
    S(t) || cm(p.target) || (m = s.value) != null && m.contains(document.activeElement) && s.value !== document.activeElement || (v = e.value) == null || v.focus();
  };
  return pe([s, () => S(t)], ([p, m]) => {
    p && (m ? p.removeAttribute("tabindex") : p.setAttribute("tabindex", "-1"));
  }), wn(s, "focus", u, !0), wn(s, "blur", d, !0), wn(s, "click", f, !0), process.env.NODE_ENV === "test" && nt(() => {
    const p = tr(e.value) ? e.value : document.querySelector("input,textarea");
    p && (wn(p, "focus", u, !0), wn(p, "blur", d, !0));
  }), {
    isFocused: c,
    wrapperRef: s,
    handleFocus: u,
    handleBlur: d
  };
}
const sce = (e) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(e);
function fh({
  afterComposition: e,
  emit: t
}) {
  const n = /* @__PURE__ */ H(!1), o = (i) => {
    t == null || t("compositionstart", i), n.value = !0;
  }, l = (i) => {
    var s;
    t == null || t("compositionupdate", i);
    const c = (s = i.target) == null ? void 0 : s.value, u = c[c.length - 1] || "";
    n.value = !sce(u);
  }, r = (i) => {
    t == null || t("compositionend", i), n.value && (n.value = !1, Ke(() => e(i)));
  };
  return {
    isComposing: n,
    handleComposition: (i) => {
      i.type === "compositionend" ? r(i) : l(i);
    },
    handleCompositionStart: o,
    handleCompositionUpdate: l,
    handleCompositionEnd: r
  };
}
function cce(e) {
  let t;
  function n() {
    if (e.value == null)
      return;
    const { selectionStart: l, selectionEnd: r, value: a } = e.value;
    if (l == null || r == null)
      return;
    const i = a.slice(0, Math.max(0, l)), s = a.slice(Math.max(0, r));
    t = {
      selectionStart: l,
      selectionEnd: r,
      value: a,
      beforeTxt: i,
      afterTxt: s
    };
  }
  function o() {
    if (e.value == null || t == null)
      return;
    const { value: l } = e.value, { beforeTxt: r, afterTxt: a, selectionStart: i } = t;
    if (r == null || a == null || i == null)
      return;
    let s = l.length;
    if (l.endsWith(a))
      s = l.length - a.length;
    else if (l.startsWith(r))
      s = r.length;
    else {
      const c = r[i - 1], u = l.indexOf(c, i - 1);
      u !== -1 && (s = u + 1);
    }
    e.value.setSelectionRange(s, s);
  }
  return [n, o];
}
const uce = ["id", "name", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus", "role", "inputmode"], dce = ["id", "name", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus", "rows", "role"], S3 = "ElInput", fce = /* @__PURE__ */ le({
  name: S3,
  inheritAttrs: !1,
  __name: "input",
  props: uh,
  emits: nce,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = Ti(), a = L1(), i = So(), s = O(() => [
      o.type === "textarea" ? h.b() : v.b(),
      v.m(p.value),
      v.is("disabled", m.value),
      v.is("exceed", W.value),
      {
        [v.b("group")]: i.prepend || i.append,
        [v.m("prefix")]: i.prefix || o.prefixIcon,
        [v.m("suffix")]: i.suffix || o.suffixIcon || o.clearable || o.showPassword,
        [v.bm("suffix", "password-clear")]: L.value && B.value,
        [v.b("hidden")]: o.type === "hidden"
      },
      r.class
    ]), c = O(() => [
      v.e("wrapper"),
      v.is("focus", T.value)
    ]), { form: u, formItem: d } = cl(), { inputId: f } = zr(o, {
      formItemContext: d
    }), p = Mo(), m = io(), v = Ve("input"), h = Ve("textarea"), g = /* @__PURE__ */ Ce(), y = /* @__PURE__ */ Ce(), b = /* @__PURE__ */ H(!1), C = /* @__PURE__ */ H(!1), w = /* @__PURE__ */ H(), x = /* @__PURE__ */ Ce(o.inputStyle), E = O(() => g.value || y.value), { wrapperRef: I, isFocused: T, handleFocus: P, handleBlur: k } = Os(
      E,
      {
        disabled: m,
        afterBlur() {
          var ie;
          o.validateEvent && ((ie = d == null ? void 0 : d.validate) == null || ie.call(d, "blur").catch((we) => Gt(we)));
        }
      }
    ), N = O(() => {
      var ie;
      return (ie = u == null ? void 0 : u.statusIcon) != null ? ie : !1;
    }), R = O(() => (d == null ? void 0 : d.validateState) || ""), z = O(
      () => R.value && D1[R.value]
    ), D = O(
      () => C.value ? Bse : sse
    ), F = O(() => [
      r.style
    ]), M = O(() => [
      o.inputStyle,
      x.value,
      { resize: o.resize }
    ]), A = O(
      () => wo(o.modelValue) ? "" : String(o.modelValue)
    ), L = O(
      () => o.clearable && !m.value && !o.readonly && !!A.value && (T.value || b.value)
    ), B = O(
      () => o.showPassword && !m.value && !!A.value
    ), V = O(
      () => o.showWordLimit && !!o.maxlength && (o.type === "text" || o.type === "textarea") && !m.value && !o.readonly && !o.showPassword
    ), j = O(() => A.value.length), W = O(
      () => !!V.value && j.value > Number(o.maxlength)
    ), Y = O(
      () => !!i.suffix || !!o.suffixIcon || L.value || o.showPassword || V.value || !!R.value && N.value
    ), U = O(
      () => !!Object.keys(o.modelModifiers).length
    ), [te, J] = cce(g);
    Xn(y, (ie) => {
      if (q(), !V.value || o.resize !== "both" && o.resize !== "horizontal")
        return;
      const we = ie[0], { width: Ne } = we.contentRect;
      w.value = {
        right: `calc(100% - ${Ne + 22 - 10}px)`
      };
    });
    const re = () => {
      const { type: ie, autosize: we } = o;
      if (!(!Sn || ie !== "textarea" || !y.value))
        if (we) {
          const Ne = Mt(we) ? we.minRows : void 0, tt = Mt(we) ? we.maxRows : void 0, Pe = g3(y.value, Ne, tt);
          x.value = Be({
            overflowY: "hidden"
          }, Pe), Ke(() => {
            y.value.offsetHeight, x.value = Pe;
          });
        } else
          x.value = {
            minHeight: g3(y.value).minHeight
          };
    }, q = ((ie) => {
      let we = !1;
      return () => {
        var Ne;
        if (we || !o.autosize)
          return;
        ((Ne = y.value) == null ? void 0 : Ne.offsetParent) === null || (setTimeout(ie), we = !0);
      };
    })(re), K = () => {
      const ie = E.value, we = o.formatter ? o.formatter(A.value) : A.value;
      !ie || ie.value === we || o.type === "file" || (ie.value = we);
    }, se = (ie) => {
      const { trim: we, number: Ne } = o.modelModifiers;
      return we && (ie = ie.trim()), Ne && (ie = `${h3(ie)}`), o.formatter && o.parser && (ie = o.parser(ie)), ie;
    }, Z = (ie) => Rt(this, null, function* () {
      if (fe.value)
        return;
      const { lazy: we } = o.modelModifiers;
      let { value: Ne } = ie.target;
      if (we) {
        l(Po, Ne);
        return;
      }
      if (Ne = se(Ne), String(Ne) === A.value) {
        o.formatter && K();
        return;
      }
      te(), l(It, Ne), l(Po, Ne), yield Ke(), (o.formatter && o.parser || !U.value) && K(), J();
    }), ee = (ie) => Rt(this, null, function* () {
      let { value: we } = ie.target;
      we = se(we), o.modelModifiers.lazy && l(It, we), l(en, we, ie), yield Ke(), K();
    }), {
      isComposing: fe,
      handleCompositionStart: me,
      handleCompositionUpdate: ge,
      handleCompositionEnd: he
    } = fh({ emit: l, afterComposition: Z }), $e = () => {
      C.value = !C.value;
    }, ne = () => {
      var ie;
      return (ie = E.value) == null ? void 0 : ie.focus();
    }, ae = () => {
      var ie;
      return (ie = E.value) == null ? void 0 : ie.blur();
    }, ce = (ie) => {
      b.value = !1, l("mouseleave", ie);
    }, xe = (ie) => {
      b.value = !0, l("mouseenter", ie);
    }, Te = (ie) => {
      l("keydown", ie);
    }, Se = () => {
      var ie;
      (ie = E.value) == null || ie.select();
    }, be = () => {
      l(It, ""), l(en, ""), l("clear"), l(Po, "");
    };
    return pe(
      () => o.modelValue,
      () => {
        var ie;
        Ke(() => re()), o.validateEvent && ((ie = d == null ? void 0 : d.validate) == null || ie.call(d, "change").catch((we) => Gt(we)));
      }
    ), pe(A, (ie) => {
      if (!E.value)
        return;
      const { trim: we, number: Ne } = o.modelModifiers, tt = E.value.value, Pe = (Ne || o.type === "number") && !/^0\d/.test(tt) ? `${h3(tt)}` : tt;
      Pe !== ie && (document.activeElement === E.value && E.value.type !== "range" && we && Pe.trim() === ie || K());
    }), pe(
      () => o.type,
      () => Rt(this, null, function* () {
        yield Ke(), K(), re();
      })
    ), nt(() => {
      !o.formatter && o.parser && Gt(
        S3,
        "If you set the parser, you also need to set the formatter."
      ), K(), Ke(re);
    }), t({
      input: g,
      textarea: y,
      ref: E,
      textareaStyle: M,
      autosize: /* @__PURE__ */ ft(o, "autosize"),
      isComposing: fe,
      focus: ne,
      blur: ae,
      select: Se,
      clear: be,
      resizeTextarea: re
    }), (ie, we) => (G(), ue(
      "div",
      {
        class: X([
          s.value,
          {
            [S(v).bm("group", "append")]: ie.$slots.append,
            [S(v).bm("group", "prepend")]: ie.$slots.prepend
          }
        ]),
        style: gt(F.value),
        onMouseenter: xe,
        onMouseleave: ce
      },
      [
        Ie(" input "),
        ie.type !== "textarea" ? (G(), ue(
          Ge,
          { key: 0 },
          [
            Ie(" prepend slot "),
            ie.$slots.prepend ? (G(), ue(
              "div",
              {
                key: 0,
                class: X(S(v).be("group", "prepend"))
              },
              [
                Oe(ie.$slots, "prepend")
              ],
              2
            )) : Ie("v-if", !0),
            ve(
              "div",
              {
                ref_key: "wrapperRef",
                ref: I,
                class: X(c.value)
              },
              [
                Ie(" prefix slot "),
                ie.$slots.prefix || ie.prefixIcon ? (G(), ue(
                  "span",
                  {
                    key: 0,
                    class: X(S(v).e("prefix"))
                  },
                  [
                    ve(
                      "span",
                      {
                        class: X(S(v).e("prefix-inner"))
                      },
                      [
                        Oe(ie.$slots, "prefix"),
                        ie.prefixIcon ? (G(), Me(S(ut), {
                          key: 0,
                          class: X(S(v).e("icon"))
                        }, {
                          default: Ee(() => [
                            (G(), Me(Ht(ie.prefixIcon)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : Ie("v-if", !0)
                      ],
                      2
                    )
                  ],
                  2
                )) : Ie("v-if", !0),
                ve("input", Ut({
                  id: S(f),
                  ref_key: "input",
                  ref: g,
                  class: S(v).e("inner")
                }, S(a), {
                  name: ie.name,
                  minlength: ie.minlength,
                  maxlength: ie.maxlength,
                  type: ie.showPassword ? C.value ? "text" : "password" : ie.type,
                  disabled: S(m),
                  readonly: ie.readonly,
                  autocomplete: ie.autocomplete,
                  tabindex: ie.tabindex,
                  "aria-label": ie.ariaLabel,
                  placeholder: ie.placeholder,
                  style: ie.inputStyle,
                  form: ie.form,
                  autofocus: ie.autofocus,
                  role: ie.containerRole,
                  inputmode: ie.inputmode,
                  onCompositionstart: we[0] || (we[0] = (...Ne) => S(me) && S(me)(...Ne)),
                  onCompositionupdate: we[1] || (we[1] = (...Ne) => S(ge) && S(ge)(...Ne)),
                  onCompositionend: we[2] || (we[2] = (...Ne) => S(he) && S(he)(...Ne)),
                  onInput: Z,
                  onChange: ee,
                  onKeydown: Te
                }), null, 16, uce),
                Ie(" suffix slot "),
                Y.value ? (G(), ue(
                  "span",
                  {
                    key: 1,
                    class: X(S(v).e("suffix"))
                  },
                  [
                    ve(
                      "span",
                      {
                        class: X(S(v).e("suffix-inner"))
                      },
                      [
                        !L.value || !B.value || !V.value ? (G(), ue(
                          Ge,
                          { key: 0 },
                          [
                            Oe(ie.$slots, "suffix"),
                            ie.suffixIcon ? (G(), Me(S(ut), {
                              key: 0,
                              class: X(S(v).e("icon"))
                            }, {
                              default: Ee(() => [
                                (G(), Me(Ht(ie.suffixIcon)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : Ie("v-if", !0)
                          ],
                          64
                        )) : Ie("v-if", !0),
                        L.value ? (G(), Me(S(ut), {
                          key: 1,
                          class: X([S(v).e("icon"), S(v).e("clear")]),
                          onMousedown: Et(S(gn), ["prevent"]),
                          onClick: be
                        }, {
                          default: Ee(() => [
                            (G(), Me(Ht(ie.clearIcon)))
                          ]),
                          _: 1
                        }, 8, ["class", "onMousedown"])) : Ie("v-if", !0),
                        B.value ? (G(), Me(S(ut), {
                          key: 2,
                          class: X([S(v).e("icon"), S(v).e("password")]),
                          onClick: $e,
                          onMousedown: Et(S(gn), ["prevent"]),
                          onMouseup: Et(S(gn), ["prevent"])
                        }, {
                          default: Ee(() => [
                            (G(), Me(Ht(D.value)))
                          ]),
                          _: 1
                        }, 8, ["class", "onMousedown", "onMouseup"])) : Ie("v-if", !0),
                        V.value ? (G(), ue(
                          "span",
                          {
                            key: 3,
                            class: X([
                              S(v).e("count"),
                              S(v).is("outside", ie.wordLimitPosition === "outside")
                            ])
                          },
                          [
                            ve(
                              "span",
                              {
                                class: X(S(v).e("count-inner"))
                              },
                              qe(j.value) + " / " + qe(ie.maxlength),
                              3
                            )
                          ],
                          2
                        )) : Ie("v-if", !0),
                        R.value && z.value && N.value ? (G(), Me(S(ut), {
                          key: 4,
                          class: X([
                            S(v).e("icon"),
                            S(v).e("validateIcon"),
                            S(v).is("loading", R.value === "validating")
                          ])
                        }, {
                          default: Ee(() => [
                            (G(), Me(Ht(z.value)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : Ie("v-if", !0)
                      ],
                      2
                    )
                  ],
                  2
                )) : Ie("v-if", !0)
              ],
              2
            ),
            Ie(" append slot "),
            ie.$slots.append ? (G(), ue(
              "div",
              {
                key: 1,
                class: X(S(v).be("group", "append"))
              },
              [
                Oe(ie.$slots, "append")
              ],
              2
            )) : Ie("v-if", !0)
          ],
          64
        )) : (G(), ue(
          Ge,
          { key: 1 },
          [
            Ie(" textarea "),
            ve("textarea", Ut({
              id: S(f),
              ref_key: "textarea",
              ref: y,
              class: [S(h).e("inner"), S(v).is("focus", S(T))]
            }, S(a), {
              name: ie.name,
              minlength: ie.minlength,
              maxlength: ie.maxlength,
              tabindex: ie.tabindex,
              disabled: S(m),
              readonly: ie.readonly,
              autocomplete: ie.autocomplete,
              style: M.value,
              "aria-label": ie.ariaLabel,
              placeholder: ie.placeholder,
              form: ie.form,
              autofocus: ie.autofocus,
              rows: ie.rows,
              role: ie.containerRole,
              onCompositionstart: we[3] || (we[3] = (...Ne) => S(me) && S(me)(...Ne)),
              onCompositionupdate: we[4] || (we[4] = (...Ne) => S(ge) && S(ge)(...Ne)),
              onCompositionend: we[5] || (we[5] = (...Ne) => S(he) && S(he)(...Ne)),
              onInput: Z,
              onFocus: we[6] || (we[6] = (...Ne) => S(P) && S(P)(...Ne)),
              onBlur: we[7] || (we[7] = (...Ne) => S(k) && S(k)(...Ne)),
              onChange: ee,
              onKeydown: Te
            }), null, 16, dce),
            V.value ? (G(), ue(
              "span",
              {
                key: 0,
                style: gt(w.value),
                class: X([
                  S(v).e("count"),
                  S(v).is("outside", ie.wordLimitPosition === "outside")
                ])
              },
              qe(j.value) + " / " + qe(ie.maxlength),
              7
            )) : Ie("v-if", !0)
          ],
          64
        ))
      ],
      38
    ));
  }
});
var pce = /* @__PURE__ */ Je(fce, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
const Nl = Dt(pce), xd = 4, A7 = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
}, vce = ({
  move: e,
  size: t,
  bar: n
}) => ({
  [n.size]: t,
  transform: `translate${n.axis}(${e}%)`
}), BO = Symbol(
  "scrollbarContextKey"
), mce = Xe({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: !0
  },
  always: Boolean
}), hce = "Thumb", gce = /* @__PURE__ */ le({
  __name: "thumb",
  props: mce,
  setup(e) {
    const t = e, n = ze(BO), o = Ve("scrollbar");
    n || no(hce, "can not inject scrollbar context");
    const l = /* @__PURE__ */ H(), r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H({}), i = /* @__PURE__ */ H(!1);
    let s = !1, c = !1, u = 0, d = 0, f = Sn ? document.onselectstart : null;
    const p = O(() => A7[t.vertical ? "vertical" : "horizontal"]), m = O(
      () => vce({
        size: t.size,
        move: t.move,
        bar: p.value
      })
    ), v = O(
      () => Gh(l.value[p.value.offset], 2) / n.wrapElement[p.value.scrollSize] / t.ratio / r.value[p.value.offset]
    ), h = (I) => {
      var T;
      if (I.stopPropagation(), I.ctrlKey || [1, 2].includes(I.button))
        return;
      (T = window.getSelection()) == null || T.removeAllRanges(), y(I);
      const P = I.currentTarget;
      P && (a.value[p.value.axis] = P[p.value.offset] - (I[p.value.client] - P.getBoundingClientRect()[p.value.direction]));
    }, g = (I) => {
      if (!r.value || !l.value || !n.wrapElement)
        return;
      const T = Math.abs(
        I.target.getBoundingClientRect()[p.value.direction] - I[p.value.client]
      ), P = r.value[p.value.offset] / 2, k = (T - P) * 100 * v.value / l.value[p.value.offset];
      n.wrapElement[p.value.scroll] = k * n.wrapElement[p.value.scrollSize] / 100;
    }, y = (I) => {
      I.stopImmediatePropagation(), s = !0, u = n.wrapElement.scrollHeight, d = n.wrapElement.scrollWidth, document.addEventListener("mousemove", b), document.addEventListener("mouseup", C), f = document.onselectstart, document.onselectstart = () => !1;
    }, b = (I) => {
      if (!l.value || !r.value || s === !1)
        return;
      const T = a.value[p.value.axis];
      if (!T)
        return;
      const P = (l.value.getBoundingClientRect()[p.value.direction] - I[p.value.client]) * -1, k = r.value[p.value.offset] - T, N = (P - k) * 100 * v.value / l.value[p.value.offset];
      p.value.scroll === "scrollLeft" ? n.wrapElement[p.value.scroll] = N * d / 100 : n.wrapElement[p.value.scroll] = N * u / 100;
    }, C = () => {
      s = !1, a.value[p.value.axis] = 0, document.removeEventListener("mousemove", b), document.removeEventListener("mouseup", C), E(), c && (i.value = !1);
    }, w = () => {
      c = !1, i.value = !!t.size;
    }, x = () => {
      c = !0, i.value = s;
    };
    yt(() => {
      E(), document.removeEventListener("mouseup", C);
    });
    const E = () => {
      document.onselectstart !== f && (document.onselectstart = f);
    };
    return wn(
      /* @__PURE__ */ ft(n, "scrollbarElement"),
      "mousemove",
      w
    ), wn(
      /* @__PURE__ */ ft(n, "scrollbarElement"),
      "mouseleave",
      x
    ), (I, T) => (G(), Me(Vn, {
      name: S(o).b("fade"),
      persisted: ""
    }, {
      default: Ee(() => [
        _t(ve(
          "div",
          {
            ref_key: "instance",
            ref: l,
            class: X([S(o).e("bar"), S(o).is(p.value.key)]),
            onMousedown: g,
            onClick: T[0] || (T[0] = Et(() => {
            }, ["stop"]))
          },
          [
            ve(
              "div",
              {
                ref_key: "thumb",
                ref: r,
                class: X(S(o).e("thumb")),
                style: gt(m.value),
                onMousedown: h
              },
              null,
              38
            )
          ],
          34
        ), [
          [Jt, I.always || i.value]
        ])
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var C3 = /* @__PURE__ */ Je(gce, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
const bce = Xe({
  always: {
    type: Boolean,
    default: !0
  },
  minSize: {
    type: Number,
    required: !0
  }
}), yce = /* @__PURE__ */ le({
  __name: "bar",
  props: bce,
  setup(e, { expose: t }) {
    const n = e, o = ze(BO), l = /* @__PURE__ */ H(0), r = /* @__PURE__ */ H(0), a = /* @__PURE__ */ H(""), i = /* @__PURE__ */ H(""), s = /* @__PURE__ */ H(1), c = /* @__PURE__ */ H(1);
    return t({
      handleScroll: (f) => {
        if (f) {
          const p = f.offsetHeight - xd, m = f.offsetWidth - xd;
          r.value = f.scrollTop * 100 / p * s.value, l.value = f.scrollLeft * 100 / m * c.value;
        }
      },
      update: () => {
        const f = o == null ? void 0 : o.wrapElement;
        if (!f)
          return;
        const p = f.offsetHeight - xd, m = f.offsetWidth - xd, v = Gh(p, 2) / f.scrollHeight, h = Gh(m, 2) / f.scrollWidth, g = Math.max(v, n.minSize), y = Math.max(h, n.minSize);
        s.value = v / (p - v) / (g / (p - g)), c.value = h / (m - h) / (y / (m - y)), i.value = g + xd < p ? `${g}px` : "", a.value = y + xd < m ? `${y}px` : "";
      }
    }), (f, p) => (G(), ue(
      Ge,
      null,
      [
        $(C3, {
          move: l.value,
          ratio: c.value,
          size: a.value,
          always: f.always
        }, null, 8, ["move", "ratio", "size", "always"]),
        $(C3, {
          move: r.value,
          ratio: s.value,
          size: i.value,
          vertical: "",
          always: f.always
        }, null, 8, ["move", "ratio", "size", "always"])
      ],
      64
    ));
  }
});
var Sce = /* @__PURE__ */ Je(yce, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
const Cce = Xe(Be({
  distance: {
    type: Number,
    default: 0
  },
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: Boolean,
  wrapStyle: {
    type: ye([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  },
  tabindex: {
    type: [String, Number],
    default: void 0
  },
  id: String,
  role: String
}, zl(["ariaLabel", "ariaOrientation"]))), R7 = {
  "end-reached": (e) => ["left", "right", "top", "bottom"].includes(e),
  scroll: ({
    scrollTop: e,
    scrollLeft: t
  }) => [e, t].every(mt)
}, wce = ["tabindex"], LC = "ElScrollbar", $ce = /* @__PURE__ */ le({
  name: LC,
  __name: "scrollbar",
  props: Cce,
  emits: R7,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = Ve("scrollbar");
    let a, i, s, c = 0, u = 0, d = "";
    const f = {
      bottom: !1,
      top: !1,
      right: !1,
      left: !1
    }, p = /* @__PURE__ */ H(), m = /* @__PURE__ */ H(), v = /* @__PURE__ */ H(), h = /* @__PURE__ */ H(), g = O(() => {
      const N = {}, R = ao(o.height), z = ao(o.maxHeight);
      return R && (N.height = R), z && (N.maxHeight = z), [o.wrapStyle, N];
    }), y = O(() => [
      o.wrapClass,
      r.e("wrap"),
      { [r.em("wrap", "hidden-default")]: !o.native }
    ]), b = O(() => [r.e("view"), o.viewClass]), C = (N) => {
      var R;
      return (R = f[N]) != null ? R : !1;
    }, w = {
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }, x = (N) => {
      const R = w[d];
      if (!R)
        return;
      const z = N[d], D = N[R];
      z && !f[d] && (f[d] = !0), !D && f[R] && (f[R] = !1);
    }, E = () => {
      var N;
      if (m.value) {
        (N = h.value) == null || N.handleScroll(m.value);
        const R = c, z = u;
        c = m.value.scrollTop, u = m.value.scrollLeft;
        const D = {
          bottom: c + m.value.clientHeight >= m.value.scrollHeight - o.distance,
          top: c <= o.distance && R !== 0,
          right: u + m.value.clientWidth >= m.value.scrollWidth - o.distance && z !== u,
          left: u <= o.distance && z !== 0
        };
        if (l("scroll", {
          scrollTop: c,
          scrollLeft: u
        }), R !== c && (d = c > R ? "bottom" : "top"), z !== u && (d = u > z ? "right" : "left"), o.distance > 0) {
          if (C(d))
            return;
          x(D);
        }
        D[d] && l("end-reached", d);
      }
    };
    function I(N, R) {
      Mt(N) ? m.value.scrollTo(N) : mt(N) && mt(R) && m.value.scrollTo(N, R);
    }
    const T = (N) => {
      if (!mt(N)) {
        Gt(LC, "value must be a number");
        return;
      }
      m.value.scrollTop = N;
    }, P = (N) => {
      if (!mt(N)) {
        Gt(LC, "value must be a number");
        return;
      }
      m.value.scrollLeft = N;
    }, k = () => {
      var N;
      (N = h.value) == null || N.update(), f[d] = !1;
    };
    return pe(
      () => o.noresize,
      (N) => {
        N ? (a == null || a(), i == null || i(), s == null || s()) : ({ stop: a } = Xn(v, k), { stop: i } = Xn(m, k), s = wn("resize", k));
      },
      { immediate: !0 }
    ), pe(
      () => [o.maxHeight, o.height],
      () => {
        o.native || Ke(() => {
          var N;
          k(), m.value && ((N = h.value) == null || N.handleScroll(m.value));
        });
      }
    ), at(
      BO,
      /* @__PURE__ */ kt({
        scrollbarElement: p,
        wrapElement: m
      })
    ), nd(() => {
      m.value && (m.value.scrollTop = c, m.value.scrollLeft = u);
    }), nt(() => {
      o.native || Ke(() => {
        k();
      });
    }), $o(() => k()), t({
      wrapRef: m,
      update: k,
      scrollTo: I,
      setScrollTop: T,
      setScrollLeft: P,
      handleScroll: E
    }), (N, R) => (G(), ue(
      "div",
      {
        ref_key: "scrollbarRef",
        ref: p,
        class: X(S(r).b())
      },
      [
        ve("div", {
          ref_key: "wrapRef",
          ref: m,
          class: X(y.value),
          style: gt(g.value),
          tabindex: N.tabindex,
          onScroll: E
        }, [
          (G(), Me(Ht(N.tag), {
            id: N.id,
            ref_key: "resizeRef",
            ref: v,
            class: X(b.value),
            style: gt(N.viewStyle),
            role: N.role,
            "aria-label": N.ariaLabel,
            "aria-orientation": N.ariaOrientation
          }, {
            default: Ee(() => [
              Oe(N.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
        ], 46, wce),
        N.native ? Ie("v-if", !0) : (G(), Me(Sce, {
          key: 0,
          ref_key: "barRef",
          ref: h,
          always: N.always,
          "min-size": N.minSize
        }, null, 8, ["always", "min-size"]))
      ],
      2
    ));
  }
});
var xce = /* @__PURE__ */ Je($ce, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
const Ba = Dt(xce), FO = Symbol("popper"), D7 = Symbol("popperContent"), L7 = [
  "dialog",
  "grid",
  "group",
  "listbox",
  "menu",
  "navigation",
  "tooltip",
  "tree"
], B7 = Xe({
  role: {
    type: String,
    values: L7,
    default: "tooltip"
  }
}), Ece = /* @__PURE__ */ le({
  name: "ElPopper",
  inheritAttrs: !1,
  __name: "popper",
  props: B7,
  setup(e, { expose: t }) {
    const n = e, o = /* @__PURE__ */ H(), l = /* @__PURE__ */ H(), r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H(), i = O(() => n.role), s = {
      triggerRef: o,
      popperInstanceRef: l,
      contentRef: r,
      referenceRef: a,
      role: i
    };
    return t(s), at(FO, s), (c, u) => Oe(c.$slots, "default");
  }
});
var Oce = /* @__PURE__ */ Je(Ece, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
const _ce = /* @__PURE__ */ le({
  name: "ElPopperArrow",
  inheritAttrs: !1,
  __name: "arrow",
  setup(e, { expose: t }) {
    const n = Ve("popper"), { arrowRef: o, arrowStyle: l } = ze(
      D7,
      void 0
    );
    return yt(() => {
      o.value = void 0;
    }), t({
      arrowRef: o
    }), (r, a) => (G(), ue(
      "span",
      {
        ref_key: "arrowRef",
        ref: o,
        class: X(S(n).e("arrow")),
        style: gt(S(l)),
        "data-popper-arrow": ""
      },
      null,
      6
    ));
  }
});
var Ice = /* @__PURE__ */ Je(_ce, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
const F7 = Xe({
  virtualRef: {
    type: ye(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: {
    type: ye(Function)
  },
  onMouseleave: {
    type: ye(Function)
  },
  onClick: {
    type: ye(Function)
  },
  onKeydown: {
    type: ye(Function)
  },
  onFocus: {
    type: ye(Function)
  },
  onBlur: {
    type: ye(Function)
  },
  onContextmenu: {
    type: ye(Function)
  },
  id: String,
  open: Boolean
}), V7 = Symbol("elForwardRef"), Tce = (e) => {
  at(V7, {
    setForwardRef: (n) => {
      e.value = n;
    }
  });
}, Pce = (e) => ({
  mounted(t) {
    e(t);
  },
  updated(t) {
    e(t);
  },
  unmounted() {
    e(null);
  }
}), BC = "ElOnlyChild", z7 = /* @__PURE__ */ le({
  name: BC,
  setup(e, {
    slots: t,
    attrs: n
  }) {
    var o;
    const l = ze(V7), r = Pce((o = l == null ? void 0 : l.setForwardRef) != null ? o : gn);
    return () => {
      var a;
      const i = (a = t.default) == null ? void 0 : a.call(t, n);
      if (!i)
        return null;
      const [s, c] = H7(i);
      return s ? (c > 1 && Gt(BC, "requires exact only one valid child."), _t(No(s, n), [[r]])) : (Gt(BC, "no valid child node found"), null);
    };
  }
});
function H7(e) {
  if (!e)
    return [null, 0];
  const t = e, n = t.filter((o) => o.type !== qn).length;
  for (const o of t) {
    if (Mt(o))
      switch (o.type) {
        case qn:
          continue;
        case Vr:
        case "svg":
          return [w3(o), n];
        case Ge:
          return H7(o.children);
        default:
          return [o, n];
      }
    return [w3(o), n];
  }
  return [null, 0];
}
function w3(e) {
  const t = Ve("only-child");
  return $("span", {
    class: t.e("content")
  }, [e]);
}
const kce = /* @__PURE__ */ le({
  name: "ElPopperTrigger",
  inheritAttrs: !1,
  __name: "trigger",
  props: F7,
  setup(e, { expose: t }) {
    const n = e, { role: o, triggerRef: l } = ze(FO, void 0);
    Tce(l);
    const r = O(() => i.value ? n.id : void 0), a = O(() => {
      if (o && o.value === "tooltip")
        return n.open && n.id ? n.id : void 0;
    }), i = O(() => {
      if (o && o.value !== "tooltip")
        return o.value;
    }), s = O(() => i.value ? `${n.open}` : void 0);
    let c;
    const u = [
      "onMouseenter",
      "onMouseleave",
      "onClick",
      "onKeydown",
      "onFocus",
      "onBlur",
      "onContextmenu"
    ];
    return nt(() => {
      pe(
        () => n.virtualRef,
        (d) => {
          d && (l.value = Lo(d));
        },
        {
          immediate: !0
        }
      ), pe(
        l,
        (d, f) => {
          c == null || c(), c = void 0, tr(f) && u.forEach((p) => {
            const m = n[p];
            m && f.removeEventListener(
              p.slice(2).toLowerCase(),
              m,
              ["onFocus", "onBlur"].includes(p)
            );
          }), tr(d) && (u.forEach((p) => {
            const m = n[p];
            m && d.addEventListener(
              p.slice(2).toLowerCase(),
              m,
              ["onFocus", "onBlur"].includes(p)
            );
          }), cm(d) && (c = pe(
            [r, a, i, s],
            (p) => {
              [
                "aria-controls",
                "aria-describedby",
                "aria-haspopup",
                "aria-expanded"
              ].forEach((m, v) => {
                wo(p[v]) ? d.removeAttribute(m) : d.setAttribute(m, p[v]);
              });
            },
            { immediate: !0 }
          ))), tr(f) && cm(f) && [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((p) => f.removeAttribute(p));
        },
        {
          immediate: !0
        }
      );
    }), yt(() => {
      if (c == null || c(), c = void 0, l.value && tr(l.value)) {
        const d = l.value;
        u.forEach((f) => {
          const p = n[f];
          p && d.removeEventListener(
            f.slice(2).toLowerCase(),
            p,
            ["onFocus", "onBlur"].includes(f)
          );
        }), l.value = void 0;
      }
    }), t({
      triggerRef: l
    }), (d, f) => d.virtualTriggering ? Ie("v-if", !0) : (G(), Me(S(z7), Ut({ key: 0 }, d.$attrs, {
      "aria-controls": r.value,
      "aria-describedby": a.value,
      "aria-expanded": s.value,
      "aria-haspopup": i.value
    }), {
      default: Ee(() => [
        Oe(d.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
  }
});
var Nce = /* @__PURE__ */ Je(kce, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
const FC = "focus-trap.focus-after-trapped", VC = "focus-trap.focus-after-released", Mce = "focus-trap.focusout-prevented", $3 = {
  cancelable: !0,
  bubbles: !1
}, Ace = {
  cancelable: !0,
  bubbles: !1
}, x3 = "focusAfterTrapped", E3 = "focusAfterReleased", j7 = Symbol("elFocusTrap"), VO = /* @__PURE__ */ H(), B1 = /* @__PURE__ */ H(0), zO = /* @__PURE__ */ H(0);
let lg = 0;
const W7 = (e) => {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (o) => {
      const l = o.tagName === "INPUT" && o.type === "hidden";
      return o.disabled || o.hidden || l ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 || o === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    t.push(n.currentNode);
  return t;
}, O3 = (e, t) => {
  for (const n of e)
    if (!Rce(n, t))
      return n;
}, Rce = (e, t) => {
  if (process.env.NODE_ENV === "test")
    return !1;
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  for (; e; ) {
    if (t && e === t)
      return !1;
    if (getComputedStyle(e).display === "none")
      return !0;
    e = e.parentElement;
  }
  return !1;
}, Dce = (e) => {
  const t = W7(e), n = O3(t, e), o = O3(t.reverse(), e);
  return [n, o];
}, Lce = (e) => e instanceof HTMLInputElement && "select" in e, Bs = (e, t) => {
  if (e) {
    const n = document.activeElement;
    dh(e, { preventScroll: !0 }), zO.value = window.performance.now(), e !== n && Lce(e) && t && e.select();
  }
};
function _3(e, t) {
  const n = [...e], o = e.indexOf(t);
  return o !== -1 && n.splice(o, 1), n;
}
const Bce = () => {
  let e = [];
  return {
    push: (o) => {
      const l = e[0];
      l && o !== l && l.pause(), e = _3(e, o), e.unshift(o);
    },
    remove: (o) => {
      var l, r;
      e = _3(e, o), (r = (l = e[0]) == null ? void 0 : l.resume) == null || r.call(l);
    }
  };
}, Fce = (e, t = !1) => {
  const n = document.activeElement;
  for (const o of e)
    if (Bs(o, t), document.activeElement !== n)
      return;
}, I3 = Bce(), Vce = () => B1.value > zO.value, rg = () => {
  VO.value = "pointer", B1.value = window.performance.now();
}, T3 = () => {
  VO.value = "keyboard", B1.value = window.performance.now();
}, zce = () => (nt(() => {
  lg === 0 && (document.addEventListener("mousedown", rg), document.addEventListener("touchstart", rg), document.addEventListener("keydown", T3)), lg++;
}), yt(() => {
  lg--, lg <= 0 && (document.removeEventListener("mousedown", rg), document.removeEventListener("touchstart", rg), document.removeEventListener("keydown", T3));
}), {
  focusReason: VO,
  lastUserFocusTimestamp: B1,
  lastAutomatedFocusTimestamp: zO
}), ag = (e) => new CustomEvent(Mce, vt(Be({}, Ace), {
  detail: e
})), Ye = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
}, qo = (e, t, { checkForDefaultPrevented: n = !0 } = {}) => (l) => {
  const r = e == null ? void 0 : e(l);
  if (n === !1 || !r)
    return t == null ? void 0 : t(l);
}, P3 = (e) => (t) => t.pointerType === "mouse" ? e(t) : void 0, Nn = (e) => {
  if (e.code && e.code !== "Unidentified")
    return e.code;
  const t = K7(e);
  if (t) {
    if (Object.values(Ye).includes(t))
      return t;
    switch (t) {
      case " ":
        return Ye.space;
      default:
        return "";
    }
  }
  return "";
}, K7 = (e) => {
  let t = e.key && e.key !== "Unidentified" ? e.key : "";
  if (!t && e.type === "keyup" && P7()) {
    const n = e.target;
    t = n.value.charAt(n.selectionStart - 1);
  }
  return t;
};
let Vd = [];
const k3 = (e) => {
  Nn(e) === Ye.esc && Vd.forEach(
    (n) => n(e)
  );
}, Hce = (e) => {
  nt(() => {
    Vd.length === 0 && document.addEventListener("keydown", k3), Sn && Vd.push(e);
  }), yt(() => {
    Vd = Vd.filter(
      (t) => t !== e
    ), Vd.length === 0 && Sn && document.removeEventListener("keydown", k3);
  });
}, jce = /* @__PURE__ */ le({
  name: "ElFocusTrap",
  inheritAttrs: !1,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    x3,
    E3,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(e, { emit: t }) {
    const n = /* @__PURE__ */ H();
    let o, l;
    const { focusReason: r } = zce();
    Hce((m) => {
      e.trapped && !a.paused && t("release-requested", m);
    });
    const a = {
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }, i = (m) => {
      if (!e.loop && !e.trapped || a.paused)
        return;
      const { altKey: v, ctrlKey: h, metaKey: g, currentTarget: y, shiftKey: b } = m, { loop: C } = e, x = Nn(m) === Ye.tab && !v && !h && !g, E = document.activeElement;
      if (x && E) {
        const I = y, [T, P] = Dce(I);
        if (T && P) {
          if (!b && E === P) {
            const N = ag({
              focusReason: r.value
            });
            t("focusout-prevented", N), N.defaultPrevented || (m.preventDefault(), C && Bs(T, !0));
          } else if (b && [T, I].includes(E)) {
            const N = ag({
              focusReason: r.value
            });
            t("focusout-prevented", N), N.defaultPrevented || (m.preventDefault(), C && Bs(P, !0));
          }
        } else if (E === I) {
          const N = ag({
            focusReason: r.value
          });
          t("focusout-prevented", N), N.defaultPrevented || m.preventDefault();
        }
      }
    };
    at(j7, {
      focusTrapRef: n,
      onKeydown: i
    }), pe(
      () => e.focusTrapEl,
      (m) => {
        m && (n.value = m);
      },
      { immediate: !0 }
    ), pe([n], ([m], [v]) => {
      m && (m.addEventListener("keydown", i), m.addEventListener("focusin", u), m.addEventListener("focusout", d)), v && (v.removeEventListener("keydown", i), v.removeEventListener("focusin", u), v.removeEventListener("focusout", d));
    });
    const s = (m) => {
      t(x3, m);
    }, c = (m) => t(E3, m), u = (m) => {
      const v = S(n);
      if (!v)
        return;
      const h = m.target, g = m.relatedTarget, y = h && v.contains(h);
      e.trapped || g && v.contains(g) || (o = g), y && t("focusin", m), !a.paused && e.trapped && (y ? l = h : Bs(l, !0));
    }, d = (m) => {
      const v = S(n);
      if (!(a.paused || !v))
        if (e.trapped) {
          const h = m.relatedTarget;
          !wo(h) && !v.contains(h) && setTimeout(() => {
            if (!a.paused && e.trapped) {
              const g = ag({
                focusReason: r.value
              });
              t("focusout-prevented", g), g.defaultPrevented || Bs(l, !0);
            }
          }, 0);
        } else {
          const h = m.target;
          h && v.contains(h) || t("focusout", m);
        }
    };
    function f() {
      return Rt(this, null, function* () {
        yield Ke();
        const m = S(n);
        if (m) {
          I3.push(a);
          const v = m.contains(
            document.activeElement
          ) ? o : document.activeElement;
          if (o = v, !m.contains(v)) {
            const g = new Event(
              FC,
              $3
            );
            m.addEventListener(FC, s), m.dispatchEvent(g), g.defaultPrevented || Ke(() => {
              let y = e.focusStartEl;
              rt(y) || (Bs(y), document.activeElement !== y && (y = "first")), y === "first" && Fce(
                W7(m),
                !0
              ), (document.activeElement === v || y === "container") && Bs(m);
            });
          }
        }
      });
    }
    function p() {
      const m = S(n);
      if (m) {
        m.removeEventListener(FC, s);
        const v = new CustomEvent(VC, vt(Be({}, $3), {
          detail: {
            focusReason: r.value
          }
        }));
        m.addEventListener(VC, c), m.dispatchEvent(v), !v.defaultPrevented && (r.value == "keyboard" || !Vce() || m.contains(document.activeElement)) && Bs(o != null ? o : document.body), m.removeEventListener(VC, c), I3.remove(a), o = null, l = null;
      }
    }
    return nt(() => {
      e.trapped && f(), pe(
        () => e.trapped,
        (m) => {
          m ? f() : p();
        }
      );
    }), yt(() => {
      e.trapped && p(), n.value && (n.value.removeEventListener("keydown", i), n.value.removeEventListener("focusin", u), n.value.removeEventListener("focusout", d), n.value = void 0), o = null, l = null;
    }), {
      onKeydown: i
    };
  }
});
function Wce(e, t, n, o, l, r) {
  return Oe(e.$slots, "default", { handleKeydown: e.onKeydown });
}
var xp = /* @__PURE__ */ Je(jce, [["render", Wce], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]), gr = "top", ia = "bottom", sa = "right", br = "left", HO = "auto", ph = [gr, ia, sa, br], Wf = "start", um = "end", Kce = "clippingParents", U7 = "viewport", Zp = "popper", Uce = "reference", N3 = ph.reduce(function(e, t) {
  return e.concat([t + "-" + Wf, t + "-" + um]);
}, []), Mi = [].concat(ph, [HO]).reduce(function(e, t) {
  return e.concat([t, t + "-" + Wf, t + "-" + um]);
}, []), Gce = "beforeRead", Yce = "read", Xce = "afterRead", qce = "beforeMain", Jce = "main", Zce = "afterMain", Qce = "beforeWrite", eue = "write", tue = "afterWrite", nue = [Gce, Yce, Xce, qce, Jce, Zce, Qce, eue, tue];
function xi(e) {
  return e ? (e.nodeName || "").toLowerCase() : null;
}
function Ga(e) {
  if (e == null) return window;
  if (e.toString() !== "[object Window]") {
    var t = e.ownerDocument;
    return t && t.defaultView || window;
  }
  return e;
}
function Kf(e) {
  var t = Ga(e).Element;
  return e instanceof t || e instanceof Element;
}
function na(e) {
  var t = Ga(e).HTMLElement;
  return e instanceof t || e instanceof HTMLElement;
}
function jO(e) {
  if (typeof ShadowRoot == "undefined") return !1;
  var t = Ga(e).ShadowRoot;
  return e instanceof t || e instanceof ShadowRoot;
}
function oue(e) {
  var t = e.state;
  Object.keys(t.elements).forEach(function(n) {
    var o = t.styles[n] || {}, l = t.attributes[n] || {}, r = t.elements[n];
    !na(r) || !xi(r) || (Object.assign(r.style, o), Object.keys(l).forEach(function(a) {
      var i = l[a];
      i === !1 ? r.removeAttribute(a) : r.setAttribute(a, i === !0 ? "" : i);
    }));
  });
}
function lue(e) {
  var t = e.state, n = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
    Object.keys(t.elements).forEach(function(o) {
      var l = t.elements[o], r = t.attributes[o] || {}, a = Object.keys(t.styles.hasOwnProperty(o) ? t.styles[o] : n[o]), i = a.reduce(function(s, c) {
        return s[c] = "", s;
      }, {});
      !na(l) || !xi(l) || (Object.assign(l.style, i), Object.keys(r).forEach(function(s) {
        l.removeAttribute(s);
      }));
    });
  };
}
var G7 = { name: "applyStyles", enabled: !0, phase: "write", fn: oue, effect: lue, requires: ["computeStyles"] };
function vi(e) {
  return e.split("-")[0];
}
var Eu = Math.max, M0 = Math.min, Uf = Math.round;
function Gf(e, t) {
  t === void 0 && (t = !1);
  var n = e.getBoundingClientRect(), o = 1, l = 1;
  if (na(e) && t) {
    var r = e.offsetHeight, a = e.offsetWidth;
    a > 0 && (o = Uf(n.width) / a || 1), r > 0 && (l = Uf(n.height) / r || 1);
  }
  return { width: n.width / o, height: n.height / l, top: n.top / l, right: n.right / o, bottom: n.bottom / l, left: n.left / o, x: n.left / o, y: n.top / l };
}
function WO(e) {
  var t = Gf(e), n = e.offsetWidth, o = e.offsetHeight;
  return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - o) <= 1 && (o = t.height), { x: e.offsetLeft, y: e.offsetTop, width: n, height: o };
}
function Y7(e, t) {
  var n = t.getRootNode && t.getRootNode();
  if (e.contains(t)) return !0;
  if (n && jO(n)) {
    var o = t;
    do {
      if (o && e.isSameNode(o)) return !0;
      o = o.parentNode || o.host;
    } while (o);
  }
  return !1;
}
function hs(e) {
  return Ga(e).getComputedStyle(e);
}
function rue(e) {
  return ["table", "td", "th"].indexOf(xi(e)) >= 0;
}
function Nc(e) {
  return ((Kf(e) ? e.ownerDocument : e.document) || window.document).documentElement;
}
function F1(e) {
  return xi(e) === "html" ? e : e.assignedSlot || e.parentNode || (jO(e) ? e.host : null) || Nc(e);
}
function M3(e) {
  return !na(e) || hs(e).position === "fixed" ? null : e.offsetParent;
}
function aue(e) {
  var t = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && na(e)) {
    var o = hs(e);
    if (o.position === "fixed") return null;
  }
  var l = F1(e);
  for (jO(l) && (l = l.host); na(l) && ["html", "body"].indexOf(xi(l)) < 0; ) {
    var r = hs(l);
    if (r.transform !== "none" || r.perspective !== "none" || r.contain === "paint" || ["transform", "perspective"].indexOf(r.willChange) !== -1 || t && r.willChange === "filter" || t && r.filter && r.filter !== "none") return l;
    l = l.parentNode;
  }
  return null;
}
function vh(e) {
  for (var t = Ga(e), n = M3(e); n && rue(n) && hs(n).position === "static"; ) n = M3(n);
  return n && (xi(n) === "html" || xi(n) === "body" && hs(n).position === "static") ? t : n || aue(e) || t;
}
function KO(e) {
  return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
}
function Tv(e, t, n) {
  return Eu(e, M0(t, n));
}
function iue(e, t, n) {
  var o = Tv(e, t, n);
  return o > n ? n : o;
}
function X7() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function q7(e) {
  return Object.assign({}, X7(), e);
}
function J7(e, t) {
  return t.reduce(function(n, o) {
    return n[o] = e, n;
  }, {});
}
var sue = function(e, t) {
  return e = typeof e == "function" ? e(Object.assign({}, t.rects, { placement: t.placement })) : e, q7(typeof e != "number" ? e : J7(e, ph));
};
function cue(e) {
  var t, n = e.state, o = e.name, l = e.options, r = n.elements.arrow, a = n.modifiersData.popperOffsets, i = vi(n.placement), s = KO(i), c = [br, sa].indexOf(i) >= 0, u = c ? "height" : "width";
  if (!(!r || !a)) {
    var d = sue(l.padding, n), f = WO(r), p = s === "y" ? gr : br, m = s === "y" ? ia : sa, v = n.rects.reference[u] + n.rects.reference[s] - a[s] - n.rects.popper[u], h = a[s] - n.rects.reference[s], g = vh(r), y = g ? s === "y" ? g.clientHeight || 0 : g.clientWidth || 0 : 0, b = v / 2 - h / 2, C = d[p], w = y - f[u] - d[m], x = y / 2 - f[u] / 2 + b, E = Tv(C, x, w), I = s;
    n.modifiersData[o] = (t = {}, t[I] = E, t.centerOffset = E - x, t);
  }
}
function uue(e) {
  var t = e.state, n = e.options, o = n.element, l = o === void 0 ? "[data-popper-arrow]" : o;
  l != null && (typeof l == "string" && (l = t.elements.popper.querySelector(l), !l) || !Y7(t.elements.popper, l) || (t.elements.arrow = l));
}
var due = { name: "arrow", enabled: !0, phase: "main", fn: cue, effect: uue, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function Yf(e) {
  return e.split("-")[1];
}
var fue = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function pue(e) {
  var t = e.x, n = e.y, o = window, l = o.devicePixelRatio || 1;
  return { x: Uf(t * l) / l || 0, y: Uf(n * l) / l || 0 };
}
function A3(e) {
  var t, n = e.popper, o = e.popperRect, l = e.placement, r = e.variation, a = e.offsets, i = e.position, s = e.gpuAcceleration, c = e.adaptive, u = e.roundOffsets, d = e.isFixed, f = a.x, p = f === void 0 ? 0 : f, m = a.y, v = m === void 0 ? 0 : m, h = typeof u == "function" ? u({ x: p, y: v }) : { x: p, y: v };
  p = h.x, v = h.y;
  var g = a.hasOwnProperty("x"), y = a.hasOwnProperty("y"), b = br, C = gr, w = window;
  if (c) {
    var x = vh(n), E = "clientHeight", I = "clientWidth";
    if (x === Ga(n) && (x = Nc(n), hs(x).position !== "static" && i === "absolute" && (E = "scrollHeight", I = "scrollWidth")), x = x, l === gr || (l === br || l === sa) && r === um) {
      C = ia;
      var T = d && x === w && w.visualViewport ? w.visualViewport.height : x[E];
      v -= T - o.height, v *= s ? 1 : -1;
    }
    if (l === br || (l === gr || l === ia) && r === um) {
      b = sa;
      var P = d && x === w && w.visualViewport ? w.visualViewport.width : x[I];
      p -= P - o.width, p *= s ? 1 : -1;
    }
  }
  var k = Object.assign({ position: i }, c && fue), N = u === !0 ? pue({ x: p, y: v }) : { x: p, y: v };
  if (p = N.x, v = N.y, s) {
    var R;
    return Object.assign({}, k, (R = {}, R[C] = y ? "0" : "", R[b] = g ? "0" : "", R.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + v + "px)" : "translate3d(" + p + "px, " + v + "px, 0)", R));
  }
  return Object.assign({}, k, (t = {}, t[C] = y ? v + "px" : "", t[b] = g ? p + "px" : "", t.transform = "", t));
}
function vue(e) {
  var t = e.state, n = e.options, o = n.gpuAcceleration, l = o === void 0 ? !0 : o, r = n.adaptive, a = r === void 0 ? !0 : r, i = n.roundOffsets, s = i === void 0 ? !0 : i, c = { placement: vi(t.placement), variation: Yf(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: l, isFixed: t.options.strategy === "fixed" };
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, A3(Object.assign({}, c, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: a, roundOffsets: s })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, A3(Object.assign({}, c, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: s })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement });
}
var Z7 = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: vue, data: {} }, ig = { passive: !0 };
function mue(e) {
  var t = e.state, n = e.instance, o = e.options, l = o.scroll, r = l === void 0 ? !0 : l, a = o.resize, i = a === void 0 ? !0 : a, s = Ga(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return r && c.forEach(function(u) {
    u.addEventListener("scroll", n.update, ig);
  }), i && s.addEventListener("resize", n.update, ig), function() {
    r && c.forEach(function(u) {
      u.removeEventListener("scroll", n.update, ig);
    }), i && s.removeEventListener("resize", n.update, ig);
  };
}
var Q7 = { name: "eventListeners", enabled: !0, phase: "write", fn: function() {
}, effect: mue, data: {} }, hue = { left: "right", right: "left", bottom: "top", top: "bottom" };
function db(e) {
  return e.replace(/left|right|bottom|top/g, function(t) {
    return hue[t];
  });
}
var gue = { start: "end", end: "start" };
function R3(e) {
  return e.replace(/start|end/g, function(t) {
    return gue[t];
  });
}
function UO(e) {
  var t = Ga(e), n = t.pageXOffset, o = t.pageYOffset;
  return { scrollLeft: n, scrollTop: o };
}
function GO(e) {
  return Gf(Nc(e)).left + UO(e).scrollLeft;
}
function bue(e) {
  var t = Ga(e), n = Nc(e), o = t.visualViewport, l = n.clientWidth, r = n.clientHeight, a = 0, i = 0;
  return o && (l = o.width, r = o.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = o.offsetLeft, i = o.offsetTop)), { width: l, height: r, x: a + GO(e), y: i };
}
function yue(e) {
  var t, n = Nc(e), o = UO(e), l = (t = e.ownerDocument) == null ? void 0 : t.body, r = Eu(n.scrollWidth, n.clientWidth, l ? l.scrollWidth : 0, l ? l.clientWidth : 0), a = Eu(n.scrollHeight, n.clientHeight, l ? l.scrollHeight : 0, l ? l.clientHeight : 0), i = -o.scrollLeft + GO(e), s = -o.scrollTop;
  return hs(l || n).direction === "rtl" && (i += Eu(n.clientWidth, l ? l.clientWidth : 0) - r), { width: r, height: a, x: i, y: s };
}
function YO(e) {
  var t = hs(e), n = t.overflow, o = t.overflowX, l = t.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + l + o);
}
function eF(e) {
  return ["html", "body", "#document"].indexOf(xi(e)) >= 0 ? e.ownerDocument.body : na(e) && YO(e) ? e : eF(F1(e));
}
function Pv(e, t) {
  var n;
  t === void 0 && (t = []);
  var o = eF(e), l = o === ((n = e.ownerDocument) == null ? void 0 : n.body), r = Ga(o), a = l ? [r].concat(r.visualViewport || [], YO(o) ? o : []) : o, i = t.concat(a);
  return l ? i : i.concat(Pv(F1(a)));
}
function lx(e) {
  return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height });
}
function Sue(e) {
  var t = Gf(e);
  return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t;
}
function D3(e, t) {
  return t === U7 ? lx(bue(e)) : Kf(t) ? Sue(t) : lx(yue(Nc(e)));
}
function Cue(e) {
  var t = Pv(F1(e)), n = ["absolute", "fixed"].indexOf(hs(e).position) >= 0, o = n && na(e) ? vh(e) : e;
  return Kf(o) ? t.filter(function(l) {
    return Kf(l) && Y7(l, o) && xi(l) !== "body";
  }) : [];
}
function wue(e, t, n) {
  var o = t === "clippingParents" ? Cue(e) : [].concat(t), l = [].concat(o, [n]), r = l[0], a = l.reduce(function(i, s) {
    var c = D3(e, s);
    return i.top = Eu(c.top, i.top), i.right = M0(c.right, i.right), i.bottom = M0(c.bottom, i.bottom), i.left = Eu(c.left, i.left), i;
  }, D3(e, r));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function tF(e) {
  var t = e.reference, n = e.element, o = e.placement, l = o ? vi(o) : null, r = o ? Yf(o) : null, a = t.x + t.width / 2 - n.width / 2, i = t.y + t.height / 2 - n.height / 2, s;
  switch (l) {
    case gr:
      s = { x: a, y: t.y - n.height };
      break;
    case ia:
      s = { x: a, y: t.y + t.height };
      break;
    case sa:
      s = { x: t.x + t.width, y: i };
      break;
    case br:
      s = { x: t.x - n.width, y: i };
      break;
    default:
      s = { x: t.x, y: t.y };
  }
  var c = l ? KO(l) : null;
  if (c != null) {
    var u = c === "y" ? "height" : "width";
    switch (r) {
      case Wf:
        s[c] = s[c] - (t[u] / 2 - n[u] / 2);
        break;
      case um:
        s[c] = s[c] + (t[u] / 2 - n[u] / 2);
        break;
    }
  }
  return s;
}
function dm(e, t) {
  t === void 0 && (t = {});
  var n = t, o = n.placement, l = o === void 0 ? e.placement : o, r = n.boundary, a = r === void 0 ? Kce : r, i = n.rootBoundary, s = i === void 0 ? U7 : i, c = n.elementContext, u = c === void 0 ? Zp : c, d = n.altBoundary, f = d === void 0 ? !1 : d, p = n.padding, m = p === void 0 ? 0 : p, v = q7(typeof m != "number" ? m : J7(m, ph)), h = u === Zp ? Uce : Zp, g = e.rects.popper, y = e.elements[f ? h : u], b = wue(Kf(y) ? y : y.contextElement || Nc(e.elements.popper), a, s), C = Gf(e.elements.reference), w = tF({ reference: C, element: g, placement: l }), x = lx(Object.assign({}, g, w)), E = u === Zp ? x : C, I = { top: b.top - E.top + v.top, bottom: E.bottom - b.bottom + v.bottom, left: b.left - E.left + v.left, right: E.right - b.right + v.right }, T = e.modifiersData.offset;
  if (u === Zp && T) {
    var P = T[l];
    Object.keys(I).forEach(function(k) {
      var N = [sa, ia].indexOf(k) >= 0 ? 1 : -1, R = [gr, ia].indexOf(k) >= 0 ? "y" : "x";
      I[k] += P[R] * N;
    });
  }
  return I;
}
function $ue(e, t) {
  t === void 0 && (t = {});
  var n = t, o = n.placement, l = n.boundary, r = n.rootBoundary, a = n.padding, i = n.flipVariations, s = n.allowedAutoPlacements, c = s === void 0 ? Mi : s, u = Yf(o), d = u ? i ? N3 : N3.filter(function(m) {
    return Yf(m) === u;
  }) : ph, f = d.filter(function(m) {
    return c.indexOf(m) >= 0;
  });
  f.length === 0 && (f = d);
  var p = f.reduce(function(m, v) {
    return m[v] = dm(e, { placement: v, boundary: l, rootBoundary: r, padding: a })[vi(v)], m;
  }, {});
  return Object.keys(p).sort(function(m, v) {
    return p[m] - p[v];
  });
}
function xue(e) {
  if (vi(e) === HO) return [];
  var t = db(e);
  return [R3(e), t, R3(t)];
}
function Eue(e) {
  var t = e.state, n = e.options, o = e.name;
  if (!t.modifiersData[o]._skip) {
    for (var l = n.mainAxis, r = l === void 0 ? !0 : l, a = n.altAxis, i = a === void 0 ? !0 : a, s = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, f = n.altBoundary, p = n.flipVariations, m = p === void 0 ? !0 : p, v = n.allowedAutoPlacements, h = t.options.placement, g = vi(h), y = g === h, b = s || (y || !m ? [db(h)] : xue(h)), C = [h].concat(b).reduce(function(Y, U) {
      return Y.concat(vi(U) === HO ? $ue(t, { placement: U, boundary: u, rootBoundary: d, padding: c, flipVariations: m, allowedAutoPlacements: v }) : U);
    }, []), w = t.rects.reference, x = t.rects.popper, E = /* @__PURE__ */ new Map(), I = !0, T = C[0], P = 0; P < C.length; P++) {
      var k = C[P], N = vi(k), R = Yf(k) === Wf, z = [gr, ia].indexOf(N) >= 0, D = z ? "width" : "height", F = dm(t, { placement: k, boundary: u, rootBoundary: d, altBoundary: f, padding: c }), M = z ? R ? sa : br : R ? ia : gr;
      w[D] > x[D] && (M = db(M));
      var A = db(M), L = [];
      if (r && L.push(F[N] <= 0), i && L.push(F[M] <= 0, F[A] <= 0), L.every(function(Y) {
        return Y;
      })) {
        T = k, I = !1;
        break;
      }
      E.set(k, L);
    }
    if (I) for (var B = m ? 3 : 1, V = function(Y) {
      var U = C.find(function(te) {
        var J = E.get(te);
        if (J) return J.slice(0, Y).every(function(re) {
          return re;
        });
      });
      if (U) return T = U, "break";
    }, j = B; j > 0; j--) {
      var W = V(j);
      if (W === "break") break;
    }
    t.placement !== T && (t.modifiersData[o]._skip = !0, t.placement = T, t.reset = !0);
  }
}
var Oue = { name: "flip", enabled: !0, phase: "main", fn: Eue, requiresIfExists: ["offset"], data: { _skip: !1 } };
function L3(e, t, n) {
  return n === void 0 && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x };
}
function B3(e) {
  return [gr, sa, ia, br].some(function(t) {
    return e[t] >= 0;
  });
}
function _ue(e) {
  var t = e.state, n = e.name, o = t.rects.reference, l = t.rects.popper, r = t.modifiersData.preventOverflow, a = dm(t, { elementContext: "reference" }), i = dm(t, { altBoundary: !0 }), s = L3(a, o), c = L3(i, l, r), u = B3(s), d = B3(c);
  t.modifiersData[n] = { referenceClippingOffsets: s, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: d }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": d });
}
var Iue = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: _ue };
function Tue(e, t, n) {
  var o = vi(e), l = [br, gr].indexOf(o) >= 0 ? -1 : 1, r = typeof n == "function" ? n(Object.assign({}, t, { placement: e })) : n, a = r[0], i = r[1];
  return a = a || 0, i = (i || 0) * l, [br, sa].indexOf(o) >= 0 ? { x: i, y: a } : { x: a, y: i };
}
function Pue(e) {
  var t = e.state, n = e.options, o = e.name, l = n.offset, r = l === void 0 ? [0, 0] : l, a = Mi.reduce(function(u, d) {
    return u[d] = Tue(d, t.rects, r), u;
  }, {}), i = a[t.placement], s = i.x, c = i.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += s, t.modifiersData.popperOffsets.y += c), t.modifiersData[o] = a;
}
var kue = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: Pue };
function Nue(e) {
  var t = e.state, n = e.name;
  t.modifiersData[n] = tF({ reference: t.rects.reference, element: t.rects.popper, placement: t.placement });
}
var nF = { name: "popperOffsets", enabled: !0, phase: "read", fn: Nue, data: {} };
function Mue(e) {
  return e === "x" ? "y" : "x";
}
function Aue(e) {
  var t = e.state, n = e.options, o = e.name, l = n.mainAxis, r = l === void 0 ? !0 : l, a = n.altAxis, i = a === void 0 ? !1 : a, s = n.boundary, c = n.rootBoundary, u = n.altBoundary, d = n.padding, f = n.tether, p = f === void 0 ? !0 : f, m = n.tetherOffset, v = m === void 0 ? 0 : m, h = dm(t, { boundary: s, rootBoundary: c, padding: d, altBoundary: u }), g = vi(t.placement), y = Yf(t.placement), b = !y, C = KO(g), w = Mue(C), x = t.modifiersData.popperOffsets, E = t.rects.reference, I = t.rects.popper, T = typeof v == "function" ? v(Object.assign({}, t.rects, { placement: t.placement })) : v, P = typeof T == "number" ? { mainAxis: T, altAxis: T } : Object.assign({ mainAxis: 0, altAxis: 0 }, T), k = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, N = { x: 0, y: 0 };
  if (x) {
    if (r) {
      var R, z = C === "y" ? gr : br, D = C === "y" ? ia : sa, F = C === "y" ? "height" : "width", M = x[C], A = M + h[z], L = M - h[D], B = p ? -I[F] / 2 : 0, V = y === Wf ? E[F] : I[F], j = y === Wf ? -I[F] : -E[F], W = t.elements.arrow, Y = p && W ? WO(W) : { width: 0, height: 0 }, U = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : X7(), te = U[z], J = U[D], re = Tv(0, E[F], Y[F]), oe = b ? E[F] / 2 - B - re - te - P.mainAxis : V - re - te - P.mainAxis, q = b ? -E[F] / 2 + B + re + J + P.mainAxis : j + re + J + P.mainAxis, K = t.elements.arrow && vh(t.elements.arrow), se = K ? C === "y" ? K.clientTop || 0 : K.clientLeft || 0 : 0, Z = (R = k == null ? void 0 : k[C]) != null ? R : 0, ee = M + oe - Z - se, fe = M + q - Z, me = Tv(p ? M0(A, ee) : A, M, p ? Eu(L, fe) : L);
      x[C] = me, N[C] = me - M;
    }
    if (i) {
      var ge, he = C === "x" ? gr : br, $e = C === "x" ? ia : sa, ne = x[w], ae = w === "y" ? "height" : "width", ce = ne + h[he], xe = ne - h[$e], Te = [gr, br].indexOf(g) !== -1, Se = (ge = k == null ? void 0 : k[w]) != null ? ge : 0, be = Te ? ce : ne - E[ae] - I[ae] - Se + P.altAxis, ie = Te ? ne + E[ae] + I[ae] - Se - P.altAxis : xe, we = p && Te ? iue(be, ne, ie) : Tv(p ? be : ce, ne, p ? ie : xe);
      x[w] = we, N[w] = we - ne;
    }
    t.modifiersData[o] = N;
  }
}
var Rue = { name: "preventOverflow", enabled: !0, phase: "main", fn: Aue, requiresIfExists: ["offset"] };
function Due(e) {
  return { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop };
}
function Lue(e) {
  return e === Ga(e) || !na(e) ? UO(e) : Due(e);
}
function Bue(e) {
  var t = e.getBoundingClientRect(), n = Uf(t.width) / e.offsetWidth || 1, o = Uf(t.height) / e.offsetHeight || 1;
  return n !== 1 || o !== 1;
}
function Fue(e, t, n) {
  n === void 0 && (n = !1);
  var o = na(t), l = na(t) && Bue(t), r = Nc(t), a = Gf(e, l), i = { scrollLeft: 0, scrollTop: 0 }, s = { x: 0, y: 0 };
  return (o || !o && !n) && ((xi(t) !== "body" || YO(r)) && (i = Lue(t)), na(t) ? (s = Gf(t, !0), s.x += t.clientLeft, s.y += t.clientTop) : r && (s.x = GO(r))), { x: a.left + i.scrollLeft - s.x, y: a.top + i.scrollTop - s.y, width: a.width, height: a.height };
}
function Vue(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), o = [];
  e.forEach(function(r) {
    t.set(r.name, r);
  });
  function l(r) {
    n.add(r.name);
    var a = [].concat(r.requires || [], r.requiresIfExists || []);
    a.forEach(function(i) {
      if (!n.has(i)) {
        var s = t.get(i);
        s && l(s);
      }
    }), o.push(r);
  }
  return e.forEach(function(r) {
    n.has(r.name) || l(r);
  }), o;
}
function zue(e) {
  var t = Vue(e);
  return nue.reduce(function(n, o) {
    return n.concat(t.filter(function(l) {
      return l.phase === o;
    }));
  }, []);
}
function Hue(e) {
  var t;
  return function() {
    return t || (t = new Promise(function(n) {
      Promise.resolve().then(function() {
        t = void 0, n(e());
      });
    })), t;
  };
}
function jue(e) {
  var t = e.reduce(function(n, o) {
    var l = n[o.name];
    return n[o.name] = l ? Object.assign({}, l, o, { options: Object.assign({}, l.options, o.options), data: Object.assign({}, l.data, o.data) }) : o, n;
  }, {});
  return Object.keys(t).map(function(n) {
    return t[n];
  });
}
var F3 = { placement: "bottom", modifiers: [], strategy: "absolute" };
function V3() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
  return !t.some(function(o) {
    return !(o && typeof o.getBoundingClientRect == "function");
  });
}
function XO(e) {
  e === void 0 && (e = {});
  var t = e, n = t.defaultModifiers, o = n === void 0 ? [] : n, l = t.defaultOptions, r = l === void 0 ? F3 : l;
  return function(a, i, s) {
    s === void 0 && (s = r);
    var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, F3, r), modifiersData: {}, elements: { reference: a, popper: i }, attributes: {}, styles: {} }, u = [], d = !1, f = { state: c, setOptions: function(v) {
      var h = typeof v == "function" ? v(c.options) : v;
      m(), c.options = Object.assign({}, r, c.options, h), c.scrollParents = { reference: Kf(a) ? Pv(a) : a.contextElement ? Pv(a.contextElement) : [], popper: Pv(i) };
      var g = zue(jue([].concat(o, c.options.modifiers)));
      return c.orderedModifiers = g.filter(function(y) {
        return y.enabled;
      }), p(), f.update();
    }, forceUpdate: function() {
      if (!d) {
        var v = c.elements, h = v.reference, g = v.popper;
        if (V3(h, g)) {
          c.rects = { reference: Fue(h, vh(g), c.options.strategy === "fixed"), popper: WO(g) }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(I) {
            return c.modifiersData[I.name] = Object.assign({}, I.data);
          });
          for (var y = 0; y < c.orderedModifiers.length; y++) {
            if (c.reset === !0) {
              c.reset = !1, y = -1;
              continue;
            }
            var b = c.orderedModifiers[y], C = b.fn, w = b.options, x = w === void 0 ? {} : w, E = b.name;
            typeof C == "function" && (c = C({ state: c, options: x, name: E, instance: f }) || c);
          }
        }
      }
    }, update: Hue(function() {
      return new Promise(function(v) {
        f.forceUpdate(), v(c);
      });
    }), destroy: function() {
      m(), d = !0;
    } };
    if (!V3(a, i)) return f;
    f.setOptions(s).then(function(v) {
      !d && s.onFirstUpdate && s.onFirstUpdate(v);
    });
    function p() {
      c.orderedModifiers.forEach(function(v) {
        var h = v.name, g = v.options, y = g === void 0 ? {} : g, b = v.effect;
        if (typeof b == "function") {
          var C = b({ state: c, name: h, instance: f, options: y }), w = function() {
          };
          u.push(C || w);
        }
      });
    }
    function m() {
      u.forEach(function(v) {
        return v();
      }), u = [];
    }
    return f;
  };
}
XO();
var Wue = [Q7, nF, Z7, G7];
XO({ defaultModifiers: Wue });
var Kue = [Q7, nF, Z7, G7, kue, Oue, Rue, due, Iue], Uue = XO({ defaultModifiers: Kue });
const oF = Xe({
  arrowOffset: {
    type: Number,
    default: 5
  }
}), Gue = ["fixed", "absolute"], Yue = Xe({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: ye(Array),
    default: void 0
  },
  gpuAcceleration: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: Mi,
    default: "bottom"
  },
  popperOptions: {
    type: ye(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: Gue,
    default: "absolute"
  }
}), lF = Xe(vt(Be(vt(Be(Be({}, Yue), oF), {
  id: String,
  style: {
    type: ye([String, Array, Object])
  },
  className: {
    type: ye([String, Array, Object])
  },
  effect: {
    type: ye(String),
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: !0
  },
  pure: Boolean,
  focusOnShow: Boolean,
  trapping: Boolean,
  popperClass: {
    type: ye([String, Array, Object])
  },
  popperStyle: {
    type: ye([String, Array, Object])
  },
  referenceEl: {
    type: ye(Object)
  },
  triggerTargetEl: {
    type: ye(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: !0
  },
  virtualTriggering: Boolean,
  zIndex: Number
}), zl(["ariaLabel"])), {
  loop: Boolean
})), Xue = {
  mouseenter: (e) => e instanceof MouseEvent,
  mouseleave: (e) => e instanceof MouseEvent,
  focus: () => !0,
  blur: () => !0,
  close: () => !0
}, que = (e, t) => {
  const n = /* @__PURE__ */ H(!1), o = /* @__PURE__ */ H(), l = () => {
    t("focus");
  }, r = (c) => {
    var u;
    ((u = c.detail) == null ? void 0 : u.focusReason) !== "pointer" && (o.value = "first", t("blur"));
  }, a = (c) => {
    e.visible && !n.value && (c.target && (o.value = c.target), n.value = !0);
  }, i = (c) => {
    e.trapping || (c.detail.focusReason === "pointer" && c.preventDefault(), n.value = !1);
  }, s = () => {
    n.value = !1, t("close");
  };
  return yt(() => {
    o.value = void 0;
  }), {
    focusStartRef: o,
    trapped: n,
    onFocusAfterReleased: r,
    onFocusAfterTrapped: l,
    onFocusInTrap: a,
    onFocusoutPrevented: i,
    onReleaseRequested: s
  };
}, Jue = (e, t = []) => {
  const { placement: n, strategy: o, popperOptions: l } = e, r = vt(Be({
    placement: n,
    strategy: o
  }, l), {
    modifiers: [...Que(e), ...t]
  });
  return ede(r, l == null ? void 0 : l.modifiers), r;
}, Zue = (e) => {
  if (Sn)
    return Lo(e);
};
function Que(e) {
  const { offset: t, gpuAcceleration: n, fallbackPlacements: o } = e;
  return [
    {
      name: "offset",
      options: {
        offset: [0, t != null ? t : 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: o
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration: n
      }
    }
  ];
}
function ede(e, t) {
  t && (e.modifiers = [...e.modifiers, ...t != null ? t : []]);
}
const tde = (e, t, n = {}) => {
  const o = {
    name: "updateState",
    enabled: !0,
    phase: "write",
    fn: ({ state: s }) => {
      const c = nde(s);
      Object.assign(a.value, c);
    },
    requires: ["computeStyles"]
  }, l = O(() => {
    const { onFirstUpdate: s, placement: c, strategy: u, modifiers: d } = S(n);
    return {
      onFirstUpdate: s,
      placement: c || "bottom",
      strategy: u || "absolute",
      modifiers: [
        ...d || [],
        o,
        { name: "applyStyles", enabled: !1 }
      ]
    };
  }), r = /* @__PURE__ */ Ce(), a = /* @__PURE__ */ H({
    styles: {
      popper: {
        position: S(l).strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), i = () => {
    r.value && (r.value.destroy(), r.value = void 0);
  };
  return pe(
    l,
    (s) => {
      const c = S(r);
      c && c.setOptions(s);
    },
    {
      deep: !0
    }
  ), pe(
    [e, t],
    ([s, c]) => {
      i(), !(!s || !c) && (r.value = Uue(
        s,
        c,
        S(l)
      ));
    }
  ), yt(() => {
    i();
  }), {
    state: O(() => {
      var s;
      return Be({}, ((s = S(r)) == null ? void 0 : s.state) || {});
    }),
    styles: O(() => S(a).styles),
    attributes: O(() => S(a).attributes),
    update: () => {
      var s;
      return (s = S(r)) == null ? void 0 : s.update();
    },
    forceUpdate: () => {
      var s;
      return (s = S(r)) == null ? void 0 : s.forceUpdate();
    },
    instanceRef: O(() => S(r))
  };
};
function nde(e) {
  const t = Object.keys(e.elements), n = Hf(
    t.map(
      (l) => [l, e.styles[l] || {}]
    )
  ), o = Hf(
    t.map(
      (l) => [l, e.attributes[l]]
    )
  );
  return {
    styles: n,
    attributes: o
  };
}
const ode = 0, lde = (e) => {
  const { popperInstanceRef: t, contentRef: n, triggerRef: o, role: l } = ze(
    FO,
    void 0
  ), r = /* @__PURE__ */ H(), a = O(() => e.arrowOffset), i = O(() => ({
    name: "eventListeners",
    enabled: !!e.visible
  })), s = O(() => {
    var g;
    const y = S(r), b = (g = S(a)) != null ? g : ode;
    return {
      name: "arrow",
      enabled: !_ae(y),
      options: {
        element: y,
        padding: b
      }
    };
  }), c = O(() => Be({
    onFirstUpdate: () => {
      m();
    }
  }, Jue(e, [
    S(s),
    S(i)
  ]))), u = O(
    () => Zue(e.referenceEl) || S(o)
  ), { attributes: d, state: f, styles: p, update: m, forceUpdate: v, instanceRef: h } = tde(u, n, c);
  return pe(h, (g) => t.value = g, {
    flush: "sync"
  }), nt(() => {
    pe(
      () => {
        var g, y;
        return (y = (g = S(u)) == null ? void 0 : g.getBoundingClientRect) == null ? void 0 : y.call(g);
      },
      () => {
        m();
      }
    );
  }), yt(() => {
    t.value = void 0;
  }), {
    attributes: d,
    arrowRef: r,
    contentRef: n,
    instanceRef: h,
    state: f,
    styles: p,
    role: l,
    forceUpdate: v,
    update: m
  };
}, rde = (e, {
  attributes: t,
  styles: n,
  role: o
}) => {
  const { nextZIndex: l } = ah(), r = Ve("popper"), a = O(() => S(t).popper), i = /* @__PURE__ */ H(
    mt(e.zIndex) ? e.zIndex : l()
  ), s = O(() => [
    r.b(),
    r.is("pure", e.pure),
    r.is(e.effect),
    e.popperClass
  ]), c = O(() => [
    { zIndex: S(i) },
    S(n).popper,
    e.popperStyle || {}
  ]), u = O(
    () => o.value === "dialog" ? "false" : void 0
  ), d = O(
    () => S(n).arrow || {}
  );
  return {
    ariaModal: u,
    arrowStyle: d,
    contentAttrs: a,
    contentClass: s,
    contentStyle: c,
    contentZIndex: i,
    updateZIndex: () => {
      i.value = mt(e.zIndex) ? e.zIndex : l();
    }
  };
}, ade = /* @__PURE__ */ le({
  name: "ElPopperContent",
  __name: "content",
  props: lF,
  emits: Xue,
  setup(e, { expose: t, emit: n }) {
    const o = n, l = e, {
      focusStartRef: r,
      trapped: a,
      onFocusAfterReleased: i,
      onFocusAfterTrapped: s,
      onFocusInTrap: c,
      onFocusoutPrevented: u,
      onReleaseRequested: d
    } = que(l, o), { attributes: f, arrowRef: p, contentRef: m, styles: v, instanceRef: h, role: g, update: y } = lde(l), {
      ariaModal: b,
      arrowStyle: C,
      contentAttrs: w,
      contentClass: x,
      contentStyle: E,
      updateZIndex: I
    } = rde(l, {
      styles: v,
      attributes: f,
      role: g
    }), T = ze($i, void 0);
    at(D7, {
      arrowStyle: C,
      arrowRef: p
    }), T && at($i, vt(Be({}, T), {
      addInputId: gn,
      removeInputId: gn
    }));
    let P;
    const k = (R = !0) => {
      y(), R && I();
    }, N = () => {
      k(!1), l.visible && l.focusOnShow ? a.value = !0 : l.visible === !1 && (a.value = !1);
    };
    return nt(() => {
      pe(
        () => l.triggerTargetEl,
        (R, z) => {
          P == null || P(), P = void 0;
          const D = S(R || m.value), F = S(z || m.value);
          tr(D) && (P = pe(
            [g, () => l.ariaLabel, b, () => l.id],
            (M) => {
              ["role", "aria-label", "aria-modal", "id"].forEach((A, L) => {
                wo(M[L]) ? D.removeAttribute(A) : D.setAttribute(A, M[L]);
              });
            },
            { immediate: !0 }
          )), F !== D && tr(F) && ["role", "aria-label", "aria-modal", "id"].forEach((M) => {
            F.removeAttribute(M);
          });
        },
        { immediate: !0 }
      ), pe(() => l.visible, N, { immediate: !0 });
    }), yt(() => {
      P == null || P(), P = void 0, m.value = void 0;
    }), t({
      popperContentRef: m,
      popperInstanceRef: h,
      updatePopper: k,
      contentStyle: E
    }), (R, z) => (G(), ue(
      "div",
      Ut({
        ref_key: "contentRef",
        ref: m
      }, S(w), {
        style: S(E),
        class: S(x),
        tabindex: "-1",
        onMouseenter: z[0] || (z[0] = (D) => R.$emit("mouseenter", D)),
        onMouseleave: z[1] || (z[1] = (D) => R.$emit("mouseleave", D))
      }),
      [
        $(S(xp), {
          loop: R.loop,
          trapped: S(a),
          "trap-on-focus-in": !0,
          "focus-trap-el": S(m),
          "focus-start-el": S(r),
          onFocusAfterTrapped: S(s),
          onFocusAfterReleased: S(i),
          onFocusin: S(c),
          onFocusoutPrevented: S(u),
          onReleaseRequested: S(d)
        }, {
          default: Ee(() => [
            Oe(R.$slots, "default")
          ]),
          _: 3
        }, 8, ["loop", "trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
      ],
      16
    ));
  }
});
var ide = /* @__PURE__ */ Je(ade, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
const rF = Dt(Oce), qO = Symbol("elTooltip");
function z3() {
  let e;
  const t = (o, l) => {
    n(), e = window.setTimeout(o, l);
  }, n = () => window.clearTimeout(e);
  return rd(() => n()), {
    registerTimeout: t,
    cancelTimeout: n
  };
}
const sde = Xe({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  }
}), cde = ({
  showAfter: e,
  hideAfter: t,
  autoClose: n,
  open: o,
  close: l
}) => {
  const { registerTimeout: r } = z3(), {
    registerTimeout: a,
    cancelTimeout: i
  } = z3();
  return {
    onOpen: (u, d = S(e)) => {
      r(() => {
        o(u);
        const f = S(n);
        mt(f) && f > 0 && a(() => {
          l(u);
        }, f);
      }, d);
    },
    onClose: (u, d = S(t)) => {
      i(), r(() => {
        l(u);
      }, d);
    }
  };
}, In = Xe(Be(vt(Be(Be({}, sde), lF), {
  appendTo: {
    type: sh.to.type
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: Boolean,
  persistent: Boolean,
  visible: {
    type: ye(Boolean),
    default: null
  },
  transition: String,
  teleported: {
    type: Boolean,
    default: !0
  },
  disabled: Boolean
}), zl(["ariaLabel"]))), mi = Xe(vt(Be({}, F7), {
  disabled: Boolean,
  trigger: {
    type: ye([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: ye(Array),
    default: () => [Ye.enter, Ye.numpadEnter, Ye.space]
  },
  focusOnTarget: Boolean
})), ude = Ua({
  type: ye(Boolean),
  default: null
}), dde = Ua({
  type: ye(Function)
}), fde = (e) => {
  const t = `update:${e}`, n = `onUpdate:${e}`, o = [t], l = {
    [e]: ude,
    [n]: dde
  };
  return {
    useModelToggle: ({
      indicator: a,
      toggleReason: i,
      shouldHideWhenRouteChanges: s,
      shouldProceed: c,
      onShow: u,
      onHide: d
    }) => {
      const f = xt(), { emit: p } = f, m = f.props, v = O(
        () => it(m[n])
      ), h = O(() => m[e] === null), g = (E) => {
        a.value !== !0 && (a.value = !0, i && (i.value = E), it(u) && u(E));
      }, y = (E) => {
        a.value !== !1 && (a.value = !1, i && (i.value = E), it(d) && d(E));
      }, b = (E) => {
        if (m.disabled === !0 || it(c) && !c())
          return;
        const I = v.value && Sn;
        I && p(t, !0), (h.value || !I) && g(E);
      }, C = (E) => {
        if (m.disabled === !0 || !Sn)
          return;
        const I = v.value && Sn;
        I && p(t, !1), (h.value || !I) && y(E);
      }, w = (E) => {
        Tn(E) && (m.disabled && E ? v.value && p(t, !1) : a.value !== E && (E ? g() : y()));
      }, x = () => {
        a.value ? C() : b();
      };
      return pe(() => m[e], w), s && f.appContext.config.globalProperties.$route !== void 0 && pe(
        () => Be({}, f.proxy.$route),
        () => {
          s.value && a.value && C();
        }
      ), nt(() => {
        w(m[e]);
      }), {
        hide: C,
        show: b,
        toggle: x,
        hasUpdateHandler: v
      };
    },
    useModelToggleProps: l,
    useModelToggleEmits: o
  };
}, {
  useModelToggleProps: pde,
  useModelToggleEmits: vde,
  useModelToggle: mde
} = fde("visible"), hde = Xe(vt(Be(Be(Be(Be(Be({}, B7), pde), In), mi), oF), {
  showArrow: {
    type: Boolean,
    default: !0
  }
})), gde = [
  ...vde,
  "before-show",
  "before-hide",
  "show",
  "hide",
  "open",
  "close"
], rx = (e, t) => We(e) ? e.includes(t) : e === t, Ed = (e, t, n) => (o) => {
  rx(S(e), t) && n(o);
}, bde = /* @__PURE__ */ le({
  name: "ElTooltipTrigger",
  __name: "trigger",
  props: mi,
  setup(e, { expose: t }) {
    const n = e, o = Ve("tooltip"), { controlled: l, id: r, open: a, onOpen: i, onClose: s, onToggle: c } = ze(
      qO,
      void 0
    ), u = /* @__PURE__ */ H(null), d = () => {
      if (S(l) || n.disabled)
        return !0;
    }, f = /* @__PURE__ */ ft(n, "trigger"), p = qo(
      d,
      Ed(f, "hover", (C) => {
        i(C), n.focusOnTarget && C.target && Ke(() => {
          dh(C.target, { preventScroll: !0 });
        });
      })
    ), m = qo(
      d,
      Ed(f, "hover", s)
    ), v = qo(
      d,
      Ed(f, "click", (C) => {
        C.button === 0 && c(C);
      })
    ), h = qo(
      d,
      Ed(f, "focus", i)
    ), g = qo(
      d,
      Ed(f, "focus", s)
    ), y = qo(
      d,
      Ed(f, "contextmenu", (C) => {
        C.preventDefault(), c(C);
      })
    ), b = qo(
      d,
      (C) => {
        const w = Nn(C);
        n.triggerKeys.includes(w) && (C.preventDefault(), c(C));
      }
    );
    return t({
      triggerRef: u
    }), (C, w) => (G(), Me(S(Nce), {
      id: S(r),
      "virtual-ref": C.virtualRef,
      open: S(a),
      "virtual-triggering": C.virtualTriggering,
      class: X(S(o).e("trigger")),
      onBlur: S(g),
      onClick: S(v),
      onContextmenu: S(y),
      onFocus: S(h),
      onMouseenter: S(p),
      onMouseleave: S(m),
      onKeydown: S(b)
    }, {
      default: Ee(() => [
        Oe(C.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
  }
});
var yde = /* @__PURE__ */ Je(bde, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
const aF = () => {
  const e = dO(), t = LO(), n = O(() => `${e.value}-popper-container-${t.prefix}`), o = O(() => `#${n.value}`);
  return {
    id: n,
    selector: o
  };
}, Sde = (e) => {
  const t = document.createElement("div");
  return t.id = e, document.body.appendChild(t), t;
}, Cde = () => {
  const { id: e, selector: t } = aF();
  return _c(() => {
    Sn && (process.env.NODE_ENV === "test" || !document.body.querySelector(t.value)) && Sde(e.value);
  }), {
    id: e,
    selector: t
  };
}, H3 = (e) => [...new Set(e)], Qp = (e) => We(e) ? e[0] : e, kl = (e) => !e && e !== 0 ? [] : We(e) ? e : [e], wde = /* @__PURE__ */ le({
  name: "ElTooltipContent",
  inheritAttrs: !1,
  __name: "content",
  props: In,
  setup(e, { expose: t }) {
    const n = e, { selector: o } = aF(), l = Ve("tooltip"), r = /* @__PURE__ */ H(), a = l7(() => {
      var A;
      return (A = r.value) == null ? void 0 : A.popperContentRef;
    });
    let i;
    const {
      controlled: s,
      id: c,
      open: u,
      trigger: d,
      onClose: f,
      onOpen: p,
      onShow: m,
      onHide: v,
      onBeforeShow: h,
      onBeforeHide: g
    } = ze(qO, void 0), y = O(() => n.transition || `${l.namespace.value}-fade-in-linear`), b = O(() => process.env.NODE_ENV === "test" && !process.env.RUN_TEST_WITH_PERSISTENT ? !0 : n.persistent);
    yt(() => {
      i == null || i();
    });
    const C = O(() => S(b) ? !0 : S(u)), w = O(() => n.disabled ? !1 : S(u)), x = O(() => n.appendTo || o.value), E = O(() => {
      var A;
      return (A = n.style) != null ? A : {};
    }), I = /* @__PURE__ */ H(!0), T = () => {
      v(), M() && dh(document.body, { preventScroll: !0 }), I.value = !0;
    }, P = () => {
      if (S(s))
        return !0;
    }, k = qo(P, () => {
      n.enterable && rx(S(d), "hover") && p();
    }), N = qo(P, () => {
      rx(S(d), "hover") && f();
    }), R = () => {
      var A, L;
      (L = (A = r.value) == null ? void 0 : A.updatePopper) == null || L.call(A), h == null || h();
    }, z = () => {
      g == null || g();
    }, D = () => {
      m();
    }, F = () => {
      n.virtualTriggering || f();
    }, M = (A) => {
      var L;
      const B = (L = r.value) == null ? void 0 : L.popperContentRef, V = (A == null ? void 0 : A.relatedTarget) || document.activeElement;
      return B == null ? void 0 : B.contains(V);
    };
    return pe(
      () => S(u),
      (A) => {
        A ? (I.value = !1, i = IO(
          a,
          () => {
            if (S(s))
              return;
            kl(S(d)).every((B) => B !== "hover" && B !== "focus") && f();
          },
          { detectIframe: !0 }
        )) : i == null || i();
      },
      {
        flush: "post"
      }
    ), pe(
      () => n.content,
      () => {
        var A, L;
        (L = (A = r.value) == null ? void 0 : A.updatePopper) == null || L.call(A);
      }
    ), t({
      contentRef: r,
      isFocusInsideContent: M
    }), (A, L) => (G(), Me(S($p), {
      disabled: !A.teleported,
      to: x.value
    }, {
      default: Ee(() => [
        C.value || !I.value ? (G(), Me(Vn, {
          key: 0,
          name: y.value,
          appear: !b.value,
          onAfterLeave: T,
          onBeforeEnter: R,
          onAfterEnter: D,
          onBeforeLeave: z,
          persisted: ""
        }, {
          default: Ee(() => [
            _t($(S(ide), Ut({
              id: S(c),
              ref_key: "contentRef",
              ref: r
            }, A.$attrs, {
              "aria-label": A.ariaLabel,
              "aria-hidden": I.value,
              "boundaries-padding": A.boundariesPadding,
              "fallback-placements": A.fallbackPlacements,
              "gpu-acceleration": A.gpuAcceleration,
              offset: A.offset,
              placement: A.placement,
              "popper-options": A.popperOptions,
              "arrow-offset": A.arrowOffset,
              strategy: A.strategy,
              effect: A.effect,
              enterable: A.enterable,
              pure: A.pure,
              "popper-class": A.popperClass,
              "popper-style": [A.popperStyle, E.value],
              "reference-el": A.referenceEl,
              "trigger-target-el": A.triggerTargetEl,
              visible: w.value,
              "z-index": A.zIndex,
              loop: A.loop,
              onMouseenter: S(k),
              onMouseleave: S(N),
              onBlur: F,
              onClose: S(f)
            }), {
              default: Ee(() => [
                Oe(A.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "arrow-offset", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "loop", "onMouseenter", "onMouseleave", "onClose"]), [
              [Jt, w.value]
            ])
          ]),
          _: 3
        }, 8, ["name", "appear"])) : Ie("v-if", !0)
      ]),
      _: 3
    }, 8, ["disabled", "to"]));
  }
});
var $de = /* @__PURE__ */ Je(wde, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
const xde = ["innerHTML"], Ede = { key: 1 }, Ode = /* @__PURE__ */ le({
  name: "ElTooltip",
  __name: "tooltip",
  props: hde,
  emits: gde,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n;
    Cde();
    const r = Ve("tooltip"), a = ml(), i = /* @__PURE__ */ H(), s = /* @__PURE__ */ H(), c = () => {
      var C;
      const w = S(i);
      w && ((C = w.popperInstanceRef) == null || C.update());
    }, u = /* @__PURE__ */ H(!1), d = /* @__PURE__ */ H(), { show: f, hide: p, hasUpdateHandler: m } = mde({
      indicator: u,
      toggleReason: d
    }), { onOpen: v, onClose: h } = cde({
      showAfter: /* @__PURE__ */ ft(o, "showAfter"),
      hideAfter: /* @__PURE__ */ ft(o, "hideAfter"),
      autoClose: /* @__PURE__ */ ft(o, "autoClose"),
      open: f,
      close: p
    }), g = O(
      () => Tn(o.visible) && !m.value
    ), y = O(() => [r.b(), o.popperClass]);
    at(qO, {
      controlled: g,
      id: a,
      open: /* @__PURE__ */ Du(u),
      trigger: /* @__PURE__ */ ft(o, "trigger"),
      onOpen: v,
      onClose: h,
      onToggle: (C) => {
        S(u) ? h(C) : v(C);
      },
      onShow: () => {
        l("show", d.value);
      },
      onHide: () => {
        l("hide", d.value);
      },
      onBeforeShow: () => {
        l("before-show", d.value);
      },
      onBeforeHide: () => {
        l("before-hide", d.value);
      },
      updatePopper: c
    }), pe(
      () => o.disabled,
      (C) => {
        C && u.value && (u.value = !1);
      }
    );
    const b = (C) => {
      var w;
      return (w = s.value) == null ? void 0 : w.isFocusInsideContent(C);
    };
    return WE(() => u.value && p()), yt(() => {
      d.value = void 0;
    }), t({
      popperRef: i,
      contentRef: s,
      isFocusInsideContent: b,
      updatePopper: c,
      onOpen: v,
      onClose: h,
      hide: p
    }), (C, w) => (G(), Me(S(rF), {
      ref_key: "popperRef",
      ref: i,
      role: C.role
    }, {
      default: Ee(() => [
        $(yde, {
          disabled: C.disabled,
          trigger: C.trigger,
          "trigger-keys": C.triggerKeys,
          "virtual-ref": C.virtualRef,
          "virtual-triggering": C.virtualTriggering,
          "focus-on-target": C.focusOnTarget
        }, {
          default: Ee(() => [
            C.$slots.default ? Oe(C.$slots, "default", { key: 0 }) : Ie("v-if", !0)
          ]),
          _: 3
        }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering", "focus-on-target"]),
        $($de, {
          ref_key: "contentRef",
          ref: s,
          "aria-label": C.ariaLabel,
          "boundaries-padding": C.boundariesPadding,
          content: C.content,
          disabled: C.disabled,
          effect: C.effect,
          enterable: C.enterable,
          "fallback-placements": C.fallbackPlacements,
          "hide-after": C.hideAfter,
          "gpu-acceleration": C.gpuAcceleration,
          offset: C.offset,
          persistent: C.persistent,
          "popper-class": y.value,
          "popper-style": C.popperStyle,
          placement: C.placement,
          "popper-options": C.popperOptions,
          "arrow-offset": C.arrowOffset,
          pure: C.pure,
          "raw-content": C.rawContent,
          "reference-el": C.referenceEl,
          "trigger-target-el": C.triggerTargetEl,
          "show-after": C.showAfter,
          strategy: C.strategy,
          teleported: C.teleported,
          transition: C.transition,
          "virtual-triggering": C.virtualTriggering,
          "z-index": C.zIndex,
          "append-to": C.appendTo,
          loop: C.loop
        }, {
          default: Ee(() => [
            Oe(C.$slots, "content", {}, () => [
              C.rawContent ? (G(), ue("span", {
                key: 0,
                innerHTML: C.content
              }, null, 8, xde)) : (G(), ue(
                "span",
                Ede,
                qe(C.content),
                1
              ))
            ]),
            C.showArrow ? (G(), Me(S(Ice), { key: 0 })) : Ie("v-if", !0)
          ]),
          _: 3
        }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "arrow-offset", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to", "loop"])
      ]),
      _: 3
    }, 8, ["role"]));
  }
});
var _de = /* @__PURE__ */ Je(Ode, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
const al = Dt(_de), Ide = Xe(vt(Be({}, uh), {
  valueKey: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: [String, Number],
    default: ""
  },
  debounce: {
    type: Number,
    default: 300
  },
  placement: {
    type: ye(String),
    values: [
      "top",
      "top-start",
      "top-end",
      "bottom",
      "bottom-start",
      "bottom-end"
    ],
    default: "bottom-start"
  },
  fetchSuggestions: {
    type: ye([Function, Array]),
    default: gn
  },
  popperClass: In.popperClass,
  popperStyle: In.popperStyle,
  triggerOnFocus: {
    type: Boolean,
    default: !0
  },
  selectWhenUnmatched: Boolean,
  hideLoading: Boolean,
  teleported: In.teleported,
  appendTo: In.appendTo,
  highlightFirstItem: Boolean,
  fitInputWidth: Boolean,
  loopNavigation: {
    type: Boolean,
    default: !0
  }
})), Tde = {
  [It]: (e) => rt(e) || mt(e),
  [Po]: (e) => rt(e) || mt(e),
  [en]: (e) => rt(e) || mt(e),
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  clear: () => !0,
  select: (e) => Mt(e)
}, Pde = ["aria-expanded", "aria-owns"], kde = { key: 0 }, Nde = ["id", "aria-selected", "onClick"], j3 = "ElAutocomplete", Mde = /* @__PURE__ */ le({
  name: j3,
  inheritAttrs: !1,
  __name: "autocomplete",
  props: Ide,
  emits: Tde,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = O(() => La(o, Object.keys(uh))), a = Ti(), i = io(), s = Ve("autocomplete"), c = /* @__PURE__ */ H(), u = /* @__PURE__ */ H(), d = /* @__PURE__ */ H(), f = /* @__PURE__ */ H();
    let p = !1, m = !1;
    const v = /* @__PURE__ */ H([]), h = /* @__PURE__ */ H(-1), g = /* @__PURE__ */ H(""), y = /* @__PURE__ */ H(!1), b = /* @__PURE__ */ H(!1), C = /* @__PURE__ */ H(!1), w = ml(), x = O(() => a.style), E = O(() => (v.value.length > 0 || C.value) && y.value), I = O(() => !o.hideLoading && C.value), T = O(() => c.value ? Array.from(
      c.value.$el.querySelectorAll("input")
    ) : []), P = () => {
      E.value && (g.value = `${c.value.$el.offsetWidth}px`);
    }, k = () => {
      h.value = -1;
    }, N = (K) => Rt(this, null, function* () {
      if (b.value)
        return;
      const se = (Z) => {
        C.value = !1, !b.value && (We(Z) ? (v.value = Z, h.value = o.highlightFirstItem ? 0 : -1) : no(j3, "autocomplete suggestions must be an array"));
      };
      if (C.value = !0, We(o.fetchSuggestions))
        se(o.fetchSuggestions);
      else {
        const Z = yield o.fetchSuggestions(K, se);
        We(Z) && se(Z);
      }
    }), R = O(() => o.debounce), z = lh(N, R), D = (K) => {
      const se = !!K;
      if (l(Po, K), l(It, K), b.value = !1, y.value || (y.value = se), !o.triggerOnFocus && !K) {
        b.value = !0, v.value = [];
        return;
      }
      z(K);
    }, F = (K) => {
      var se;
      i.value || (((se = K.target) == null ? void 0 : se.tagName) !== "INPUT" || T.value.includes(document.activeElement)) && (y.value = !0);
    }, M = (K) => {
      l(en, K);
    }, A = (K) => {
      var se;
      if (m)
        m = !1;
      else {
        y.value = !0, l("focus", K);
        const Z = (se = o.modelValue) != null ? se : "";
        o.triggerOnFocus && !p && z(String(Z));
      }
    }, L = (K) => {
      setTimeout(() => {
        var se;
        if ((se = d.value) != null && se.isFocusInsideContent()) {
          m = !0;
          return;
        }
        y.value && W(), l("blur", K);
      });
    }, B = () => {
      y.value = !1, l(It, ""), l("clear");
    }, V = () => Rt(this, null, function* () {
      var K;
      (K = c.value) != null && K.isComposing || (E.value && h.value >= 0 && h.value < v.value.length ? te(v.value[h.value]) : (o.selectWhenUnmatched && (l("select", { value: o.modelValue }), v.value = [], h.value = -1), y.value = !0, z(String(o.modelValue))));
    }), j = (K) => {
      E.value && (K.preventDefault(), K.stopPropagation(), W());
    }, W = () => {
      y.value = !1;
    }, Y = () => {
      var K;
      (K = c.value) == null || K.focus();
    }, U = () => {
      var K;
      (K = c.value) == null || K.blur();
    }, te = (K) => Rt(this, null, function* () {
      l(Po, K[o.valueKey]), l(It, K[o.valueKey]), l("select", K), v.value = [], h.value = -1;
    }), J = (K) => {
      var se, Z;
      if (!E.value || C.value)
        return;
      if (K < 0) {
        if (!o.loopNavigation) {
          h.value = -1;
          return;
        }
        K = v.value.length - 1;
      }
      K >= v.value.length && (K = o.loopNavigation ? 0 : v.value.length - 1);
      const [ee, fe] = re(), me = fe[K], ge = ee.scrollTop, { offsetTop: he, scrollHeight: $e } = me;
      he + $e > ge + ee.clientHeight && (ee.scrollTop = he + $e - ee.clientHeight), he < ge && (ee.scrollTop = he), h.value = K, (Z = (se = c.value) == null ? void 0 : se.ref) == null || Z.setAttribute(
        "aria-activedescendant",
        `${w.value}-item-${h.value}`
      );
    }, re = () => {
      const K = u.value.querySelector(
        `.${s.be("suggestion", "wrap")}`
      ), se = K.querySelectorAll(
        `.${s.be("suggestion", "list")} li`
      );
      return [K, se];
    }, oe = IO(f, () => {
      var K;
      (K = d.value) != null && K.isFocusInsideContent() || E.value && W();
    }), q = (K) => {
      switch (Nn(K)) {
        case Ye.up:
          K.preventDefault(), J(h.value - 1);
          break;
        case Ye.down:
          K.preventDefault(), J(h.value + 1);
          break;
        case Ye.enter:
        case Ye.numpadEnter:
          K.preventDefault(), V();
          break;
        case Ye.tab:
          W();
          break;
        case Ye.esc:
          j(K);
          break;
        case Ye.home:
          K.preventDefault(), J(0);
          break;
        case Ye.end:
          K.preventDefault(), J(v.value.length - 1);
          break;
        case Ye.pageUp:
          K.preventDefault(), J(Math.max(0, h.value - 10));
          break;
        case Ye.pageDown:
          K.preventDefault(), J(
            Math.min(v.value.length - 1, h.value + 10)
          );
          break;
      }
    };
    return yt(() => {
      oe == null || oe();
    }), nt(() => {
      var K;
      const se = (K = c.value) == null ? void 0 : K.ref;
      se && ([
        { key: "role", value: "textbox" },
        { key: "aria-autocomplete", value: "list" },
        { key: "aria-controls", value: w.value },
        {
          key: "aria-activedescendant",
          value: `${w.value}-item-${h.value}`
        }
      ].forEach(({ key: Z, value: ee }) => se.setAttribute(Z, ee)), p = se.hasAttribute("readonly"));
    }), t({
      highlightedIndex: h,
      activated: y,
      loading: C,
      inputRef: c,
      popperRef: d,
      suggestions: v,
      handleSelect: te,
      handleKeyEnter: V,
      focus: Y,
      blur: U,
      close: W,
      highlight: J,
      getData: N
    }), (K, se) => (G(), Me(S(al), {
      ref_key: "popperRef",
      ref: d,
      visible: E.value,
      placement: K.placement,
      "fallback-placements": ["bottom-start", "top-start"],
      "popper-class": [S(s).e("popper"), K.popperClass],
      "popper-style": K.popperStyle,
      teleported: K.teleported,
      "append-to": K.appendTo,
      "gpu-acceleration": !1,
      pure: "",
      "manual-mode": "",
      effect: "light",
      trigger: "click",
      transition: `${S(s).namespace.value}-zoom-in-top`,
      persistent: "",
      role: "listbox",
      onBeforeShow: P,
      onHide: k
    }, {
      content: Ee(() => [
        ve(
          "div",
          {
            ref_key: "regionRef",
            ref: u,
            class: X([S(s).b("suggestion"), S(s).is("loading", I.value)]),
            style: gt({
              [K.fitInputWidth ? "width" : "minWidth"]: g.value,
              outline: "none"
            }),
            role: "region"
          },
          [
            K.$slots.header ? (G(), ue(
              "div",
              {
                key: 0,
                class: X(S(s).be("suggestion", "header")),
                onClick: se[0] || (se[0] = Et(() => {
                }, ["stop"]))
              },
              [
                Oe(K.$slots, "header")
              ],
              2
            )) : Ie("v-if", !0),
            $(S(Ba), {
              id: S(w),
              tag: "ul",
              "wrap-class": S(s).be("suggestion", "wrap"),
              "view-class": S(s).be("suggestion", "list"),
              role: "listbox"
            }, {
              default: Ee(() => [
                I.value ? (G(), ue("li", kde, [
                  Oe(K.$slots, "loading", {}, () => [
                    $(S(ut), {
                      class: X(S(s).is("loading"))
                    }, {
                      default: Ee(() => [
                        $(S(wi))
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ])
                ])) : (G(!0), ue(
                  Ge,
                  { key: 1 },
                  on(v.value, (Z, ee) => (G(), ue("li", {
                    id: `${S(w)}-item-${ee}`,
                    key: ee,
                    class: X({ highlighted: h.value === ee }),
                    role: "option",
                    "aria-selected": h.value === ee,
                    onClick: (fe) => te(Z)
                  }, [
                    Oe(K.$slots, "default", { item: Z }, () => [
                      Ft(
                        qe(Z[K.valueKey]),
                        1
                      )
                    ])
                  ], 10, Nde))),
                  128
                ))
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class"]),
            K.$slots.footer ? (G(), ue(
              "div",
              {
                key: 1,
                class: X(S(s).be("suggestion", "footer")),
                onClick: se[1] || (se[1] = Et(() => {
                }, ["stop"]))
              },
              [
                Oe(K.$slots, "footer")
              ],
              2
            )) : Ie("v-if", !0)
          ],
          6
        )
      ]),
      default: Ee(() => [
        ve("div", {
          ref_key: "listboxRef",
          ref: f,
          class: X([S(s).b(), K.$attrs.class]),
          style: gt(x.value),
          role: "combobox",
          "aria-haspopup": "listbox",
          "aria-expanded": E.value,
          "aria-owns": S(w)
        }, [
          $(S(Nl), Ut({
            ref_key: "inputRef",
            ref: c
          }, Ut(r.value, K.$attrs), {
            "model-value": K.modelValue,
            disabled: S(i),
            onInput: D,
            onChange: M,
            onFocus: A,
            onBlur: L,
            onClear: B,
            onKeydown: q,
            onMousedown: F
          }), or({
            _: 2
          }, [
            K.$slots.prepend ? {
              name: "prepend",
              fn: Ee(() => [
                Oe(K.$slots, "prepend")
              ]),
              key: "0"
            } : void 0,
            K.$slots.append ? {
              name: "append",
              fn: Ee(() => [
                Oe(K.$slots, "append")
              ]),
              key: "1"
            } : void 0,
            K.$slots.prefix ? {
              name: "prefix",
              fn: Ee(() => [
                Oe(K.$slots, "prefix")
              ]),
              key: "2"
            } : void 0,
            K.$slots.suffix ? {
              name: "suffix",
              fn: Ee(() => [
                Oe(K.$slots, "suffix")
              ]),
              key: "3"
            } : void 0
          ]), 1040, ["model-value", "disabled"])
        ], 14, Pde)
      ]),
      _: 3
    }, 8, ["visible", "placement", "popper-class", "popper-style", "teleported", "append-to", "transition"]));
  }
});
var Ade = /* @__PURE__ */ Je(Mde, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/autocomplete/src/autocomplete.vue"]]);
const Rde = Dt(Ade), ax = Xe({
  size: {
    type: [Number, String],
    values: ki,
    validator: (e) => mt(e)
  },
  shape: {
    type: String,
    values: ["circle", "square"]
  },
  icon: {
    type: Pn
  },
  src: {
    type: String,
    default: ""
  },
  alt: String,
  srcSet: String,
  fit: {
    type: ye(String),
    default: "cover"
  }
}), Dde = {
  error: (e) => e instanceof Event
}, iF = Symbol(
  "avatarGroupContextKey"
), Lde = ["src", "alt", "srcset"], Bde = /* @__PURE__ */ le({
  name: "ElAvatar",
  __name: "avatar",
  props: ax,
  emits: Dde,
  setup(e, { emit: t }) {
    const n = e, o = t, l = ze(iF, void 0), r = Ve("avatar"), a = /* @__PURE__ */ H(!1), i = O(() => {
      var p;
      return (p = n.size) != null ? p : l == null ? void 0 : l.size;
    }), s = O(
      () => {
        var p, m;
        return (m = (p = n.shape) != null ? p : l == null ? void 0 : l.shape) != null ? m : "circle";
      }
    ), c = O(() => {
      const { icon: p } = n, m = [r.b()];
      return rt(i.value) && m.push(r.m(i.value)), p && m.push(r.m("icon")), s.value && m.push(r.m(s.value)), m;
    }), u = O(() => mt(i.value) ? r.cssVarBlock({
      size: ao(i.value)
    }) : void 0), d = O(() => ({
      objectFit: n.fit
    }));
    pe(
      () => n.src,
      () => a.value = !1
    );
    function f(p) {
      a.value = !0, o("error", p);
    }
    return (p, m) => (G(), ue(
      "span",
      {
        class: X(c.value),
        style: gt(u.value)
      },
      [
        (p.src || p.srcSet) && !a.value ? (G(), ue("img", {
          key: 0,
          src: p.src,
          alt: p.alt,
          srcset: p.srcSet,
          style: gt(d.value),
          onError: f
        }, null, 44, Lde)) : p.icon ? (G(), Me(S(ut), { key: 1 }, {
          default: Ee(() => [
            (G(), Me(Ht(p.icon)))
          ]),
          _: 1
        })) : Oe(p.$slots, "default", { key: 2 })
      ],
      6
    ));
  }
});
var sF = /* @__PURE__ */ Je(Bde, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/avatar/src/avatar.vue"]]);
const Fde = Xe({
  size: ax.size,
  shape: ax.shape,
  collapseAvatars: Boolean,
  collapseAvatarsTooltip: Boolean,
  maxCollapseAvatars: {
    type: Number,
    default: 1
  },
  effect: {
    type: ye(String),
    default: "light"
  },
  placement: {
    type: ye(String),
    values: Mi,
    default: "top"
  },
  popperClass: In.popperClass,
  popperStyle: In.popperStyle,
  collapseClass: String,
  collapseStyle: {
    type: ye([String, Array, Object])
  }
});
var cF = /* @__PURE__ */ le({
  name: "ElAvatarGroup",
  props: Fde,
  setup(e, {
    slots: t
  }) {
    const n = Ve("avatar-group");
    return at(iF, /* @__PURE__ */ kt({
      size: /* @__PURE__ */ ft(e, "size"),
      shape: /* @__PURE__ */ ft(e, "shape")
    })), () => {
      var o, l;
      const r = Nr((l = (o = t.default) == null ? void 0 : o.call(t)) != null ? l : []);
      let a = r;
      if (e.collapseAvatars && r.length > e.maxCollapseAvatars) {
        a = r.slice(0, e.maxCollapseAvatars);
        const s = r.slice(e.maxCollapseAvatars);
        a.push($(al, {
          popperClass: e.popperClass,
          popperStyle: e.popperStyle,
          placement: e.placement,
          effect: e.effect,
          disabled: !e.collapseAvatarsTooltip
        }, {
          default: () => $(sF, {
            size: e.size,
            shape: e.shape,
            class: e.collapseClass,
            style: e.collapseStyle
          }, {
            default: () => [Ft("+ "), s.length]
          }),
          content: () => $("div", {
            class: n.e("collapse-avatars")
          }, [s.map((c, u) => {
            var d;
            return dn(c) ? No(c, {
              key: (d = c.key) != null ? d : u
            }) : c;
          })])
        }));
      }
      return $("div", {
        class: n.b()
      }, [a]);
    };
  }
});
const Vde = Dt(sF, {
  AvatarGroup: cF
}), zde = oo(cF), Hde = {
  visibilityHeight: {
    type: Number,
    default: 200
  },
  target: {
    type: String,
    default: ""
  },
  right: {
    type: Number,
    default: 40
  },
  bottom: {
    type: Number,
    default: 40
  }
}, jde = {
  click: (e) => e instanceof MouseEvent
}, Wde = (e, t, n) => {
  const o = /* @__PURE__ */ Ce(), l = /* @__PURE__ */ Ce(), r = /* @__PURE__ */ H(!1), a = () => {
    o.value && (r.value = o.value.scrollTop >= e.visibilityHeight);
  }, i = (c) => {
    var u;
    (u = o.value) == null || u.scrollTo({ top: 0, behavior: "smooth" }), t("click", c);
  }, s = s7(a, 300, !0);
  return wn(l, "scroll", s), nt(() => {
    var c;
    l.value = document, o.value = document.documentElement, e.target && (o.value = (c = document.querySelector(e.target)) != null ? c : void 0, o.value || no(n, `target does not exist: ${e.target}`), l.value = o.value), a();
  }), {
    visible: r,
    handleClick: i
  };
}, W3 = "ElBacktop", Kde = /* @__PURE__ */ le({
  name: W3,
  __name: "backtop",
  props: Hde,
  emits: jde,
  setup(e, { emit: t }) {
    const n = e, o = t, l = Ve("backtop"), { handleClick: r, visible: a } = Wde(n, o, W3), i = O(() => ({
      right: `${n.right}px`,
      bottom: `${n.bottom}px`
    }));
    return (s, c) => (G(), Me(Vn, {
      name: `${S(l).namespace.value}-fade-in`
    }, {
      default: Ee(() => [
        S(a) ? (G(), ue(
          "div",
          {
            key: 0,
            style: gt(i.value),
            class: X(S(l).b()),
            onClick: c[0] || (c[0] = Et(
              (...u) => S(r) && S(r)(...u),
              ["stop"]
            ))
          },
          [
            Oe(s.$slots, "default", {}, () => [
              $(S(ut), {
                class: X(S(l).e("icon"))
              }, {
                default: Ee(() => [
                  $(S(Wie))
                ]),
                _: 1
              }, 8, ["class"])
            ])
          ],
          6
        )) : Ie("v-if", !0)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var Ude = /* @__PURE__ */ Je(Kde, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/backtop/src/backtop.vue"]]);
const Gde = Dt(Ude), Yde = Xe({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  },
  showZero: {
    type: Boolean,
    default: !0
  },
  color: String,
  badgeStyle: {
    type: ye([String, Object, Array])
  },
  offset: {
    type: ye(Array),
    default: [0, 0]
  },
  badgeClass: {
    type: String
  }
}), Xde = /* @__PURE__ */ le({
  name: "ElBadge",
  __name: "badge",
  props: Yde,
  setup(e, { expose: t }) {
    const n = e, o = Ve("badge"), l = O(() => n.isDot ? "" : mt(n.value) && mt(n.max) ? n.max < n.value ? `${n.max}+` : `${n.value}` : `${n.value}`), r = O(() => {
      var a;
      return [
        {
          backgroundColor: n.color,
          marginRight: ao(-n.offset[0]),
          marginTop: ao(n.offset[1])
        },
        (a = n.badgeStyle) != null ? a : {}
      ];
    });
    return t({
      content: l
    }), (a, i) => (G(), ue(
      "div",
      {
        class: X(S(o).b())
      },
      [
        Oe(a.$slots, "default"),
        $(Vn, {
          name: `${S(o).namespace.value}-zoom-in-center`,
          persisted: ""
        }, {
          default: Ee(() => [
            _t(ve(
              "sup",
              {
                class: X([
                  S(o).e("content"),
                  S(o).em("content", a.type),
                  S(o).is("fixed", !!a.$slots.default),
                  S(o).is("dot", a.isDot),
                  S(o).is("hide-zero", !a.showZero && a.value === 0),
                  a.badgeClass
                ]),
                style: gt(r.value)
              },
              [
                Oe(a.$slots, "content", { value: l.value }, () => [
                  Ft(
                    qe(l.value),
                    1
                  )
                ])
              ],
              6
            ), [
              [Jt, !a.hidden && (l.value || a.isDot || a.$slots.content)]
            ])
          ]),
          _: 3
        }, 8, ["name"])
      ],
      2
    ));
  }
});
var qde = /* @__PURE__ */ Je(Xde, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
const uF = Dt(qde), dF = Symbol("breadcrumbKey"), Jde = Xe({
  separator: {
    type: String,
    default: "/"
  },
  separatorIcon: {
    type: Pn
  }
}), Zde = ["aria-label"], Qde = /* @__PURE__ */ le({
  name: "ElBreadcrumb",
  __name: "breadcrumb",
  props: Jde,
  setup(e) {
    const { t } = an(), n = e, o = Ve("breadcrumb"), l = /* @__PURE__ */ H();
    return at(dF, n), nt(() => {
      const r = l.value.querySelectorAll(`.${o.e("item")}`);
      r.length && r[r.length - 1].setAttribute("aria-current", "page");
    }), (r, a) => (G(), ue("div", {
      ref_key: "breadcrumb",
      ref: l,
      class: X(S(o).b()),
      "aria-label": S(t)("el.breadcrumb.label"),
      role: "navigation"
    }, [
      Oe(r.$slots, "default")
    ], 10, Zde));
  }
});
var efe = /* @__PURE__ */ Je(Qde, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb.vue"]]);
const tfe = Xe({
  to: {
    type: ye([String, Object]),
    default: ""
  },
  replace: Boolean
}), nfe = /* @__PURE__ */ le({
  name: "ElBreadcrumbItem",
  __name: "breadcrumb-item",
  props: tfe,
  setup(e) {
    const t = e, n = xt(), o = ze(dF, void 0), l = Ve("breadcrumb"), r = n.appContext.config.globalProperties.$router, a = () => {
      !t.to || !r || (t.replace ? r.replace(t.to) : r.push(t.to));
    };
    return (i, s) => {
      var c, u;
      return G(), ue(
        "span",
        {
          class: X(S(l).e("item"))
        },
        [
          ve(
            "span",
            {
              class: X([S(l).e("inner"), S(l).is("link", !!i.to)]),
              role: "link",
              onClick: a
            },
            [
              Oe(i.$slots, "default")
            ],
            2
          ),
          (c = S(o)) != null && c.separatorIcon ? (G(), Me(S(ut), {
            key: 0,
            class: X(S(l).e("separator"))
          }, {
            default: Ee(() => [
              (G(), Me(Ht(S(o).separatorIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : (G(), ue(
            "span",
            {
              key: 1,
              class: X(S(l).e("separator")),
              role: "presentation"
            },
            qe((u = S(o)) == null ? void 0 : u.separator),
            3
          ))
        ],
        2
      );
    };
  }
});
var fF = /* @__PURE__ */ Je(nfe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/breadcrumb/src/breadcrumb-item.vue"]]);
const ofe = Dt(efe, {
  BreadcrumbItem: fF
}), lfe = oo(fF), pF = Symbol(
  "buttonGroupContextKey"
), hi = ({ from: e, replacement: t, scope: n, version: o, ref: l, type: r = "API" }, a) => {
  pe(
    () => S(a),
    (i) => {
      i && Gt(
        n,
        `[${r}] ${e} is about to be deprecated in version ${o}, please use ${t} instead.
For more detail, please visit: ${l}
`
      );
    },
    {
      immediate: !0
    }
  );
}, rfe = (e, t) => {
  hi(
    {
      from: "type.text",
      replacement: "link",
      version: "3.0.0",
      scope: "props",
      ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
    },
    O(() => e.type === "text")
  );
  const n = ze(pF, void 0), o = wp("button"), { form: l } = cl(), r = Mo(O(() => n == null ? void 0 : n.size)), a = io(), i = /* @__PURE__ */ H(), s = So(), c = O(
    () => {
      var g;
      return e.type || (n == null ? void 0 : n.type) || ((g = o.value) == null ? void 0 : g.type) || "";
    }
  ), u = O(
    () => {
      var g, y, b;
      return (b = (y = e.autoInsertSpace) != null ? y : (g = o.value) == null ? void 0 : g.autoInsertSpace) != null ? b : !1;
    }
  ), d = O(
    () => {
      var g, y, b;
      return (b = (y = e.plain) != null ? y : (g = o.value) == null ? void 0 : g.plain) != null ? b : !1;
    }
  ), f = O(
    () => {
      var g, y, b;
      return (b = (y = e.round) != null ? y : (g = o.value) == null ? void 0 : g.round) != null ? b : !1;
    }
  ), p = O(() => {
    var g, y, b;
    return (b = (y = e.text) != null ? y : (g = o.value) == null ? void 0 : g.text) != null ? b : !1;
  }), m = O(() => e.tag === "button" ? {
    ariaDisabled: a.value || e.loading,
    disabled: a.value || e.loading,
    autofocus: e.autofocus,
    type: e.nativeType
  } : {}), v = O(() => {
    var g;
    const y = (g = s.default) == null ? void 0 : g.call(s);
    if (u.value && (y == null ? void 0 : y.length) === 1) {
      const b = y[0];
      if ((b == null ? void 0 : b.type) === Vr) {
        const C = b.children;
        return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(C.trim());
      }
    }
    return !1;
  });
  return {
    _disabled: a,
    _size: r,
    _type: c,
    _ref: i,
    _props: m,
    _plain: d,
    _round: f,
    _text: p,
    shouldAddSpace: v,
    handleClick: (g) => {
      if (a.value || e.loading) {
        g.stopPropagation();
        return;
      }
      e.nativeType === "reset" && (l == null || l.resetFields()), t("click", g);
    }
  };
}, ix = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
], afe = ["button", "submit", "reset"], sx = Xe({
  size: Bo,
  disabled: {
    type: Boolean,
    default: void 0
  },
  type: {
    type: String,
    values: ix,
    default: ""
  },
  icon: {
    type: Pn
  },
  nativeType: {
    type: String,
    values: afe,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: Pn,
    default: () => wi
  },
  plain: {
    type: Boolean,
    default: void 0
  },
  text: {
    type: Boolean,
    default: void 0
  },
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: {
    type: Boolean,
    default: void 0
  },
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  },
  tag: {
    type: ye([String, Object]),
    default: "button"
  }
}), ife = {
  click: (e) => e instanceof MouseEvent
};
function Cl(e, t) {
  sfe(e) && (e = "100%");
  var n = cfe(e);
  return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))), n && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)), e);
}
function sg(e) {
  return Math.min(1, Math.max(0, e));
}
function sfe(e) {
  return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1;
}
function cfe(e) {
  return typeof e == "string" && e.indexOf("%") !== -1;
}
function vF(e) {
  return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
}
function cg(e) {
  return e <= 1 ? "".concat(Number(e) * 100, "%") : e;
}
function du(e) {
  return e.length === 1 ? "0" + e : String(e);
}
function ufe(e, t, n) {
  return {
    r: Cl(e, 255) * 255,
    g: Cl(t, 255) * 255,
    b: Cl(n, 255) * 255
  };
}
function K3(e, t, n) {
  e = Cl(e, 255), t = Cl(t, 255), n = Cl(n, 255);
  var o = Math.max(e, t, n), l = Math.min(e, t, n), r = 0, a = 0, i = (o + l) / 2;
  if (o === l)
    a = 0, r = 0;
  else {
    var s = o - l;
    switch (a = i > 0.5 ? s / (2 - o - l) : s / (o + l), o) {
      case e:
        r = (t - n) / s + (t < n ? 6 : 0);
        break;
      case t:
        r = (n - e) / s + 2;
        break;
      case n:
        r = (e - t) / s + 4;
        break;
    }
    r /= 6;
  }
  return { h: r, s: a, l: i };
}
function zC(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function dfe(e, t, n) {
  var o, l, r;
  if (e = Cl(e, 360), t = Cl(t, 100), n = Cl(n, 100), t === 0)
    l = n, r = n, o = n;
  else {
    var a = n < 0.5 ? n * (1 + t) : n + t - n * t, i = 2 * n - a;
    o = zC(i, a, e + 1 / 3), l = zC(i, a, e), r = zC(i, a, e - 1 / 3);
  }
  return { r: o * 255, g: l * 255, b: r * 255 };
}
function cx(e, t, n) {
  e = Cl(e, 255), t = Cl(t, 255), n = Cl(n, 255);
  var o = Math.max(e, t, n), l = Math.min(e, t, n), r = 0, a = o, i = o - l, s = o === 0 ? 0 : i / o;
  if (o === l)
    r = 0;
  else {
    switch (o) {
      case e:
        r = (t - n) / i + (t < n ? 6 : 0);
        break;
      case t:
        r = (n - e) / i + 2;
        break;
      case n:
        r = (e - t) / i + 4;
        break;
    }
    r /= 6;
  }
  return { h: r, s, v: a };
}
function ffe(e, t, n) {
  e = Cl(e, 360) * 6, t = Cl(t, 100), n = Cl(n, 100);
  var o = Math.floor(e), l = e - o, r = n * (1 - t), a = n * (1 - l * t), i = n * (1 - (1 - l) * t), s = o % 6, c = [n, a, r, r, i, n][s], u = [i, n, n, a, r, r][s], d = [r, r, i, n, n, a][s];
  return { r: c * 255, g: u * 255, b: d * 255 };
}
function ux(e, t, n, o) {
  var l = [
    du(Math.round(e).toString(16)),
    du(Math.round(t).toString(16)),
    du(Math.round(n).toString(16))
  ];
  return o && l[0].startsWith(l[0].charAt(1)) && l[1].startsWith(l[1].charAt(1)) && l[2].startsWith(l[2].charAt(1)) ? l[0].charAt(0) + l[1].charAt(0) + l[2].charAt(0) : l.join("");
}
function pfe(e, t, n, o, l) {
  var r = [
    du(Math.round(e).toString(16)),
    du(Math.round(t).toString(16)),
    du(Math.round(n).toString(16)),
    du(vfe(o))
  ];
  return l && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1)) && r[3].startsWith(r[3].charAt(1)) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) + r[3].charAt(0) : r.join("");
}
function vfe(e) {
  return Math.round(parseFloat(e) * 255).toString(16);
}
function U3(e) {
  return Or(e) / 255;
}
function Or(e) {
  return parseInt(e, 16);
}
function mfe(e) {
  return {
    r: e >> 16,
    g: (e & 65280) >> 8,
    b: e & 255
  };
}
var dx = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function zd(e) {
  var t = { r: 0, g: 0, b: 0 }, n = 1, o = null, l = null, r = null, a = !1, i = !1;
  return typeof e == "string" && (e = bfe(e)), typeof e == "object" && (zi(e.r) && zi(e.g) && zi(e.b) ? (t = ufe(e.r, e.g, e.b), a = !0, i = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : zi(e.h) && zi(e.s) && zi(e.v) ? (o = cg(e.s), l = cg(e.v), t = ffe(e.h, o, l), a = !0, i = "hsv") : zi(e.h) && zi(e.s) && zi(e.l) && (o = cg(e.s), r = cg(e.l), t = dfe(e.h, o, r), a = !0, i = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (n = e.a)), n = vF(n), {
    ok: a,
    format: e.format || i,
    r: Math.min(255, Math.max(t.r, 0)),
    g: Math.min(255, Math.max(t.g, 0)),
    b: Math.min(255, Math.max(t.b, 0)),
    a: n
  };
}
var hfe = "[-\\+]?\\d+%?", gfe = "[-\\+]?\\d*\\.\\d+%?", ec = "(?:".concat(gfe, ")|(?:").concat(hfe, ")"), HC = "[\\s|\\(]+(".concat(ec, ")[,|\\s]+(").concat(ec, ")[,|\\s]+(").concat(ec, ")\\s*\\)?"), jC = "[\\s|\\(]+(".concat(ec, ")[,|\\s]+(").concat(ec, ")[,|\\s]+(").concat(ec, ")[,|\\s]+(").concat(ec, ")\\s*\\)?"), va = {
  CSS_UNIT: new RegExp(ec),
  rgb: new RegExp("rgb" + HC),
  rgba: new RegExp("rgba" + jC),
  hsl: new RegExp("hsl" + HC),
  hsla: new RegExp("hsla" + jC),
  hsv: new RegExp("hsv" + HC),
  hsva: new RegExp("hsva" + jC),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function bfe(e) {
  if (e = e.trim().toLowerCase(), e.length === 0)
    return !1;
  var t = !1;
  if (dx[e])
    e = dx[e], t = !0;
  else if (e === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = va.rgb.exec(e);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = va.rgba.exec(e), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = va.hsl.exec(e), n ? { h: n[1], s: n[2], l: n[3] } : (n = va.hsla.exec(e), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = va.hsv.exec(e), n ? { h: n[1], s: n[2], v: n[3] } : (n = va.hsva.exec(e), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = va.hex8.exec(e), n ? {
    r: Or(n[1]),
    g: Or(n[2]),
    b: Or(n[3]),
    a: U3(n[4]),
    format: t ? "name" : "hex8"
  } : (n = va.hex6.exec(e), n ? {
    r: Or(n[1]),
    g: Or(n[2]),
    b: Or(n[3]),
    format: t ? "name" : "hex"
  } : (n = va.hex4.exec(e), n ? {
    r: Or(n[1] + n[1]),
    g: Or(n[2] + n[2]),
    b: Or(n[3] + n[3]),
    a: U3(n[4] + n[4]),
    format: t ? "name" : "hex8"
  } : (n = va.hex3.exec(e), n ? {
    r: Or(n[1] + n[1]),
    g: Or(n[2] + n[2]),
    b: Or(n[3] + n[3]),
    format: t ? "name" : "hex"
  } : !1)))))))));
}
function zi(e) {
  return !!va.CSS_UNIT.exec(String(e));
}
var xn = (
  /** @class */
  function() {
    function e(t, n) {
      t === void 0 && (t = ""), n === void 0 && (n = {});
      var o;
      if (t instanceof e)
        return t;
      typeof t == "number" && (t = mfe(t)), this.originalInput = t;
      var l = zd(t);
      this.originalInput = t, this.r = l.r, this.g = l.g, this.b = l.b, this.a = l.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (o = n.format) !== null && o !== void 0 ? o : l.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = l.ok;
    }
    return e.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, e.prototype.isLight = function() {
      return !this.isDark();
    }, e.prototype.getBrightness = function() {
      var t = this.toRgb();
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
    }, e.prototype.getLuminance = function() {
      var t = this.toRgb(), n, o, l, r = t.r / 255, a = t.g / 255, i = t.b / 255;
      return r <= 0.03928 ? n = r / 12.92 : n = Math.pow((r + 0.055) / 1.055, 2.4), a <= 0.03928 ? o = a / 12.92 : o = Math.pow((a + 0.055) / 1.055, 2.4), i <= 0.03928 ? l = i / 12.92 : l = Math.pow((i + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * o + 0.0722 * l;
    }, e.prototype.getAlpha = function() {
      return this.a;
    }, e.prototype.setAlpha = function(t) {
      return this.a = vF(t), this.roundA = Math.round(100 * this.a) / 100, this;
    }, e.prototype.isMonochrome = function() {
      var t = this.toHsl().s;
      return t === 0;
    }, e.prototype.toHsv = function() {
      var t = cx(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
    }, e.prototype.toHsvString = function() {
      var t = cx(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), l = Math.round(t.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(o, "%, ").concat(l, "%)") : "hsva(".concat(n, ", ").concat(o, "%, ").concat(l, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHsl = function() {
      var t = K3(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
    }, e.prototype.toHslString = function() {
      var t = K3(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), l = Math.round(t.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(o, "%, ").concat(l, "%)") : "hsla(".concat(n, ", ").concat(o, "%, ").concat(l, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHex = function(t) {
      return t === void 0 && (t = !1), ux(this.r, this.g, this.b, t);
    }, e.prototype.toHexString = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex(t);
    }, e.prototype.toHex8 = function(t) {
      return t === void 0 && (t = !1), pfe(this.r, this.g, this.b, this.a, t);
    }, e.prototype.toHex8String = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex8(t);
    }, e.prototype.toHexShortString = function(t) {
      return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
    }, e.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, e.prototype.toRgbString = function() {
      var t = Math.round(this.r), n = Math.round(this.g), o = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(t, ", ").concat(n, ", ").concat(o, ")") : "rgba(".concat(t, ", ").concat(n, ", ").concat(o, ", ").concat(this.roundA, ")");
    }, e.prototype.toPercentageRgb = function() {
      var t = function(n) {
        return "".concat(Math.round(Cl(n, 255) * 100), "%");
      };
      return {
        r: t(this.r),
        g: t(this.g),
        b: t(this.b),
        a: this.a
      };
    }, e.prototype.toPercentageRgbString = function() {
      var t = function(n) {
        return Math.round(Cl(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
    }, e.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var t = "#" + ux(this.r, this.g, this.b, !1), n = 0, o = Object.entries(dx); n < o.length; n++) {
        var l = o[n], r = l[0], a = l[1];
        if (t === a)
          return r;
      }
      return !1;
    }, e.prototype.toString = function(t) {
      var n = !!t;
      t = t != null ? t : this.format;
      var o = !1, l = this.a < 1 && this.a >= 0, r = !n && l && (t.startsWith("hex") || t === "name");
      return r ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (o = this.toRgbString()), t === "prgb" && (o = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (o = this.toHexString()), t === "hex3" && (o = this.toHexString(!0)), t === "hex4" && (o = this.toHex8String(!0)), t === "hex8" && (o = this.toHex8String()), t === "name" && (o = this.toName()), t === "hsl" && (o = this.toHslString()), t === "hsv" && (o = this.toHsvString()), o || this.toHexString());
    }, e.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, e.prototype.clone = function() {
      return new e(this.toString());
    }, e.prototype.lighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l += t / 100, n.l = sg(n.l), new e(n);
    }, e.prototype.brighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100)))), new e(n);
    }, e.prototype.darken = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l -= t / 100, n.l = sg(n.l), new e(n);
    }, e.prototype.tint = function(t) {
      return t === void 0 && (t = 10), this.mix("white", t);
    }, e.prototype.shade = function(t) {
      return t === void 0 && (t = 10), this.mix("black", t);
    }, e.prototype.desaturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s -= t / 100, n.s = sg(n.s), new e(n);
    }, e.prototype.saturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s += t / 100, n.s = sg(n.s), new e(n);
    }, e.prototype.greyscale = function() {
      return this.desaturate(100);
    }, e.prototype.spin = function(t) {
      var n = this.toHsl(), o = (n.h + t) % 360;
      return n.h = o < 0 ? 360 + o : o, new e(n);
    }, e.prototype.mix = function(t, n) {
      n === void 0 && (n = 50);
      var o = this.toRgb(), l = new e(t).toRgb(), r = n / 100, a = {
        r: (l.r - o.r) * r + o.r,
        g: (l.g - o.g) * r + o.g,
        b: (l.b - o.b) * r + o.b,
        a: (l.a - o.a) * r + o.a
      };
      return new e(a);
    }, e.prototype.analogous = function(t, n) {
      t === void 0 && (t = 6), n === void 0 && (n = 30);
      var o = this.toHsl(), l = 360 / n, r = [this];
      for (o.h = (o.h - (l * t >> 1) + 720) % 360; --t; )
        o.h = (o.h + l) % 360, r.push(new e(o));
      return r;
    }, e.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360, new e(t);
    }, e.prototype.monochromatic = function(t) {
      t === void 0 && (t = 6);
      for (var n = this.toHsv(), o = n.h, l = n.s, r = n.v, a = [], i = 1 / t; t--; )
        a.push(new e({ h: o, s: l, v: r })), r = (r + i) % 1;
      return a;
    }, e.prototype.splitcomplement = function() {
      var t = this.toHsl(), n = t.h;
      return [
        this,
        new e({ h: (n + 72) % 360, s: t.s, l: t.l }),
        new e({ h: (n + 216) % 360, s: t.s, l: t.l })
      ];
    }, e.prototype.onBackground = function(t) {
      var n = this.toRgb(), o = new e(t).toRgb(), l = n.a + o.a * (1 - n.a);
      return new e({
        r: (n.r * n.a + o.r * o.a * (1 - n.a)) / l,
        g: (n.g * n.a + o.g * o.a * (1 - n.a)) / l,
        b: (n.b * n.a + o.b * o.a * (1 - n.a)) / l,
        a: l
      });
    }, e.prototype.triad = function() {
      return this.polyad(3);
    }, e.prototype.tetrad = function() {
      return this.polyad(4);
    }, e.prototype.polyad = function(t) {
      for (var n = this.toHsl(), o = n.h, l = [this], r = 360 / t, a = 1; a < t; a++)
        l.push(new e({ h: (o + a * r) % 360, s: n.s, l: n.l }));
      return l;
    }, e.prototype.equals = function(t) {
      return this.toRgbString() === new e(t).toRgbString();
    }, e;
  }()
);
function As(e, t = 20) {
  return e.mix("#141414", t).toString();
}
function yfe(e) {
  const t = io(), n = Ve("button");
  return O(() => {
    let o = {}, l = e.color;
    if (l) {
      const r = l.match(/var\((.*?)\)/);
      r && (l = window.getComputedStyle(window.document.documentElement).getPropertyValue(r[1]));
      const a = new xn(l), i = e.dark ? a.tint(20).toString() : As(a, 20);
      if (e.plain)
        o = n.cssVarBlock({
          "bg-color": e.dark ? As(a, 90) : a.tint(90).toString(),
          "text-color": l,
          "border-color": e.dark ? As(a, 50) : a.tint(50).toString(),
          "hover-text-color": `var(${n.cssVarName("color-white")})`,
          "hover-bg-color": l,
          "hover-border-color": l,
          "active-bg-color": i,
          "active-text-color": `var(${n.cssVarName("color-white")})`,
          "active-border-color": i
        }), t.value && (o[n.cssVarBlockName("disabled-bg-color")] = e.dark ? As(a, 90) : a.tint(90).toString(), o[n.cssVarBlockName("disabled-text-color")] = e.dark ? As(a, 50) : a.tint(50).toString(), o[n.cssVarBlockName("disabled-border-color")] = e.dark ? As(a, 80) : a.tint(80).toString());
      else {
        const s = e.dark ? As(a, 30) : a.tint(30).toString(), c = a.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
        if (o = n.cssVarBlock({
          "bg-color": l,
          "text-color": c,
          "border-color": l,
          "hover-bg-color": s,
          "hover-text-color": c,
          "hover-border-color": s,
          "active-bg-color": i,
          "active-border-color": i
        }), t.value) {
          const u = e.dark ? As(a, 50) : a.tint(50).toString();
          o[n.cssVarBlockName("disabled-bg-color")] = u, o[n.cssVarBlockName("disabled-text-color")] = e.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`, o[n.cssVarBlockName("disabled-border-color")] = u;
        }
      }
    }
    return o;
  });
}
const Sfe = /* @__PURE__ */ le({
  name: "ElButton",
  __name: "button",
  props: sx,
  emits: ife,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = yfe(o), a = Ve("button"), {
      _ref: i,
      _size: s,
      _type: c,
      _disabled: u,
      _props: d,
      _plain: f,
      _round: p,
      _text: m,
      shouldAddSpace: v,
      handleClick: h
    } = rfe(o, l), g = O(() => [
      a.b(),
      a.m(c.value),
      a.m(s.value),
      a.is("disabled", u.value),
      a.is("loading", o.loading),
      a.is("plain", f.value),
      a.is("round", p.value),
      a.is("circle", o.circle),
      a.is("text", m.value),
      a.is("link", o.link),
      a.is("has-bg", o.bg)
    ]);
    return t({
      ref: i,
      size: s,
      type: c,
      disabled: u,
      shouldAddSpace: v
    }), (y, b) => (G(), Me(Ht(y.tag), Ut({
      ref_key: "_ref",
      ref: i
    }, S(d), {
      class: g.value,
      style: S(r),
      onClick: S(h)
    }), {
      default: Ee(() => [
        y.loading ? (G(), ue(
          Ge,
          { key: 0 },
          [
            y.$slots.loading ? Oe(y.$slots, "loading", { key: 0 }) : (G(), Me(S(ut), {
              key: 1,
              class: X(S(a).is("loading"))
            }, {
              default: Ee(() => [
                (G(), Me(Ht(y.loadingIcon)))
              ]),
              _: 1
            }, 8, ["class"]))
          ],
          64
        )) : y.icon || y.$slots.icon ? (G(), Me(S(ut), { key: 1 }, {
          default: Ee(() => [
            y.icon ? (G(), Me(Ht(y.icon), { key: 0 })) : Oe(y.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : Ie("v-if", !0),
        y.$slots.default ? (G(), ue(
          "span",
          {
            key: 2,
            class: X({ [S(a).em("text", "expand")]: S(v) })
          },
          [
            Oe(y.$slots, "default")
          ],
          2
        )) : Ie("v-if", !0)
      ]),
      _: 3
    }, 16, ["class", "style", "onClick"]));
  }
});
var Cfe = /* @__PURE__ */ Je(Sfe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
const wfe = {
  size: sx.size,
  type: sx.type,
  direction: {
    type: ye(String),
    values: ["horizontal", "vertical"],
    default: "horizontal"
  }
}, $fe = /* @__PURE__ */ le({
  name: "ElButtonGroup",
  __name: "button-group",
  props: wfe,
  setup(e) {
    const t = e;
    at(
      pF,
      /* @__PURE__ */ kt({
        size: /* @__PURE__ */ ft(t, "size"),
        type: /* @__PURE__ */ ft(t, "type")
      })
    );
    const n = Ve("button");
    return (o, l) => (G(), ue(
      "div",
      {
        class: X([S(n).b("group"), S(n).bm("group", t.direction)])
      },
      [
        Oe(o.$slots, "default")
      ],
      2
    ));
  }
});
var mF = /* @__PURE__ */ Je($fe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
const Qo = Dt(Cfe, {
  ButtonGroup: mF
}), hF = oo(mF);
var Ya = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function Xa(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var gF = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Ya, function() {
    var n = 1e3, o = 6e4, l = 36e5, r = "millisecond", a = "second", i = "minute", s = "hour", c = "day", u = "week", d = "month", f = "quarter", p = "year", m = "date", v = "Invalid Date", h = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, g = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, y = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(z) {
      var D = ["th", "st", "nd", "rd"], F = z % 100;
      return "[" + z + (D[(F - 20) % 10] || D[F] || D[0]) + "]";
    } }, b = function(z, D, F) {
      var M = String(z);
      return !M || M.length >= D ? z : "" + Array(D + 1 - M.length).join(F) + z;
    }, C = { s: b, z: function(z) {
      var D = -z.utcOffset(), F = Math.abs(D), M = Math.floor(F / 60), A = F % 60;
      return (D <= 0 ? "+" : "-") + b(M, 2, "0") + ":" + b(A, 2, "0");
    }, m: function z(D, F) {
      if (D.date() < F.date()) return -z(F, D);
      var M = 12 * (F.year() - D.year()) + (F.month() - D.month()), A = D.clone().add(M, d), L = F - A < 0, B = D.clone().add(M + (L ? -1 : 1), d);
      return +(-(M + (F - A) / (L ? A - B : B - A)) || 0);
    }, a: function(z) {
      return z < 0 ? Math.ceil(z) || 0 : Math.floor(z);
    }, p: function(z) {
      return { M: d, y: p, w: u, d: c, D: m, h: s, m: i, s: a, ms: r, Q: f }[z] || String(z || "").toLowerCase().replace(/s$/, "");
    }, u: function(z) {
      return z === void 0;
    } }, w = "en", x = {};
    x[w] = y;
    var E = "$isDayjsObject", I = function(z) {
      return z instanceof N || !(!z || !z[E]);
    }, T = function z(D, F, M) {
      var A;
      if (!D) return w;
      if (typeof D == "string") {
        var L = D.toLowerCase();
        x[L] && (A = L), F && (x[L] = F, A = L);
        var B = D.split("-");
        if (!A && B.length > 1) return z(B[0]);
      } else {
        var V = D.name;
        x[V] = D, A = V;
      }
      return !M && A && (w = A), A || !M && w;
    }, P = function(z, D) {
      if (I(z)) return z.clone();
      var F = typeof D == "object" ? D : {};
      return F.date = z, F.args = arguments, new N(F);
    }, k = C;
    k.l = T, k.i = I, k.w = function(z, D) {
      return P(z, { locale: D.$L, utc: D.$u, x: D.$x, $offset: D.$offset });
    };
    var N = function() {
      function z(F) {
        this.$L = T(F.locale, null, !0), this.parse(F), this.$x = this.$x || F.x || {}, this[E] = !0;
      }
      var D = z.prototype;
      return D.parse = function(F) {
        this.$d = function(M) {
          var A = M.date, L = M.utc;
          if (A === null) return /* @__PURE__ */ new Date(NaN);
          if (k.u(A)) return /* @__PURE__ */ new Date();
          if (A instanceof Date) return new Date(A);
          if (typeof A == "string" && !/Z$/i.test(A)) {
            var B = A.match(h);
            if (B) {
              var V = B[2] - 1 || 0, j = (B[7] || "0").substring(0, 3);
              return L ? new Date(Date.UTC(B[1], V, B[3] || 1, B[4] || 0, B[5] || 0, B[6] || 0, j)) : new Date(B[1], V, B[3] || 1, B[4] || 0, B[5] || 0, B[6] || 0, j);
            }
          }
          return new Date(A);
        }(F), this.init();
      }, D.init = function() {
        var F = this.$d;
        this.$y = F.getFullYear(), this.$M = F.getMonth(), this.$D = F.getDate(), this.$W = F.getDay(), this.$H = F.getHours(), this.$m = F.getMinutes(), this.$s = F.getSeconds(), this.$ms = F.getMilliseconds();
      }, D.$utils = function() {
        return k;
      }, D.isValid = function() {
        return this.$d.toString() !== v;
      }, D.isSame = function(F, M) {
        var A = P(F);
        return this.startOf(M) <= A && A <= this.endOf(M);
      }, D.isAfter = function(F, M) {
        return P(F) < this.startOf(M);
      }, D.isBefore = function(F, M) {
        return this.endOf(M) < P(F);
      }, D.$g = function(F, M, A) {
        return k.u(F) ? this[M] : this.set(A, F);
      }, D.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, D.valueOf = function() {
        return this.$d.getTime();
      }, D.startOf = function(F, M) {
        var A = this, L = !!k.u(M) || M, B = k.p(F), V = function(oe, q) {
          var K = k.w(A.$u ? Date.UTC(A.$y, q, oe) : new Date(A.$y, q, oe), A);
          return L ? K : K.endOf(c);
        }, j = function(oe, q) {
          return k.w(A.toDate()[oe].apply(A.toDate("s"), (L ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(q)), A);
        }, W = this.$W, Y = this.$M, U = this.$D, te = "set" + (this.$u ? "UTC" : "");
        switch (B) {
          case p:
            return L ? V(1, 0) : V(31, 11);
          case d:
            return L ? V(1, Y) : V(0, Y + 1);
          case u:
            var J = this.$locale().weekStart || 0, re = (W < J ? W + 7 : W) - J;
            return V(L ? U - re : U + (6 - re), Y);
          case c:
          case m:
            return j(te + "Hours", 0);
          case s:
            return j(te + "Minutes", 1);
          case i:
            return j(te + "Seconds", 2);
          case a:
            return j(te + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, D.endOf = function(F) {
        return this.startOf(F, !1);
      }, D.$set = function(F, M) {
        var A, L = k.p(F), B = "set" + (this.$u ? "UTC" : ""), V = (A = {}, A[c] = B + "Date", A[m] = B + "Date", A[d] = B + "Month", A[p] = B + "FullYear", A[s] = B + "Hours", A[i] = B + "Minutes", A[a] = B + "Seconds", A[r] = B + "Milliseconds", A)[L], j = L === c ? this.$D + (M - this.$W) : M;
        if (L === d || L === p) {
          var W = this.clone().set(m, 1);
          W.$d[V](j), W.init(), this.$d = W.set(m, Math.min(this.$D, W.daysInMonth())).$d;
        } else V && this.$d[V](j);
        return this.init(), this;
      }, D.set = function(F, M) {
        return this.clone().$set(F, M);
      }, D.get = function(F) {
        return this[k.p(F)]();
      }, D.add = function(F, M) {
        var A, L = this;
        F = Number(F);
        var B = k.p(M), V = function(Y) {
          var U = P(L);
          return k.w(U.date(U.date() + Math.round(Y * F)), L);
        };
        if (B === d) return this.set(d, this.$M + F);
        if (B === p) return this.set(p, this.$y + F);
        if (B === c) return V(1);
        if (B === u) return V(7);
        var j = (A = {}, A[i] = o, A[s] = l, A[a] = n, A)[B] || 1, W = this.$d.getTime() + F * j;
        return k.w(W, this);
      }, D.subtract = function(F, M) {
        return this.add(-1 * F, M);
      }, D.format = function(F) {
        var M = this, A = this.$locale();
        if (!this.isValid()) return A.invalidDate || v;
        var L = F || "YYYY-MM-DDTHH:mm:ssZ", B = k.z(this), V = this.$H, j = this.$m, W = this.$M, Y = A.weekdays, U = A.months, te = A.meridiem, J = function(q, K, se, Z) {
          return q && (q[K] || q(M, L)) || se[K].slice(0, Z);
        }, re = function(q) {
          return k.s(V % 12 || 12, q, "0");
        }, oe = te || function(q, K, se) {
          var Z = q < 12 ? "AM" : "PM";
          return se ? Z.toLowerCase() : Z;
        };
        return L.replace(g, function(q, K) {
          return K || function(se) {
            switch (se) {
              case "YY":
                return String(M.$y).slice(-2);
              case "YYYY":
                return k.s(M.$y, 4, "0");
              case "M":
                return W + 1;
              case "MM":
                return k.s(W + 1, 2, "0");
              case "MMM":
                return J(A.monthsShort, W, U, 3);
              case "MMMM":
                return J(U, W);
              case "D":
                return M.$D;
              case "DD":
                return k.s(M.$D, 2, "0");
              case "d":
                return String(M.$W);
              case "dd":
                return J(A.weekdaysMin, M.$W, Y, 2);
              case "ddd":
                return J(A.weekdaysShort, M.$W, Y, 3);
              case "dddd":
                return Y[M.$W];
              case "H":
                return String(V);
              case "HH":
                return k.s(V, 2, "0");
              case "h":
                return re(1);
              case "hh":
                return re(2);
              case "a":
                return oe(V, j, !0);
              case "A":
                return oe(V, j, !1);
              case "m":
                return String(j);
              case "mm":
                return k.s(j, 2, "0");
              case "s":
                return String(M.$s);
              case "ss":
                return k.s(M.$s, 2, "0");
              case "SSS":
                return k.s(M.$ms, 3, "0");
              case "Z":
                return B;
            }
            return null;
          }(q) || B.replace(":", "");
        });
      }, D.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, D.diff = function(F, M, A) {
        var L, B = this, V = k.p(M), j = P(F), W = (j.utcOffset() - this.utcOffset()) * o, Y = this - j, U = function() {
          return k.m(B, j);
        };
        switch (V) {
          case p:
            L = U() / 12;
            break;
          case d:
            L = U();
            break;
          case f:
            L = U() / 3;
            break;
          case u:
            L = (Y - W) / 6048e5;
            break;
          case c:
            L = (Y - W) / 864e5;
            break;
          case s:
            L = Y / l;
            break;
          case i:
            L = Y / o;
            break;
          case a:
            L = Y / n;
            break;
          default:
            L = Y;
        }
        return A ? L : k.a(L);
      }, D.daysInMonth = function() {
        return this.endOf(d).$D;
      }, D.$locale = function() {
        return x[this.$L];
      }, D.locale = function(F, M) {
        if (!F) return this.$L;
        var A = this.clone(), L = T(F, M, !0);
        return L && (A.$L = L), A;
      }, D.clone = function() {
        return k.w(this.$d, this);
      }, D.toDate = function() {
        return new Date(this.valueOf());
      }, D.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, D.toISOString = function() {
        return this.$d.toISOString();
      }, D.toString = function() {
        return this.$d.toUTCString();
      }, z;
    }(), R = N.prototype;
    return P.prototype = R, [["$ms", r], ["$s", a], ["$m", i], ["$H", s], ["$W", c], ["$M", d], ["$y", p], ["$D", m]].forEach(function(z) {
      R[z[1]] = function(D) {
        return this.$g(D, z[0], z[1]);
      };
    }), P.extend = function(z, D) {
      return z.$i || (z(D, N, P), z.$i = !0), P;
    }, P.locale = T, P.isDayjs = I, P.unix = function(z) {
      return P(1e3 * z);
    }, P.en = x[w], P.Ls = x, P.p = {}, P;
  });
})(gF);
var xfe = gF.exports;
const wt = /* @__PURE__ */ Xa(xfe), WC = (e, t) => [
  e > 0 ? e - 1 : void 0,
  e,
  e < t ? e + 1 : void 0
], cc = (e) => Array.from(Array.from({ length: e }).keys()), bF = (e) => e.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim(), yF = (e) => e.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim(), G3 = function(e, t) {
  const n = vc(e), o = vc(t);
  return n && o ? e.getTime() === t.getTime() : !n && !o ? e === t : !1;
}, SF = function(e, t) {
  const n = We(e), o = We(t);
  return n && o ? e.length !== t.length ? !1 : e.every((l, r) => G3(l, t[r])) : !n && !o ? G3(e, t) : !1;
}, Y3 = function(e, t, n) {
  const o = Ql(t) || t === "x" ? wt(e).locale(n) : wt(e, t).locale(n);
  return o.isValid() ? o : void 0;
}, X3 = function(e, t, n) {
  return Ql(t) ? e : t === "x" ? +e : wt(e).locale(n).format(t);
}, KC = (e, t) => {
  var n;
  const o = [], l = t == null ? void 0 : t();
  for (let r = 0; r < e; r++)
    o.push((n = l == null ? void 0 : l.includes(r)) != null ? n : !1);
  return o;
}, fb = (e) => We(e) ? e.map((t) => t.toDate()) : e.toDate(), Efe = (e, t) => {
  const n = e.subtract(1, "month").endOf("month").date();
  return cc(t).map((o, l) => n - (t - l - 1));
}, Ofe = (e) => {
  const t = e.daysInMonth();
  return cc(t).map((n, o) => o + 1);
}, _fe = (e) => cc(e.length / 7).map((t) => {
  const n = t * 7;
  return e.slice(n, n + 7);
}), Ife = Xe({
  selectedDay: {
    type: ye(Object)
  },
  range: {
    type: ye(Array)
  },
  date: {
    type: ye(Object),
    required: !0
  },
  hideHeader: {
    type: Boolean
  }
}), Tfe = {
  pick: (e) => Mt(e)
};
var CF = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Ya, function() {
    return function(n, o, l) {
      var r = o.prototype, a = function(d) {
        return d && (d.indexOf ? d : d.s);
      }, i = function(d, f, p, m, v) {
        var h = d.name ? d : d.$locale(), g = a(h[f]), y = a(h[p]), b = g || y.map(function(w) {
          return w.slice(0, m);
        });
        if (!v) return b;
        var C = h.weekStart;
        return b.map(function(w, x) {
          return b[(x + (C || 0)) % 7];
        });
      }, s = function() {
        return l.Ls[l.locale()];
      }, c = function(d, f) {
        return d.formats[f] || function(p) {
          return p.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(m, v, h) {
            return v || h.slice(1);
          });
        }(d.formats[f.toUpperCase()]);
      }, u = function() {
        var d = this;
        return { months: function(f) {
          return f ? f.format("MMMM") : i(d, "months");
        }, monthsShort: function(f) {
          return f ? f.format("MMM") : i(d, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return d.$locale().weekStart || 0;
        }, weekdays: function(f) {
          return f ? f.format("dddd") : i(d, "weekdays");
        }, weekdaysMin: function(f) {
          return f ? f.format("dd") : i(d, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(f) {
          return f ? f.format("ddd") : i(d, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(f) {
          return c(d.$locale(), f);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      r.localeData = function() {
        return u.bind(this)();
      }, l.localeData = function() {
        var d = s();
        return { firstDayOfWeek: function() {
          return d.weekStart || 0;
        }, weekdays: function() {
          return l.weekdays();
        }, weekdaysShort: function() {
          return l.weekdaysShort();
        }, weekdaysMin: function() {
          return l.weekdaysMin();
        }, months: function() {
          return l.months();
        }, monthsShort: function() {
          return l.monthsShort();
        }, longDateFormat: function(f) {
          return c(d, f);
        }, meridiem: d.meridiem, ordinal: d.ordinal };
      }, l.months = function() {
        return i(s(), "months");
      }, l.monthsShort = function() {
        return i(s(), "monthsShort", "months", 3);
      }, l.weekdays = function(d) {
        return i(s(), "weekdays", null, null, d);
      }, l.weekdaysShort = function(d) {
        return i(s(), "weekdaysShort", "weekdays", 3, d);
      }, l.weekdaysMin = function(d) {
        return i(s(), "weekdaysMin", "weekdays", 2, d);
      };
    };
  });
})(CF);
var Pfe = CF.exports;
const JO = /* @__PURE__ */ Xa(Pfe), kfe = [
  "year",
  "years",
  "month",
  "months",
  "date",
  "dates",
  "week",
  "datetime",
  "datetimerange",
  "daterange",
  "monthrange",
  "yearrange"
], UC = [
  "sun",
  "mon",
  "tue",
  "wed",
  "thu",
  "fri",
  "sat"
], Nfe = (e, t) => {
  wt.extend(JO);
  const n = wt.localeData().firstDayOfWeek(), { t: o, lang: l } = an(), r = wt().locale(l.value), a = O(() => !!e.range && !!e.range.length), i = O(() => {
    let f = [];
    if (a.value) {
      const [p, m] = e.range, v = cc(
        m.date() - p.date() + 1
      ).map((y) => ({
        text: p.date() + y,
        type: "current"
      }));
      let h = v.length % 7;
      h = h === 0 ? 0 : 7 - h;
      const g = cc(h).map(
        (y, b) => ({
          text: b + 1,
          type: "next"
        })
      );
      f = v.concat(g);
    } else {
      const p = e.date.startOf("month").day(), m = Efe(
        e.date,
        (p - n + 7) % 7
      ).map((y) => ({
        text: y,
        type: "prev"
      })), v = Ofe(e.date).map(
        (y) => ({
          text: y,
          type: "current"
        })
      );
      f = [...m, ...v];
      const h = 7 - (f.length % 7 || 7), g = cc(h).map(
        (y, b) => ({
          text: b + 1,
          type: "next"
        })
      );
      f = f.concat(g);
    }
    return _fe(f);
  }), s = O(() => {
    const f = n;
    return f === 0 ? UC.map((p) => o(`el.datepicker.weeks.${p}`)) : UC.slice(f).concat(UC.slice(0, f)).map((p) => o(`el.datepicker.weeks.${p}`));
  }), c = (f, p) => {
    switch (p) {
      case "prev":
        return e.date.startOf("month").subtract(1, "month").date(f);
      case "next":
        return e.date.startOf("month").add(1, "month").date(f);
      case "current":
        return e.date.date(f);
    }
  };
  return {
    now: r,
    isInRange: a,
    rows: i,
    weekDays: s,
    getFormattedDate: c,
    handlePickDay: ({ text: f, type: p }) => {
      const m = c(f, p);
      t("pick", m);
    },
    getSlotData: ({ text: f, type: p }) => {
      const m = c(f, p);
      return {
        isSelected: m.isSame(e.selectedDay),
        type: `${p}-month`,
        day: m.format("YYYY-MM-DD"),
        date: m.toDate()
      };
    }
  };
}, Mfe = { key: 0 }, Afe = ["onClick"], Rfe = /* @__PURE__ */ le({
  name: "DateTable",
  __name: "date-table",
  props: Ife,
  emits: Tfe,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, {
      isInRange: r,
      now: a,
      rows: i,
      weekDays: s,
      getFormattedDate: c,
      handlePickDay: u,
      getSlotData: d
    } = Nfe(o, l), f = Ve("calendar-table"), p = Ve("calendar-day"), m = ({ text: v, type: h }) => {
      const g = [h];
      if (h === "current") {
        const y = c(v, h);
        y.isSame(o.selectedDay, "day") && g.push(p.is("selected")), y.isSame(a, "day") && g.push(p.is("today"));
      }
      return g;
    };
    return t({
      getFormattedDate: c
    }), (v, h) => (G(), ue(
      "table",
      {
        class: X([S(f).b(), S(f).is("range", S(r))]),
        cellspacing: "0",
        cellpadding: "0"
      },
      [
        v.hideHeader ? Ie("v-if", !0) : (G(), ue("thead", Mfe, [
          ve("tr", null, [
            (G(!0), ue(
              Ge,
              null,
              on(S(s), (g) => (G(), ue(
                "th",
                {
                  key: g,
                  scope: "col"
                },
                qe(g),
                1
              ))),
              128
            ))
          ])
        ])),
        ve("tbody", null, [
          (G(!0), ue(
            Ge,
            null,
            on(S(i), (g, y) => (G(), ue(
              "tr",
              {
                key: y,
                class: X({
                  [S(f).e("row")]: !0,
                  [S(f).em("row", "hide-border")]: y === 0 && v.hideHeader
                })
              },
              [
                (G(!0), ue(
                  Ge,
                  null,
                  on(g, (b, C) => (G(), ue("td", {
                    key: C,
                    class: X(m(b)),
                    onClick: (w) => S(u)(b)
                  }, [
                    ve(
                      "div",
                      {
                        class: X(S(p).b())
                      },
                      [
                        Oe(v.$slots, "date-cell", {
                          data: S(d)(b)
                        }, () => [
                          ve(
                            "span",
                            null,
                            qe(b.text),
                            1
                          )
                        ])
                      ],
                      2
                    )
                  ], 10, Afe))),
                  128
                ))
              ],
              2
            ))),
            128
          ))
        ])
      ],
      2
    ));
  }
});
var q3 = /* @__PURE__ */ Je(Rfe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/date-table.vue"]]);
const Dfe = (e, t) => {
  const n = e.endOf("month"), o = t.startOf("month"), r = n.isSame(o, "week") ? o.add(1, "week") : o;
  return [
    [e, n],
    [r.startOf("week"), t]
  ];
}, Lfe = (e, t) => {
  const n = e.endOf("month"), o = e.add(1, "month").startOf("month"), l = n.isSame(
    o,
    "week"
  ) ? o.add(1, "week") : o, r = l.endOf("month"), a = t.startOf("month"), i = r.isSame(a, "week") ? a.add(1, "week") : a;
  return [
    [e, n],
    [l.startOf("week"), r],
    [i.startOf("week"), t]
  ];
}, Bfe = (e, t, n) => {
  const { lang: o } = an(), l = /* @__PURE__ */ H(), r = wt().locale(o.value), a = O({
    get() {
      return e.modelValue ? s.value : l.value;
    },
    set(g) {
      if (!g)
        return;
      l.value = g;
      const y = g.toDate();
      t(Po, y), t(It, y);
    }
  }), i = O(() => {
    if (!e.range || !We(e.range) || e.range.length !== 2 || e.range.some((C) => !vc(C)))
      return [];
    const g = e.range.map((C) => wt(C).locale(o.value)), [y, b] = g;
    return y.isAfter(b) ? (Gt(n, "end time should be greater than start time"), []) : y.isSame(b, "month") ? p(y, b) : y.add(1, "month").month() !== b.month() ? (Gt(
      n,
      "start time and end time interval must not exceed two months"
    ), []) : p(y, b);
  }), s = O(() => e.modelValue ? wt(e.modelValue).locale(o.value) : a.value || (i.value.length ? i.value[0][0] : r)), c = O(() => s.value.subtract(1, "month").date(1)), u = O(() => s.value.add(1, "month").date(1)), d = O(() => s.value.subtract(1, "year").date(1)), f = O(() => s.value.add(1, "year").date(1)), p = (g, y) => {
    const b = g.startOf("week"), C = y.endOf("week"), w = b.get("month"), x = C.get("month");
    return w === x ? [[b, C]] : (w + 1) % 12 === x ? Dfe(b, C) : w + 2 === x || (w + 1) % 11 === x ? Lfe(b, C) : (Gt(
      n,
      "start time and end time interval must not exceed two months"
    ), []);
  }, m = (g) => {
    a.value = g;
  }, v = (g) => {
    const b = {
      "prev-month": c.value,
      "next-month": u.value,
      "prev-year": d.value,
      "next-year": f.value,
      today: r
    }[g];
    b.isSame(s.value, "day") || m(b);
  };
  return {
    calculateValidatedDateRange: p,
    date: s,
    realSelectedDay: a,
    pickDay: m,
    selectDate: v,
    validatedRange: i,
    handleDateChange: (g) => {
      g === "today" ? v("today") : m(g);
    }
  };
}, Ffe = (e) => We(e) && e.length === 2 && e.every((t) => vc(t)), Vfe = Xe({
  modelValue: {
    type: Date
  },
  range: {
    type: ye(Array),
    validator: Ffe
  },
  controllerType: {
    type: String,
    values: ["button", "select"],
    default: "button"
  },
  formatter: {
    type: ye(Function)
  }
}), zfe = {
  [It]: (e) => vc(e),
  [Po]: (e) => vc(e)
}, gs = Xe({
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger"],
    default: "primary"
  },
  closable: Boolean,
  disableTransitions: Boolean,
  hit: Boolean,
  color: String,
  size: {
    type: String,
    values: ki
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
}), Hfe = {
  close: (e) => e instanceof MouseEvent,
  click: (e) => e instanceof MouseEvent
}, jfe = ["aria-label"], Wfe = ["aria-label"], Kfe = /* @__PURE__ */ le({
  name: "ElTag",
  __name: "tag",
  props: gs,
  emits: Hfe,
  setup(e, { emit: t }) {
    const n = e, o = t, l = Mo(), { t: r } = an(), a = Ve("tag"), i = O(() => {
      const { type: d, hit: f, effect: p, closable: m, round: v } = n;
      return [
        a.b(),
        a.is("closable", m),
        a.m(d || "primary"),
        a.m(l.value),
        a.m(p),
        a.is("hit", f),
        a.is("round", v)
      ];
    }), s = (d) => {
      o("close", d);
    }, c = (d) => {
      o("click", d);
    }, u = (d) => {
      var f, p, m;
      (m = (p = (f = d == null ? void 0 : d.component) == null ? void 0 : f.subTree) == null ? void 0 : p.component) != null && m.bum && (d.component.subTree.component.bum = null);
    };
    return (d, f) => d.disableTransitions ? (G(), ue(
      "span",
      {
        key: 0,
        class: X(i.value),
        style: gt({ backgroundColor: d.color }),
        onClick: c
      },
      [
        ve(
          "span",
          {
            class: X(S(a).e("content"))
          },
          [
            Oe(d.$slots, "default")
          ],
          2
        ),
        d.closable ? (G(), ue("button", {
          key: 0,
          "aria-label": S(r)("el.tag.close"),
          class: X(S(a).e("close")),
          type: "button",
          onClick: Et(s, ["stop"])
        }, [
          $(S(ut), null, {
            default: Ee(() => [
              $(S(aa))
            ]),
            _: 1
          })
        ], 10, jfe)) : Ie("v-if", !0)
      ],
      6
    )) : (G(), Me(Vn, {
      key: 1,
      name: `${S(a).namespace.value}-zoom-in-center`,
      appear: "",
      onVnodeMounted: u
    }, {
      default: Ee(() => [
        ve(
          "span",
          {
            class: X(i.value),
            style: gt({ backgroundColor: d.color }),
            onClick: c
          },
          [
            ve(
              "span",
              {
                class: X(S(a).e("content"))
              },
              [
                Oe(d.$slots, "default")
              ],
              2
            ),
            d.closable ? (G(), ue("button", {
              key: 0,
              "aria-label": S(r)("el.tag.close"),
              class: X(S(a).e("close")),
              type: "button",
              onClick: Et(s, ["stop"])
            }, [
              $(S(ut), null, {
                default: Ee(() => [
                  $(S(aa))
                ]),
                _: 1
              })
            ], 10, Wfe)) : Ie("v-if", !0)
          ],
          6
        )
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
var Ufe = /* @__PURE__ */ Je(Kfe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
const fs = Dt(Ufe), A0 = {
  label: "label",
  value: "value",
  disabled: "disabled",
  options: "options"
};
function mh(e) {
  const t = /* @__PURE__ */ H(Be(Be({}, A0), e.props));
  let n = Be({}, e.props);
  return pe(
    () => e.props,
    (i) => {
      Jn(i, n) || (t.value = Be(Be({}, A0), i), n = Be({}, i));
    },
    { deep: !0 }
  ), {
    aliasProps: t,
    getLabel: (i) => Oo(i, t.value.label),
    getValue: (i) => Oo(i, t.value.value),
    getDisabled: (i) => Oo(i, t.value.disabled),
    getOptions: (i) => Oo(i, t.value.options)
  };
}
const wF = Symbol("ElSelectGroup"), hh = Symbol("ElSelect"), fx = "ElOption", Gfe = Xe({
  value: {
    type: [String, Number, Boolean, Object],
    required: !0
  },
  label: {
    type: [String, Number]
  },
  created: Boolean,
  disabled: Boolean
}), ZO = (e = "") => e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), Gs = (e) => hc(e);
function Yfe(e, t) {
  const n = ze(hh);
  n || no(fx, "usage: <el-select><el-option /></el-select/>");
  const o = ze(wF, { disabled: !1 }), l = O(() => u(ll(n.props.modelValue), e.value)), r = O(() => {
    var p;
    if (n.props.multiple) {
      const m = ll((p = n.props.modelValue) != null ? p : []);
      return !l.value && m.length >= n.props.multipleLimit && n.props.multipleLimit > 0;
    } else
      return !1;
  }), a = O(() => {
    var p;
    return (p = e.label) != null ? p : Mt(e.value) ? "" : e.value;
  }), i = O(() => e.value || e.label || ""), s = O(() => e.disabled || t.groupDisabled || r.value), c = xt(), u = (p = [], m) => {
    if (Mt(e.value)) {
      const v = n.props.valueKey;
      return p && p.some((h) => /* @__PURE__ */ Wt(Oo(h, v)) === Oo(m, v));
    } else
      return p && p.includes(m);
  }, d = () => {
    s.value || (n.states.hoveringIndex = n.optionsArray.indexOf(c.proxy));
  }, f = (p) => {
    const m = new RegExp(ZO(p), "i");
    t.visible = m.test(String(a.value)) || e.created;
  };
  return pe(
    () => a.value,
    () => {
      !e.created && !n.props.remote && n.setSelected();
    }
  ), pe(
    () => e.value,
    (p, m) => {
      const { remote: v, valueKey: h } = n.props;
      if ((v ? p !== m : !Jn(p, m)) && (n.onOptionDestroy(m, c.proxy), n.onOptionCreate(c.proxy)), !e.created && !v) {
        if (h && Mt(p) && Mt(m) && p[h] === m[h])
          return;
        n.setSelected();
      }
    }
  ), pe(
    () => o.disabled,
    () => {
      t.groupDisabled = o.disabled;
    },
    { immediate: !0 }
  ), {
    select: n,
    currentLabel: a,
    currentValue: i,
    itemSelected: l,
    isDisabled: s,
    hoverItem: d,
    updateOption: f
  };
}
const Xfe = /* @__PURE__ */ le({
  name: fx,
  componentName: fx,
  props: Gfe,
  setup(e) {
    const t = Ve("select"), n = ml(), o = O(() => [
      t.be("dropdown", "item"),
      t.is("disabled", S(i)),
      t.is("selected", S(a)),
      t.is("hovering", S(f))
    ]), l = /* @__PURE__ */ kt({
      index: -1,
      groupDisabled: !1,
      visible: !0,
      hover: !1
    }), {
      currentLabel: r,
      itemSelected: a,
      isDisabled: i,
      select: s,
      hoverItem: c,
      updateOption: u
    } = Yfe(e, l), { visible: d, hover: f } = /* @__PURE__ */ to(l), p = xt().proxy;
    s.onOptionCreate(p), yt(() => {
      const v = p.value;
      Ke(() => {
        const { selected: h } = s.states, g = h.some((y) => y.value === p.value);
        s.states.cachedOptions.get(v) === p && !g && s.states.cachedOptions.delete(v);
      }), s.onOptionDestroy(v, p);
    });
    function m() {
      i.value || s.handleOptionSelect(p);
    }
    return {
      ns: t,
      id: n,
      containerKls: o,
      currentLabel: r,
      itemSelected: a,
      isDisabled: i,
      select: s,
      visible: d,
      hover: f,
      states: l,
      hoverItem: c,
      updateOption: u,
      selectOptionClick: m
    };
  }
}), qfe = ["id", "aria-disabled", "aria-selected"];
function Jfe(e, t, n, o, l, r) {
  return _t((G(), ue("li", {
    id: e.id,
    class: X(e.containerKls),
    role: "option",
    "aria-disabled": e.isDisabled || void 0,
    "aria-selected": e.itemSelected,
    onMousemove: t[0] || (t[0] = (...a) => e.hoverItem && e.hoverItem(...a)),
    onClick: t[1] || (t[1] = Et((...a) => e.selectOptionClick && e.selectOptionClick(...a), ["stop"]))
  }, [
    Oe(e.$slots, "default", {}, () => [
      ve(
        "span",
        null,
        qe(e.currentLabel),
        1
      )
    ])
  ], 42, qfe)), [
    [Jt, e.visible]
  ]);
}
var QO = /* @__PURE__ */ Je(Xfe, [["render", Jfe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option.vue"]]);
const V1 = 11, $F = 2, Zfe = /* @__PURE__ */ le({
  name: "ElSelectDropdown",
  componentName: "ElSelectDropdown",
  setup() {
    const e = ze(hh), t = Ve("select"), n = O(() => e.props.popperClass), o = O(() => e.props.multiple), l = O(() => e.props.fitInputWidth), r = /* @__PURE__ */ H("");
    function a() {
      var i;
      const s = (i = e.selectRef) == null ? void 0 : i.offsetWidth;
      s ? r.value = `${s - $F}px` : r.value = "";
    }
    return nt(() => {
      a(), Xn(e.selectRef, a);
    }), {
      ns: t,
      minWidth: r,
      popperClass: n,
      isMultiple: o,
      isFitInputWidth: l
    };
  }
});
function Qfe(e, t, n, o, l, r) {
  return G(), ue(
    "div",
    {
      class: X([e.ns.b("dropdown"), e.ns.is("multiple", e.isMultiple), e.popperClass]),
      style: gt({ [e.isFitInputWidth ? "width" : "minWidth"]: e.minWidth })
    },
    [
      e.$slots.header ? (G(), ue(
        "div",
        {
          key: 0,
          class: X(e.ns.be("dropdown", "header"))
        },
        [
          Oe(e.$slots, "header")
        ],
        2
      )) : Ie("v-if", !0),
      Oe(e.$slots, "default"),
      e.$slots.footer ? (G(), ue(
        "div",
        {
          key: 1,
          class: X(e.ns.be("dropdown", "footer"))
        },
        [
          Oe(e.$slots, "footer")
        ],
        2
      )) : Ie("v-if", !0)
    ],
    6
  );
}
var epe = /* @__PURE__ */ Je(Zfe, [["render", Qfe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select-dropdown.vue"]]);
const tpe = (e, t) => {
  const { t: n } = an(), o = So(), l = ml(), r = Ve("select"), a = Ve("input"), i = /* @__PURE__ */ kt({
    inputValue: "",
    options: /* @__PURE__ */ new Map(),
    cachedOptions: /* @__PURE__ */ new Map(),
    optionValues: [],
    selected: [],
    selectionWidth: 0,
    collapseItemWidth: 0,
    selectedLabel: "",
    hoveringIndex: -1,
    previousQuery: null,
    inputHovering: !1,
    menuVisibleOnFocus: !1,
    isBeforeHide: !1
  }), s = /* @__PURE__ */ H(), c = /* @__PURE__ */ H(), u = /* @__PURE__ */ H(), d = /* @__PURE__ */ H(), f = /* @__PURE__ */ H(), p = /* @__PURE__ */ H(), m = /* @__PURE__ */ H(), v = /* @__PURE__ */ H(), h = /* @__PURE__ */ H(), g = /* @__PURE__ */ H(), y = /* @__PURE__ */ H(), b = /* @__PURE__ */ H(!1), C = /* @__PURE__ */ H(), w = /* @__PURE__ */ H(!1), { form: x, formItem: E } = cl(), { inputId: I } = zr(e, {
    formItemContext: E
  }), { valueOnClear: T, isEmptyValue: P } = ih(e), {
    isComposing: k,
    handleCompositionStart: N,
    handleCompositionUpdate: R,
    handleCompositionEnd: z
  } = fh({
    afterComposition: (He) => tt(He)
  }), D = io(), { wrapperRef: F, isFocused: M, handleBlur: A } = Os(f, {
    disabled: D,
    afterFocus() {
      e.automaticDropdown && !b.value && (b.value = !0, i.menuVisibleOnFocus = !0);
    },
    beforeBlur(He) {
      var St, Xt;
      return ((St = u.value) == null ? void 0 : St.isFocusInsideContent(He)) || ((Xt = d.value) == null ? void 0 : Xt.isFocusInsideContent(He));
    },
    afterBlur() {
      var He;
      b.value = !1, i.menuVisibleOnFocus = !1, e.validateEvent && ((He = E == null ? void 0 : E.validate) == null || He.call(E, "blur").catch((St) => Gt(St)));
    }
  }), L = O(() => We(e.modelValue) ? e.modelValue.length > 0 : !P(e.modelValue)), B = O(() => {
    var He;
    return (He = x == null ? void 0 : x.statusIcon) != null ? He : !1;
  }), V = O(() => e.clearable && !D.value && L.value && (M.value || i.inputHovering)), j = O(
    () => e.remote && e.filterable && !e.remoteShowSuffix ? "" : e.suffixIcon
  ), W = O(
    () => r.is("reverse", !!(j.value && b.value))
  ), Y = O(() => (E == null ? void 0 : E.validateState) || ""), U = O(
    () => Y.value && D1[Y.value]
  ), te = O(() => e.remote ? e.debounce : 0), J = O(
    () => e.remote && !i.inputValue && i.options.size === 0
  ), re = O(() => e.loading ? e.loadingText || n("el.select.loading") : e.filterable && i.inputValue && i.options.size > 0 && oe.value === 0 ? e.noMatchText || n("el.select.noMatch") : i.options.size === 0 ? e.noDataText || n("el.select.noData") : null), oe = O(
    () => q.value.filter((He) => He.visible).length
  ), q = O(() => {
    const He = Array.from(i.options.values()), St = [];
    return i.optionValues.forEach((Xt) => {
      const Mn = He.findIndex((jn) => jn.value === Xt);
      Mn > -1 && St.push(He[Mn]);
    }), St.length >= He.length ? St : He;
  }), K = O(
    () => Array.from(i.cachedOptions.values())
  ), se = O(() => {
    const He = q.value.filter((St) => !St.created).some((St) => St.currentLabel === i.inputValue);
    return e.filterable && e.allowCreate && i.inputValue !== "" && !He;
  }), Z = () => {
    e.filterable && it(e.filterMethod) || e.filterable && e.remote && it(e.remoteMethod) || q.value.forEach((He) => {
      var St;
      (St = He.updateOption) == null || St.call(He, i.inputValue);
    });
  }, ee = Mo(), fe = O(
    () => ["small"].includes(ee.value) ? "small" : "default"
  ), me = O({
    get() {
      return b.value && (e.loading || !J.value || e.remote && !!o.empty) && (!w.value || !Ql(i.previousQuery));
    },
    set(He) {
      b.value = He;
    }
  }), ge = O(() => {
    if (e.multiple && !fn(e.modelValue))
      return ll(e.modelValue).length === 0 && !i.inputValue;
    const He = We(e.modelValue) ? e.modelValue[0] : e.modelValue;
    return e.filterable || fn(He) ? !i.inputValue : !0;
  }), he = O(() => {
    var He;
    const St = (He = e.placeholder) != null ? He : n("el.select.placeholder");
    return e.multiple || !L.value ? St : i.selectedLabel;
  }), $e = O(() => k0 ? null : "mouseenter");
  pe(
    () => e.modelValue,
    (He, St) => {
      e.multiple && e.filterable && !e.reserveKeyword && (i.inputValue = "", ne("")), ce(), !Jn(He, St) && e.validateEvent && (E == null || E.validate("change").catch((Xt) => Gt(Xt)));
    },
    {
      flush: "post",
      deep: !0
    }
  ), pe(
    () => b.value,
    (He) => {
      He ? ne(i.inputValue) : (i.inputValue = "", i.previousQuery = null, i.isBeforeHide = !0);
    }
  ), pe(
    () => i.options.entries(),
    () => {
      Sn && (ce(), e.defaultFirstOption && (e.filterable || e.remote) && oe.value && ae());
    },
    {
      flush: "post"
    }
  ), pe([() => i.hoveringIndex, q], ([He]) => {
    mt(He) && He > -1 ? C.value = q.value[He] || {} : C.value = {}, q.value.forEach((St) => {
      St.hover = C.value === St;
    });
  }), Ot(() => {
    i.isBeforeHide || Z();
  });
  const ne = (He) => {
    i.previousQuery === He || k.value || (i.previousQuery = He, e.filterable && it(e.filterMethod) ? e.filterMethod(He) : e.filterable && e.remote && it(e.remoteMethod) && e.remoteMethod(He), e.defaultFirstOption && (e.filterable || e.remote) && oe.value ? Ke(ae) : Ke(Te));
  }, ae = () => {
    const He = q.value.filter(
      (jn) => jn.visible && !jn.disabled && !jn.states.groupDisabled
    ), St = He.find((jn) => jn.created), Xt = He[0], Mn = q.value.map((jn) => jn.value);
    i.hoveringIndex = Ze(
      Mn,
      St || Xt
    );
  }, ce = () => {
    if (e.multiple)
      i.selectedLabel = "";
    else {
      const St = We(e.modelValue) ? e.modelValue[0] : e.modelValue, Xt = xe(St);
      i.selectedLabel = Xt.currentLabel, i.selected = [Xt];
      return;
    }
    const He = [];
    fn(e.modelValue) || ll(e.modelValue).forEach((St) => {
      He.push(xe(St));
    }), i.selected = He;
  }, xe = (He) => {
    let St;
    const Xt = Gv(He);
    for (let so = i.cachedOptions.size - 1; so >= 0; so--) {
      const xo = K.value[so];
      if (Xt ? Oo(xo.value, e.valueKey) === Oo(He, e.valueKey) : xo.value === He) {
        St = {
          index: q.value.filter((wr) => !wr.created).indexOf(xo),
          value: He,
          currentLabel: xo.currentLabel,
          get isDisabled() {
            return xo.isDisabled;
          }
        };
        break;
      }
    }
    if (St)
      return St;
    const Mn = Xt ? He.label : He != null ? He : "";
    return {
      index: -1,
      value: He,
      currentLabel: Mn
    };
  }, Te = () => {
    const He = i.selected.length;
    if (He > 0) {
      const St = i.selected[He - 1];
      i.hoveringIndex = q.value.findIndex(
        (Xt) => Gn(St) === Gn(Xt)
      );
    } else
      i.hoveringIndex = -1;
  }, Se = () => {
    i.selectionWidth = Number.parseFloat(
      window.getComputedStyle(c.value).width
    );
  }, be = () => {
    i.collapseItemWidth = g.value.getBoundingClientRect().width;
  }, ie = () => {
    var He, St;
    (St = (He = u.value) == null ? void 0 : He.updatePopper) == null || St.call(He);
  }, we = () => {
    var He, St;
    (St = (He = d.value) == null ? void 0 : He.updatePopper) == null || St.call(He);
  }, Ne = () => {
    i.inputValue.length > 0 && !b.value && (b.value = !0), ne(i.inputValue);
  }, tt = (He) => {
    if (i.inputValue = He.target.value, e.remote)
      w.value = !0, Pe();
    else
      return Ne();
  }, Pe = lh(() => {
    Ne(), w.value = !1;
  }, te), Re = (He) => {
    Jn(e.modelValue, He) || t(en, He);
  }, Le = (He) => ZB(He, (St) => {
    const Xt = i.cachedOptions.get(St);
    return !(Xt != null && Xt.disabled) && !(Xt != null && Xt.states.groupDisabled);
  }), Ue = (He) => {
    const St = Nn(He);
    if (e.multiple && St !== Ye.delete && He.target.value.length <= 0) {
      const Xt = ll(e.modelValue).slice(), Mn = Le(Xt);
      if (Mn < 0)
        return;
      const jn = Xt[Mn];
      Xt.splice(Mn, 1), t(It, Xt), Re(Xt), t("remove-tag", jn);
    }
  }, Ae = (He, St) => {
    const Xt = i.selected.indexOf(St);
    if (Xt > -1 && !D.value) {
      const Mn = ll(e.modelValue).slice();
      Mn.splice(Xt, 1), t(It, Mn), Re(Mn), t("remove-tag", St.value);
    }
    He.stopPropagation(), lt();
  }, De = (He) => {
    He.stopPropagation();
    const St = e.multiple ? [] : T.value;
    if (e.multiple)
      for (const Xt of i.selected)
        Xt.isDisabled && St.push(Xt.value);
    t(It, St), Re(St), i.hoveringIndex = -1, b.value = !1, t("clear"), lt();
  }, _e = (He) => {
    var St;
    if (e.multiple) {
      const Xt = ll((St = e.modelValue) != null ? St : []).slice(), Mn = Ze(Xt, He);
      Mn > -1 ? Xt.splice(Mn, 1) : (e.multipleLimit <= 0 || Xt.length < e.multipleLimit) && Xt.push(He.value), t(It, Xt), Re(Xt), He.created && ne(""), e.filterable && !e.reserveKeyword && (i.inputValue = "");
    } else
      !Jn(e.modelValue, He.value) && t(It, He.value), Re(He.value), b.value = !1;
    lt(), !b.value && Ke(() => {
      dt(He);
    });
  }, Ze = (He, St) => fn(St) ? -1 : Mt(St.value) ? He.findIndex((Xt) => Jn(Oo(Xt, e.valueKey), Gn(St))) : He.indexOf(St.value), dt = (He) => {
    var St, Xt, Mn, jn, so;
    const xo = We(He) ? He[He.length - 1] : He;
    let Ao = null;
    if (!wo(xo == null ? void 0 : xo.value)) {
      const wr = q.value.filter(
        (Ts) => Ts.value === xo.value
      );
      wr.length > 0 && (Ao = wr[0].$el);
    }
    if (u.value && Ao) {
      const wr = (jn = (Mn = (Xt = (St = u.value) == null ? void 0 : St.popperRef) == null ? void 0 : Xt.contentRef) == null ? void 0 : Mn.querySelector) == null ? void 0 : jn.call(
        Mn,
        `.${r.be("dropdown", "wrap")}`
      );
      wr && NO(wr, Ao);
    }
    (so = y.value) == null || so.handleScroll();
  }, Tt = (He) => {
    i.options.set(He.value, He), i.cachedOptions.set(He.value, He);
  }, jt = (He, St) => {
    i.options.get(He) === St && i.options.delete(He);
  }, Qt = O(() => {
    var He, St;
    return (St = (He = u.value) == null ? void 0 : He.popperRef) == null ? void 0 : St.contentRef;
  }), je = () => {
    i.isBeforeHide = !1, Ke(() => {
      var He;
      (He = y.value) == null || He.update(), dt(i.selected);
    });
  }, lt = () => {
    var He;
    (He = f.value) == null || He.focus();
  }, Ct = () => {
    var He;
    if (b.value) {
      b.value = !1, Ke(() => {
        var St;
        return (St = f.value) == null ? void 0 : St.blur();
      });
      return;
    }
    (He = f.value) == null || He.blur();
  }, vn = (He) => {
    De(He);
  }, tn = (He) => {
    if (b.value = !1, M.value) {
      const St = new FocusEvent("blur", He);
      Ke(() => A(St));
    }
  }, ct = () => {
    i.inputValue.length > 0 ? i.inputValue = "" : b.value = !1;
  }, pt = (He) => {
    var St;
    D.value || e.filterable && b.value && He && !((St = m.value) != null && St.contains(He.target)) || (k0 && (i.inputHovering = !0), i.menuVisibleOnFocus ? i.menuVisibleOnFocus = !1 : b.value = !b.value);
  }, Lt = () => {
    if (!b.value)
      pt();
    else {
      const He = q.value[i.hoveringIndex];
      He && !He.isDisabled && _e(He);
    }
  }, Gn = (He) => Mt(He.value) ? Oo(He.value, e.valueKey) : He.value, To = O(
    () => q.value.filter((He) => He.visible).every((He) => He.isDisabled)
  ), st = O(() => e.multiple ? e.collapseTags ? i.selected.slice(0, e.maxCollapseTags) : i.selected : []), Yt = O(() => e.multiple ? e.collapseTags ? i.selected.slice(e.maxCollapseTags) : [] : []), Kt = (He) => {
    if (!b.value) {
      b.value = !0;
      return;
    }
    if (!(i.options.size === 0 || oe.value === 0 || k.value) && !To.value) {
      He === "next" ? (i.hoveringIndex++, i.hoveringIndex === i.options.size && (i.hoveringIndex = 0)) : He === "prev" && (i.hoveringIndex--, i.hoveringIndex < 0 && (i.hoveringIndex = i.options.size - 1));
      const St = q.value[i.hoveringIndex];
      (St.isDisabled || !St.visible) && Kt(He), Ke(() => dt(C.value));
    }
  }, Ln = (He, St, Xt, Mn) => {
    for (let jn = St; jn >= 0 && jn < Mn; jn += Xt) {
      const so = He[jn];
      if (!(so != null && so.isDisabled) && (so != null && so.visible))
        return jn;
    }
    return null;
  }, Zn = (He, St) => {
    var Xt;
    const Mn = i.options.size;
    if (Mn === 0)
      return;
    const jn = T1(He, 0, Mn - 1), so = q.value, xo = St === "up" ? -1 : 1, Ao = (Xt = Ln(so, jn, xo, Mn)) != null ? Xt : Ln(so, jn - xo, -xo, Mn);
    Ao != null && (i.hoveringIndex = Ao, Ke(() => dt(C.value)));
  }, ho = (He) => {
    const St = Nn(He);
    let Xt = !0;
    switch (St) {
      case Ye.up:
        Kt("prev");
        break;
      case Ye.down:
        Kt("next");
        break;
      case Ye.enter:
      case Ye.numpadEnter:
        k.value || Lt();
        break;
      case Ye.esc:
        ct();
        break;
      case Ye.backspace:
        Xt = !1, Ue(He);
        return;
      case Ye.home:
        if (!b.value)
          return;
        Zn(0, "down");
        break;
      case Ye.end:
        if (!b.value)
          return;
        Zn(i.options.size - 1, "up");
        break;
      case Ye.pageUp:
        if (!b.value)
          return;
        Zn(i.hoveringIndex - 10, "up");
        break;
      case Ye.pageDown:
        if (!b.value)
          return;
        Zn(i.hoveringIndex + 10, "down");
        break;
      default:
        Xt = !1;
        break;
    }
    Xt && (He.preventDefault(), He.stopPropagation());
  }, ul = () => {
    if (!c.value)
      return 0;
    const He = window.getComputedStyle(c.value);
    return Number.parseFloat(He.gap || "6px");
  }, zo = O(() => {
    const He = ul(), St = e.filterable ? He + V1 : 0;
    return { maxWidth: `${g.value && e.maxCollapseTags === 1 ? i.selectionWidth - i.collapseItemWidth - He - St : i.selectionWidth - St}px` };
  }), ir = O(() => ({ maxWidth: `${i.selectionWidth}px` })), hl = (He) => {
    t("popup-scroll", He);
  };
  Xn(c, Se), Xn(F, ie), Xn(h, we), Xn(g, be);
  let Go;
  return pe(
    () => me.value,
    (He) => {
      He ? Go = Xn(v, ie).stop : (Go == null || Go(), Go = void 0), t("visible-change", He);
    }
  ), nt(() => {
    ce();
  }), {
    inputId: I,
    contentId: l,
    nsSelect: r,
    nsInput: a,
    states: i,
    isFocused: M,
    expanded: b,
    optionsArray: q,
    hoverOption: C,
    selectSize: ee,
    filteredOptionsCount: oe,
    updateTooltip: ie,
    updateTagTooltip: we,
    debouncedOnInputChange: Pe,
    onInput: tt,
    deletePrevTag: Ue,
    deleteTag: Ae,
    deleteSelected: De,
    handleOptionSelect: _e,
    scrollToOption: dt,
    hasModelValue: L,
    shouldShowPlaceholder: ge,
    currentPlaceholder: he,
    mouseEnterEventName: $e,
    needStatusIcon: B,
    showClearBtn: V,
    iconComponent: j,
    iconReverse: W,
    validateState: Y,
    validateIcon: U,
    showNewOption: se,
    updateOptions: Z,
    collapseTagSize: fe,
    setSelected: ce,
    selectDisabled: D,
    emptyText: re,
    handleCompositionStart: N,
    handleCompositionUpdate: R,
    handleCompositionEnd: z,
    handleKeydown: ho,
    onOptionCreate: Tt,
    onOptionDestroy: jt,
    handleMenuEnter: je,
    focus: lt,
    blur: Ct,
    handleClearClick: vn,
    handleClickOutside: tn,
    handleEsc: ct,
    toggleMenu: pt,
    selectOption: Lt,
    getValueKey: Gn,
    navigateOptions: Kt,
    dropdownMenuVisible: me,
    showTagList: st,
    collapseTagList: Yt,
    popupScroll: hl,
    getOption: xe,
    tagStyle: zo,
    collapseTagStyle: ir,
    popperRef: Qt,
    inputRef: f,
    tooltipRef: u,
    tagTooltipRef: d,
    prefixRef: p,
    suffixRef: m,
    selectRef: s,
    wrapperRef: F,
    selectionRef: c,
    scrollbarRef: y,
    menuRef: v,
    tagMenuRef: h,
    collapseItemRef: g
  };
};
var npe = /* @__PURE__ */ le({
  name: "ElOptions",
  setup(e, { slots: t }) {
    const n = ze(hh);
    let o = [];
    return () => {
      var l, r;
      const a = (l = t.default) == null ? void 0 : l.call(t), i = [];
      function s(c) {
        We(c) && c.forEach((u) => {
          var d, f, p, m;
          const v = (d = (u == null ? void 0 : u.type) || {}) == null ? void 0 : d.name;
          v === "ElOptionGroup" ? s(
            !rt(u.children) && !We(u.children) && it((f = u.children) == null ? void 0 : f.default) ? (p = u.children) == null ? void 0 : p.default() : u.children
          ) : v === "ElOption" ? i.push((m = u.props) == null ? void 0 : m.value) : We(u.children) && s(u.children);
        });
      }
      return a.length && s((r = a[0]) == null ? void 0 : r.children), Jn(i, o) || (o = i, n && (n.states.optionValues = i)), a;
    };
  }
});
const xF = Xe(Be(Be({
  name: String,
  id: String,
  modelValue: {
    type: ye([
      Array,
      String,
      Number,
      Boolean,
      Object
    ]),
    default: void 0
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  automaticDropdown: Boolean,
  size: Bo,
  effect: {
    type: ye(String),
    default: "light"
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  clearable: Boolean,
  filterable: Boolean,
  allowCreate: Boolean,
  loading: Boolean,
  popperClass: {
    type: String,
    default: ""
  },
  popperStyle: {
    type: ye([String, Object])
  },
  popperOptions: {
    type: ye(Object),
    default: () => ({})
  },
  remote: Boolean,
  debounce: {
    type: Number,
    default: 300
  },
  loadingText: String,
  noMatchText: String,
  noDataText: String,
  remoteMethod: {
    type: ye(Function)
  },
  filterMethod: {
    type: ye(Function)
  },
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  placeholder: {
    type: String
  },
  defaultFirstOption: Boolean,
  reserveKeyword: {
    type: Boolean,
    default: !0
  },
  valueKey: {
    type: String,
    default: "value"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  teleported: In.teleported,
  persistent: {
    type: Boolean,
    default: !0
  },
  clearIcon: {
    type: Pn,
    default: Es
  },
  fitInputWidth: Boolean,
  suffixIcon: {
    type: Pn,
    default: Ni
  },
  tagType: vt(Be({}, gs.type), { default: "info" }),
  tagEffect: vt(Be({}, gs.effect), { default: "light" }),
  validateEvent: {
    type: Boolean,
    default: !0
  },
  remoteShowSuffix: Boolean,
  showArrow: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: ye(String),
    values: Mi,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: ye(Array),
    default: ["bottom-start", "top-start", "right", "left"]
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  appendTo: In.appendTo,
  options: {
    type: ye(Array)
  },
  props: {
    type: ye(Object),
    default: () => A0
  }
}, ad), zl(["ariaLabel"])));
R7.scroll;
const ope = /* @__PURE__ */ le({
  name: "ElOptionGroup",
  componentName: "ElOptionGroup",
  props: {
    label: String,
    disabled: Boolean
  },
  setup(e) {
    const t = Ve("select"), n = /* @__PURE__ */ H(), o = xt(), l = /* @__PURE__ */ H([]);
    at(
      wF,
      /* @__PURE__ */ kt(Be({}, /* @__PURE__ */ to(e)))
    );
    const r = O(
      () => l.value.some((c) => c.visible === !0)
    ), a = (c) => {
      var u;
      return c.type.name === "ElOption" && !!((u = c.component) != null && u.proxy);
    }, i = (c) => {
      const u = ll(c), d = [];
      return u.forEach((f) => {
        var p;
        dn(f) && (a(f) ? d.push(f.component.proxy) : We(f.children) && f.children.length ? d.push(...i(f.children)) : (p = f.component) != null && p.subTree && d.push(...i(f.component.subTree)));
      }), d;
    }, s = () => {
      l.value = i(o.subTree);
    };
    return nt(() => {
      s();
    }), rh(n, s, {
      attributes: !0,
      subtree: !0,
      childList: !0
    }), {
      groupRef: n,
      visible: r,
      ns: t
    };
  }
});
function lpe(e, t, n, o, l, r) {
  return _t((G(), ue(
    "ul",
    {
      ref: "groupRef",
      class: X(e.ns.be("group", "wrap"))
    },
    [
      ve(
        "li",
        {
          class: X(e.ns.be("group", "title"))
        },
        qe(e.label),
        3
      ),
      ve("li", null, [
        ve(
          "ul",
          {
            class: X(e.ns.b("group"))
          },
          [
            Oe(e.$slots, "default")
          ],
          2
        )
      ])
    ],
    2
  )), [
    [Jt, e.visible]
  ]);
}
var e_ = /* @__PURE__ */ Je(ope, [["render", lpe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/option-group.vue"]]);
const Fs = /* @__PURE__ */ new Map();
if (Sn) {
  let e;
  document.addEventListener("mousedown", (t) => e = t), document.addEventListener("mouseup", (t) => {
    if (e) {
      for (const n of Fs.values())
        for (const { documentHandler: o } of n)
          o(t, e);
      e = void 0;
    }
  });
}
function J3(e, t) {
  let n = [];
  return We(t.arg) ? n = t.arg : tr(t.arg) && n.push(t.arg), function(o, l) {
    const r = t.instance.popperRef, a = o.target, i = l == null ? void 0 : l.target, s = !t || !t.instance, c = !a || !i, u = e.contains(a) || e.contains(i), d = e === a, f = n.length && n.some((m) => m == null ? void 0 : m.contains(a)) || n.length && n.includes(i), p = r && (r.contains(a) || r.contains(i));
    s || c || u || d || f || p || t.value(o, l);
  };
}
const Cc = {
  beforeMount(e, t) {
    Fs.has(e) || Fs.set(e, []), Fs.get(e).push({
      documentHandler: J3(e, t),
      bindingFn: t.value
    });
  },
  updated(e, t) {
    Fs.has(e) || Fs.set(e, []);
    const n = Fs.get(e), o = n.findIndex(
      (r) => r.bindingFn === t.oldValue
    ), l = {
      documentHandler: J3(e, t),
      bindingFn: t.value
    };
    o >= 0 ? n.splice(o, 1, l) : n.push(l);
  },
  unmounted(e) {
    Fs.delete(e);
  }
};
function t_() {
  const e = /* @__PURE__ */ Ce(), t = /* @__PURE__ */ H(0), n = O(() => ({
    minWidth: `${Math.max(t.value, V1)}px`
  }));
  return Xn(e, () => {
    var l, r;
    t.value = (r = (l = e.value) == null ? void 0 : l.getBoundingClientRect().width) != null ? r : 0;
  }), {
    calculatorRef: e,
    calculatorWidth: t,
    inputStyle: n
  };
}
const Z3 = "ElSelect", fm = /* @__PURE__ */ new WeakMap(), rpe = (e) => (...t) => {
  var n, o;
  const l = t[0];
  if (!l || l.includes(
    'Slot "default" invoked outside of the render function'
  ) && ((n = t[2]) != null && n.includes("ElTreeSelect")))
    return;
  const r = (o = fm.get(e)) == null ? void 0 : o.originalWarnHandler;
  if (r) {
    r(...t);
    return;
  }
  console.warn(...t);
}, ape = (e) => {
  let t = fm.get(e);
  return t || (t = {
    originalWarnHandler: e.config.warnHandler,
    handler: rpe(e),
    count: 0
  }, fm.set(e, t)), t;
}, ipe = /* @__PURE__ */ le({
  name: Z3,
  componentName: Z3,
  components: {
    ElSelectMenu: epe,
    ElOption: QO,
    ElOptions: npe,
    ElOptionGroup: e_,
    ElTag: fs,
    ElScrollbar: Ba,
    ElTooltip: al,
    ElIcon: ut
  },
  directives: { ClickOutside: Cc },
  props: xF,
  emits: [
    It,
    en,
    "remove-tag",
    "clear",
    "visible-change",
    "focus",
    "blur",
    "popup-scroll"
  ],
  setup(e, { emit: t, slots: n }) {
    const o = xt(), l = ape(o.appContext);
    l.count += 1, o.appContext.config.warnHandler = l.handler;
    const r = O(() => {
      const { modelValue: y, multiple: b } = e, C = b ? [] : void 0;
      return We(y) ? b ? y : C : b ? C : y;
    }), a = /* @__PURE__ */ kt(vt(Be({}, /* @__PURE__ */ to(e)), {
      modelValue: r
    })), i = tpe(a, t), { calculatorRef: s, inputStyle: c } = t_(), { getLabel: u, getValue: d, getOptions: f, getDisabled: p } = mh(e), m = (y) => ({
      label: u(y),
      value: d(y),
      disabled: p(y)
    }), v = (y) => y.reduce((b, C) => (b.push(C), C.children && C.children.length > 0 && b.push(...v(C.children)), b), []), h = (y) => {
      Nr(y || []).forEach((C) => {
        var w;
        if (Mt(C) && (C.type.name === "ElOption" || C.type.name === "ElTree")) {
          const x = C.type.name;
          if (x === "ElTree") {
            const E = ((w = C.props) == null ? void 0 : w.data) || [];
            v(E).forEach((T) => {
              T.currentLabel = T.label || (Mt(T.value) ? "" : T.value), i.onOptionCreate(T);
            });
          } else if (x === "ElOption") {
            const E = Be({}, C.props);
            E.currentLabel = E.label || (Mt(E.value) ? "" : E.value), i.onOptionCreate(E);
          }
        }
      });
    };
    pe(
      () => {
        var y;
        return [(y = n.default) == null ? void 0 : y.call(n), r.value];
      },
      () => {
        var y;
        e.persistent || i.expanded.value || (i.states.options.clear(), h((y = n.default) == null ? void 0 : y.call(n)));
      },
      {
        immediate: !0
      }
    ), at(
      hh,
      /* @__PURE__ */ kt({
        props: a,
        states: i.states,
        selectRef: i.selectRef,
        optionsArray: i.optionsArray,
        setSelected: i.setSelected,
        handleOptionSelect: i.handleOptionSelect,
        onOptionCreate: i.onOptionCreate,
        onOptionDestroy: i.onOptionDestroy
      })
    );
    const g = O(() => e.multiple ? i.states.selected.map((y) => y.currentLabel) : i.states.selectedLabel);
    return yt(() => {
      const y = fm.get(o.appContext);
      y && (y.count -= 1, y.count <= 0 && (o.appContext.config.warnHandler = y.originalWarnHandler, fm.delete(o.appContext)));
    }), vt(Be({}, i), {
      modelValue: r,
      selectedLabel: g,
      calculatorRef: s,
      inputStyle: c,
      getLabel: u,
      getValue: d,
      getOptions: f,
      getDisabled: p,
      getOptionProps: m
    });
  }
}), spe = ["id", "name", "disabled", "autocomplete", "tabindex", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label"], cpe = ["textContent"], upe = { key: 1 };
function dpe(e, t, n, o, l, r) {
  const a = yn("el-tag"), i = yn("el-tooltip"), s = yn("el-icon"), c = yn("el-option"), u = yn("el-option-group"), d = yn("el-options"), f = yn("el-scrollbar"), p = yn("el-select-menu"), m = s1("click-outside");
  return _t((G(), ue(
    "div",
    Ut({
      ref: "selectRef",
      class: [e.nsSelect.b(), e.nsSelect.m(e.selectSize)]
    }, {
      [Yi(e.mouseEnterEventName)]: t[11] || (t[11] = (v) => e.states.inputHovering = !0)
    }, {
      onMouseleave: t[12] || (t[12] = (v) => e.states.inputHovering = !1)
    }),
    [
      $(i, {
        ref: "tooltipRef",
        visible: e.dropdownMenuVisible,
        placement: e.placement,
        teleported: e.teleported,
        "popper-class": [e.nsSelect.e("popper"), e.popperClass],
        "popper-style": e.popperStyle,
        "popper-options": e.popperOptions,
        "fallback-placements": e.fallbackPlacements,
        effect: e.effect,
        pure: "",
        trigger: "click",
        transition: `${e.nsSelect.namespace.value}-zoom-in-top`,
        "stop-popper-mouse-event": !1,
        "gpu-acceleration": !1,
        persistent: e.persistent,
        "append-to": e.appendTo,
        "show-arrow": e.showArrow,
        offset: e.offset,
        onBeforeShow: e.handleMenuEnter,
        onHide: t[10] || (t[10] = (v) => e.states.isBeforeHide = !1)
      }, {
        default: Ee(() => {
          var v;
          return [
            ve(
              "div",
              {
                ref: "wrapperRef",
                class: X([
                  e.nsSelect.e("wrapper"),
                  e.nsSelect.is("focused", e.isFocused),
                  e.nsSelect.is("hovering", e.states.inputHovering),
                  e.nsSelect.is("filterable", e.filterable),
                  e.nsSelect.is("disabled", e.selectDisabled)
                ]),
                onClick: t[7] || (t[7] = Et((...h) => e.toggleMenu && e.toggleMenu(...h), ["prevent"]))
              },
              [
                e.$slots.prefix ? (G(), ue(
                  "div",
                  {
                    key: 0,
                    ref: "prefixRef",
                    class: X(e.nsSelect.e("prefix"))
                  },
                  [
                    Oe(e.$slots, "prefix")
                  ],
                  2
                )) : Ie("v-if", !0),
                ve(
                  "div",
                  {
                    ref: "selectionRef",
                    class: X([
                      e.nsSelect.e("selection"),
                      e.nsSelect.is(
                        "near",
                        e.multiple && !e.$slots.prefix && !!e.states.selected.length
                      )
                    ])
                  },
                  [
                    e.multiple ? Oe(e.$slots, "tag", {
                      key: 0,
                      data: e.states.selected,
                      deleteTag: e.deleteTag,
                      selectDisabled: e.selectDisabled
                    }, () => [
                      (G(!0), ue(
                        Ge,
                        null,
                        on(e.showTagList, (h) => (G(), ue(
                          "div",
                          {
                            key: e.getValueKey(h),
                            class: X(e.nsSelect.e("selected-item"))
                          },
                          [
                            $(a, {
                              closable: !e.selectDisabled && !h.isDisabled,
                              size: e.collapseTagSize,
                              type: e.tagType,
                              effect: e.tagEffect,
                              "disable-transitions": "",
                              style: gt(e.tagStyle),
                              onClose: (g) => e.deleteTag(g, h)
                            }, {
                              default: Ee(() => [
                                ve(
                                  "span",
                                  {
                                    class: X(e.nsSelect.e("tags-text"))
                                  },
                                  [
                                    Oe(e.$slots, "label", {
                                      index: h.index,
                                      label: h.currentLabel,
                                      value: h.value
                                    }, () => [
                                      Ft(
                                        qe(h.currentLabel),
                                        1
                                      )
                                    ])
                                  ],
                                  2
                                )
                              ]),
                              _: 2
                            }, 1032, ["closable", "size", "type", "effect", "style", "onClose"])
                          ],
                          2
                        ))),
                        128
                      )),
                      e.collapseTags && e.states.selected.length > e.maxCollapseTags ? (G(), Me(i, {
                        key: 0,
                        ref: "tagTooltipRef",
                        disabled: e.dropdownMenuVisible || !e.collapseTagsTooltip,
                        "fallback-placements": ["bottom", "top", "right", "left"],
                        effect: e.effect,
                        placement: "bottom",
                        "popper-class": e.popperClass,
                        "popper-style": e.popperStyle,
                        teleported: e.teleported,
                        "popper-options": e.popperOptions
                      }, {
                        default: Ee(() => [
                          ve(
                            "div",
                            {
                              ref: "collapseItemRef",
                              class: X(e.nsSelect.e("selected-item"))
                            },
                            [
                              $(a, {
                                closable: !1,
                                size: e.collapseTagSize,
                                type: e.tagType,
                                effect: e.tagEffect,
                                "disable-transitions": "",
                                style: gt(e.collapseTagStyle)
                              }, {
                                default: Ee(() => [
                                  ve(
                                    "span",
                                    {
                                      class: X(e.nsSelect.e("tags-text"))
                                    },
                                    " + " + qe(e.states.selected.length - e.maxCollapseTags),
                                    3
                                  )
                                ]),
                                _: 1
                              }, 8, ["size", "type", "effect", "style"])
                            ],
                            2
                          )
                        ]),
                        content: Ee(() => [
                          ve(
                            "div",
                            {
                              ref: "tagMenuRef",
                              class: X(e.nsSelect.e("selection"))
                            },
                            [
                              (G(!0), ue(
                                Ge,
                                null,
                                on(e.collapseTagList, (h) => (G(), ue(
                                  "div",
                                  {
                                    key: e.getValueKey(h),
                                    class: X(e.nsSelect.e("selected-item"))
                                  },
                                  [
                                    $(a, {
                                      class: "in-tooltip",
                                      closable: !e.selectDisabled && !h.isDisabled,
                                      size: e.collapseTagSize,
                                      type: e.tagType,
                                      effect: e.tagEffect,
                                      "disable-transitions": "",
                                      onClose: (g) => e.deleteTag(g, h)
                                    }, {
                                      default: Ee(() => [
                                        ve(
                                          "span",
                                          {
                                            class: X(e.nsSelect.e("tags-text"))
                                          },
                                          [
                                            Oe(e.$slots, "label", {
                                              index: h.index,
                                              label: h.currentLabel,
                                              value: h.value
                                            }, () => [
                                              Ft(
                                                qe(h.currentLabel),
                                                1
                                              )
                                            ])
                                          ],
                                          2
                                        )
                                      ]),
                                      _: 2
                                    }, 1032, ["closable", "size", "type", "effect", "onClose"])
                                  ],
                                  2
                                ))),
                                128
                              ))
                            ],
                            2
                          )
                        ]),
                        _: 3
                      }, 8, ["disabled", "effect", "popper-class", "popper-style", "teleported", "popper-options"])) : Ie("v-if", !0)
                    ]) : Ie("v-if", !0),
                    ve(
                      "div",
                      {
                        class: X([
                          e.nsSelect.e("selected-item"),
                          e.nsSelect.e("input-wrapper"),
                          e.nsSelect.is("hidden", !e.filterable || e.selectDisabled)
                        ])
                      },
                      [
                        _t(ve("input", {
                          id: e.inputId,
                          ref: "inputRef",
                          "onUpdate:modelValue": t[0] || (t[0] = (h) => e.states.inputValue = h),
                          type: "text",
                          name: e.name,
                          class: X([e.nsSelect.e("input"), e.nsSelect.is(e.selectSize)]),
                          disabled: e.selectDisabled,
                          autocomplete: e.autocomplete,
                          style: gt(e.inputStyle),
                          tabindex: e.tabindex,
                          role: "combobox",
                          readonly: !e.filterable,
                          spellcheck: "false",
                          "aria-activedescendant": ((v = e.hoverOption) == null ? void 0 : v.id) || "",
                          "aria-controls": e.contentId,
                          "aria-expanded": e.dropdownMenuVisible,
                          "aria-label": e.ariaLabel,
                          "aria-autocomplete": "none",
                          "aria-haspopup": "listbox",
                          onKeydown: t[1] || (t[1] = (...h) => e.handleKeydown && e.handleKeydown(...h)),
                          onCompositionstart: t[2] || (t[2] = (...h) => e.handleCompositionStart && e.handleCompositionStart(...h)),
                          onCompositionupdate: t[3] || (t[3] = (...h) => e.handleCompositionUpdate && e.handleCompositionUpdate(...h)),
                          onCompositionend: t[4] || (t[4] = (...h) => e.handleCompositionEnd && e.handleCompositionEnd(...h)),
                          onInput: t[5] || (t[5] = (...h) => e.onInput && e.onInput(...h)),
                          onClick: t[6] || (t[6] = Et((...h) => e.toggleMenu && e.toggleMenu(...h), ["stop"]))
                        }, null, 46, spe), [
                          [d1, e.states.inputValue]
                        ]),
                        e.filterable ? (G(), ue("span", {
                          key: 0,
                          ref: "calculatorRef",
                          "aria-hidden": "true",
                          class: X(e.nsSelect.e("input-calculator")),
                          textContent: qe(e.states.inputValue)
                        }, null, 10, cpe)) : Ie("v-if", !0)
                      ],
                      2
                    ),
                    e.shouldShowPlaceholder ? (G(), ue(
                      "div",
                      {
                        key: 1,
                        class: X([
                          e.nsSelect.e("selected-item"),
                          e.nsSelect.e("placeholder"),
                          e.nsSelect.is(
                            "transparent",
                            !e.hasModelValue || e.expanded && !e.states.inputValue
                          )
                        ])
                      },
                      [
                        e.hasModelValue ? Oe(e.$slots, "label", {
                          key: 0,
                          index: e.getOption(e.modelValue).index,
                          label: e.currentPlaceholder,
                          value: e.modelValue
                        }, () => [
                          ve(
                            "span",
                            null,
                            qe(e.currentPlaceholder),
                            1
                          )
                        ]) : (G(), ue(
                          "span",
                          upe,
                          qe(e.currentPlaceholder),
                          1
                        ))
                      ],
                      2
                    )) : Ie("v-if", !0)
                  ],
                  2
                ),
                ve(
                  "div",
                  {
                    ref: "suffixRef",
                    class: X(e.nsSelect.e("suffix"))
                  },
                  [
                    e.iconComponent && !e.showClearBtn ? (G(), Me(s, {
                      key: 0,
                      class: X([e.nsSelect.e("caret"), e.nsSelect.e("icon"), e.iconReverse])
                    }, {
                      default: Ee(() => [
                        (G(), Me(Ht(e.iconComponent)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : Ie("v-if", !0),
                    e.showClearBtn && e.clearIcon ? (G(), Me(s, {
                      key: 1,
                      class: X([
                        e.nsSelect.e("caret"),
                        e.nsSelect.e("icon"),
                        e.nsSelect.e("clear")
                      ]),
                      onClick: e.handleClearClick
                    }, {
                      default: Ee(() => [
                        (G(), Me(Ht(e.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : Ie("v-if", !0),
                    e.validateState && e.validateIcon && e.needStatusIcon ? (G(), Me(s, {
                      key: 2,
                      class: X([
                        e.nsInput.e("icon"),
                        e.nsInput.e("validateIcon"),
                        e.nsInput.is("loading", e.validateState === "validating")
                      ])
                    }, {
                      default: Ee(() => [
                        (G(), Me(Ht(e.validateIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : Ie("v-if", !0)
                  ],
                  2
                )
              ],
              2
            )
          ];
        }),
        content: Ee(() => [
          $(
            p,
            { ref: "menuRef" },
            {
              default: Ee(() => [
                e.$slots.header ? (G(), ue(
                  "div",
                  {
                    key: 0,
                    class: X(e.nsSelect.be("dropdown", "header")),
                    onClick: t[8] || (t[8] = Et(() => {
                    }, ["stop"]))
                  },
                  [
                    Oe(e.$slots, "header")
                  ],
                  2
                )) : Ie("v-if", !0),
                _t($(f, {
                  id: e.contentId,
                  ref: "scrollbarRef",
                  tag: "ul",
                  "wrap-class": e.nsSelect.be("dropdown", "wrap"),
                  "view-class": e.nsSelect.be("dropdown", "list"),
                  class: X([e.nsSelect.is("empty", e.filteredOptionsCount === 0)]),
                  role: "listbox",
                  "aria-label": e.ariaLabel,
                  "aria-orientation": "vertical",
                  onScroll: e.popupScroll
                }, {
                  default: Ee(() => [
                    e.showNewOption ? (G(), Me(c, {
                      key: 0,
                      value: e.states.inputValue,
                      created: !0
                    }, null, 8, ["value"])) : Ie("v-if", !0),
                    $(d, null, {
                      default: Ee(() => [
                        Oe(e.$slots, "default", {}, () => [
                          (G(!0), ue(
                            Ge,
                            null,
                            on(e.options, (v, h) => {
                              var g;
                              return G(), ue(
                                Ge,
                                { key: h },
                                [
                                  (g = e.getOptions(v)) != null && g.length ? (G(), Me(u, {
                                    key: 0,
                                    label: e.getLabel(v),
                                    disabled: e.getDisabled(v)
                                  }, {
                                    default: Ee(() => [
                                      (G(!0), ue(
                                        Ge,
                                        null,
                                        on(e.getOptions(v), (y) => (G(), Me(
                                          c,
                                          Ut({
                                            key: e.getValue(y)
                                          }, { ref_for: !0 }, e.getOptionProps(y)),
                                          null,
                                          16
                                        ))),
                                        128
                                      ))
                                    ]),
                                    _: 2
                                  }, 1032, ["label", "disabled"])) : (G(), Me(
                                    c,
                                    Ut({
                                      key: 1,
                                      ref_for: !0
                                    }, e.getOptionProps(v)),
                                    null,
                                    16
                                  ))
                                ],
                                64
                              );
                            }),
                            128
                          ))
                        ])
                      ]),
                      _: 3
                    })
                  ]),
                  _: 3
                }, 8, ["id", "wrap-class", "view-class", "class", "aria-label", "onScroll"]), [
                  [Jt, e.states.options.size > 0 && !e.loading]
                ]),
                e.$slots.loading && e.loading ? (G(), ue(
                  "div",
                  {
                    key: 1,
                    class: X(e.nsSelect.be("dropdown", "loading"))
                  },
                  [
                    Oe(e.$slots, "loading")
                  ],
                  2
                )) : e.loading || e.filteredOptionsCount === 0 ? (G(), ue(
                  "div",
                  {
                    key: 2,
                    class: X(e.nsSelect.be("dropdown", "empty"))
                  },
                  [
                    Oe(e.$slots, "empty", {}, () => [
                      ve(
                        "span",
                        null,
                        qe(e.emptyText),
                        1
                      )
                    ])
                  ],
                  2
                )) : Ie("v-if", !0),
                e.$slots.footer ? (G(), ue(
                  "div",
                  {
                    key: 3,
                    class: X(e.nsSelect.be("dropdown", "footer")),
                    onClick: t[9] || (t[9] = Et(() => {
                    }, ["stop"]))
                  },
                  [
                    Oe(e.$slots, "footer")
                  ],
                  2
                )) : Ie("v-if", !0)
              ]),
              _: 3
            },
            512
          )
        ]),
        _: 3
      }, 8, ["visible", "placement", "teleported", "popper-class", "popper-style", "popper-options", "fallback-placements", "effect", "transition", "persistent", "append-to", "show-arrow", "offset", "onBeforeShow"])
    ],
    16
  )), [
    [m, e.handleClickOutside, e.popperRef]
  ]);
}
var fpe = /* @__PURE__ */ Je(ipe, [["render", dpe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select/src/select.vue"]]);
const wc = Dt(fpe, {
  Option: QO,
  OptionGroup: e_
}), R0 = oo(QO), ppe = oo(e_), vpe = Xe({
  date: {
    type: ye(Object),
    required: !0
  },
  formatter: {
    type: ye(Function)
  }
}), mpe = {
  "date-change": (e) => Mt(e) || rt(e)
}, hpe = /* @__PURE__ */ le({
  name: "SelectController",
  __name: "select-controller",
  props: vpe,
  emits: mpe,
  setup(e, { emit: t }) {
    const n = e, o = t, l = Ve("calendar-select"), { t: r, lang: a } = an(), i = Array.from({ length: 12 }, (m, v) => {
      const h = v + 1, g = it(n.formatter) ? n.formatter(h, "month") : h;
      return {
        value: h,
        label: g
      };
    }), s = O(() => n.date.year()), c = O(() => n.date.month() + 1), u = O(() => {
      const m = [];
      for (let v = -10; v < 10; v++) {
        const h = s.value + v;
        if (h > 0) {
          const g = it(n.formatter) ? n.formatter(h, "year") : h;
          m.push({ value: h, label: g });
        }
      }
      return m;
    }), d = (m) => {
      o(
        "date-change",
        wt(new Date(m, c.value - 1, 1)).locale(a.value)
      );
    }, f = (m) => {
      o(
        "date-change",
        wt(new Date(s.value, m - 1, 1)).locale(a.value)
      );
    }, p = () => {
      o("date-change", "today");
    };
    return (m, v) => (G(), ue(
      Ge,
      null,
      [
        $(S(wc), {
          "model-value": s.value,
          size: "small",
          class: X(S(l).e("year")),
          "validate-event": !1,
          options: u.value,
          onChange: d
        }, null, 8, ["model-value", "class", "options"]),
        $(S(wc), {
          "model-value": c.value,
          size: "small",
          class: X(S(l).e("month")),
          "validate-event": !1,
          options: S(i),
          onChange: f
        }, null, 8, ["model-value", "class", "options"]),
        $(S(Qo), {
          size: "small",
          onClick: p
        }, {
          default: Ee(() => [
            Ft(
              qe(S(r)("el.datepicker.today")),
              1
            )
          ]),
          _: 1
        })
      ],
      64
    ));
  }
});
var gpe = /* @__PURE__ */ Je(hpe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/select-controller.vue"]]);
const Q3 = "ElCalendar", bpe = /* @__PURE__ */ le({
  name: Q3,
  __name: "calendar",
  props: Vfe,
  emits: zfe,
  setup(e, { expose: t, emit: n }) {
    const o = Ve("calendar"), l = e, r = n, {
      calculateValidatedDateRange: a,
      date: i,
      pickDay: s,
      realSelectedDay: c,
      selectDate: u,
      validatedRange: d,
      handleDateChange: f
    } = Bfe(l, r, Q3), { t: p } = an(), m = O(() => {
      const v = `el.datepicker.month${i.value.format("M")}`;
      return `${i.value.year()} ${p("el.datepicker.year")} ${p(v)}`;
    });
    return t({
      selectedDay: c,
      pickDay: s,
      selectDate: u,
      calculateValidatedDateRange: a
    }), (v, h) => (G(), ue(
      "div",
      {
        class: X(S(o).b())
      },
      [
        ve(
          "div",
          {
            class: X(S(o).e("header"))
          },
          [
            Oe(v.$slots, "header", { date: m.value }, () => [
              ve(
                "div",
                {
                  class: X(S(o).e("title"))
                },
                qe(m.value),
                3
              ),
              S(d).length === 0 && v.controllerType === "button" ? (G(), ue(
                "div",
                {
                  key: 0,
                  class: X(S(o).e("button-group"))
                },
                [
                  $(S(hF), null, {
                    default: Ee(() => [
                      $(S(Qo), {
                        size: "small",
                        onClick: h[0] || (h[0] = (g) => S(u)("prev-month"))
                      }, {
                        default: Ee(() => [
                          Ft(
                            qe(S(p)("el.datepicker.prevMonth")),
                            1
                          )
                        ]),
                        _: 1
                      }),
                      $(S(Qo), {
                        size: "small",
                        onClick: h[1] || (h[1] = (g) => S(u)("today"))
                      }, {
                        default: Ee(() => [
                          Ft(
                            qe(S(p)("el.datepicker.today")),
                            1
                          )
                        ]),
                        _: 1
                      }),
                      $(S(Qo), {
                        size: "small",
                        onClick: h[2] || (h[2] = (g) => S(u)("next-month"))
                      }, {
                        default: Ee(() => [
                          Ft(
                            qe(S(p)("el.datepicker.nextMonth")),
                            1
                          )
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ],
                2
              )) : S(d).length === 0 && v.controllerType === "select" ? (G(), ue(
                "div",
                {
                  key: 1,
                  class: X(S(o).e("select-controller"))
                },
                [
                  $(gpe, {
                    date: S(i),
                    formatter: v.formatter,
                    onDateChange: S(f)
                  }, null, 8, ["date", "formatter", "onDateChange"])
                ],
                2
              )) : Ie("v-if", !0)
            ])
          ],
          2
        ),
        S(d).length === 0 ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(o).e("body"))
          },
          [
            $(q3, {
              date: S(i),
              "selected-day": S(c),
              onPick: S(s)
            }, or({
              _: 2
            }, [
              v.$slots["date-cell"] ? {
                name: "date-cell",
                fn: Ee((g) => [
                  Oe(v.$slots, "date-cell", cs(us(g)))
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["date", "selected-day", "onPick"])
          ],
          2
        )) : (G(), ue(
          "div",
          {
            key: 1,
            class: X(S(o).e("body"))
          },
          [
            (G(!0), ue(
              Ge,
              null,
              on(S(d), (g, y) => (G(), Me(q3, {
                key: y,
                date: g[0],
                "selected-day": S(c),
                range: g,
                "hide-header": y !== 0,
                onPick: S(s)
              }, or({
                _: 2
              }, [
                v.$slots["date-cell"] ? {
                  name: "date-cell",
                  fn: Ee((b) => [
                    Oe(v.$slots, "date-cell", Ut({ ref_for: !0 }, b))
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["date", "selected-day", "range", "hide-header", "onPick"]))),
              128
            ))
          ],
          2
        ))
      ],
      2
    ));
  }
});
var ype = /* @__PURE__ */ Je(bpe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/calendar/src/calendar.vue"]]);
const Spe = Dt(ype), Cpe = Xe({
  header: {
    type: String,
    default: ""
  },
  footer: {
    type: String,
    default: ""
  },
  bodyStyle: {
    type: ye([String, Object, Array]),
    default: ""
  },
  headerClass: String,
  bodyClass: String,
  footerClass: String,
  shadow: {
    type: String,
    values: ["always", "hover", "never"],
    default: void 0
  }
}), wpe = /* @__PURE__ */ le({
  name: "ElCard",
  __name: "card",
  props: Cpe,
  setup(e) {
    const t = wp("card"), n = Ve("card");
    return (o, l) => {
      var r;
      return G(), ue(
        "div",
        {
          class: X([
            S(n).b(),
            S(n).is(`${o.shadow || ((r = S(t)) == null ? void 0 : r.shadow) || "always"}-shadow`)
          ])
        },
        [
          o.$slots.header || o.header ? (G(), ue(
            "div",
            {
              key: 0,
              class: X([S(n).e("header"), o.headerClass])
            },
            [
              Oe(o.$slots, "header", {}, () => [
                Ft(
                  qe(o.header),
                  1
                )
              ])
            ],
            2
          )) : Ie("v-if", !0),
          ve(
            "div",
            {
              class: X([S(n).e("body"), o.bodyClass]),
              style: gt(o.bodyStyle)
            },
            [
              Oe(o.$slots, "default")
            ],
            6
          ),
          o.$slots.footer || o.footer ? (G(), ue(
            "div",
            {
              key: 1,
              class: X([S(n).e("footer"), o.footerClass])
            },
            [
              Oe(o.$slots, "footer", {}, () => [
                Ft(
                  qe(o.footer),
                  1
                )
              ])
            ],
            2
          )) : Ie("v-if", !0)
        ],
        2
      );
    };
  }
});
var $pe = /* @__PURE__ */ Je(wpe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/card/src/card.vue"]]);
const xpe = Dt($pe), Epe = Xe({
  initialIndex: {
    type: Number,
    default: 0
  },
  height: {
    type: String,
    default: ""
  },
  trigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  autoplay: {
    type: Boolean,
    default: !0
  },
  interval: {
    type: Number,
    default: 3e3
  },
  indicatorPosition: {
    type: String,
    values: ["", "none", "outside"],
    default: ""
  },
  arrow: {
    type: String,
    values: ["always", "hover", "never"],
    default: "hover"
  },
  type: {
    type: String,
    values: ["", "card"],
    default: ""
  },
  cardScale: {
    type: Number,
    default: 0.83
  },
  loop: {
    type: Boolean,
    default: !0
  },
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  pauseOnHover: {
    type: Boolean,
    default: !0
  },
  motionBlur: Boolean
}), Ope = {
  change: (e, t) => [e, t].every(mt)
}, EF = Symbol("carouselContextKey"), pm = "ElCarouselItem", _pe = (e, t, n) => Nr(e.subTree).filter(
  (r) => {
    var a;
    return dn(r) && ((a = r.type) == null ? void 0 : a.name) === t && !!r.component;
  }
).map((r) => r.component.uid).map((r) => n[r]).filter((r) => !!r), z1 = (e, t) => {
  const n = /* @__PURE__ */ Ce({}), o = /* @__PURE__ */ Ce([]), l = /* @__PURE__ */ new WeakMap(), r = (u) => {
    n.value[u.uid] = u, lf(n), nt(() => {
      const d = u.getVnode().el, f = d.parentNode;
      if (!l.has(f)) {
        l.set(f, []);
        const p = f.insertBefore.bind(f);
        f.insertBefore = (m, v) => (l.get(f).some((g) => m === g || v === g) && lf(n), p(m, v));
      }
      l.get(f).push(d);
    });
  }, a = (u) => {
    delete n.value[u.uid], lf(n);
    const d = u.getVnode().el, f = d.parentNode, p = l.get(f), m = p.indexOf(d);
    p.splice(m, 1);
  }, i = () => {
    o.value = _pe(
      e,
      t,
      n.value
    );
  }, s = (u) => u.render();
  return {
    children: o,
    addChild: r,
    removeChild: a,
    ChildrenSorter: /* @__PURE__ */ le({
      setup(u, { slots: d }) {
        return () => (i(), d.default ? ht(s, {
          render: d.default
        }) : null);
      }
    })
  };
}, eN = 300, Ipe = (e, t, n) => {
  const {
    children: o,
    addChild: l,
    removeChild: r,
    ChildrenSorter: a
  } = z1(
    xt(),
    pm
  ), i = So(), s = /* @__PURE__ */ H(-1), c = /* @__PURE__ */ H(null), u = /* @__PURE__ */ H(!1), d = /* @__PURE__ */ H(), f = /* @__PURE__ */ H(0), p = /* @__PURE__ */ H(!0), m = O(
    () => e.arrow !== "never" && !S(g)
  ), v = O(() => o.value.some((U) => U.props.label.toString().length > 0)), h = O(() => e.type === "card"), g = O(() => e.direction === "vertical"), y = O(() => e.height !== "auto" ? {
    height: e.height
  } : {
    height: `${f.value}px`,
    overflow: "hidden"
  }), b = Qs(
    (U) => {
      T(U);
    },
    eN,
    { trailing: !0 }
  ), C = Qs((U) => {
    M(U);
  }, eN), w = (U) => p.value ? s.value <= 1 ? U <= 1 : U > 1 : !0;
  function x() {
    c.value && (clearInterval(c.value), c.value = null);
  }
  function E() {
    e.interval <= 0 || !e.autoplay || c.value || (c.value = setInterval(() => I(), e.interval));
  }
  const I = () => {
    s.value < o.value.length - 1 ? s.value = s.value + 1 : e.loop && (s.value = 0);
  };
  function T(U) {
    if (rt(U)) {
      const re = o.value.filter(
        (oe) => oe.props.name === U
      );
      re.length > 0 && (U = o.value.indexOf(re[0]));
    }
    if (U = Number(U), Number.isNaN(U) || U !== Math.floor(U)) {
      Gt(n, "index must be integer.");
      return;
    }
    const te = o.value.length, J = s.value;
    U < 0 ? s.value = e.loop ? te - 1 : 0 : U >= te ? s.value = e.loop ? 0 : te - 1 : s.value = U, J === s.value && P(J), B();
  }
  function P(U) {
    o.value.forEach((te, J) => {
      te.translateItem(J, s.value, U);
    });
  }
  function k(U, te) {
    var J, re, oe, q;
    const K = S(o), se = K.length;
    if (se === 0 || !U.states.inStage)
      return !1;
    const Z = te + 1, ee = te - 1, fe = se - 1, me = K[fe].states.active, ge = K[0].states.active, he = (re = (J = K[Z]) == null ? void 0 : J.states) == null ? void 0 : re.active, $e = (q = (oe = K[ee]) == null ? void 0 : oe.states) == null ? void 0 : q.active;
    return te === fe && ge || he ? "left" : te === 0 && me || $e ? "right" : !1;
  }
  function N() {
    u.value = !0, e.pauseOnHover && x();
  }
  function R() {
    u.value = !1, E();
  }
  function z(U) {
    S(g) || o.value.forEach((te, J) => {
      U === k(te, J) && (te.states.hover = !0);
    });
  }
  function D() {
    S(g) || o.value.forEach((U) => {
      U.states.hover = !1;
    });
  }
  function F(U) {
    s.value = U;
  }
  function M(U) {
    e.trigger === "hover" && U !== s.value && (s.value = U);
  }
  function A() {
    T(s.value - 1);
  }
  function L() {
    T(s.value + 1);
  }
  function B() {
    x(), e.pauseOnHover || E();
  }
  function V(U) {
    e.height === "auto" && (f.value = U);
  }
  function j() {
    var U;
    const te = (U = i.default) == null ? void 0 : U.call(i);
    if (!te)
      return null;
    const re = Nr(te).filter((oe) => dn(oe) && oe.type.name === pm);
    return (re == null ? void 0 : re.length) === 2 && e.loop && !h.value ? (p.value = !0, re) : (p.value = !1, null);
  }
  pe(
    () => s.value,
    (U, te) => {
      P(te), p.value && (U = U % 2, te = te % 2), te > -1 && t(en, U, te);
    }
  );
  const W = O({
    get: () => p.value ? s.value % 2 : s.value,
    set: (U) => s.value = U
  });
  pe(
    () => e.autoplay,
    (U) => {
      U ? E() : x();
    }
  ), pe(
    () => e.loop,
    () => {
      T(s.value);
    }
  ), pe(
    () => e.interval,
    () => {
      B();
    }
  );
  const Y = /* @__PURE__ */ Ce();
  return nt(() => {
    pe(
      () => o.value,
      () => {
        o.value.length > 0 && T(e.initialIndex);
      },
      {
        immediate: !0
      }
    ), Y.value = Xn(d.value, () => {
      P();
    }), E();
  }), yt(() => {
    x(), d.value && Y.value && Y.value.stop();
  }), at(EF, {
    root: d,
    isCardType: h,
    isVertical: g,
    items: o,
    loop: e.loop,
    cardScale: e.cardScale,
    addItem: l,
    removeItem: r,
    setActiveItem: T,
    setContainerHeight: V
  }), {
    root: d,
    activeIndex: s,
    exposeActiveIndex: W,
    arrowDisplay: m,
    hasLabel: v,
    hover: u,
    isCardType: h,
    items: o,
    isVertical: g,
    containerStyle: y,
    isItemsTwoLength: p,
    handleButtonEnter: z,
    handleButtonLeave: D,
    handleIndicatorClick: F,
    handleMouseEnter: N,
    handleMouseLeave: R,
    setActiveItem: T,
    prev: A,
    next: L,
    PlaceholderItem: j,
    isTwoLengthShow: w,
    ItemsSorter: a,
    throttledArrowClick: b,
    throttledIndicatorHover: C
  };
}, Tpe = ["aria-label"], Ppe = ["aria-label"], kpe = ["onMouseenter", "onClick"], Npe = ["aria-label"], Mpe = { key: 0 }, Ape = {
  key: 2,
  xmlns: "http://www.w3.org/2000/svg",
  version: "1.1",
  style: { display: "none" }
}, tN = "ElCarousel", Rpe = /* @__PURE__ */ le({
  name: tN,
  __name: "carousel",
  props: Epe,
  emits: Ope,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, {
      root: r,
      activeIndex: a,
      exposeActiveIndex: i,
      arrowDisplay: s,
      hasLabel: c,
      hover: u,
      isCardType: d,
      items: f,
      isVertical: p,
      containerStyle: m,
      handleButtonEnter: v,
      handleButtonLeave: h,
      handleIndicatorClick: g,
      handleMouseEnter: y,
      handleMouseLeave: b,
      setActiveItem: C,
      prev: w,
      next: x,
      PlaceholderItem: E,
      isTwoLengthShow: I,
      ItemsSorter: T,
      throttledArrowClick: P,
      throttledIndicatorHover: k
    } = Ipe(o, l, tN), N = Ve("carousel"), { t: R } = an(), z = O(() => {
      const A = [N.b(), N.m(o.direction)];
      return S(d) && A.push(N.m("card")), A;
    }), D = O(() => {
      const A = [N.e("indicators"), N.em("indicators", o.direction)];
      return S(c) && A.push(N.em("indicators", "labels")), o.indicatorPosition === "outside" && A.push(N.em("indicators", "outside")), S(p) && A.push(N.em("indicators", "right")), A;
    });
    function F(A) {
      if (!o.motionBlur)
        return;
      const L = S(p) ? `${N.namespace.value}-transitioning-vertical` : `${N.namespace.value}-transitioning`;
      A.currentTarget.classList.add(L);
    }
    function M(A) {
      if (!o.motionBlur)
        return;
      const L = S(p) ? `${N.namespace.value}-transitioning-vertical` : `${N.namespace.value}-transitioning`;
      A.currentTarget.classList.remove(L);
    }
    return t({
      activeIndex: i,
      setActiveItem: C,
      prev: w,
      next: x
    }), (A, L) => (G(), ue(
      "div",
      {
        ref_key: "root",
        ref: r,
        class: X(z.value),
        onMouseenter: L[6] || (L[6] = Et(
          (...B) => S(y) && S(y)(...B),
          ["stop"]
        )),
        onMouseleave: L[7] || (L[7] = Et(
          (...B) => S(b) && S(b)(...B),
          ["stop"]
        ))
      },
      [
        S(s) ? (G(), Me(Vn, {
          key: 0,
          name: "carousel-arrow-left",
          persisted: ""
        }, {
          default: Ee(() => [
            _t(ve("button", {
              type: "button",
              class: X([S(N).e("arrow"), S(N).em("arrow", "left")]),
              "aria-label": S(R)("el.carousel.leftArrow"),
              onMouseenter: L[0] || (L[0] = (B) => S(v)("left")),
              onMouseleave: L[1] || (L[1] = (...B) => S(h) && S(h)(...B)),
              onClick: L[2] || (L[2] = Et((B) => S(P)(S(a) - 1), ["stop"]))
            }, [
              $(S(ut), null, {
                default: Ee(() => [
                  $(S(ms))
                ]),
                _: 1
              })
            ], 42, Tpe), [
              [Jt, (A.arrow === "always" || S(u)) && (A.loop || S(a) > 0)]
            ])
          ]),
          _: 1
        })) : Ie("v-if", !0),
        S(s) ? (G(), Me(Vn, {
          key: 1,
          name: "carousel-arrow-right",
          persisted: ""
        }, {
          default: Ee(() => [
            _t(ve("button", {
              type: "button",
              class: X([S(N).e("arrow"), S(N).em("arrow", "right")]),
              "aria-label": S(R)("el.carousel.rightArrow"),
              onMouseenter: L[3] || (L[3] = (B) => S(v)("right")),
              onMouseleave: L[4] || (L[4] = (...B) => S(h) && S(h)(...B)),
              onClick: L[5] || (L[5] = Et((B) => S(P)(S(a) + 1), ["stop"]))
            }, [
              $(S(ut), null, {
                default: Ee(() => [
                  $(S(Rl))
                ]),
                _: 1
              })
            ], 42, Ppe), [
              [
                Jt,
                (A.arrow === "always" || S(u)) && (A.loop || S(a) < S(f).length - 1)
              ]
            ])
          ]),
          _: 1
        })) : Ie("v-if", !0),
        ve(
          "div",
          {
            class: X(S(N).e("container")),
            style: gt(S(m)),
            onTransitionstart: F,
            onTransitionend: M
          },
          [
            $(S(E)),
            Oe(A.$slots, "default")
          ],
          38
        ),
        $(S(T), null, {
          default: Ee(() => [
            A.indicatorPosition !== "none" ? (G(), ue(
              "ul",
              {
                key: 0,
                class: X(D.value)
              },
              [
                (G(!0), ue(
                  Ge,
                  null,
                  on(S(f), (B, V) => _t((G(), ue("li", {
                    key: V,
                    class: X([
                      S(N).e("indicator"),
                      S(N).em("indicator", A.direction),
                      S(N).is("active", V === S(a))
                    ]),
                    onMouseenter: (j) => S(k)(V),
                    onClick: Et((j) => S(g)(V), ["stop"])
                  }, [
                    ve("button", {
                      class: X(S(N).e("button")),
                      "aria-label": S(R)("el.carousel.indicator", { index: V + 1 })
                    }, [
                      S(c) ? (G(), ue(
                        "span",
                        Mpe,
                        qe(B.props.label),
                        1
                      )) : Ie("v-if", !0)
                    ], 10, Npe)
                  ], 42, kpe)), [
                    [Jt, S(I)(V)]
                  ])),
                  128
                ))
              ],
              2
            )) : Ie("v-if", !0)
          ]),
          _: 1
        }),
        A.motionBlur ? (G(), ue("svg", Ape, [...L[8] || (L[8] = [
          ve(
            "defs",
            null,
            [
              ve("filter", { id: "elCarouselHorizontal" }, [
                ve("feGaussianBlur", {
                  in: "SourceGraphic",
                  stdDeviation: "12,0"
                })
              ]),
              ve("filter", { id: "elCarouselVertical" }, [
                ve("feGaussianBlur", {
                  in: "SourceGraphic",
                  stdDeviation: "0,10"
                })
              ])
            ],
            -1
          )
        ])])) : Ie("v-if", !0)
      ],
      34
    ));
  }
});
var Dpe = /* @__PURE__ */ Je(Rpe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel.vue"]]);
const Lpe = Xe({
  name: { type: String, default: "" },
  label: {
    type: [String, Number],
    default: ""
  }
}), Bpe = (e) => {
  const t = ze(EF), n = xt();
  t || Gt(
    pm,
    "usage: <el-carousel></el-carousel-item></el-carousel>"
  ), n || Gt(
    pm,
    "compositional hook can only be invoked inside setups"
  );
  const o = /* @__PURE__ */ H(), l = /* @__PURE__ */ H(!1), r = /* @__PURE__ */ H(0), a = /* @__PURE__ */ H(1), i = /* @__PURE__ */ H(!1), s = /* @__PURE__ */ H(!1), c = /* @__PURE__ */ H(!1), u = /* @__PURE__ */ H(!1), { isCardType: d, isVertical: f, cardScale: p } = t;
  function m(C, w, x) {
    const E = x - 1, I = w - 1, T = w + 1, P = x / 2;
    return w === 0 && C === E ? -1 : w === E && C === 0 ? x : C < I && w - C >= P ? x + 1 : C > T && C - w >= P ? -2 : C;
  }
  function v(C, w) {
    var x, E;
    const I = S(f) ? ((x = t.root.value) == null ? void 0 : x.offsetHeight) || 0 : ((E = t.root.value) == null ? void 0 : E.offsetWidth) || 0;
    return c.value ? I * ((2 - p) * (C - w) + 1) / 4 : C < w ? -(1 + p) * I / 4 : (3 + p) * I / 4;
  }
  function h(C, w, x) {
    const E = t.root.value;
    return E ? ((x ? E.offsetHeight : E.offsetWidth) || 0) * (C - w) : 0;
  }
  const g = (C, w, x) => {
    var E;
    const I = S(d), T = (E = t.items.value.length) != null ? E : Number.NaN, P = C === w;
    !I && !fn(x) && (u.value = P || C === x), !P && T > 2 && t.loop && (C = m(C, w, T));
    const k = S(f);
    i.value = P, I ? (c.value = Math.round(Math.abs(C - w)) <= 1, r.value = v(C, w), a.value = S(i) ? 1 : p) : r.value = h(C, w, k), s.value = !0, P && o.value && t.setContainerHeight(o.value.offsetHeight);
  };
  function y() {
    if (t && S(d)) {
      const C = t.items.value.findIndex(
        ({ uid: w }) => w === n.uid
      );
      t.setActiveItem(C);
    }
  }
  const b = {
    props: e,
    states: /* @__PURE__ */ kt({
      hover: l,
      translate: r,
      scale: a,
      active: i,
      ready: s,
      inStage: c,
      animating: u
    }),
    uid: n.uid,
    getVnode: () => n.vnode,
    translateItem: g
  };
  return t.addItem(b), yt(() => {
    t.removeItem(b);
  }), {
    carouselItemRef: o,
    active: i,
    animating: u,
    hover: l,
    inStage: c,
    isVertical: f,
    translate: r,
    isCardType: d,
    scale: a,
    ready: s,
    handleItemClick: y
  };
}, Fpe = /* @__PURE__ */ le({
  name: pm,
  __name: "carousel-item",
  props: Lpe,
  setup(e) {
    const t = e, n = Ve("carousel"), {
      carouselItemRef: o,
      active: l,
      animating: r,
      hover: a,
      inStage: i,
      isVertical: s,
      translate: c,
      isCardType: u,
      scale: d,
      ready: f,
      handleItemClick: p
    } = Bpe(t), m = O(() => [
      n.e("item"),
      n.is("active", l.value),
      n.is("in-stage", i.value),
      n.is("hover", a.value),
      n.is("animating", r.value),
      {
        [n.em("item", "card")]: u.value,
        [n.em("item", "card-vertical")]: u.value && s.value
      }
    ]), v = O(() => {
      const g = `${`translate${S(s) ? "Y" : "X"}`}(${S(c)}px)`, y = `scale(${S(d)})`;
      return {
        transform: [g, y].join(" ")
      };
    });
    return (h, g) => _t((G(), ue(
      "div",
      {
        ref_key: "carouselItemRef",
        ref: o,
        class: X(m.value),
        style: gt(v.value),
        onClick: g[0] || (g[0] = (...y) => S(p) && S(p)(...y))
      },
      [
        S(u) ? _t((G(), ue(
          "div",
          {
            key: 0,
            class: X(S(n).e("mask"))
          },
          null,
          2
        )), [
          [Jt, !S(l)]
        ]) : Ie("v-if", !0),
        Oe(h.$slots, "default")
      ],
      6
    )), [
      [Jt, S(f)]
    ]);
  }
});
var OF = /* @__PURE__ */ Je(Fpe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/carousel/src/carousel-item.vue"]]);
const Vpe = Dt(Dpe, {
  CarouselItem: OF
}), zpe = oo(OF), _F = Be({
  modelValue: {
    type: [Number, String, Boolean],
    default: void 0
  },
  label: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  value: {
    type: [String, Boolean, Number, Object],
    default: void 0
  },
  indeterminate: Boolean,
  disabled: {
    type: Boolean,
    default: void 0
  },
  checked: Boolean,
  name: {
    type: String,
    default: void 0
  },
  trueValue: {
    type: [String, Number],
    default: void 0
  },
  falseValue: {
    type: [String, Number],
    default: void 0
  },
  trueLabel: {
    type: [String, Number],
    default: void 0
  },
  falseLabel: {
    type: [String, Number],
    default: void 0
  },
  id: {
    type: String,
    default: void 0
  },
  border: Boolean,
  size: Bo,
  tabindex: [String, Number],
  validateEvent: {
    type: Boolean,
    default: !0
  },
  ariaLabel: String
}, zl(["ariaControls"])), IF = {
  [It]: (e) => rt(e) || mt(e) || Tn(e),
  change: (e) => rt(e) || mt(e) || Tn(e)
}, Ep = Symbol("checkboxGroupContextKey"), Hpe = ({
  model: e,
  isChecked: t
}) => {
  const n = ze(Ep, void 0), o = ze(id, void 0), l = O(() => {
    var a, i;
    const s = (a = n == null ? void 0 : n.max) == null ? void 0 : a.value, c = (i = n == null ? void 0 : n.min) == null ? void 0 : i.value;
    return !fn(s) && e.value.length >= s && !t.value || !fn(c) && e.value.length <= c && t.value;
  });
  return {
    isDisabled: io(
      O(() => {
        var a, i;
        return n === void 0 ? (a = o == null ? void 0 : o.disabled) != null ? a : l.value : ((i = n.disabled) == null ? void 0 : i.value) || l.value;
      })
    ),
    isLimitDisabled: l
  };
}, jpe = (e, {
  model: t,
  isLimitExceeded: n,
  hasOwnLabel: o,
  isDisabled: l,
  isLabeledByFormItem: r
}) => {
  const a = ze(Ep, void 0), { formItem: i } = cl(), { emit: s } = xt();
  function c(m) {
    var v, h, g, y;
    return [!0, e.trueValue, e.trueLabel].includes(m) ? (h = (v = e.trueValue) != null ? v : e.trueLabel) != null ? h : !0 : (y = (g = e.falseValue) != null ? g : e.falseLabel) != null ? y : !1;
  }
  function u(m, v) {
    s(en, c(m), v);
  }
  function d(m) {
    if (n.value)
      return;
    const v = m.target;
    s(en, c(v.checked), m);
  }
  function f(m) {
    return Rt(this, null, function* () {
      n.value || !o.value && !l.value && r.value && (m.composedPath().some(
        (g) => g.tagName === "LABEL"
      ) || (t.value = c(
        [!1, e.falseValue, e.falseLabel].includes(t.value)
      ), yield Ke(), u(t.value, m)));
    });
  }
  const p = O(
    () => (a == null ? void 0 : a.validateEvent) || e.validateEvent
  );
  return pe(
    () => e.modelValue,
    () => {
      p.value && (i == null || i.validate("change").catch((m) => Gt(m)));
    }
  ), {
    handleChange: d,
    onClickRoot: f
  };
}, Wpe = (e) => {
  const t = /* @__PURE__ */ H(!1), { emit: n } = xt(), o = ze(Ep, void 0), l = O(() => fn(o) === !1), r = /* @__PURE__ */ H(!1), a = O({
    get() {
      var i, s;
      return l.value ? (i = o == null ? void 0 : o.modelValue) == null ? void 0 : i.value : (s = e.modelValue) != null ? s : t.value;
    },
    set(i) {
      var s, c;
      l.value && We(i) ? (r.value = ((s = o == null ? void 0 : o.max) == null ? void 0 : s.value) !== void 0 && i.length > (o == null ? void 0 : o.max.value) && i.length > a.value.length, r.value === !1 && ((c = o == null ? void 0 : o.changeEvent) == null || c.call(o, i))) : (n(It, i), t.value = i);
    }
  });
  return {
    model: a,
    isGroup: l,
    isLimitExceeded: r
  };
}, Kpe = (e, t, { model: n }) => {
  const o = ze(Ep, void 0), l = /* @__PURE__ */ H(!1), r = O(() => hr(e.value) ? e.label : e.value), a = O(() => {
    const u = n.value;
    return Tn(u) ? u : We(u) ? Mt(r.value) ? u.map(Wt).some((d) => Jn(d, r.value)) : u.map(Wt).includes(r.value) : u != null ? u === e.trueValue || u === e.trueLabel : !!u;
  }), i = Mo(
    O(() => {
      var u;
      return (u = o == null ? void 0 : o.size) == null ? void 0 : u.value;
    }),
    {
      prop: !0
    }
  ), s = Mo(O(() => {
    var u;
    return (u = o == null ? void 0 : o.size) == null ? void 0 : u.value;
  })), c = O(() => !!t.default || !hr(r.value));
  return {
    checkboxButtonSize: i,
    isChecked: a,
    isFocused: l,
    checkboxSize: s,
    hasOwnLabel: c,
    actualValue: r
  };
}, TF = (e, t) => {
  const { formItem: n } = cl(), { model: o, isGroup: l, isLimitExceeded: r } = Wpe(e), {
    isFocused: a,
    isChecked: i,
    checkboxButtonSize: s,
    checkboxSize: c,
    hasOwnLabel: u,
    actualValue: d
  } = Kpe(e, t, { model: o }), { isDisabled: f } = Hpe({ model: o, isChecked: i }), { inputId: p, isLabeledByFormItem: m } = zr(e, {
    formItemContext: n,
    disableIdGeneration: u,
    disableIdManagement: l
  }), { handleChange: v, onClickRoot: h } = jpe(e, {
    model: o,
    isLimitExceeded: r,
    hasOwnLabel: u,
    isDisabled: f,
    isLabeledByFormItem: m
  });
  return (() => {
    function y() {
      var b, C;
      We(o.value) && !o.value.includes(d.value) ? o.value.push(d.value) : o.value = (C = (b = e.trueValue) != null ? b : e.trueLabel) != null ? C : !0;
    }
    e.checked && y();
  })(), hi(
    {
      from: "label act as value",
      replacement: "value",
      version: "3.0.0",
      scope: "el-checkbox",
      ref: "https://element-plus.org/en-US/component/checkbox.html"
    },
    O(() => l.value && hr(e.value))
  ), hi(
    {
      from: "true-label",
      replacement: "true-value",
      version: "3.0.0",
      scope: "el-checkbox",
      ref: "https://element-plus.org/en-US/component/checkbox.html"
    },
    O(() => !!e.trueLabel)
  ), hi(
    {
      from: "false-label",
      replacement: "false-value",
      version: "3.0.0",
      scope: "el-checkbox",
      ref: "https://element-plus.org/en-US/component/checkbox.html"
    },
    O(() => !!e.falseLabel)
  ), {
    inputId: p,
    isLabeledByFormItem: m,
    isChecked: i,
    isDisabled: f,
    isFocused: a,
    checkboxButtonSize: s,
    checkboxSize: c,
    hasOwnLabel: u,
    model: o,
    actualValue: d,
    handleChange: v,
    onClickRoot: h
  };
}, Upe = ["id", "indeterminate", "name", "tabindex", "disabled"], Gpe = /* @__PURE__ */ le({
  name: "ElCheckbox",
  __name: "checkbox",
  props: _F,
  emits: IF,
  setup(e) {
    const t = e, n = So(), {
      inputId: o,
      isLabeledByFormItem: l,
      isChecked: r,
      isDisabled: a,
      isFocused: i,
      checkboxSize: s,
      hasOwnLabel: c,
      model: u,
      actualValue: d,
      handleChange: f,
      onClickRoot: p
    } = TF(t, n), m = O(() => {
      var y, b, C, w;
      return t.trueValue || t.falseValue || t.trueLabel || t.falseLabel ? {
        "true-value": (b = (y = t.trueValue) != null ? y : t.trueLabel) != null ? b : !0,
        "false-value": (w = (C = t.falseValue) != null ? C : t.falseLabel) != null ? w : !1
      } : {
        value: d.value
      };
    }), v = Ve("checkbox"), h = O(() => [
      v.b(),
      v.m(s.value),
      v.is("disabled", a.value),
      v.is("bordered", t.border),
      v.is("checked", r.value)
    ]), g = O(() => [
      v.e("input"),
      v.is("disabled", a.value),
      v.is("checked", r.value),
      v.is("indeterminate", t.indeterminate),
      v.is("focus", i.value)
    ]);
    return (y, b) => (G(), Me(Ht(!S(c) && S(l) ? "span" : "label"), {
      for: !S(c) && S(l) ? null : S(o),
      class: X(h.value),
      "aria-controls": y.indeterminate ? y.ariaControls : null,
      "aria-checked": y.indeterminate ? "mixed" : void 0,
      "aria-label": y.ariaLabel,
      onClick: S(p)
    }, {
      default: Ee(() => [
        ve(
          "span",
          {
            class: X(g.value)
          },
          [
            _t(ve("input", Ut({
              id: S(o),
              "onUpdate:modelValue": b[0] || (b[0] = (C) => /* @__PURE__ */ kn(u) ? u.value = C : null),
              class: S(v).e("original"),
              type: "checkbox",
              indeterminate: y.indeterminate,
              name: y.name,
              tabindex: y.tabindex,
              disabled: S(a)
            }, m.value, {
              onChange: b[1] || (b[1] = (...C) => S(f) && S(f)(...C)),
              onFocus: b[2] || (b[2] = (C) => i.value = !0),
              onBlur: b[3] || (b[3] = (C) => i.value = !1),
              onClick: b[4] || (b[4] = Et(() => {
              }, ["stop"]))
            }), null, 16, Upe), [
              [dL, S(u)]
            ]),
            ve(
              "span",
              {
                class: X(S(v).e("inner"))
              },
              null,
              2
            )
          ],
          2
        ),
        S(c) ? (G(), ue(
          "span",
          {
            key: 0,
            class: X(S(v).e("label"))
          },
          [
            Oe(y.$slots, "default"),
            y.$slots.default ? Ie("v-if", !0) : (G(), ue(
              Ge,
              { key: 0 },
              [
                Ft(
                  qe(y.label),
                  1
                )
              ],
              64
            ))
          ],
          2
        )) : Ie("v-if", !0)
      ]),
      _: 3
    }, 8, ["for", "class", "aria-controls", "aria-checked", "aria-label", "onClick"]));
  }
});
var PF = /* @__PURE__ */ Je(Gpe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox.vue"]]);
const Ype = ["name", "tabindex", "disabled"], Xpe = /* @__PURE__ */ le({
  name: "ElCheckboxButton",
  __name: "checkbox-button",
  props: _F,
  emits: IF,
  setup(e) {
    const t = e, n = So(), {
      isFocused: o,
      isChecked: l,
      isDisabled: r,
      checkboxButtonSize: a,
      model: i,
      actualValue: s,
      handleChange: c
    } = TF(t, n), u = O(() => {
      var v, h, g, y;
      return t.trueValue || t.falseValue || t.trueLabel || t.falseLabel ? {
        "true-value": (h = (v = t.trueValue) != null ? v : t.trueLabel) != null ? h : !0,
        "false-value": (y = (g = t.falseValue) != null ? g : t.falseLabel) != null ? y : !1
      } : {
        value: s.value
      };
    }), d = ze(Ep, void 0), f = Ve("checkbox"), p = O(() => {
      var v, h, g, y;
      const b = (h = (v = d == null ? void 0 : d.fill) == null ? void 0 : v.value) != null ? h : "";
      return {
        backgroundColor: b,
        borderColor: b,
        color: (y = (g = d == null ? void 0 : d.textColor) == null ? void 0 : g.value) != null ? y : "",
        boxShadow: b ? `-1px 0 0 0 ${b}` : void 0
      };
    }), m = O(() => [
      f.b("button"),
      f.bm("button", a.value),
      f.is("disabled", r.value),
      f.is("checked", l.value),
      f.is("focus", o.value)
    ]);
    return (v, h) => (G(), ue(
      "label",
      {
        class: X(m.value)
      },
      [
        _t(ve("input", Ut({
          "onUpdate:modelValue": h[0] || (h[0] = (g) => /* @__PURE__ */ kn(i) ? i.value = g : null),
          class: S(f).be("button", "original"),
          type: "checkbox",
          name: v.name,
          tabindex: v.tabindex,
          disabled: S(r)
        }, u.value, {
          onChange: h[1] || (h[1] = (...g) => S(c) && S(c)(...g)),
          onFocus: h[2] || (h[2] = (g) => o.value = !0),
          onBlur: h[3] || (h[3] = (g) => o.value = !1),
          onClick: h[4] || (h[4] = Et(() => {
          }, ["stop"]))
        }), null, 16, Ype), [
          [dL, S(i)]
        ]),
        v.$slots.default || v.label ? (G(), ue(
          "span",
          {
            key: 0,
            class: X(S(f).be("button", "inner")),
            style: gt(S(l) ? p.value : void 0)
          },
          [
            Oe(v.$slots, "default", {}, () => [
              Ft(
                qe(v.label),
                1
              )
            ])
          ],
          6
        )) : Ie("v-if", !0)
      ],
      2
    ));
  }
});
var n_ = /* @__PURE__ */ Je(Xpe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-button.vue"]]);
const qpe = Xe(Be({
  modelValue: {
    type: ye(Array),
    default: () => []
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  min: Number,
  max: Number,
  size: Bo,
  fill: String,
  textColor: String,
  tag: {
    type: String,
    default: "div"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  options: {
    type: ye(Array)
  },
  props: {
    type: ye(Object),
    default: () => kF
  },
  type: {
    type: String,
    values: ["checkbox", "button"],
    default: "checkbox"
  }
}, zl(["ariaLabel"]))), Jpe = {
  [It]: (e) => We(e),
  change: (e) => We(e)
}, kF = {
  label: "label",
  value: "value",
  disabled: "disabled"
}, Zpe = /* @__PURE__ */ le({
  name: "ElCheckboxGroup",
  __name: "checkbox-group",
  props: qpe,
  emits: Jpe,
  setup(e, { emit: t }) {
    const n = e, o = t, l = Ve("checkbox"), r = io(), { formItem: a } = cl(), { inputId: i, isLabeledByFormItem: s } = zr(n, {
      formItemContext: a
    }), c = (m) => Rt(this, null, function* () {
      o(It, m), yield Ke(), o(en, m);
    }), u = O({
      get() {
        return n.modelValue;
      },
      set(m) {
        c(m);
      }
    }), d = O(() => Be(Be({}, kF), n.props)), f = (m) => {
      const { label: v, value: h, disabled: g } = d.value, y = {
        label: m[v],
        value: m[h],
        disabled: m[g]
      };
      return Be(Be({}, Cp(m, [v, h, g])), y);
    }, p = O(
      () => n.type === "button" ? n_ : PF
    );
    return at(Ep, vt(Be({}, La(/* @__PURE__ */ to(n), [
      "size",
      "min",
      "max",
      "validateEvent",
      "fill",
      "textColor"
    ])), {
      disabled: r,
      modelValue: u,
      changeEvent: c
    })), pe(
      () => n.modelValue,
      (m, v) => {
        n.validateEvent && !Jn(m, v) && (a == null || a.validate("change").catch((h) => Gt(h)));
      }
    ), (m, v) => {
      var h;
      return G(), Me(Ht(m.tag), {
        id: S(i),
        class: X(S(l).b("group")),
        role: "group",
        "aria-label": S(s) ? void 0 : m.ariaLabel || "checkbox-group",
        "aria-labelledby": S(s) ? (h = S(a)) == null ? void 0 : h.labelId : void 0
      }, {
        default: Ee(() => [
          Oe(m.$slots, "default", {}, () => [
            (G(!0), ue(
              Ge,
              null,
              on(m.options, (g, y) => (G(), Me(
                Ht(p.value),
                Ut({ key: y }, { ref_for: !0 }, f(g)),
                null,
                16
              ))),
              128
            ))
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
    };
  }
});
var NF = /* @__PURE__ */ Je(Zpe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/checkbox/src/checkbox-group.vue"]]);
const Fa = Dt(PF, {
  CheckboxButton: n_,
  CheckboxGroup: NF
}), Qpe = oo(n_), o_ = oo(NF), MF = Xe({
  modelValue: {
    type: [String, Number, Boolean],
    default: void 0
  },
  size: Bo,
  disabled: {
    type: Boolean,
    default: void 0
  },
  label: {
    type: [String, Number, Boolean],
    default: void 0
  },
  value: {
    type: [String, Number, Boolean],
    default: void 0
  },
  name: {
    type: String,
    default: void 0
  }
}), eve = Xe(vt(Be({}, MF), {
  border: Boolean
})), AF = {
  [It]: (e) => rt(e) || mt(e) || Tn(e),
  [en]: (e) => rt(e) || mt(e) || Tn(e)
}, RF = Symbol("radioGroupKey"), DF = (e, t) => {
  const n = /* @__PURE__ */ H(), o = ze(RF, void 0), l = O(() => !!o), r = O(() => hr(e.value) ? e.label : e.value), a = O({
    get() {
      return l.value ? o.modelValue : e.modelValue;
    },
    set(d) {
      l.value ? o.changeEvent(d) : t && t(It, d), n.value.checked = e.modelValue === r.value;
    }
  }), i = Mo(O(() => o == null ? void 0 : o.size)), s = io(O(() => o == null ? void 0 : o.disabled)), c = /* @__PURE__ */ H(!1), u = O(() => s.value || l.value && a.value !== r.value ? -1 : 0);
  return hi(
    {
      from: "label act as value",
      replacement: "value",
      version: "3.0.0",
      scope: "el-radio",
      ref: "https://element-plus.org/en-US/component/radio.html"
    },
    O(() => l.value && hr(e.value))
  ), {
    radioRef: n,
    isGroup: l,
    radioGroup: o,
    focus: c,
    size: i,
    disabled: s,
    tabIndex: u,
    modelValue: a,
    actualValue: r
  };
}, tve = ["value", "name", "disabled", "checked"], nve = /* @__PURE__ */ le({
  name: "ElRadio",
  __name: "radio",
  props: eve,
  emits: AF,
  setup(e, { emit: t }) {
    const n = e, o = t, l = Ve("radio"), { radioRef: r, radioGroup: a, focus: i, size: s, disabled: c, modelValue: u, actualValue: d } = DF(n, o);
    function f() {
      Ke(() => o(en, u.value));
    }
    return (p, m) => {
      var v;
      return G(), ue(
        "label",
        {
          class: X([
            S(l).b(),
            S(l).is("disabled", S(c)),
            S(l).is("focus", S(i)),
            S(l).is("bordered", p.border),
            S(l).is("checked", S(u) === S(d)),
            S(l).m(S(s))
          ])
        },
        [
          ve(
            "span",
            {
              class: X([
                S(l).e("input"),
                S(l).is("disabled", S(c)),
                S(l).is("checked", S(u) === S(d))
              ])
            },
            [
              _t(ve("input", {
                ref_key: "radioRef",
                ref: r,
                "onUpdate:modelValue": m[0] || (m[0] = (h) => /* @__PURE__ */ kn(u) ? u.value = h : null),
                class: X(S(l).e("original")),
                value: S(d),
                name: p.name || ((v = S(a)) == null ? void 0 : v.name),
                disabled: S(c),
                checked: S(u) === S(d),
                type: "radio",
                onFocus: m[1] || (m[1] = (h) => i.value = !0),
                onBlur: m[2] || (m[2] = (h) => i.value = !1),
                onChange: f,
                onClick: m[3] || (m[3] = Et(() => {
                }, ["stop"]))
              }, null, 42, tve), [
                [fL, S(u)]
              ]),
              ve(
                "span",
                {
                  class: X(S(l).e("inner"))
                },
                null,
                2
              )
            ],
            2
          ),
          ve(
            "span",
            {
              class: X(S(l).e("label")),
              onKeydown: m[4] || (m[4] = Et(() => {
              }, ["stop"]))
            },
            [
              Oe(p.$slots, "default", {}, () => [
                Ft(
                  qe(p.label),
                  1
                )
              ])
            ],
            34
          )
        ],
        2
      );
    };
  }
});
var LF = /* @__PURE__ */ Je(nve, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio.vue"]]);
const ove = Xe(Be({}, MF)), lve = ["value", "name", "disabled"], rve = /* @__PURE__ */ le({
  name: "ElRadioButton",
  __name: "radio-button",
  props: ove,
  setup(e) {
    const t = e, n = Ve("radio"), { radioRef: o, focus: l, size: r, disabled: a, modelValue: i, radioGroup: s, actualValue: c } = DF(t), u = O(() => ({
      backgroundColor: (s == null ? void 0 : s.fill) || "",
      borderColor: (s == null ? void 0 : s.fill) || "",
      boxShadow: s != null && s.fill ? `-1px 0 0 0 ${s.fill}` : "",
      color: (s == null ? void 0 : s.textColor) || ""
    }));
    return (d, f) => {
      var p;
      return G(), ue(
        "label",
        {
          class: X([
            S(n).b("button"),
            S(n).is("active", S(i) === S(c)),
            S(n).is("disabled", S(a)),
            S(n).is("focus", S(l)),
            S(n).bm("button", S(r))
          ])
        },
        [
          _t(ve("input", {
            ref_key: "radioRef",
            ref: o,
            "onUpdate:modelValue": f[0] || (f[0] = (m) => /* @__PURE__ */ kn(i) ? i.value = m : null),
            class: X(S(n).be("button", "original-radio")),
            value: S(c),
            type: "radio",
            name: d.name || ((p = S(s)) == null ? void 0 : p.name),
            disabled: S(a),
            onFocus: f[1] || (f[1] = (m) => l.value = !0),
            onBlur: f[2] || (f[2] = (m) => l.value = !1),
            onClick: f[3] || (f[3] = Et(() => {
            }, ["stop"]))
          }, null, 42, lve), [
            [fL, S(i)]
          ]),
          ve(
            "span",
            {
              class: X(S(n).be("button", "inner")),
              style: gt(S(i) === S(c) ? u.value : {}),
              onKeydown: f[4] || (f[4] = Et(() => {
              }, ["stop"]))
            },
            [
              Oe(d.$slots, "default", {}, () => [
                Ft(
                  qe(d.label),
                  1
                )
              ])
            ],
            38
          )
        ],
        2
      );
    };
  }
});
var l_ = /* @__PURE__ */ Je(rve, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-button.vue"]]);
const ave = Xe(Be({
  id: {
    type: String,
    default: void 0
  },
  size: Bo,
  disabled: {
    type: Boolean,
    default: void 0
  },
  modelValue: {
    type: [String, Number, Boolean],
    default: void 0
  },
  fill: {
    type: String,
    default: ""
  },
  textColor: {
    type: String,
    default: ""
  },
  name: {
    type: String,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  options: {
    type: ye(Array)
  },
  props: {
    type: ye(Object),
    default: () => BF
  },
  type: {
    type: String,
    values: ["radio", "button"],
    default: "radio"
  }
}, zl(["ariaLabel"]))), ive = AF, BF = {
  label: "label",
  value: "value",
  disabled: "disabled"
}, sve = ["id", "aria-label", "aria-labelledby"], cve = /* @__PURE__ */ le({
  name: "ElRadioGroup",
  __name: "radio-group",
  props: ave,
  emits: ive,
  setup(e, { emit: t }) {
    const n = e, o = t, l = Ve("radio"), r = ml(), a = /* @__PURE__ */ H(), { formItem: i } = cl(), { inputId: s, isLabeledByFormItem: c } = zr(n, {
      formItemContext: i
    }), u = (v) => {
      o(It, v), Ke(() => o(en, v));
    };
    nt(() => {
      const v = a.value.querySelectorAll("[type=radio]"), h = v[0];
      !Array.from(v).some((g) => g.checked) && h && (h.tabIndex = 0);
    });
    const d = O(() => n.name || r.value), f = O(() => Be(Be({}, BF), n.props)), p = (v) => {
      const { label: h, value: g, disabled: y } = f.value, b = {
        label: v[h],
        value: v[g],
        disabled: v[y]
      };
      return Be(Be({}, Cp(v, [h, g, y])), b);
    }, m = O(
      () => n.type === "button" ? l_ : LF
    );
    return at(
      RF,
      /* @__PURE__ */ kt(vt(Be({}, /* @__PURE__ */ to(n)), {
        changeEvent: u,
        name: d
      }))
    ), pe(
      () => n.modelValue,
      (v, h) => {
        n.validateEvent && !Jn(v, h) && (i == null || i.validate("change").catch((g) => Gt(g)));
      }
    ), (v, h) => (G(), ue("div", {
      id: S(s),
      ref_key: "radioGroupRef",
      ref: a,
      class: X(S(l).b("group")),
      role: "radiogroup",
      "aria-label": S(c) ? void 0 : v.ariaLabel || "radio-group",
      "aria-labelledby": S(c) ? S(i).labelId : void 0
    }, [
      Oe(v.$slots, "default", {}, () => [
        (G(!0), ue(
          Ge,
          null,
          on(v.options, (g, y) => (G(), Me(
            Ht(m.value),
            Ut({ key: y }, { ref_for: !0 }, p(g)),
            null,
            16
          ))),
          128
        ))
      ])
    ], 10, sve));
  }
});
var FF = /* @__PURE__ */ Je(cve, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/radio/src/radio-group.vue"]]);
const VF = Dt(LF, {
  RadioButton: l_,
  RadioGroup: FF
}), uve = oo(FF), dve = oo(l_), H1 = Symbol();
function fve(e) {
  return !!(We(e) ? e.every(({
    type: t
  }) => t === qn) : (e == null ? void 0 : e.type) === qn);
}
var pve = /* @__PURE__ */ le({
  name: "NodeContent",
  props: {
    node: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const t = Ve("cascader-node"), {
      renderLabelFn: n
    } = ze(H1), {
      node: o
    } = e, {
      data: l,
      label: r
    } = o, a = () => {
      const i = n == null ? void 0 : n({
        node: o,
        data: l
      });
      return fve(i) ? r : i != null ? i : r;
    };
    return () => $("span", {
      class: t.e("label")
    }, [a()]);
  }
});
const vve = ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"], mve = /* @__PURE__ */ le({
  name: "ElCascaderNode",
  __name: "node",
  props: {
    node: {
      type: Object,
      required: !0
    },
    menuId: String
  },
  emits: ["expand"],
  setup(e, { emit: t }) {
    const n = e, o = t, l = ze(H1), r = Ve("cascader-node"), a = O(() => l.isHoverMenu), i = O(() => l.config.multiple), s = O(() => l.config.checkStrictly), c = O(() => l.config.showPrefix), u = O(() => {
      var T;
      return (T = l.checkedNodes[0]) == null ? void 0 : T.uid;
    }), d = O(() => n.node.isDisabled), f = O(() => n.node.isLeaf), p = O(
      () => s.value && !f.value || !d.value
    ), m = O(() => h(l.expandingNode)), v = O(
      () => s.value && l.checkedNodes.some(h)
    ), h = (T) => {
      var P;
      const { level: k, uid: N } = n.node;
      return ((P = T == null ? void 0 : T.pathNodes[k - 1]) == null ? void 0 : P.uid) === N;
    }, g = () => {
      m.value || l.expandNode(n.node);
    }, y = (T) => {
      const { node: P } = n;
      T !== P.checked && l.handleCheckChange(P, T);
    }, b = () => {
      l.lazyLoad(n.node, () => {
        f.value || g();
      });
    }, C = (T) => {
      a.value && (w(), !f.value && o("expand", T));
    }, w = () => {
      const { node: T } = n;
      !p.value || T.loading || (T.loaded ? g() : b());
    }, x = () => {
      f.value && !d.value && !s.value && !i.value ? I(!0) : (l.config.checkOnClickNode && (i.value || s.value) || f.value && l.config.checkOnClickLeaf) && !d.value ? E(!n.node.checked) : a.value || w();
    }, E = (T) => {
      s.value ? (y(T), n.node.loaded && g()) : I(T);
    }, I = (T) => {
      n.node.loaded ? (y(T), !s.value && g()) : b();
    };
    return (T, P) => (G(), ue("li", {
      id: `${e.menuId}-${e.node.uid}`,
      role: "menuitem",
      "aria-haspopup": !f.value,
      "aria-owns": f.value ? void 0 : e.menuId,
      "aria-expanded": m.value,
      tabindex: p.value ? -1 : void 0,
      class: X([
        S(r).b(),
        S(r).is("selectable", s.value),
        S(r).is("active", e.node.checked),
        S(r).is("disabled", !p.value),
        m.value && "in-active-path",
        v.value && "in-checked-path"
      ]),
      onMouseenter: C,
      onFocus: C,
      onClick: x
    }, [
      Ie(" prefix "),
      i.value && c.value ? (G(), Me(S(Fa), {
        key: 0,
        "model-value": e.node.checked,
        indeterminate: e.node.indeterminate,
        disabled: d.value,
        onClick: P[0] || (P[0] = Et(() => {
        }, ["stop"])),
        "onUpdate:modelValue": E
      }, null, 8, ["model-value", "indeterminate", "disabled"])) : s.value && c.value ? (G(), Me(S(VF), {
        key: 1,
        "model-value": u.value,
        label: e.node.uid,
        disabled: d.value,
        "onUpdate:modelValue": E,
        onClick: P[1] || (P[1] = Et(() => {
        }, ["stop"]))
      }, {
        default: Ee(() => [
          Ie(`
        Add an empty element to avoid render label,
        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485
      `),
          P[2] || (P[2] = ve(
            "span",
            null,
            null,
            -1
          ))
        ]),
        _: 1
      }, 8, ["model-value", "label", "disabled"])) : f.value && e.node.checked ? (G(), Me(S(ut), {
        key: 2,
        class: X(S(r).e("prefix"))
      }, {
        default: Ee(() => [
          $(S(ch))
        ]),
        _: 1
      }, 8, ["class"])) : Ie("v-if", !0),
      Ie(" content "),
      $(S(pve), { node: e.node }, null, 8, ["node"]),
      Ie(" postfix "),
      f.value ? Ie("v-if", !0) : (G(), ue(
        Ge,
        { key: 3 },
        [
          e.node.loading ? (G(), Me(S(ut), {
            key: 0,
            class: X([S(r).is("loading"), S(r).e("postfix")])
          }, {
            default: Ee(() => [
              $(S(wi))
            ]),
            _: 1
          }, 8, ["class"])) : (G(), Me(S(ut), {
            key: 1,
            class: X(["arrow-right", S(r).e("postfix")])
          }, {
            default: Ee(() => [
              $(S(Rl))
            ]),
            _: 1
          }, 8, ["class"]))
        ],
        64
      ))
    ], 42, vve));
  }
});
var hve = /* @__PURE__ */ Je(mve, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/node.vue"]]);
const gve = /* @__PURE__ */ le({
  name: "ElCascaderMenu",
  __name: "menu",
  props: {
    nodes: {
      type: Array,
      required: !0
    },
    index: {
      type: Number,
      required: !0
    }
  },
  setup(e) {
    const t = e, n = xt(), o = Ve("cascader-menu"), { t: l } = an(), r = ml();
    let a, i;
    const s = ze(H1), c = /* @__PURE__ */ H(), u = O(() => !t.nodes.length), d = O(() => !s.initialLoaded), f = O(() => `${r.value}-${t.index}`), p = (g) => {
      a = g.target;
    }, m = (g) => {
      var y;
      if (!(!s.isHoverMenu || !a || !c.value))
        if (a.contains(g.target)) {
          v();
          const b = n.vnode.el, { left: C } = b.getBoundingClientRect(), { offsetWidth: w, offsetHeight: x } = b, E = g.clientX - C, I = a.offsetTop, T = I + a.offsetHeight, P = ((y = b.querySelector(`.${o.e("wrap")}`)) == null ? void 0 : y.scrollTop) || 0;
          c.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${E} ${I} L${w} ${P} V${I} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${E} ${T} L${w} ${x + P} V${T} Z" />
        `;
        } else i || (i = window.setTimeout(h, s.config.hoverThreshold));
    }, v = () => {
      i && (clearTimeout(i), i = void 0);
    }, h = () => {
      c.value && (c.value.innerHTML = "", v());
    };
    return (g, y) => (G(), Me(S(Ba), {
      key: f.value,
      tag: "ul",
      role: "menu",
      class: X(S(o).b()),
      "wrap-class": S(o).e("wrap"),
      "view-class": [S(o).e("list"), S(o).is("empty", u.value)],
      onMousemove: m,
      onMouseleave: h
    }, {
      default: Ee(() => {
        var b;
        return [
          (G(!0), ue(
            Ge,
            null,
            on(e.nodes, (C) => (G(), Me(hve, {
              key: C.uid,
              node: C,
              "menu-id": f.value,
              onExpand: p
            }, null, 8, ["node", "menu-id"]))),
            128
          )),
          d.value ? (G(), ue(
            "div",
            {
              key: 0,
              class: X(S(o).e("empty-text"))
            },
            [
              $(S(ut), {
                size: "14",
                class: X(S(o).is("loading"))
              }, {
                default: Ee(() => [
                  $(S(wi))
                ]),
                _: 1
              }, 8, ["class"]),
              Ft(
                " " + qe(S(l)("el.cascader.loading")),
                1
              )
            ],
            2
          )) : u.value ? (G(), ue(
            "div",
            {
              key: 1,
              class: X(S(o).e("empty-text"))
            },
            [
              Oe(g.$slots, "empty", {}, () => [
                Ft(
                  qe(S(l)("el.cascader.noData")),
                  1
                )
              ])
            ],
            2
          )) : (b = S(s)) != null && b.isHoverMenu ? (G(), ue(
            Ge,
            { key: 2 },
            [
              Ie(" eslint-disable vue/html-self-closing "),
              (G(), ue(
                "svg",
                {
                  ref_key: "hoverZone",
                  ref: c,
                  class: X(S(o).e("hover-zone"))
                },
                null,
                2
              ))
            ],
            2112
          )) : Ie("v-if", !0),
          Ie(" eslint-enable vue/html-self-closing ")
        ];
      }),
      _: 3
    }, 8, ["class", "wrap-class", "view-class"]));
  }
});
var bve = /* @__PURE__ */ Je(gve, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/menu.vue"]]);
let yve = 0;
const Sve = (e) => {
  const t = [e];
  let { parent: n } = e;
  for (; n; )
    t.unshift(n), n = n.parent;
  return t;
};
let px = class vx {
  constructor(t, n, o, l = !1) {
    this.data = t, this.config = n, this.parent = o, this.root = l, this.uid = yve++, this.checked = !1, this.indeterminate = !1, this.loading = !1;
    const { value: r, label: a, children: i } = n, s = t[i], c = Sve(this);
    this.level = l ? 0 : o ? o.level + 1 : 1, this.value = t[r], this.label = t[a], this.pathNodes = c, this.pathValues = c.map((u) => u.value), this.pathLabels = c.map((u) => u.label), this.childrenData = s, this.children = (s || []).map(
      (u) => new vx(u, n, this)
    ), this.loaded = !n.lazy || this.isLeaf || !Ql(s), this.text = "";
  }
  get isDisabled() {
    const { data: t, parent: n, config: o } = this, { disabled: l, checkStrictly: r } = o;
    return (it(l) ? l(t, this) : !!t[l]) || !r && !!(n != null && n.isDisabled);
  }
  get isLeaf() {
    const { data: t, config: n, childrenData: o, loaded: l } = this, { lazy: r, leaf: a } = n, i = it(a) ? a(t, this) : t[a];
    return fn(i) ? r && !l ? !1 : !(We(o) && o.length) : !!i;
  }
  get valueByOption() {
    return this.config.emitPath ? this.pathValues : this.value;
  }
  appendChild(t) {
    const { childrenData: n, children: o } = this, l = new vx(t, this.config, this);
    return We(n) ? n.push(t) : this.childrenData = [t], o.push(l), l;
  }
  calcText(t, n) {
    const o = t ? this.pathLabels.join(n) : this.label;
    return this.text = o, o;
  }
  broadcast(t) {
    this.children.forEach((n) => {
      var o;
      n && (n.broadcast(t), (o = n.onParentCheck) == null || o.call(n, t));
    });
  }
  emit() {
    var t;
    const { parent: n } = this;
    n && ((t = n.onChildCheck) == null || t.call(n), n.emit());
  }
  onParentCheck(t) {
    this.isDisabled || this.setCheckState(t);
  }
  onChildCheck() {
    const { children: t } = this, n = t.filter((l) => !l.isDisabled), o = n.length ? n.every((l) => l.checked) : !1;
    this.setCheckState(o);
  }
  setCheckState(t) {
    const n = this.children.length, o = this.children.reduce((l, r) => {
      const a = r.checked ? 1 : r.indeterminate ? 0.5 : 0;
      return l + a;
    }, 0);
    this.checked = this.loaded && this.children.filter((l) => !l.isDisabled).every((l) => l.loaded && l.checked) && t, this.indeterminate = this.loaded && o !== n && o > 0;
  }
  doCheck(t) {
    if (this.checked === t)
      return;
    const { checkStrictly: n, multiple: o } = this.config;
    n || !o ? this.checked = t : (this.broadcast(t), this.setCheckState(t), this.emit());
  }
};
const mx = (e, t) => e.reduce((n, o) => (o.isLeaf ? n.push(o) : (!t && n.push(o), n = n.concat(mx(o.children, t))), n), []);
class nN {
  constructor(t, n) {
    this.config = n;
    const o = (t || []).map(
      (l) => new px(l, this.config)
    );
    this.nodes = o, this.allNodes = mx(o, !1), this.leafNodes = mx(o, !0);
  }
  getNodes() {
    return this.nodes;
  }
  getFlattedNodes(t) {
    return t ? this.leafNodes : this.allNodes;
  }
  appendNode(t, n) {
    const o = n ? n.appendChild(t) : new px(t, this.config);
    n || this.nodes.push(o), this.appendAllNodesAndLeafNodes(o);
  }
  appendNodes(t, n) {
    t.length > 0 ? t.forEach((o) => this.appendNode(o, n)) : n && n.isLeaf && this.leafNodes.push(n);
  }
  appendAllNodesAndLeafNodes(t) {
    this.allNodes.push(t), t.isLeaf && this.leafNodes.push(t), t.children && t.children.forEach((n) => {
      this.appendAllNodesAndLeafNodes(n);
    });
  }
  getNodeByValue(t, n = !1) {
    return hr(t) ? null : this.getFlattedNodes(n).find(
      (l) => Jn(l.value, t) || Jn(l.pathValues, t)
    ) || null;
  }
  getSameNode(t) {
    return t && this.getFlattedNodes(!1).find(
      ({ value: o, level: l }) => Jn(t.value, o) && t.level === l
    ) || null;
  }
}
const zF = Xe({
  modelValue: {
    type: ye([Number, String, Array, Object])
  },
  options: {
    type: ye(Array),
    default: () => []
  },
  props: {
    type: ye(Object),
    default: () => ({})
  }
}), Cve = {
  expandTrigger: "click",
  multiple: !1,
  checkStrictly: !1,
  emitPath: !0,
  lazy: !1,
  lazyLoad: gn,
  value: "value",
  label: "label",
  children: "children",
  leaf: "leaf",
  disabled: "disabled",
  hoverThreshold: 500,
  checkOnClickNode: !1,
  checkOnClickLeaf: !0,
  showPrefix: !0
}, wve = Xe(vt(Be({}, zF), {
  border: {
    type: Boolean,
    default: !0
  },
  renderLabel: {
    type: Function
  }
})), oN = (e) => !0, $ve = {
  [It]: oN,
  [en]: oN,
  close: () => !0,
  "expand-change": (e) => e
}, xve = (e) => O(() => Be(Be({}, Cve), e.props)), lN = (e) => {
  if (!e)
    return 0;
  const t = e.id.split("-");
  return Number(t[t.length - 2]);
}, Eve = (e) => {
  if (!e)
    return;
  const t = e.querySelector("input");
  t ? t.click() : N7(e) && e.click();
}, Ove = (e, t) => {
  const n = t.slice(0), o = n.map((r) => r.uid), l = e.reduce((r, a) => {
    const i = o.indexOf(a.uid);
    return i > -1 && (r.push(a), n.splice(i, 1), o.splice(i, 1)), r;
  }, []);
  return l.push(...n), l;
}, _ve = /* @__PURE__ */ le({
  name: "ElCascaderPanel",
  __name: "index",
  props: wve,
  emits: $ve,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n;
    let r = !1;
    const a = Ve("cascader"), i = xve(o), s = So();
    let c;
    const u = /* @__PURE__ */ H(!0), d = /* @__PURE__ */ H(!1), f = /* @__PURE__ */ H([]), p = /* @__PURE__ */ H(), m = /* @__PURE__ */ H([]), v = /* @__PURE__ */ H(), h = /* @__PURE__ */ H([]), g = O(() => i.value.expandTrigger === "hover"), y = O(() => o.renderLabel || s.default), b = () => {
      const { options: M } = o, A = i.value;
      r = !1, c = new nN(M, A), m.value = [c.getNodes()], A.lazy && Ql(o.options) ? (u.value = !1, C(void 0, (L) => {
        L && (c = new nN(L, A), m.value = [c.getNodes()]), u.value = !0, N(!1, !0);
      })) : N(!1, !0);
    }, C = (M, A) => {
      const L = i.value;
      M = M || new px({}, L, void 0, !0), M.loading = !0;
      const B = (j) => {
        const W = M, Y = W.root ? null : W;
        W.loading = !1, W.loaded = !0, W.childrenData = W.childrenData || [], j && (c == null || c.appendNodes(j, Y)), j && (A == null || A(j)), M.level === 0 && (d.value = !0);
      }, V = () => {
        M.loading = !1, M.loaded = !1, M.level === 0 && (u.value = !0);
      };
      L.lazyLoad(M, B, V);
    }, w = (M, A) => {
      var L;
      const { level: B } = M, V = m.value.slice(0, B);
      let j;
      M.isLeaf ? j = M.pathNodes[B - 2] : (j = M, V.push(M.children)), ((L = v.value) == null ? void 0 : L.uid) !== (j == null ? void 0 : j.uid) && (v.value = M, m.value = V, !A && l("expand-change", (M == null ? void 0 : M.pathValues) || []));
    }, x = (M, A, L = !0) => {
      const { checkStrictly: B, multiple: V } = i.value, j = h.value[0];
      r = !0, !V && (j == null || j.doCheck(!1)), M.doCheck(A), k(), L && !V && !B && l("close"), !L && !V && E(M);
    }, E = (M) => {
      M && (M = M.parent, E(M), M && w(M));
    }, I = (M) => c == null ? void 0 : c.getFlattedNodes(M), T = (M) => {
      var A;
      return (A = I(M)) == null ? void 0 : A.filter(({ checked: L }) => L !== !1);
    }, P = () => {
      h.value.forEach((M) => M.doCheck(!1)), k(), m.value = m.value.slice(0, 1), v.value = void 0, l("expand-change", []);
    }, k = () => {
      var M;
      const { checkStrictly: A, multiple: L } = i.value, B = h.value, V = T(!A), j = Ove(B, V), W = j.map((Y) => Y.valueByOption);
      h.value = j, p.value = L ? W : (M = W[0]) != null ? M : null;
    }, N = (M = !1, A = !1) => {
      const { modelValue: L } = o, { lazy: B, multiple: V, checkStrictly: j } = i.value, W = !j;
      if (!(!u.value || r || !A && Jn(L, p.value)))
        if (B && !M) {
          const U = H3(
            dae(kl(L))
          ).map((te) => c == null ? void 0 : c.getNodeByValue(te)).filter((te) => !!te && !te.loaded && !te.loading);
          U.length ? U.forEach((te) => {
            C(te, () => N(!1, A));
          }) : N(!0, A);
        } else {
          const Y = V ? kl(L) : [L], U = H3(
            Y.map(
              (te) => c == null ? void 0 : c.getNodeByValue(te, W)
            )
          );
          R(U, A), p.value = sc(L != null ? L : void 0);
        }
    }, R = (M, A = !0) => {
      const { checkStrictly: L } = i.value, B = h.value, V = M.filter(
        (Y) => !!Y && (L || Y.isLeaf)
      ), j = c == null ? void 0 : c.getSameNode(v.value), W = A && j || V[0];
      W ? W.pathNodes.forEach((Y) => w(Y, !0)) : v.value = void 0, B.forEach((Y) => Y.doCheck(!1)), (/* @__PURE__ */ kt(V)).forEach((Y) => Y.doCheck(!0)), h.value = V, Ke(z);
    }, z = () => {
      Sn && f.value.forEach((M) => {
        const A = M == null ? void 0 : M.$el;
        if (A) {
          const L = A.querySelector(
            `.${a.namespace.value}-scrollbar__wrap`
          );
          let B = A.querySelector(
            `.${a.b("node")}.in-active-path`
          );
          if (!B) {
            const V = A.querySelectorAll(
              `.${a.b("node")}.${a.is("active")}`
            );
            B = V[V.length - 1];
          }
          NO(L, B);
        }
      });
    }, D = (M) => {
      const A = M.target, L = Nn(M);
      switch (L) {
        case Ye.up:
        case Ye.down: {
          M.preventDefault();
          const B = L === Ye.up ? -1 : 1;
          ub(
            M7(
              A,
              B,
              `.${a.b("node")}[tabindex="-1"]`
            )
          );
          break;
        }
        case Ye.left: {
          M.preventDefault();
          const B = f.value[lN(A) - 1], V = B == null ? void 0 : B.$el.querySelector(
            `.${a.b("node")}[aria-expanded="true"]`
          );
          ub(V);
          break;
        }
        case Ye.right: {
          M.preventDefault();
          const B = f.value[lN(A) + 1], V = B == null ? void 0 : B.$el.querySelector(
            `.${a.b("node")}[tabindex="-1"]`
          );
          ub(V);
          break;
        }
        case Ye.enter:
        case Ye.numpadEnter:
          Eve(A);
          break;
      }
    };
    at(
      H1,
      /* @__PURE__ */ kt({
        config: i,
        expandingNode: v,
        checkedNodes: h,
        isHoverMenu: g,
        initialLoaded: u,
        renderLabelFn: y,
        lazyLoad: C,
        expandNode: w,
        handleCheckChange: x
      })
    ), pe(
      i,
      (M, A) => {
        Jn(M, A) || b();
      },
      {
        immediate: !0
      }
    ), pe(() => o.options, b, {
      deep: !0
    }), pe(
      () => o.modelValue,
      () => {
        r = !1, N();
      },
      {
        deep: !0
      }
    ), pe(
      () => p.value,
      (M) => {
        Jn(M, o.modelValue) || (l(It, M), l(en, M));
      }
    );
    const F = () => {
      d.value || b();
    };
    return vp(() => f.value = []), nt(() => !Ql(o.modelValue) && N()), t({
      menuList: f,
      menus: m,
      checkedNodes: h,
      handleKeyDown: D,
      handleCheckChange: x,
      getFlattedNodes: I,
      getCheckedNodes: T,
      clearCheckedNodes: P,
      calculateCheckedValue: k,
      scrollToExpandingNode: z,
      loadLazyRootNodes: F
    }), (M, A) => (G(), ue(
      "div",
      {
        class: X([S(a).b("panel"), S(a).is("bordered", M.border)]),
        onKeydown: D
      },
      [
        (G(!0), ue(
          Ge,
          null,
          on(m.value, (L, B) => (G(), Me(bve, {
            key: B,
            ref_for: !0,
            ref: (V) => f.value[B] = V,
            index: B,
            nodes: [...L]
          }, {
            empty: Ee(() => [
              Oe(M.$slots, "empty")
            ]),
            _: 3
          }, 8, ["index", "nodes"]))),
          128
        ))
      ],
      34
    ));
  }
});
var Ive = /* @__PURE__ */ Je(_ve, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue"]]);
const HF = Dt(Ive), Tve = Xe(Be(vt(Be({}, zF), {
  size: Bo,
  placeholder: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  clearable: Boolean,
  clearIcon: {
    type: Pn,
    default: Es
  },
  filterable: Boolean,
  filterMethod: {
    type: ye(
      Function
    ),
    default: (e, t) => e.text.includes(t)
  },
  separator: {
    type: String,
    default: " / "
  },
  showAllLevels: {
    type: Boolean,
    default: !0
  },
  collapseTags: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  collapseTagsTooltip: Boolean,
  maxCollapseTagsTooltipHeight: {
    type: [String, Number]
  },
  debounce: {
    type: Number,
    default: 300
  },
  beforeFilter: {
    type: ye(Function),
    default: () => !0
  },
  placement: {
    type: ye(String),
    values: Mi,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: ye(Array),
    default: ["bottom-start", "bottom", "top-start", "top", "right", "left"]
  },
  popperClass: In.popperClass,
  popperStyle: In.popperStyle,
  teleported: In.teleported,
  effect: {
    type: ye(String),
    default: "light"
  },
  tagType: vt(Be({}, gs.type), { default: "info" }),
  tagEffect: vt(Be({}, gs.effect), { default: "light" }),
  validateEvent: {
    type: Boolean,
    default: !0
  },
  persistent: {
    type: Boolean,
    default: !0
  },
  showCheckedStrategy: {
    type: String,
    values: ["parent", "child"],
    default: "child"
  },
  checkOnClickNode: Boolean,
  showPrefix: {
    type: Boolean,
    default: !0
  }
}), ad)), rN = (e) => !0, Pve = {
  [It]: rN,
  [en]: rN,
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  clear: () => !0,
  visibleChange: (e) => Tn(e),
  expandChange: (e) => !!e,
  removeTag: (e) => !!e
}, kve = ["placeholder"], Nve = ["onClick"], Mve = /* @__PURE__ */ le({
  name: "ElCascader",
  __name: "cascader",
  props: Tve,
  emits: Pve,
  setup(e, { expose: t, emit: n }) {
    const o = {
      modifiers: [
        {
          name: "arrowPosition",
          enabled: !0,
          phase: "main",
          fn: ({ state: je }) => {
            const { modifiersData: lt, placement: Ct } = je;
            ["right", "left", "bottom", "top"].includes(Ct) || lt.arrow && (lt.arrow.x = 35);
          },
          requires: ["arrow"]
        }
      ]
    }, l = e, r = n, a = Ti(), i = So();
    let s = 0, c = 0;
    const u = Ve("cascader"), d = Ve("input"), f = {
      small: 7,
      default: 11,
      large: 15
    }, { t: p } = an(), { formItem: m } = cl(), v = io(), { valueOnClear: h } = ih(l), { isComposing: g, handleComposition: y } = fh({
      afterComposition(je) {
        var lt;
        const Ct = (lt = je.target) == null ? void 0 : lt.value;
        dt(Ct);
      }
    }), b = /* @__PURE__ */ H(), C = /* @__PURE__ */ H(), w = /* @__PURE__ */ H(), x = /* @__PURE__ */ H(), E = /* @__PURE__ */ H(), I = /* @__PURE__ */ H(), T = /* @__PURE__ */ H(!1), P = /* @__PURE__ */ H(!1), k = /* @__PURE__ */ H(!1), N = /* @__PURE__ */ H(""), R = /* @__PURE__ */ H(""), z = /* @__PURE__ */ H([]), D = /* @__PURE__ */ H([]), F = O(() => l.props.multiple ? l.collapseTags ? z.value.slice(0, l.maxCollapseTags) : z.value : []), M = O(() => l.props.multiple ? l.collapseTags ? z.value.slice(l.maxCollapseTags) : [] : []), A = O(() => a.style), L = O(
      () => {
        var je;
        return (je = l.placeholder) != null ? je : p("el.cascader.placeholder");
      }
    ), B = O(
      () => R.value || z.value.length > 0 || g.value ? "" : L.value
    ), V = Mo(), j = O(
      () => V.value === "small" ? "small" : "default"
    ), W = O(() => !!l.props.multiple), Y = O(() => !l.filterable || W.value), U = O(
      () => W.value ? R.value : N.value
    ), te = O(
      () => {
        var je;
        return ((je = E.value) == null ? void 0 : je.checkedNodes) || [];
      }
    ), { wrapperRef: J, isFocused: re, handleBlur: oe } = Os(w, {
      disabled: v,
      beforeBlur(je) {
        var lt, Ct;
        return ((lt = b.value) == null ? void 0 : lt.isFocusInsideContent(je)) || ((Ct = C.value) == null ? void 0 : Ct.isFocusInsideContent(je));
      },
      afterBlur() {
        var je;
        l.validateEvent && ((je = m == null ? void 0 : m.validate) == null || je.call(m, "blur").catch((lt) => Gt(lt)));
      }
    }), q = O(() => !l.clearable || v.value || k.value || !P.value && !re.value ? !1 : !!te.value.length), K = O(() => {
      const { showAllLevels: je, separator: lt } = l, Ct = te.value;
      return Ct.length ? W.value ? "" : Ct[0].calcText(je, lt) : "";
    }), se = O(() => (m == null ? void 0 : m.validateState) || ""), Z = O({
      get() {
        return sc(l.modelValue);
      },
      set(je) {
        const lt = je != null ? je : h.value;
        r(It, lt), r(en, lt), l.validateEvent && (m == null || m.validate("change").catch((Ct) => Gt(Ct)));
      }
    }), ee = O(() => [
      u.b(),
      u.m(V.value),
      u.is("disabled", v.value),
      a.class
    ]), fe = O(() => [
      d.e("icon"),
      "icon-arrow-down",
      u.is("reverse", T.value)
    ]), me = O(() => u.is("focus", re.value)), ge = O(() => {
      var je, lt;
      return (lt = (je = b.value) == null ? void 0 : je.popperRef) == null ? void 0 : lt.contentRef;
    }), he = (je) => {
      if (re.value) {
        const lt = new FocusEvent("blur", je);
        oe(lt);
      }
      $e(!1);
    }, $e = (je) => {
      var lt, Ct;
      v.value || (je = je != null ? je : !T.value, je !== T.value && (T.value = je, (Ct = (lt = w.value) == null ? void 0 : lt.input) == null || Ct.setAttribute("aria-expanded", `${je}`), je ? (ne(), E.value && Ke(E.value.scrollToExpandingNode)) : l.filterable && Le(), r("visibleChange", je)));
    }, ne = () => {
      Ke(() => {
        var je;
        (je = b.value) == null || je.updatePopper();
      });
    }, ae = () => {
      k.value = !1;
    }, ce = (je) => {
      const { showAllLevels: lt, separator: Ct } = l;
      return {
        node: je,
        key: je.uid,
        text: je.calcText(lt, Ct),
        hitState: !1,
        closable: !v.value && !je.isDisabled
      };
    }, xe = (je) => {
      var lt;
      const Ct = je.node;
      Ct.doCheck(!1), (lt = E.value) == null || lt.calculateCheckedValue(), r("removeTag", Ct.valueByOption);
    }, Te = () => {
      switch (l.showCheckedStrategy) {
        case "child":
          return te.value;
        case "parent": {
          const je = Ne(!1), lt = je.map((vn) => vn.value);
          return je.filter(
            (vn) => !vn.parent || !lt.includes(vn.parent.value)
          );
        }
        default:
          return [];
      }
    }, Se = () => {
      if (!W.value)
        return;
      const je = Te(), lt = [];
      je.forEach((Ct) => lt.push(ce(Ct))), z.value = lt;
    }, be = () => {
      var je, lt;
      const { filterMethod: Ct, showAllLevels: vn, separator: tn } = l, ct = (lt = (je = E.value) == null ? void 0 : je.getFlattedNodes(!l.props.checkStrictly)) == null ? void 0 : lt.filter((pt) => pt.isDisabled ? !1 : (pt.calcText(vn, tn), Ct(pt, U.value)));
      W.value && z.value.forEach((pt) => {
        pt.hitState = !1;
      }), k.value = !0, D.value = ct, ne();
    }, ie = () => {
      var je;
      let lt;
      k.value && I.value ? lt = I.value.$el.querySelector(
        `.${u.e("suggestion-item")}`
      ) : lt = (je = E.value) == null ? void 0 : je.$el.querySelector(
        `.${u.b("node")}[tabindex="-1"]`
      ), lt && (lt.focus(), !k.value && lt.click());
    }, we = () => {
      var je, lt, Ct;
      const vn = (je = w.value) == null ? void 0 : je.input, tn = x.value, ct = (lt = I.value) == null ? void 0 : lt.$el;
      if (!(!Sn || !vn)) {
        if (ct) {
          const pt = ct.querySelector(
            `.${u.e("suggestion-list")}`
          );
          pt.style.minWidth = `${vn.offsetWidth}px`;
        }
        if (tn) {
          const { offsetHeight: pt } = tn, Lt = z.value.length > 0 ? `${Math.max(pt, s) - 2}px` : `${s}px`;
          if (vn.style.height = Lt, i.prefix) {
            const Gn = (Ct = w.value) == null ? void 0 : Ct.$el.querySelector(
              `.${d.e("prefix")}`
            );
            let To = 0;
            Gn && (To = Gn.offsetWidth, To > 0 && (To += f[V.value || "default"])), tn.style.left = `${To}px`;
          } else
            tn.style.left = "0";
          ne();
        }
      }
    }, Ne = (je) => {
      var lt;
      return (lt = E.value) == null ? void 0 : lt.getCheckedNodes(je);
    }, tt = (je) => {
      ne(), r("expandChange", je);
    }, Pe = (je) => {
      if (g.value)
        return;
      switch (Nn(je)) {
        case Ye.enter:
        case Ye.numpadEnter:
          $e();
          break;
        case Ye.down:
          $e(!0), Ke(ie), je.preventDefault();
          break;
        case Ye.esc:
          T.value === !0 && (je.preventDefault(), je.stopPropagation(), $e(!1));
          break;
        case Ye.tab:
          $e(!1);
          break;
      }
    }, Re = () => {
      var je;
      (je = E.value) == null || je.clearCheckedNodes(), !T.value && l.filterable && Le(), $e(!1), r("clear");
    }, Le = () => {
      const { value: je } = K;
      N.value = je, R.value = je;
    }, Ue = (je) => {
      var lt, Ct;
      const { checked: vn } = je;
      W.value ? (lt = E.value) == null || lt.handleCheckChange(je, !vn, !1) : (!vn && ((Ct = E.value) == null || Ct.handleCheckChange(je, !0, !1)), $e(!1));
    }, Ae = (je) => {
      const lt = je.target, Ct = Nn(je);
      switch (Ct) {
        case Ye.up:
        case Ye.down: {
          je.preventDefault();
          const vn = Ct === Ye.up ? -1 : 1;
          ub(
            M7(
              lt,
              vn,
              `.${u.e("suggestion-item")}[tabindex="-1"]`
            )
          );
          break;
        }
        case Ye.enter:
        case Ye.numpadEnter:
          lt.click();
          break;
      }
    }, De = () => {
      const je = z.value[z.value.length - 1];
      c = R.value ? 0 : c + 1, !(!je || !c || l.collapseTags && z.value.length > 1) && (je.hitState ? xe(je) : je.hitState = !0);
    }, _e = O(() => l.debounce), Ze = lh(() => {
      const { value: je } = U;
      if (!je)
        return;
      const lt = l.beforeFilter(je);
      mc(lt) ? lt.then(be).catch(() => {
      }) : lt !== !1 ? be() : ae();
    }, _e), dt = (je, lt) => {
      !T.value && $e(!0), !(lt != null && lt.isComposing) && (je ? Ze() : ae());
    }, Tt = (je) => Number.parseFloat(
      rie(d.cssVarName("input-height"), je).value
    ) - 2, jt = () => {
      var je;
      (je = w.value) == null || je.focus();
    }, Qt = () => {
      var je;
      (je = w.value) == null || je.blur();
    };
    return pe(k, ne), pe(
      [
        te,
        v,
        () => l.collapseTags,
        () => l.maxCollapseTags
      ],
      Se
    ), pe(z, () => {
      Ke(() => we());
    }), pe(V, () => Rt(this, null, function* () {
      yield Ke();
      const je = w.value.input;
      s = Tt(je) || s, we();
    })), pe(K, Le, { immediate: !0 }), pe(
      () => T.value,
      (je) => {
        var lt;
        je && l.props.lazy && l.props.lazyLoad && ((lt = E.value) == null || lt.loadLazyRootNodes());
      }
    ), nt(() => {
      const je = w.value.input, lt = Tt(je);
      s = je.offsetHeight || lt, Xn(je, we);
    }), t({
      getCheckedNodes: Ne,
      cascaderPanelRef: E,
      togglePopperVisible: $e,
      contentRef: ge,
      presentText: K,
      focus: jt,
      blur: Qt
    }), (je, lt) => (G(), Me(S(al), {
      ref_key: "tooltipRef",
      ref: b,
      visible: T.value,
      teleported: je.teleported,
      "popper-class": [S(u).e("dropdown"), je.popperClass],
      "popper-style": je.popperStyle,
      "popper-options": o,
      "fallback-placements": je.fallbackPlacements,
      "stop-popper-mouse-event": !1,
      "gpu-acceleration": !1,
      placement: je.placement,
      transition: `${S(u).namespace.value}-zoom-in-top`,
      effect: je.effect,
      pure: "",
      persistent: je.persistent,
      onHide: ae
    }, {
      default: Ee(() => [
        _t((G(), ue(
          "div",
          {
            ref_key: "wrapperRef",
            ref: J,
            class: X(ee.value),
            style: gt(A.value),
            onClick: lt[8] || (lt[8] = () => $e(Y.value ? void 0 : !0)),
            onKeydown: Pe,
            onMouseenter: lt[9] || (lt[9] = (Ct) => P.value = !0),
            onMouseleave: lt[10] || (lt[10] = (Ct) => P.value = !1)
          },
          [
            $(S(Nl), {
              ref_key: "inputRef",
              ref: w,
              modelValue: N.value,
              "onUpdate:modelValue": lt[1] || (lt[1] = (Ct) => N.value = Ct),
              placeholder: B.value,
              readonly: Y.value,
              disabled: S(v),
              "validate-event": !1,
              size: S(V),
              class: X(me.value),
              tabindex: W.value && je.filterable && !S(v) ? -1 : void 0,
              onCompositionstart: S(y),
              onCompositionupdate: S(y),
              onCompositionend: S(y),
              onInput: dt
            }, or({
              suffix: Ee(() => [
                q.value ? (G(), Me(S(ut), {
                  key: "clear",
                  class: X([S(d).e("icon"), "icon-circle-close"]),
                  onClick: Et(Re, ["stop"])
                }, {
                  default: Ee(() => [
                    (G(), Me(Ht(je.clearIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : (G(), Me(S(ut), {
                  key: "arrow-down",
                  class: X(fe.value),
                  onClick: lt[0] || (lt[0] = Et((Ct) => $e(), ["stop"]))
                }, {
                  default: Ee(() => [
                    $(S(Ni))
                  ]),
                  _: 1
                }, 8, ["class"]))
              ]),
              _: 2
            }, [
              je.$slots.prefix ? {
                name: "prefix",
                fn: Ee(() => [
                  Oe(je.$slots, "prefix")
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex", "onCompositionstart", "onCompositionupdate", "onCompositionend"]),
            W.value ? (G(), ue(
              "div",
              {
                key: 0,
                ref_key: "tagWrapper",
                ref: x,
                class: X([
                  S(u).e("tags"),
                  S(u).is("validate", !!se.value)
                ])
              },
              [
                Oe(je.$slots, "tag", {
                  data: z.value,
                  deleteTag: xe
                }, () => [
                  (G(!0), ue(
                    Ge,
                    null,
                    on(F.value, (Ct) => (G(), Me(S(fs), {
                      key: Ct.key,
                      type: je.tagType,
                      size: j.value,
                      effect: je.tagEffect,
                      hit: Ct.hitState,
                      closable: Ct.closable,
                      "disable-transitions": "",
                      onClose: (vn) => xe(Ct)
                    }, {
                      default: Ee(() => [
                        ve(
                          "span",
                          null,
                          qe(Ct.text),
                          1
                        )
                      ]),
                      _: 2
                    }, 1032, ["type", "size", "effect", "hit", "closable", "onClose"]))),
                    128
                  ))
                ]),
                je.collapseTags && z.value.length > je.maxCollapseTags ? (G(), Me(S(al), {
                  key: 0,
                  ref_key: "tagTooltipRef",
                  ref: C,
                  disabled: T.value || !je.collapseTagsTooltip,
                  "fallback-placements": ["bottom", "top", "right", "left"],
                  placement: "bottom",
                  "popper-class": je.popperClass,
                  "popper-style": je.popperStyle,
                  effect: je.effect,
                  persistent: je.persistent
                }, {
                  default: Ee(() => [
                    $(S(fs), {
                      closable: !1,
                      size: j.value,
                      type: je.tagType,
                      effect: je.tagEffect,
                      "disable-transitions": ""
                    }, {
                      default: Ee(() => [
                        ve(
                          "span",
                          {
                            class: X(S(u).e("tags-text"))
                          },
                          " + " + qe(z.value.length - je.maxCollapseTags),
                          3
                        )
                      ]),
                      _: 1
                    }, 8, ["size", "type", "effect"])
                  ]),
                  content: Ee(() => [
                    $(S(Ba), { "max-height": je.maxCollapseTagsTooltipHeight }, {
                      default: Ee(() => [
                        ve(
                          "div",
                          {
                            class: X(S(u).e("collapse-tags"))
                          },
                          [
                            (G(!0), ue(
                              Ge,
                              null,
                              on(M.value, (Ct, vn) => (G(), ue(
                                "div",
                                {
                                  key: vn,
                                  class: X(S(u).e("collapse-tag"))
                                },
                                [
                                  (G(), Me(S(fs), {
                                    key: Ct.key,
                                    class: "in-tooltip",
                                    type: je.tagType,
                                    size: j.value,
                                    effect: je.tagEffect,
                                    hit: Ct.hitState,
                                    closable: Ct.closable,
                                    "disable-transitions": "",
                                    onClose: (tn) => xe(Ct)
                                  }, {
                                    default: Ee(() => [
                                      ve(
                                        "span",
                                        null,
                                        qe(Ct.text),
                                        1
                                      )
                                    ]),
                                    _: 2
                                  }, 1032, ["type", "size", "effect", "hit", "closable", "onClose"]))
                                ],
                                2
                              ))),
                              128
                            ))
                          ],
                          2
                        )
                      ]),
                      _: 1
                    }, 8, ["max-height"])
                  ]),
                  _: 1
                }, 8, ["disabled", "popper-class", "popper-style", "effect", "persistent"])) : Ie("v-if", !0),
                je.filterable && !S(v) ? _t((G(), ue("input", {
                  key: 1,
                  "onUpdate:modelValue": lt[2] || (lt[2] = (Ct) => R.value = Ct),
                  type: "text",
                  class: X(S(u).e("search-input")),
                  placeholder: K.value ? "" : L.value,
                  onInput: lt[3] || (lt[3] = (Ct) => dt(R.value, Ct)),
                  onClick: lt[4] || (lt[4] = Et((Ct) => $e(!0), ["stop"])),
                  onKeydown: uo(De, ["delete"]),
                  onCompositionstart: lt[5] || (lt[5] = (...Ct) => S(y) && S(y)(...Ct)),
                  onCompositionupdate: lt[6] || (lt[6] = (...Ct) => S(y) && S(y)(...Ct)),
                  onCompositionend: lt[7] || (lt[7] = (...Ct) => S(y) && S(y)(...Ct))
                }, null, 42, kve)), [
                  [d1, R.value]
                ]) : Ie("v-if", !0)
              ],
              2
            )) : Ie("v-if", !0)
          ],
          38
        )), [
          [S(Cc), he, ge.value]
        ])
      ]),
      content: Ee(() => [
        je.$slots.header ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(u).e("header")),
            onClick: lt[11] || (lt[11] = Et(() => {
            }, ["stop"]))
          },
          [
            Oe(je.$slots, "header")
          ],
          2
        )) : Ie("v-if", !0),
        _t($(S(HF), {
          ref_key: "cascaderPanelRef",
          ref: E,
          modelValue: Z.value,
          "onUpdate:modelValue": lt[12] || (lt[12] = (Ct) => Z.value = Ct),
          options: je.options,
          props: l.props,
          border: !1,
          "render-label": je.$slots.default,
          onExpandChange: tt,
          onClose: lt[13] || (lt[13] = (Ct) => je.$nextTick(() => $e(!1)))
        }, {
          empty: Ee(() => [
            Oe(je.$slots, "empty")
          ]),
          _: 3
        }, 8, ["modelValue", "options", "props", "render-label"]), [
          [Jt, !k.value]
        ]),
        je.filterable ? _t((G(), Me(S(Ba), {
          key: 1,
          ref_key: "suggestionPanel",
          ref: I,
          tag: "ul",
          class: X(S(u).e("suggestion-panel")),
          "view-class": S(u).e("suggestion-list"),
          onKeydown: Ae
        }, {
          default: Ee(() => [
            D.value.length ? (G(!0), ue(
              Ge,
              { key: 0 },
              on(D.value, (Ct) => (G(), ue("li", {
                key: Ct.uid,
                class: X([
                  S(u).e("suggestion-item"),
                  S(u).is("checked", Ct.checked)
                ]),
                tabindex: -1,
                onClick: (vn) => Ue(Ct)
              }, [
                Oe(je.$slots, "suggestion-item", { item: Ct }, () => [
                  ve(
                    "span",
                    null,
                    qe(Ct.text),
                    1
                  ),
                  Ct.checked ? (G(), Me(S(ut), { key: 0 }, {
                    default: Ee(() => [
                      $(S(ch))
                    ]),
                    _: 1
                  })) : Ie("v-if", !0)
                ])
              ], 10, Nve))),
              128
            )) : Oe(je.$slots, "empty", { key: 1 }, () => [
              ve(
                "li",
                {
                  class: X(S(u).e("empty-text"))
                },
                qe(S(p)("el.cascader.noMatch")),
                3
              )
            ])
          ]),
          _: 3
        }, 8, ["class", "view-class"])), [
          [Jt, k.value]
        ]) : Ie("v-if", !0),
        je.$slots.footer ? (G(), ue(
          "div",
          {
            key: 2,
            class: X(S(u).e("footer")),
            onClick: lt[14] || (lt[14] = Et(() => {
            }, ["stop"]))
          },
          [
            Oe(je.$slots, "footer")
          ],
          2
        )) : Ie("v-if", !0)
      ]),
      _: 3
    }, 8, ["visible", "teleported", "popper-class", "popper-style", "fallback-placements", "placement", "transition", "effect", "persistent"]));
  }
});
var Ave = /* @__PURE__ */ Je(Mve, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/cascader/src/cascader.vue"]]);
const Rve = Dt(Ave), Dve = Xe({
  checked: Boolean,
  disabled: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger"],
    default: "primary"
  }
}), Lve = {
  "update:checked": (e) => Tn(e),
  [en]: (e) => Tn(e)
}, Bve = /* @__PURE__ */ le({
  name: "ElCheckTag",
  __name: "check-tag",
  props: Dve,
  emits: Lve,
  setup(e, { emit: t }) {
    const n = e, o = t, l = Ve("check-tag"), r = O(() => [
      l.b(),
      l.is("checked", n.checked),
      l.is("disabled", n.disabled),
      l.m(n.type || "primary")
    ]), a = () => {
      if (n.disabled)
        return;
      const i = !n.checked;
      o(en, i), o("update:checked", i);
    };
    return (i, s) => (G(), ue(
      "span",
      {
        class: X(r.value),
        onClick: a
      },
      [
        Oe(i.$slots, "default")
      ],
      2
    ));
  }
});
var Fve = /* @__PURE__ */ Je(Bve, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/check-tag/src/check-tag.vue"]]);
const Vve = Dt(Fve), zve = Xe({
  tag: {
    type: String,
    default: "div"
  },
  span: {
    type: Number,
    default: 24
  },
  offset: {
    type: Number,
    default: 0
  },
  pull: {
    type: Number,
    default: 0
  },
  push: {
    type: Number,
    default: 0
  },
  xs: {
    type: ye([Number, Object]),
    default: () => lo({})
  },
  sm: {
    type: ye([Number, Object]),
    default: () => lo({})
  },
  md: {
    type: ye([Number, Object]),
    default: () => lo({})
  },
  lg: {
    type: ye([Number, Object]),
    default: () => lo({})
  },
  xl: {
    type: ye([Number, Object]),
    default: () => lo({})
  }
}), jF = Symbol("rowContextKey"), Hve = /* @__PURE__ */ le({
  name: "ElCol",
  __name: "col",
  props: zve,
  setup(e) {
    const t = e, { gutter: n } = ze(jF, { gutter: O(() => 0) }), o = Ve("col"), l = O(() => {
      const a = {};
      return n.value && (a.paddingLeft = a.paddingRight = `${n.value / 2}px`), a;
    }), r = O(() => {
      const a = [];
      return ["span", "offset", "pull", "push"].forEach((c) => {
        const u = t[c];
        mt(u) && (c === "span" ? a.push(o.b(`${t[c]}`)) : u > 0 && a.push(o.b(`${c}-${t[c]}`)));
      }), ["xs", "sm", "md", "lg", "xl"].forEach((c) => {
        mt(t[c]) ? a.push(o.b(`${c}-${t[c]}`)) : Mt(t[c]) && Object.entries(t[c]).forEach(([u, d]) => {
          a.push(
            u !== "span" ? o.b(`${c}-${u}-${d}`) : o.b(`${c}-${d}`)
          );
        });
      }), n.value && a.push(o.is("guttered")), [o.b(), a];
    });
    return (a, i) => (G(), Me(Ht(a.tag), {
      class: X(r.value),
      style: gt(l.value)
    }, {
      default: Ee(() => [
        Oe(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "style"]));
  }
});
var jve = /* @__PURE__ */ Je(Hve, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/col/src/col.vue"]]);
const Wve = Dt(jve), aN = (e) => mt(e) || rt(e) || We(e), Kve = Xe({
  accordion: Boolean,
  modelValue: {
    type: ye([Array, String, Number]),
    default: () => lo([])
  },
  expandIconPosition: {
    type: ye([String]),
    default: "right"
  },
  beforeCollapse: {
    type: ye(
      Function
    )
  }
}), Uve = {
  [It]: aN,
  [en]: aN
}, WF = Symbol("collapseContextKey"), iN = "ElCollapse", Gve = (e, t) => {
  const n = /* @__PURE__ */ H(ll(e.modelValue)), o = (a) => {
    n.value = a;
    const i = e.accordion ? n.value[0] : n.value;
    t(It, i), t(en, i);
  }, l = (a) => {
    if (e.accordion)
      o([n.value[0] === a ? "" : a]);
    else {
      const i = [...n.value], s = i.indexOf(a);
      s > -1 ? i.splice(s, 1) : i.push(a), o(i);
    }
  }, r = (a) => Rt(void 0, null, function* () {
    const { beforeCollapse: i } = e;
    if (!i) {
      l(a);
      return;
    }
    const s = i(a);
    [
      mc(s),
      Tn(s)
    ].includes(!0) || no(
      iN,
      "beforeCollapse must return type `Promise<boolean>` or `boolean`"
    ), mc(s) ? s.then((u) => {
      u !== !1 && l(a);
    }).catch((u) => {
      Gt(iN, `some error occurred: ${u}`);
    }) : s && l(a);
  });
  return pe(
    () => e.modelValue,
    () => n.value = ll(e.modelValue),
    { deep: !0 }
  ), at(WF, {
    activeNames: n,
    handleItemClick: r
  }), {
    activeNames: n,
    setActiveNames: o
  };
}, Yve = (e) => {
  const t = Ve("collapse");
  return {
    rootKls: O(() => [
      t.b(),
      t.b(`icon-position-${e.expandIconPosition}`)
    ])
  };
}, Xve = /* @__PURE__ */ le({
  name: "ElCollapse",
  __name: "collapse",
  props: Kve,
  emits: Uve,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, { activeNames: r, setActiveNames: a } = Gve(o, l), { rootKls: i } = Yve(o);
    return t({
      activeNames: r,
      setActiveNames: a
    }), (s, c) => (G(), ue(
      "div",
      {
        class: X(S(i))
      },
      [
        Oe(s.$slots, "default")
      ],
      2
    ));
  }
});
var qve = /* @__PURE__ */ Je(Xve, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse.vue"]]);
const Jve = /* @__PURE__ */ le({
  name: "ElCollapseTransition",
  __name: "collapse-transition",
  setup(e) {
    const t = Ve("collapse-transition"), n = (l) => {
      l.style.maxHeight = "", l.style.overflow = l.dataset.oldOverflow, l.style.paddingTop = l.dataset.oldPaddingTop, l.style.paddingBottom = l.dataset.oldPaddingBottom;
    }, o = {
      beforeEnter(l) {
        l.dataset || (l.dataset = {}), l.dataset.oldPaddingTop = l.style.paddingTop, l.dataset.oldPaddingBottom = l.style.paddingBottom, l.style.height && (l.dataset.elExistsHeight = l.style.height), l.style.maxHeight = 0, l.style.paddingTop = 0, l.style.paddingBottom = 0;
      },
      enter(l) {
        requestAnimationFrame(() => {
          l.dataset.oldOverflow = l.style.overflow, l.dataset.elExistsHeight ? l.style.maxHeight = l.dataset.elExistsHeight : l.scrollHeight !== 0 ? l.style.maxHeight = `${l.scrollHeight}px` : l.style.maxHeight = 0, l.style.paddingTop = l.dataset.oldPaddingTop, l.style.paddingBottom = l.dataset.oldPaddingBottom, l.style.overflow = "hidden";
        });
      },
      afterEnter(l) {
        l.style.maxHeight = "", l.style.overflow = l.dataset.oldOverflow;
      },
      enterCancelled(l) {
        n(l);
      },
      beforeLeave(l) {
        l.dataset || (l.dataset = {}), l.dataset.oldPaddingTop = l.style.paddingTop, l.dataset.oldPaddingBottom = l.style.paddingBottom, l.dataset.oldOverflow = l.style.overflow, l.style.maxHeight = `${l.scrollHeight}px`, l.style.overflow = "hidden";
      },
      leave(l) {
        l.scrollHeight !== 0 && (l.style.maxHeight = 0, l.style.paddingTop = 0, l.style.paddingBottom = 0);
      },
      afterLeave(l) {
        n(l);
      },
      leaveCancelled(l) {
        n(l);
      }
    };
    return (l, r) => (G(), Me(Vn, Ut({
      name: S(t).b()
    }, yq(o)), {
      default: Ee(() => [
        Oe(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["name"]));
  }
});
var Zve = /* @__PURE__ */ Je(Jve, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);
const j1 = Dt(Zve), Qve = Xe({
  title: {
    type: String,
    default: ""
  },
  name: {
    type: ye([String, Number]),
    default: void 0
  },
  icon: {
    type: Pn,
    default: Rl
  },
  disabled: Boolean
}), eme = (e) => {
  const t = ze(WF), { namespace: n } = Ve("collapse"), o = /* @__PURE__ */ H(!1), l = /* @__PURE__ */ H(!1), r = LO(), a = O(() => r.current++), i = O(() => {
    var f;
    return (f = e.name) != null ? f : `${n.value}-id-${r.prefix}-${S(a)}`;
  }), s = O(
    () => t == null ? void 0 : t.activeNames.value.includes(S(i))
  );
  return {
    focusing: o,
    id: a,
    isActive: s,
    handleFocus: () => {
      setTimeout(() => {
        l.value ? l.value = !1 : o.value = !0;
      }, 50);
    },
    handleHeaderClick: (f) => {
      if (e.disabled)
        return;
      const p = f.target;
      p != null && p.closest("input, textarea, select") || (t == null || t.handleItemClick(S(i)), o.value = !1, l.value = !0);
    },
    handleEnterClick: (f) => {
      const p = f.target;
      p != null && p.closest("input, textarea, select") || (f.preventDefault(), t == null || t.handleItemClick(S(i)));
    }
  };
}, tme = (e, { focusing: t, isActive: n, id: o }) => {
  const l = Ve("collapse"), r = O(() => [
    l.b("item"),
    l.is("active", S(n)),
    l.is("disabled", e.disabled)
  ]), a = O(() => [
    l.be("item", "header"),
    l.is("active", S(n)),
    { focusing: S(t) && !e.disabled }
  ]), i = O(() => [
    l.be("item", "arrow"),
    l.is("active", S(n))
  ]), s = O(() => [l.be("item", "title")]), c = O(() => l.be("item", "wrap")), u = O(() => l.be("item", "content")), d = O(() => l.b(`content-${S(o)}`)), f = O(() => l.b(`head-${S(o)}`));
  return {
    itemTitleKls: s,
    arrowKls: i,
    headKls: a,
    rootKls: r,
    itemWrapperKls: c,
    itemContentKls: u,
    scopedContentId: d,
    scopedHeadId: f
  };
}, nme = ["id", "aria-expanded", "aria-controls", "aria-describedby", "tabindex", "aria-disabled"], ome = ["id", "aria-hidden", "aria-labelledby"], lme = /* @__PURE__ */ le({
  name: "ElCollapseItem",
  __name: "collapse-item",
  props: Qve,
  setup(e, { expose: t }) {
    const n = e, {
      focusing: o,
      id: l,
      isActive: r,
      handleFocus: a,
      handleHeaderClick: i,
      handleEnterClick: s
    } = eme(n), {
      arrowKls: c,
      headKls: u,
      rootKls: d,
      itemTitleKls: f,
      itemWrapperKls: p,
      itemContentKls: m,
      scopedContentId: v,
      scopedHeadId: h
    } = tme(n, { focusing: o, isActive: r, id: l });
    return t({
      isActive: r
    }), (g, y) => (G(), ue(
      "div",
      {
        class: X(S(d))
      },
      [
        ve("div", {
          id: S(h),
          class: X(S(u)),
          "aria-expanded": S(r),
          "aria-controls": S(v),
          "aria-describedby": S(v),
          tabindex: g.disabled ? void 0 : 0,
          "aria-disabled": g.disabled,
          role: "button",
          onClick: y[0] || (y[0] = (...b) => S(i) && S(i)(...b)),
          onKeydown: y[1] || (y[1] = uo(Et(
            (...b) => S(s) && S(s)(...b),
            ["stop"]
          ), ["space", "enter"])),
          onFocus: y[2] || (y[2] = (...b) => S(a) && S(a)(...b)),
          onBlur: y[3] || (y[3] = (b) => o.value = !1)
        }, [
          ve(
            "span",
            {
              class: X(S(f))
            },
            [
              Oe(g.$slots, "title", { isActive: S(r) }, () => [
                Ft(
                  qe(g.title),
                  1
                )
              ])
            ],
            2
          ),
          Oe(g.$slots, "icon", { isActive: S(r) }, () => [
            $(S(ut), {
              class: X(S(c))
            }, {
              default: Ee(() => [
                (G(), Me(Ht(g.icon)))
              ]),
              _: 1
            }, 8, ["class"])
          ])
        ], 42, nme),
        $(S(j1), null, {
          default: Ee(() => [
            _t(ve("div", {
              id: S(v),
              role: "region",
              class: X(S(p)),
              "aria-hidden": !S(r),
              "aria-labelledby": S(h)
            }, [
              ve(
                "div",
                {
                  class: X(S(m))
                },
                [
                  Oe(g.$slots, "default")
                ],
                2
              )
            ], 10, ome), [
              [Jt, S(r)]
            ])
          ]),
          _: 3
        })
      ],
      2
    ));
  }
});
var KF = /* @__PURE__ */ Je(lme, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse/src/collapse-item.vue"]]);
const rme = Dt(qve, {
  CollapseItem: KF
}), ame = oo(KF), UF = Xe({
  color: {
    type: ye(Object),
    required: !0
  },
  vertical: Boolean,
  disabled: Boolean
}), ime = UF;
let GC = !1;
function hx(e, t) {
  if (!Sn)
    return;
  const n = function(r) {
    var a;
    (a = t.drag) == null || a.call(t, r);
  }, o = function(r) {
    var a;
    document.removeEventListener("mousemove", n), document.removeEventListener("mouseup", o), document.removeEventListener("touchmove", n), document.removeEventListener("touchend", o), document.onselectstart = null, document.ondragstart = null, GC = !1, (a = t.end) == null || a.call(t, r);
  }, l = function(r) {
    var a;
    GC || (document.onselectstart = () => !1, document.ondragstart = () => !1, document.addEventListener("mousemove", n), document.addEventListener("mouseup", o), document.addEventListener("touchmove", n), document.addEventListener("touchend", o), GC = !0, (a = t.start) == null || a.call(t, r));
  };
  e.addEventListener("mousedown", l), e.addEventListener("touchstart", l, { passive: !1 });
}
const sN = (e) => {
  let t = 0, n = e;
  for (; n; )
    t += n.offsetTop, n = n.offsetParent;
  return t;
}, gx = (e, t) => Math.abs(sN(e) - sN(t)), GF = (e) => {
  let t, n;
  return e.type === "touchend" ? (n = e.changedTouches[0].clientY, t = e.changedTouches[0].clientX) : e.type.startsWith("touch") ? (n = e.touches[0].clientY, t = e.touches[0].clientX) : (n = e.clientY, t = e.clientX), {
    clientX: t,
    clientY: n
  };
}, YF = (e, { key: t, minValue: n, maxValue: o }) => {
  const l = xt(), r = /* @__PURE__ */ Ce(), a = /* @__PURE__ */ Ce(), i = O(() => e.color.get(t));
  function s(f) {
    var p;
    if (e.disabled)
      return;
    f.target !== r.value && c(f), (p = r.value) == null || p.focus();
  }
  function c(f) {
    if (!a.value || !r.value || e.disabled)
      return;
    const m = l.vnode.el.getBoundingClientRect(), { clientX: v, clientY: h } = GF(f);
    let g;
    if (e.vertical) {
      let y = h - m.top;
      y = Math.max(r.value.offsetHeight / 2, y), y = Math.min(y, m.height - r.value.offsetHeight / 2), g = Math.round(
        (y - r.value.offsetHeight / 2) / (m.height - r.value.offsetHeight) * o
      );
    } else {
      let y = v - m.left;
      y = Math.max(r.value.offsetWidth / 2, y), y = Math.min(y, m.width - r.value.offsetWidth / 2), g = Math.round(
        (y - r.value.offsetWidth / 2) / (m.width - r.value.offsetWidth) * o
      );
    }
    e.color.set(t, g);
  }
  function u(f) {
    if (e.disabled)
      return;
    const { shiftKey: p } = f, m = Nn(f), v = p ? 10 : 1, h = t === "hue" ? -1 : 1;
    let g = !0;
    switch (m) {
      case Ye.left:
      case Ye.down:
        d(-v * h);
        break;
      case Ye.right:
      case Ye.up:
        d(v * h);
        break;
      case Ye.home:
        e.color.set(t, t === "hue" ? o : n);
        break;
      case Ye.end:
        e.color.set(t, t === "hue" ? n : o);
        break;
      case Ye.pageDown:
        d(-4 * h);
        break;
      case Ye.pageUp:
        d(4 * h);
        break;
      default:
        g = !1;
        break;
    }
    g && f.preventDefault();
  }
  function d(f) {
    let p = i.value + f;
    p = p < n ? n : p > o ? o : p, e.color.set(t, p);
  }
  return {
    thumb: r,
    bar: a,
    currentValue: i,
    handleDrag: c,
    handleClick: s,
    handleKeydown: u
  };
}, XF = (e, {
  namespace: t,
  maxValue: n,
  bar: o,
  thumb: l,
  currentValue: r,
  handleDrag: a,
  getBackground: i
}) => {
  const s = xt(), c = Ve(t), u = /* @__PURE__ */ H(0), d = /* @__PURE__ */ H(0), f = /* @__PURE__ */ H();
  function p() {
    if (!l.value || e.vertical)
      return 0;
    const w = s.vnode.el, x = r.value;
    return w ? Math.round(
      x * (w.offsetWidth - l.value.offsetWidth / 2) / n
    ) : 0;
  }
  function m() {
    if (!l.value)
      return 0;
    const w = s.vnode.el;
    if (!e.vertical)
      return 0;
    const x = r.value;
    return w ? Math.round(
      x * (w.offsetHeight - l.value.offsetHeight / 2) / n
    ) : 0;
  }
  function v() {
    u.value = p(), d.value = m(), f.value = i == null ? void 0 : i();
  }
  nt(() => {
    if (!o.value || !l.value)
      return;
    const w = {
      drag: (x) => {
        a(x);
      },
      end: (x) => {
        a(x);
      }
    };
    hx(o.value, w), hx(l.value, w), v();
  }), pe(r, () => v()), pe(
    () => e.color.value,
    () => v()
  );
  const h = O(() => [
    c.b(),
    c.is("vertical", e.vertical),
    c.is("disabled", e.disabled)
  ]), g = O(() => c.e("bar")), y = O(() => c.e("thumb")), b = O(() => ({ background: f.value })), C = O(() => ({
    left: ao(u.value),
    top: ao(d.value)
  }));
  return {
    rootKls: h,
    barKls: g,
    barStyle: b,
    thumbKls: y,
    thumbStyle: C,
    thumbLeft: u,
    thumbTop: d,
    update: v
  };
}, sme = ["aria-label", "aria-valuenow", "aria-valuetext", "aria-orientation", "tabindex", "aria-disabled"], cN = 0, YC = 100, cme = /* @__PURE__ */ le({
  name: "ElColorAlphaSlider",
  __name: "alpha-slider",
  props: UF,
  setup(e, { expose: t }) {
    const n = e, { currentValue: o, bar: l, thumb: r, handleDrag: a, handleClick: i, handleKeydown: s } = YF(n, { key: "alpha", minValue: cN, maxValue: YC }), { rootKls: c, barKls: u, barStyle: d, thumbKls: f, thumbStyle: p, update: m } = XF(n, {
      namespace: "color-alpha-slider",
      maxValue: YC,
      currentValue: o,
      bar: l,
      thumb: r,
      handleDrag: a,
      getBackground: y
    }), { t: v } = an(), h = O(() => v("el.colorpicker.alphaLabel")), g = O(() => v("el.colorpicker.alphaDescription", {
      alpha: o.value,
      color: n.color.value
    }));
    function y() {
      if (n.color && n.color.value) {
        const { r: b, g: C, b: w } = n.color.toRgb();
        return `linear-gradient(to right, rgba(${b}, ${C}, ${w}, 0) 0%, rgba(${b}, ${C}, ${w}, 1) 100%)`;
      }
      return "";
    }
    return t({
      update: m,
      bar: l,
      thumb: r
    }), (b, C) => (G(), ue(
      "div",
      {
        class: X(S(c))
      },
      [
        ve(
          "div",
          {
            ref_key: "bar",
            ref: l,
            class: X(S(u)),
            style: gt(S(d)),
            onClick: C[0] || (C[0] = (...w) => S(i) && S(i)(...w))
          },
          null,
          6
        ),
        ve("div", {
          ref_key: "thumb",
          ref: r,
          class: X(S(f)),
          style: gt(S(p)),
          "aria-label": h.value,
          "aria-valuenow": S(o),
          "aria-valuetext": g.value,
          "aria-orientation": b.vertical ? "vertical" : "horizontal",
          "aria-valuemin": cN,
          "aria-valuemax": YC,
          role: "slider",
          tabindex: b.disabled ? void 0 : 0,
          "aria-disabled": b.disabled,
          onKeydown: C[1] || (C[1] = (...w) => S(s) && S(s)(...w))
        }, null, 46, sme)
      ],
      2
    ));
  }
});
var ume = /* @__PURE__ */ Je(cme, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker-panel/src/components/alpha-slider.vue"]]);
const dme = ["aria-label", "aria-valuenow", "aria-valuetext", "aria-orientation", "tabindex", "aria-disabled"], uN = 0, XC = 360, fme = /* @__PURE__ */ le({
  name: "ElColorHueSlider",
  __name: "hue-slider",
  props: ime,
  setup(e, { expose: t }) {
    const n = e, { currentValue: o, bar: l, thumb: r, handleDrag: a, handleClick: i, handleKeydown: s } = YF(n, { key: "hue", minValue: uN, maxValue: XC }), { rootKls: c, barKls: u, thumbKls: d, thumbStyle: f, thumbTop: p, update: m } = XF(n, {
      namespace: "color-hue-slider",
      maxValue: XC,
      currentValue: o,
      bar: l,
      thumb: r,
      handleDrag: a
    }), { t: v } = an(), h = O(() => v("el.colorpicker.hueLabel")), g = O(() => v("el.colorpicker.hueDescription", {
      hue: o.value,
      color: n.color.value
    }));
    return t({
      bar: l,
      thumb: r,
      thumbTop: p,
      update: m
    }), (y, b) => (G(), ue(
      "div",
      {
        class: X(S(c))
      },
      [
        ve(
          "div",
          {
            ref_key: "bar",
            ref: l,
            class: X(S(u)),
            onClick: b[0] || (b[0] = (...C) => S(i) && S(i)(...C))
          },
          null,
          2
        ),
        ve("div", {
          ref_key: "thumb",
          ref: r,
          class: X(S(d)),
          style: gt(S(f)),
          "aria-label": h.value,
          "aria-valuenow": S(o),
          "aria-valuetext": g.value,
          "aria-orientation": y.vertical ? "vertical" : "horizontal",
          "aria-valuemin": uN,
          "aria-valuemax": XC,
          role: "slider",
          tabindex: y.disabled ? void 0 : 0,
          "aria-disabled": y.disabled,
          onKeydown: b[1] || (b[1] = (...C) => S(s) && S(s)(...C))
        }, null, 46, dme)
      ],
      2
    ));
  }
});
var pme = /* @__PURE__ */ Je(fme, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker-panel/src/components/hue-slider.vue"]]);
const vme = Xe({
  colors: {
    type: ye(Array),
    required: !0
  },
  color: {
    type: ye(Object),
    required: !0
  },
  enableAlpha: {
    type: Boolean,
    required: !0
  },
  disabled: Boolean
}), qF = Xe({
  modelValue: {
    type: ye(String),
    default: void 0
  },
  border: {
    type: Boolean,
    default: !0
  },
  showAlpha: Boolean,
  colorFormat: String,
  disabled: Boolean,
  predefine: {
    type: ye(Array)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), mme = {
  [It]: (e) => rt(e) || wo(e)
}, JF = Symbol("colorCommonPickerKey"), ZF = Symbol("colorPickerPanelContextKey");
class D0 {
  constructor(t = {}) {
    this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100, this._tiny = new xn(), this._isValid = !1, this.enableAlpha = !1, this.format = "", this.value = "";
    for (const n in t)
      hn(t, n) && (this[n] = t[n]);
    t.value ? this.fromString(t.value) : this.doOnChange();
  }
  set(t, n) {
    if (arguments.length === 1 && typeof t == "object") {
      for (const o in t)
        hn(t, o) && this.set(o, t[o]);
      return;
    }
    this[`_${t}`] = n, this._isValid = !0, this.doOnChange();
  }
  get(t) {
    return ["hue", "saturation", "value", "alpha"].includes(t) ? Math.round(this[`_${t}`]) : this[`_${t}`];
  }
  toRgb() {
    return this._isValid ? this._tiny.toRgb() : { r: 255, g: 255, b: 255, a: 0 };
  }
  fromString(t) {
    const n = new xn(t);
    if (this._isValid = n.isValid, n.isValid) {
      const { h: o, s: l, v: r, a } = n.toHsv();
      this._hue = o, this._saturation = l * 100, this._value = r * 100, this._alpha = a * 100;
    } else
      this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100;
    this.doOnChange();
  }
  clear() {
    this._isValid = !1, this.value = "", this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100;
  }
  compare(t) {
    const n = new xn({
      h: t._hue,
      s: t._saturation / 100,
      v: t._value / 100,
      a: t._alpha / 100
    });
    return this._tiny.equals(n);
  }
  doOnChange() {
    const { _hue: t, _saturation: n, _value: o, _alpha: l, format: r, enableAlpha: a } = this;
    let i = r || (a ? "rgb" : "hex");
    r === "hex" && a && (i = "hex8"), this._tiny = new xn({
      h: t,
      s: n / 100,
      v: o / 100,
      a: l / 100
    }), this.value = this._isValid ? this._tiny.toString(i) : "";
  }
}
const hme = (e) => {
  const { currentColor: t } = ze(ZF), n = /* @__PURE__ */ H(l(e.colors, e.color));
  pe(
    () => t.value,
    (r) => {
      const a = new D0({
        value: r,
        enableAlpha: e.enableAlpha
      });
      n.value.forEach((i) => {
        i.selected = a.compare(i);
      });
    }
  ), Ot(() => {
    n.value = l(e.colors, e.color);
  });
  function o(r) {
    e.color.fromString(e.colors[r]);
  }
  function l(r, a) {
    return r.map((i) => {
      const s = new D0({
        value: i,
        enableAlpha: e.enableAlpha
      });
      return s.selected = s.compare(a), s;
    });
  }
  return {
    rgbaColors: n,
    handleSelect: o
  };
}, gme = (e) => {
  const t = Ve("color-predefine"), n = O(() => [t.b(), t.is("disabled", e.disabled)]), o = O(() => t.e("colors"));
  function l(r) {
    return [
      t.e("color-selector"),
      t.is("alpha", r.get("alpha") < 100),
      { selected: r.selected }
    ];
  }
  return {
    rootKls: n,
    colorsKls: o,
    colorSelectorKls: l
  };
}, bme = ["disabled", "aria-label", "onClick"], yme = /* @__PURE__ */ le({
  name: "ElColorPredefine",
  __name: "predefine",
  props: vme,
  setup(e) {
    const t = e, { rgbaColors: n, handleSelect: o } = hme(t), { rootKls: l, colorsKls: r, colorSelectorKls: a } = gme(t), { t: i } = an(), s = (c) => i("el.colorpicker.predefineDescription", { value: c });
    return (c, u) => (G(), ue(
      "div",
      {
        class: X(S(l))
      },
      [
        ve(
          "div",
          {
            class: X(S(r))
          },
          [
            (G(!0), ue(
              Ge,
              null,
              on(S(n), (d, f) => (G(), ue("button", {
                key: c.colors[f],
                type: "button",
                disabled: c.disabled,
                "aria-label": s(d.value),
                class: X(S(a)(d)),
                onClick: (p) => S(o)(f)
              }, [
                ve(
                  "div",
                  {
                    style: gt({ backgroundColor: d.value })
                  },
                  null,
                  4
                )
              ], 10, bme))),
              128
            ))
          ],
          2
        )
      ],
      2
    ));
  }
});
var Sme = /* @__PURE__ */ Je(yme, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker-panel/src/components/predefine.vue"]]);
const Cme = Xe({
  color: {
    type: ye(Object),
    required: !0
  },
  disabled: Boolean
}), wme = (e) => {
  const t = xt(), n = /* @__PURE__ */ H(), o = /* @__PURE__ */ H(0), l = /* @__PURE__ */ H(0), r = /* @__PURE__ */ H("hsl(0, 100%, 50%)"), a = O(() => e.color.get("saturation")), i = O(() => e.color.get("value")), s = O(() => e.color.get("hue"));
  function c(m) {
    var v;
    if (e.disabled)
      return;
    m.target !== n.value && u(m), (v = n.value) == null || v.focus({ preventScroll: !0 });
  }
  function u(m) {
    if (e.disabled)
      return;
    const h = t.vnode.el.getBoundingClientRect(), { clientX: g, clientY: y } = GF(m);
    let b = g - h.left, C = y - h.top;
    b = Math.max(0, b), b = Math.min(b, h.width), C = Math.max(0, C), C = Math.min(C, h.height), l.value = b, o.value = C, e.color.set({
      saturation: b / h.width * 100,
      value: 100 - C / h.height * 100
    });
  }
  function d(m) {
    if (e.disabled)
      return;
    const { shiftKey: v } = m, h = Nn(m), g = v ? 10 : 1;
    let y = !0;
    switch (h) {
      case Ye.left:
        f(-g);
        break;
      case Ye.right:
        f(g);
        break;
      case Ye.up:
        p(g);
        break;
      case Ye.down:
        p(-g);
        break;
      default:
        y = !1;
        break;
    }
    y && m.preventDefault();
  }
  function f(m) {
    let v = a.value + m;
    v = v < 0 ? 0 : v > 100 ? 100 : v, e.color.set("saturation", v);
  }
  function p(m) {
    let v = i.value + m;
    v = v < 0 ? 0 : v > 100 ? 100 : v, e.color.set("value", v);
  }
  return {
    cursorRef: n,
    cursorTop: o,
    cursorLeft: l,
    background: r,
    saturation: a,
    brightness: i,
    hue: s,
    handleClick: c,
    handleDrag: u,
    handleKeydown: d
  };
}, $me = (e, {
  cursorTop: t,
  cursorLeft: n,
  background: o,
  handleDrag: l
}) => {
  const r = xt(), a = Ve("color-svpanel");
  function i() {
    const f = e.color.get("saturation"), p = e.color.get("value"), m = r.vnode.el, { clientWidth: v, clientHeight: h } = m;
    n.value = f * v / 100, t.value = (100 - p) * h / 100, o.value = `hsl(${e.color.get("hue")}, 100%, 50%)`;
  }
  nt(() => {
    hx(r.vnode.el, {
      drag: (f) => {
        l(f);
      },
      end: (f) => {
        l(f);
      }
    }), i();
  }), pe(
    [
      () => e.color.get("hue"),
      () => e.color.get("value"),
      () => e.color.value
    ],
    () => i()
  );
  const s = O(() => a.b()), c = O(() => a.e("cursor")), u = O(() => ({
    backgroundColor: o.value
  })), d = O(() => ({
    top: ao(t.value),
    left: ao(n.value)
  }));
  return {
    rootKls: s,
    cursorKls: c,
    rootStyle: u,
    cursorStyle: d,
    update: i
  };
}, xme = ["tabindex", "aria-disabled", "aria-label", "aria-valuenow", "aria-valuetext"], Eme = /* @__PURE__ */ le({
  name: "ElSvPanel",
  __name: "sv-panel",
  props: Cme,
  setup(e, { expose: t }) {
    const n = e, {
      cursorRef: o,
      cursorTop: l,
      cursorLeft: r,
      background: a,
      saturation: i,
      brightness: s,
      handleClick: c,
      handleDrag: u,
      handleKeydown: d
    } = wme(n), { rootKls: f, cursorKls: p, rootStyle: m, cursorStyle: v, update: h } = $me(
      n,
      {
        cursorTop: l,
        cursorLeft: r,
        background: a,
        handleDrag: u
      }
    ), { t: g } = an(), y = O(() => g("el.colorpicker.svLabel")), b = O(() => g("el.colorpicker.svDescription", {
      saturation: i.value,
      brightness: s.value,
      color: n.color.value
    }));
    return t({
      update: h
    }), (C, w) => (G(), ue(
      "div",
      {
        class: X(S(f)),
        style: gt(S(m)),
        onClick: w[1] || (w[1] = (...x) => S(c) && S(c)(...x))
      },
      [
        ve("div", {
          ref_key: "cursorRef",
          ref: o,
          class: X(S(p)),
          style: gt(S(v)),
          tabindex: C.disabled ? void 0 : 0,
          "aria-disabled": C.disabled,
          role: "slider",
          "aria-valuemin": "0,0",
          "aria-valuemax": "100,100",
          "aria-label": y.value,
          "aria-valuenow": `${S(i)},${S(s)}`,
          "aria-valuetext": b.value,
          onKeydown: w[0] || (w[0] = (...x) => S(d) && S(d)(...x))
        }, null, 46, xme)
      ],
      6
    ));
  }
});
var Ome = /* @__PURE__ */ Je(Eme, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker-panel/src/components/sv-panel.vue"]]);
const QF = (e, t) => {
  const n = /* @__PURE__ */ kt(
    new D0({
      enableAlpha: e.showAlpha,
      format: e.colorFormat || "",
      value: e.modelValue
    })
  );
  return pe(
    () => [e.colorFormat, e.showAlpha],
    () => {
      n.enableAlpha = e.showAlpha, n.format = e.colorFormat || n.format, n.doOnChange(), t(It, n.value);
    }
  ), {
    color: n
  };
}, _me = /* @__PURE__ */ le({
  name: "ElColorPickerPanel",
  __name: "color-picker-panel",
  props: qF,
  emits: mme,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = Ve("color-picker-panel"), { formItem: a } = cl(), i = io(), s = /* @__PURE__ */ H(), c = /* @__PURE__ */ H(), u = /* @__PURE__ */ H(), d = /* @__PURE__ */ H(), f = /* @__PURE__ */ H(""), { color: p } = ze(
      JF,
      () => QF(o, l),
      !0
    );
    function m() {
      p.fromString(f.value), p.value !== f.value && (f.value = p.value);
    }
    function v() {
      var g;
      o.validateEvent && ((g = a == null ? void 0 : a.validate) == null || g.call(a, "blur").catch((y) => Gt(y)));
    }
    function h() {
      var g, y, b;
      (g = s.value) == null || g.update(), (y = c.value) == null || y.update(), (b = u.value) == null || b.update();
    }
    return nt(() => {
      o.modelValue && (f.value = p.value), Ke(h);
    }), pe(
      () => o.modelValue,
      (g) => {
        g !== p.value && (g ? p.fromString(g) : p.clear());
      }
    ), pe(
      () => p.value,
      (g) => {
        l(It, g), f.value = g, o.validateEvent && (a == null || a.validate("change").catch((y) => Gt(y)));
      }
    ), at(ZF, {
      currentColor: O(() => p.value)
    }), t({
      color: p,
      inputRef: d,
      update: h
    }), (g, y) => (G(), ue(
      "div",
      {
        class: X([S(r).b(), S(r).is("disabled", S(i)), S(r).is("border", g.border)]),
        onFocusout: v
      },
      [
        ve(
          "div",
          {
            class: X(S(r).e("wrapper"))
          },
          [
            $(pme, {
              ref_key: "hueRef",
              ref: s,
              class: "hue-slider",
              color: S(p),
              vertical: "",
              disabled: S(i)
            }, null, 8, ["color", "disabled"]),
            $(Ome, {
              ref_key: "svRef",
              ref: c,
              color: S(p),
              disabled: S(i)
            }, null, 8, ["color", "disabled"])
          ],
          2
        ),
        g.showAlpha ? (G(), Me(ume, {
          key: 0,
          ref_key: "alphaRef",
          ref: u,
          color: S(p),
          disabled: S(i)
        }, null, 8, ["color", "disabled"])) : Ie("v-if", !0),
        g.predefine ? (G(), Me(Sme, {
          key: 1,
          ref: "predefine",
          "enable-alpha": g.showAlpha,
          color: S(p),
          colors: g.predefine,
          disabled: S(i)
        }, null, 8, ["enable-alpha", "color", "colors", "disabled"])) : Ie("v-if", !0),
        ve(
          "div",
          {
            class: X(S(r).e("footer"))
          },
          [
            $(S(Nl), {
              ref_key: "inputRef",
              ref: d,
              modelValue: f.value,
              "onUpdate:modelValue": y[0] || (y[0] = (b) => f.value = b),
              "validate-event": !1,
              size: "small",
              disabled: S(i),
              onChange: m
            }, null, 8, ["modelValue", "disabled"]),
            Oe(g.$slots, "footer")
          ],
          2
        )
      ],
      34
    ));
  }
});
var Ime = /* @__PURE__ */ Je(_me, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker-panel/src/color-picker-panel.vue"]]);
const e9 = Dt(Ime), Tme = Xe(Be(Be({
  persistent: {
    type: Boolean,
    default: !0
  },
  modelValue: {
    type: ye(String),
    default: void 0
  },
  id: String,
  showAlpha: Boolean,
  colorFormat: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  clearable: {
    type: Boolean,
    default: !0
  },
  size: Bo,
  popperClass: In.popperClass,
  popperStyle: In.popperStyle,
  tabindex: {
    type: [String, Number],
    default: 0
  },
  teleported: In.teleported,
  appendTo: In.appendTo,
  predefine: {
    type: ye(Array)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}, ad), zl(["ariaLabel"]))), Pme = {
  [It]: (e) => rt(e) || wo(e),
  [en]: (e) => rt(e) || wo(e),
  activeChange: (e) => rt(e) || wo(e),
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  clear: () => !0
}, kme = ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex"], Nme = /* @__PURE__ */ le({
  name: "ElColorPicker",
  __name: "color-picker",
  props: Tme,
  emits: Pme,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, { t: r } = an(), a = Ve("color"), { formItem: i } = cl(), s = Mo(), c = io(), { valueOnClear: u, isEmptyValue: d } = ih(o, null), f = QF(o, l), { inputId: p, isLabeledByFormItem: m } = zr(o, {
      formItemContext: i
    }), v = /* @__PURE__ */ H(), h = /* @__PURE__ */ H(), g = /* @__PURE__ */ H(), y = /* @__PURE__ */ H(!1), b = /* @__PURE__ */ H(!1);
    let C = !0;
    const { isFocused: w, handleFocus: x, handleBlur: E } = Os(h, {
      disabled: c,
      beforeBlur(q) {
        var K;
        return (K = v.value) == null ? void 0 : K.isFocusInsideContent(q);
      },
      afterBlur() {
        var q;
        F(!1), B(), o.validateEvent && ((q = i == null ? void 0 : i.validate) == null || q.call(i, "blur").catch((K) => Gt(K)));
      }
    }), I = Kae(
      () => {
        var q, K;
        return (K = (q = g.value) == null ? void 0 : q.color) != null ? K : f.color;
      }
    ), T = O(
      () => La(o, Object.keys(qF))
    ), P = O(() => !o.modelValue && !b.value ? "transparent" : D(I, o.showAlpha)), k = O(() => !o.modelValue && !b.value ? "" : I.value), N = O(() => m.value ? void 0 : o.ariaLabel || r("el.colorpicker.defaultLabel")), R = O(() => m.value ? i == null ? void 0 : i.labelId : void 0), z = O(() => [
      a.b("picker"),
      a.is("disabled", c.value),
      a.bm("picker", s.value),
      a.is("focused", w.value)
    ]);
    function D(q, K) {
      const { r: se, g: Z, b: ee, a: fe } = q.toRgb();
      return K ? `rgba(${se}, ${Z}, ${ee}, ${fe})` : `rgb(${se}, ${Z}, ${ee})`;
    }
    function F(q) {
      y.value = q;
    }
    const M = Dr(F, 100, { leading: !0 });
    function A() {
      c.value || F(!0);
    }
    function L() {
      M(!1), B();
    }
    function B() {
      Ke(() => {
        o.modelValue ? I.fromString(o.modelValue) : (I.value = "", Ke(() => {
          b.value = !1;
        }));
      });
    }
    function V() {
      c.value || (y.value && B(), M(!y.value));
    }
    function j() {
      const q = d(I.value) ? u.value : I.value;
      l(It, q), l(en, q), o.validateEvent && (i == null || i.validate("change").catch((K) => Gt(K))), M(!1), Ke(() => {
        const K = new D0({
          enableAlpha: o.showAlpha,
          format: o.colorFormat || "",
          value: o.modelValue
        });
        I.compare(K) || B();
      });
    }
    function W() {
      M(!1), l(It, u.value), l(en, u.value), o.modelValue !== u.value && o.validateEvent && (i == null || i.validate("change").catch((q) => Gt(q))), B(), l("clear");
    }
    function Y() {
      var q, K;
      (K = (q = g == null ? void 0 : g.value) == null ? void 0 : q.inputRef) == null || K.focus();
    }
    function U() {
      y.value && (L(), w.value && re());
    }
    function te(q) {
      q.preventDefault(), q.stopPropagation(), F(!1), B();
    }
    function J(q) {
      switch (Nn(q)) {
        case Ye.enter:
        case Ye.numpadEnter:
        case Ye.space:
          q.preventDefault(), q.stopPropagation(), A();
          break;
        case Ye.esc:
          te(q);
          break;
      }
    }
    function re() {
      h.value.focus();
    }
    function oe() {
      h.value.blur();
    }
    return pe(
      () => k.value,
      (q) => {
        C && l("activeChange", q), C = !0;
      }
    ), pe(
      () => I.value,
      () => {
        !o.modelValue && !b.value && (b.value = !0);
      }
    ), pe(
      () => o.modelValue,
      (q) => {
        q ? q && q !== I.value && (C = !1, I.fromString(q)) : b.value = !1;
      }
    ), pe(
      () => y.value,
      () => {
        g.value && Ke(g.value.update);
      }
    ), at(JF, f), t({
      color: I,
      show: A,
      hide: L,
      focus: re,
      blur: oe
    }), (q, K) => (G(), Me(S(al), {
      ref_key: "popper",
      ref: v,
      visible: y.value,
      "show-arrow": !1,
      "fallback-placements": ["bottom", "top", "right", "left"],
      offset: 0,
      "gpu-acceleration": !1,
      "popper-class": [S(a).be("picker", "panel"), q.popperClass],
      "popper-style": q.popperStyle,
      "stop-popper-mouse-event": !1,
      pure: "",
      loop: "",
      role: "dialog",
      effect: "light",
      trigger: "click",
      teleported: q.teleported,
      transition: `${S(a).namespace.value}-zoom-in-top`,
      persistent: q.persistent,
      "append-to": q.appendTo,
      onShow: Y,
      onHide: K[2] || (K[2] = (se) => F(!1))
    }, {
      content: Ee(() => [
        _t((G(), Me(
          S(e9),
          Ut({
            ref_key: "pickerPanelRef",
            ref: g
          }, T.value, {
            border: !1,
            "validate-event": !1,
            onKeydown: uo(te, ["esc"])
          }),
          {
            footer: Ee(() => [
              ve("div", null, [
                q.clearable ? (G(), Me(S(Qo), {
                  key: 0,
                  class: X(S(a).be("footer", "link-btn")),
                  text: "",
                  size: "small",
                  onClick: W
                }, {
                  default: Ee(() => [
                    Ft(
                      qe(S(r)("el.colorpicker.clear")),
                      1
                    )
                  ]),
                  _: 1
                }, 8, ["class"])) : Ie("v-if", !0),
                $(S(Qo), {
                  plain: "",
                  size: "small",
                  class: X(S(a).be("footer", "btn")),
                  onClick: j
                }, {
                  default: Ee(() => [
                    Ft(
                      qe(S(r)("el.colorpicker.confirm")),
                      1
                    )
                  ]),
                  _: 1
                }, 8, ["class"])
              ])
            ]),
            _: 1
          },
          16
        )), [
          [S(Cc), U, h.value]
        ])
      ]),
      default: Ee(() => [
        ve("div", Ut({
          id: S(p),
          ref_key: "triggerRef",
          ref: h
        }, q.$attrs, {
          class: z.value,
          role: "button",
          "aria-label": N.value,
          "aria-labelledby": R.value,
          "aria-description": S(r)("el.colorpicker.description", { color: q.modelValue || "" }),
          "aria-disabled": S(c),
          tabindex: S(c) ? void 0 : q.tabindex,
          onKeydown: J,
          onFocus: K[0] || (K[0] = (...se) => S(x) && S(x)(...se)),
          onBlur: K[1] || (K[1] = (...se) => S(E) && S(E)(...se))
        }), [
          ve(
            "div",
            {
              class: X(S(a).be("picker", "trigger")),
              onClick: V
            },
            [
              ve(
                "span",
                {
                  class: X([S(a).be("picker", "color"), S(a).is("alpha", q.showAlpha)])
                },
                [
                  ve(
                    "span",
                    {
                      class: X(S(a).be("picker", "color-inner")),
                      style: gt({
                        backgroundColor: P.value
                      })
                    },
                    [
                      _t($(S(ut), {
                        class: X([S(a).be("picker", "icon"), S(a).is("icon-arrow-down")])
                      }, {
                        default: Ee(() => [
                          $(S(Ni))
                        ]),
                        _: 1
                      }, 8, ["class"]), [
                        [Jt, q.modelValue || b.value]
                      ]),
                      _t($(S(ut), {
                        class: X([S(a).be("picker", "empty"), S(a).is("icon-close")])
                      }, {
                        default: Ee(() => [
                          $(S(aa))
                        ]),
                        _: 1
                      }, 8, ["class"]), [
                        [Jt, !q.modelValue && !b.value]
                      ])
                    ],
                    6
                  )
                ],
                2
              )
            ],
            2
          )
        ], 16, kme)
      ]),
      _: 1
    }, 8, ["visible", "popper-class", "popper-style", "teleported", "transition", "persistent", "append-to"]));
  }
});
var Mme = /* @__PURE__ */ Je(Nme, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/color-picker/src/color-picker.vue"]]);
const Ame = Dt(Mme), Rme = Xe(Be({
  a11y: {
    type: Boolean,
    default: !0
  },
  locale: {
    type: ye(Object)
  },
  size: Bo,
  button: {
    type: ye(Object)
  },
  card: {
    type: ye(Object)
  },
  dialog: {
    type: ye(Object)
  },
  link: {
    type: ye(Object)
  },
  experimentalFeatures: {
    type: ye(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: !0
  },
  message: {
    type: ye(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  }
}, ad)), _l = {
  placement: "top"
}, Dme = /* @__PURE__ */ le({
  name: "ElConfigProvider",
  props: Rme,
  setup(e, { slots: t }) {
    const n = PO(e);
    return pe(
      () => e.message,
      (o) => {
        var l, r;
        Object.assign(_l, (r = (l = n == null ? void 0 : n.value) == null ? void 0 : l.message) != null ? r : {}, o != null ? o : {});
      },
      { immediate: !0, deep: !0 }
    ), () => Oe(t, "default", { config: n == null ? void 0 : n.value });
  }
}), Lme = Dt(Dme), Bme = /* @__PURE__ */ le({
  name: "ElContainer",
  __name: "container",
  props: Xe({
    direction: {
      type: String,
      values: ["horizontal", "vertical"]
    }
  }),
  setup(e) {
    const t = e, n = So(), o = Ve("container"), l = O(() => t.direction === "vertical" ? !0 : t.direction === "horizontal" ? !1 : n && n.default ? n.default().some((a) => {
      const i = a.type.name;
      return i === "ElHeader" || i === "ElFooter";
    }) : !1);
    return (r, a) => (G(), ue(
      "section",
      {
        class: X([S(o).b(), S(o).is("vertical", l.value)])
      },
      [
        Oe(r.$slots, "default")
      ],
      2
    ));
  }
});
var Fme = /* @__PURE__ */ Je(Bme, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/container.vue"]]);
const Vme = /* @__PURE__ */ le({
  name: "ElAside",
  __name: "aside",
  props: {
    width: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = e, n = Ve("aside"), o = O(
      () => t.width ? n.cssVarBlock({ width: t.width }) : {}
    );
    return (l, r) => (G(), ue(
      "aside",
      {
        class: X(S(n).b()),
        style: gt(o.value)
      },
      [
        Oe(l.$slots, "default")
      ],
      6
    ));
  }
});
var t9 = /* @__PURE__ */ Je(Vme, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/aside.vue"]]);
const zme = /* @__PURE__ */ le({
  name: "ElFooter",
  __name: "footer",
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = e, n = Ve("footer"), o = O(
      () => t.height ? n.cssVarBlock({ height: t.height }) : {}
    );
    return (l, r) => (G(), ue(
      "footer",
      {
        class: X(S(n).b()),
        style: gt(o.value)
      },
      [
        Oe(l.$slots, "default")
      ],
      6
    ));
  }
});
var n9 = /* @__PURE__ */ Je(zme, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/footer.vue"]]);
const Hme = /* @__PURE__ */ le({
  name: "ElHeader",
  __name: "header",
  props: {
    height: {
      type: String,
      default: null
    }
  },
  setup(e) {
    const t = e, n = Ve("header"), o = O(() => t.height ? n.cssVarBlock({
      height: t.height
    }) : {});
    return (l, r) => (G(), ue(
      "header",
      {
        class: X(S(n).b()),
        style: gt(o.value)
      },
      [
        Oe(l.$slots, "default")
      ],
      6
    ));
  }
});
var o9 = /* @__PURE__ */ Je(Hme, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/header.vue"]]);
const jme = /* @__PURE__ */ le({
  name: "ElMain",
  __name: "main",
  setup(e) {
    const t = Ve("main");
    return (n, o) => (G(), ue(
      "main",
      {
        class: X(S(t).b())
      },
      [
        Oe(n.$slots, "default")
      ],
      2
    ));
  }
});
var l9 = /* @__PURE__ */ Je(jme, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/container/src/main.vue"]]);
const Wme = Dt(Fme, {
  Aside: t9,
  Footer: n9,
  Header: o9,
  Main: l9
}), Kme = oo(t9), Ume = oo(n9), Gme = oo(o9), Yme = oo(l9);
var r9 = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Ya, function() {
    var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, o = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, l = /\d/, r = /\d\d/, a = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, s = {}, c = function(h) {
      return (h = +h) + (h > 68 ? 1900 : 2e3);
    }, u = function(h) {
      return function(g) {
        this[h] = +g;
      };
    }, d = [/[+-]\d\d:?(\d\d)?|Z/, function(h) {
      (this.zone || (this.zone = {})).offset = function(g) {
        if (!g || g === "Z") return 0;
        var y = g.match(/([+-]|\d\d)/g), b = 60 * y[1] + (+y[2] || 0);
        return b === 0 ? 0 : y[0] === "+" ? -b : b;
      }(h);
    }], f = function(h) {
      var g = s[h];
      return g && (g.indexOf ? g : g.s.concat(g.f));
    }, p = function(h, g) {
      var y, b = s.meridiem;
      if (b) {
        for (var C = 1; C <= 24; C += 1) if (h.indexOf(b(C, 0, g)) > -1) {
          y = C > 12;
          break;
        }
      } else y = h === (g ? "pm" : "PM");
      return y;
    }, m = { A: [i, function(h) {
      this.afternoon = p(h, !1);
    }], a: [i, function(h) {
      this.afternoon = p(h, !0);
    }], Q: [l, function(h) {
      this.month = 3 * (h - 1) + 1;
    }], S: [l, function(h) {
      this.milliseconds = 100 * +h;
    }], SS: [r, function(h) {
      this.milliseconds = 10 * +h;
    }], SSS: [/\d{3}/, function(h) {
      this.milliseconds = +h;
    }], s: [a, u("seconds")], ss: [a, u("seconds")], m: [a, u("minutes")], mm: [a, u("minutes")], H: [a, u("hours")], h: [a, u("hours")], HH: [a, u("hours")], hh: [a, u("hours")], D: [a, u("day")], DD: [r, u("day")], Do: [i, function(h) {
      var g = s.ordinal, y = h.match(/\d+/);
      if (this.day = y[0], g) for (var b = 1; b <= 31; b += 1) g(b).replace(/\[|\]/g, "") === h && (this.day = b);
    }], w: [a, u("week")], ww: [r, u("week")], M: [a, u("month")], MM: [r, u("month")], MMM: [i, function(h) {
      var g = f("months"), y = (f("monthsShort") || g.map(function(b) {
        return b.slice(0, 3);
      })).indexOf(h) + 1;
      if (y < 1) throw new Error();
      this.month = y % 12 || y;
    }], MMMM: [i, function(h) {
      var g = f("months").indexOf(h) + 1;
      if (g < 1) throw new Error();
      this.month = g % 12 || g;
    }], Y: [/[+-]?\d+/, u("year")], YY: [r, function(h) {
      this.year = c(h);
    }], YYYY: [/\d{4}/, u("year")], Z: d, ZZ: d };
    function v(h) {
      var g, y;
      g = h, y = s && s.formats;
      for (var b = (h = g.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(P, k, N) {
        var R = N && N.toUpperCase();
        return k || y[N] || n[N] || y[R].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(z, D, F) {
          return D || F.slice(1);
        });
      })).match(o), C = b.length, w = 0; w < C; w += 1) {
        var x = b[w], E = m[x], I = E && E[0], T = E && E[1];
        b[w] = T ? { regex: I, parser: T } : x.replace(/^\[|\]$/g, "");
      }
      return function(P) {
        for (var k = {}, N = 0, R = 0; N < C; N += 1) {
          var z = b[N];
          if (typeof z == "string") R += z.length;
          else {
            var D = z.regex, F = z.parser, M = P.slice(R), A = D.exec(M)[0];
            F.call(k, A), P = P.replace(A, "");
          }
        }
        return function(L) {
          var B = L.afternoon;
          if (B !== void 0) {
            var V = L.hours;
            B ? V < 12 && (L.hours += 12) : V === 12 && (L.hours = 0), delete L.afternoon;
          }
        }(k), k;
      };
    }
    return function(h, g, y) {
      y.p.customParseFormat = !0, h && h.parseTwoDigitYear && (c = h.parseTwoDigitYear);
      var b = g.prototype, C = b.parse;
      b.parse = function(w) {
        var x = w.date, E = w.utc, I = w.args;
        this.$u = E;
        var T = I[1];
        if (typeof T == "string") {
          var P = I[2] === !0, k = I[3] === !0, N = P || k, R = I[2];
          k && (R = I[2]), s = this.$locale(), !P && R && (s = y.Ls[R]), this.$d = function(M, A, L, B) {
            try {
              if (["x", "X"].indexOf(A) > -1) return new Date((A === "X" ? 1e3 : 1) * M);
              var V = v(A)(M), j = V.year, W = V.month, Y = V.day, U = V.hours, te = V.minutes, J = V.seconds, re = V.milliseconds, oe = V.zone, q = V.week, K = /* @__PURE__ */ new Date(), se = Y || (j || W ? 1 : K.getDate()), Z = j || K.getFullYear(), ee = 0;
              j && !W || (ee = W > 0 ? W - 1 : K.getMonth());
              var fe, me = U || 0, ge = te || 0, he = J || 0, $e = re || 0;
              return oe ? new Date(Date.UTC(Z, ee, se, me, ge, he, $e + 60 * oe.offset * 1e3)) : L ? new Date(Date.UTC(Z, ee, se, me, ge, he, $e)) : (fe = new Date(Z, ee, se, me, ge, he, $e), q && (fe = B(fe).week(q).toDate()), fe);
            } catch (ne) {
              return /* @__PURE__ */ new Date("");
            }
          }(x, T, E, y), this.init(), R && R !== !0 && (this.$L = this.locale(R).$L), N && x != this.format(T) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
        } else if (T instanceof Array) for (var z = T.length, D = 1; D <= z; D += 1) {
          I[1] = T[D - 1];
          var F = y.apply(this, I);
          if (F.isValid()) {
            this.$d = F.$d, this.$L = F.$L, this.init();
            break;
          }
          D === z && (this.$d = /* @__PURE__ */ new Date(""));
        }
        else C.call(this, w);
      };
    };
  });
})(r9);
var Xme = r9.exports;
const W1 = /* @__PURE__ */ Xa(Xme), dN = ["hours", "minutes", "seconds"], Va = "EP_PICKER_BASE", r_ = "ElPopperOptions", a9 = Symbol("commonPickerContextKey"), Xf = "HH:mm:ss", Ys = "YYYY-MM-DD", qme = {
  date: Ys,
  dates: Ys,
  week: "gggg[w]ww",
  year: "YYYY",
  years: "YYYY",
  month: "YYYY-MM",
  months: "YYYY-MM",
  datetime: `${Ys} ${Xf}`,
  monthrange: "YYYY-MM",
  yearrange: "YYYY",
  daterange: Ys,
  datetimerange: `${Ys} ${Xf}`
}, i9 = (e, t) => {
  const { lang: n } = an(), o = /* @__PURE__ */ H(!1), l = /* @__PURE__ */ H(!1), r = /* @__PURE__ */ H(null), a = O(() => {
    const { modelValue: m } = e;
    return !m || We(m) && !m.filter(Boolean).length;
  }), i = (m) => {
    if (!SF(e.modelValue, m)) {
      let v;
      We(m) ? v = m.map(
        (g) => X3(g, e.valueFormat, n.value)
      ) : m && (v = X3(m, e.valueFormat, n.value)), t(It, m && v, n.value);
    }
  }, s = O(() => {
    var m;
    let v;
    if (a.value ? c.value.getDefaultValue && (v = c.value.getDefaultValue()) : We(e.modelValue) ? v = e.modelValue.map(
      (h) => Y3(h, e.valueFormat, n.value)
    ) : v = Y3(
      (m = e.modelValue) != null ? m : "",
      e.valueFormat,
      n.value
    ), c.value.getRangeAvailableTime) {
      const h = c.value.getRangeAvailableTime(
        v
      );
      Jn(h, v) || (v = h, a.value || i(fb(v)));
    }
    return We(v) && v.some((h) => !h) && (v = []), v;
  }), c = /* @__PURE__ */ H({});
  return {
    parsedValue: s,
    pickerActualVisible: l,
    pickerOptions: c,
    pickerVisible: o,
    userInput: r,
    valueIsEmpty: a,
    emitInput: i,
    onCalendarChange: (m) => {
      t("calendar-change", m);
    },
    onPanelChange: (m, v, h) => {
      t("panel-change", m, v, h);
    },
    onPick: (m = "", v = !1) => {
      o.value = v;
      let h;
      We(m) ? h = m.map((g) => g.toDate()) : h = m && m.toDate(), r.value = null, i(h);
    },
    onSetPickerOption: (m) => {
      c.value[m[0]] = m[1], c.value.panelReady = !0;
    }
  };
}, a_ = Xe({
  disabledHours: {
    type: ye(Function)
  },
  disabledMinutes: {
    type: ye(Function)
  },
  disabledSeconds: {
    type: ye(Function)
  }
}), s9 = Xe({
  visible: Boolean,
  actualVisible: {
    type: Boolean,
    default: void 0
  },
  format: {
    type: String,
    default: ""
  }
}), i_ = Xe(vt(Be(Be(vt(Be({
  automaticDropdown: {
    type: Boolean,
    default: !0
  },
  id: {
    type: ye([Array, String])
  },
  name: {
    type: ye([Array, String])
  },
  popperClass: In.popperClass,
  popperStyle: In.popperStyle,
  format: String,
  valueFormat: String,
  dateFormat: String,
  timeFormat: String,
  type: {
    type: String,
    default: ""
  },
  clearable: {
    type: Boolean,
    default: !0
  },
  clearIcon: {
    type: ye([String, Object]),
    default: Es
  },
  editable: {
    type: Boolean,
    default: !0
  },
  prefixIcon: {
    type: ye([String, Object]),
    default: ""
  },
  size: Bo,
  readonly: Boolean,
  disabled: {
    type: Boolean,
    default: void 0
  },
  placeholder: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: ye(Object),
    default: () => ({})
  },
  modelValue: {
    type: ye([Date, Array, String, Number]),
    default: ""
  },
  rangeSeparator: {
    type: String,
    default: "-"
  },
  startPlaceholder: String,
  endPlaceholder: String,
  defaultValue: {
    type: ye([Date, Array])
  },
  defaultTime: {
    type: ye([Date, Array])
  },
  isRange: Boolean
}, a_), {
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  arrowControl: Boolean,
  tabindex: {
    type: ye([String, Number]),
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  unlinkPanels: Boolean,
  placement: {
    type: ye(String),
    values: Mi,
    default: "bottom"
  },
  fallbackPlacements: {
    type: ye(Array),
    default: ["bottom", "top", "right", "left"]
  }
}), ad), zl(["ariaLabel"])), {
  showNow: {
    type: Boolean,
    default: !0
  },
  showConfirm: {
    type: Boolean,
    default: !0
  },
  showFooter: {
    type: Boolean,
    default: !0
  },
  showWeekNumber: Boolean
})), Jme = Xe({
  id: {
    type: ye(Array)
  },
  name: {
    type: ye(Array)
  },
  modelValue: {
    type: ye([Array, String])
  },
  startPlaceholder: String,
  endPlaceholder: String,
  disabled: Boolean
}), Zme = ["id", "name", "placeholder", "value", "disabled"], Qme = ["id", "name", "placeholder", "value", "disabled"], ehe = /* @__PURE__ */ le({
  name: "PickerRangeTrigger",
  inheritAttrs: !1,
  __name: "picker-range-trigger",
  props: Jme,
  emits: [
    "mouseenter",
    "mouseleave",
    "click",
    "touchstart",
    "focus",
    "blur",
    "startInput",
    "endInput",
    "startChange",
    "endChange"
  ],
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, { formItem: r } = cl(), { inputId: a } = zr(
      /* @__PURE__ */ kt({ id: O(() => {
        var I;
        return (I = o.id) == null ? void 0 : I[0];
      }) }),
      {
        formItemContext: r
      }
    ), i = L1(), s = Ve("date"), c = Ve("range"), u = /* @__PURE__ */ H(), d = /* @__PURE__ */ H(), { wrapperRef: f, isFocused: p } = Os(u, {
      disabled: O(() => o.disabled)
    }), m = (I) => {
      l("click", I);
    }, v = (I) => {
      l("mouseenter", I);
    }, h = (I) => {
      l("mouseleave", I);
    }, g = (I) => {
      l("touchstart", I);
    }, y = (I) => {
      l("startInput", I);
    }, b = (I) => {
      l("endInput", I);
    }, C = (I) => {
      l("startChange", I);
    }, w = (I) => {
      l("endChange", I);
    };
    return t({
      focus: () => {
        var I;
        (I = u.value) == null || I.focus();
      },
      blur: () => {
        var I, T;
        (I = u.value) == null || I.blur(), (T = d.value) == null || T.blur();
      }
    }), (I, T) => (G(), ue(
      "div",
      {
        ref_key: "wrapperRef",
        ref: f,
        class: X([S(s).is("active", S(p)), I.$attrs.class]),
        style: gt(
          I.$attrs.style
        ),
        onClick: m,
        onMouseenter: v,
        onMouseleave: h,
        onTouchstartPassive: g
      },
      [
        Oe(I.$slots, "prefix"),
        ve("input", Ut(S(i), {
          id: S(a),
          ref_key: "inputRef",
          ref: u,
          name: I.name && I.name[0],
          placeholder: I.startPlaceholder,
          value: I.modelValue && I.modelValue[0],
          class: S(c).b("input"),
          disabled: I.disabled,
          onInput: y,
          onChange: C
        }), null, 16, Zme),
        Oe(I.$slots, "range-separator"),
        ve("input", Ut(S(i), {
          id: I.id && I.id[1],
          ref_key: "endInputRef",
          ref: d,
          name: I.name && I.name[1],
          placeholder: I.endPlaceholder,
          value: I.modelValue && I.modelValue[1],
          class: S(c).b("input"),
          disabled: I.disabled,
          onInput: b,
          onChange: w
        }), null, 16, Qme),
        Oe(I.$slots, "suffix")
      ],
      38
    ));
  }
});
var the = /* @__PURE__ */ Je(ehe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/common/picker-range-trigger.vue"]]);
const nhe = /* @__PURE__ */ le({
  name: "Picker",
  __name: "picker",
  props: i_,
  emits: [
    It,
    en,
    "focus",
    "blur",
    "clear",
    "calendar-change",
    "panel-change",
    "visible-change",
    "keydown"
  ],
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = Ti(), a = Ve("date"), i = Ve("input"), s = Ve("range"), { formItem: c } = cl(), u = ze(
      r_,
      {}
    ), d = ih(o, null), f = /* @__PURE__ */ H(), p = /* @__PURE__ */ H(), m = /* @__PURE__ */ H(null);
    let v = !1;
    const h = io(), g = i9(o, l), {
      parsedValue: y,
      pickerActualVisible: b,
      userInput: C,
      pickerVisible: w,
      pickerOptions: x,
      valueIsEmpty: E,
      emitInput: I,
      onPick: T,
      onSetPickerOption: P,
      onCalendarChange: k,
      onPanelChange: N
    } = g, { isFocused: R, handleFocus: z, handleBlur: D } = Os(p, {
      disabled: h,
      beforeFocus() {
        return o.readonly;
      },
      afterFocus() {
        o.automaticDropdown && (w.value = !0);
      },
      beforeBlur(_e) {
        var Ze;
        return !v && ((Ze = f.value) == null ? void 0 : Ze.isFocusInsideContent(_e));
      },
      afterBlur() {
        Se(), w.value = !1, v = !1, o.validateEvent && (c == null || c.validate("blur").catch((_e) => Gt(_e)));
      }
    }), F = /* @__PURE__ */ H(!1), M = O(() => [
      a.b("editor"),
      a.bm("editor", o.type),
      i.e("wrapper"),
      a.is("disabled", h.value),
      a.is("active", w.value),
      s.b("editor"),
      ce ? s.bm("editor", ce.value) : "",
      r.class
    ]), A = O(() => [
      i.e("icon"),
      s.e("close-icon"),
      fe.value ? "" : s.em("close-icon", "hidden")
    ]);
    pe(w, (_e) => {
      _e ? Ke(() => {
        _e && (m.value = o.modelValue);
      }) : (C.value = null, Ke(() => {
        L(o.modelValue);
      }));
    });
    const L = (_e, Ze) => {
      (Ze || !SF(_e, m.value)) && (l(en, _e), Ze && (m.value = _e), o.validateEvent && (c == null || c.validate("change").catch((dt) => Gt(dt))));
    }, B = (_e) => {
      l("keydown", _e);
    }, V = O(() => p.value ? Array.from(
      p.value.$el.querySelectorAll("input")
    ) : []), j = (_e, Ze, dt) => {
      const Tt = V.value;
      Tt.length && (!dt || dt === "min" ? (Tt[0].setSelectionRange(_e, Ze), Tt[0].focus()) : dt === "max" && (Tt[1].setSelectionRange(_e, Ze), Tt[1].focus()));
    }, W = () => {
      b.value = !0;
    }, Y = () => {
      l("visible-change", !0);
    }, U = () => {
      b.value = !1, w.value = !1, l("visible-change", !1);
    }, te = () => {
      w.value = !0;
    }, J = () => {
      w.value = !1;
    }, re = O(() => {
      const _e = ie(y.value);
      return We(C.value) ? [
        C.value[0] || _e && _e[0] || "",
        C.value[1] || _e && _e[1] || ""
      ] : C.value !== null ? C.value : !q.value && E.value || !w.value && E.value ? "" : _e ? K.value || se.value || Z.value ? _e.join(", ") : _e : "";
    }), oe = O(() => o.type.includes("time")), q = O(() => o.type.startsWith("time")), K = O(() => o.type === "dates"), se = O(() => o.type === "months"), Z = O(() => o.type === "years"), ee = O(
      () => o.prefixIcon || (oe.value ? x7 : zie)
    ), fe = O(
      () => o.clearable && !h.value && !o.readonly && !E.value && (F.value || R.value)
    ), me = (_e) => {
      o.readonly || h.value || (fe.value && (_e == null || _e.stopPropagation(), x.value.handleClear ? x.value.handleClear() : I(d.valueOnClear.value), L(d.valueOnClear.value, !0), U()), l("clear"));
    }, ge = (_e) => Rt(this, null, function* () {
      var Ze;
      o.readonly || h.value || (((Ze = _e.target) == null ? void 0 : Ze.tagName) !== "INPUT" || R.value || !o.automaticDropdown) && (w.value = !0);
    }), he = () => {
      o.readonly || h.value || !E.value && o.clearable && (F.value = !0);
    }, $e = () => {
      F.value = !1;
    }, ne = (_e) => {
      var Ze;
      o.readonly || h.value || (((Ze = _e.touches[0].target) == null ? void 0 : Ze.tagName) !== "INPUT" || R.value || !o.automaticDropdown) && (w.value = !0);
    }, ae = O(() => o.type.includes("range")), ce = Mo(), xe = O(() => {
      var _e, Ze;
      return (Ze = (_e = S(f)) == null ? void 0 : _e.popperRef) == null ? void 0 : Ze.contentRef;
    }), Te = IO(
      p,
      (_e) => {
        const Ze = S(xe), dt = Lo(p);
        Ze && (_e.target === Ze || _e.composedPath().includes(Ze)) || _e.target === dt || dt && _e.composedPath().includes(dt) || (w.value = !1);
      }
    );
    yt(() => {
      Te == null || Te();
    });
    const Se = () => {
      if (C.value) {
        const _e = be(re.value);
        _e && (we(_e) && I(fb(_e)), C.value = null);
      }
      C.value === "" && (I(d.valueOnClear.value), L(d.valueOnClear.value, !0), C.value = null);
    }, be = (_e) => _e ? x.value.parseUserInput(_e) : null, ie = (_e) => _e ? We(_e) ? _e.map((dt) => dt.format(o.format)) : _e.format(o.format) : null, we = (_e) => x.value.isValidValue(_e), Ne = (_e) => Rt(this, null, function* () {
      if (o.readonly || h.value)
        return;
      const Ze = Nn(_e);
      if (B(_e), Ze === Ye.esc) {
        w.value === !0 && (w.value = !1, _e.preventDefault(), _e.stopPropagation());
        return;
      }
      if (Ze === Ye.down && (x.value.handleFocusPicker && (_e.preventDefault(), _e.stopPropagation()), w.value === !1 && (w.value = !0, yield Ke()), x.value.handleFocusPicker)) {
        x.value.handleFocusPicker();
        return;
      }
      if (Ze === Ye.tab) {
        v = !0;
        return;
      }
      if (Ze === Ye.enter || Ze === Ye.numpadEnter) {
        w.value ? (C.value === null || C.value === "" || we(be(re.value))) && (Se(), w.value = !1) : w.value = !0, _e.preventDefault(), _e.stopPropagation();
        return;
      }
      if (C.value) {
        _e.stopPropagation();
        return;
      }
      x.value.handleKeydownInput && x.value.handleKeydownInput(_e);
    }), tt = (_e) => {
      C.value = _e, w.value || (w.value = !0);
    }, Pe = (_e) => {
      const Ze = _e.target;
      C.value ? C.value = [Ze.value, C.value[1]] : C.value = [Ze.value, null];
    }, Re = (_e) => {
      const Ze = _e.target;
      C.value ? C.value = [C.value[0], Ze.value] : C.value = [null, Ze.value];
    }, Le = () => {
      var _e;
      const Ze = C.value, dt = be(Ze && Ze[0]), Tt = S(y);
      if (dt && dt.isValid()) {
        C.value = [
          ie(dt),
          ((_e = re.value) == null ? void 0 : _e[1]) || null
        ];
        const jt = [dt, Tt && (Tt[1] || null)];
        we(jt) && (I(fb(jt)), C.value = null);
      }
    }, Ue = () => {
      var _e;
      const Ze = S(C), dt = be(Ze && Ze[1]), Tt = S(y);
      if (dt && dt.isValid()) {
        C.value = [
          ((_e = S(re)) == null ? void 0 : _e[0]) || null,
          ie(dt)
        ];
        const jt = [Tt && Tt[0], dt];
        we(jt) && (I(fb(jt)), C.value = null);
      }
    }, Ae = () => {
      var _e;
      (_e = p.value) == null || _e.focus();
    }, De = () => {
      var _e;
      (_e = p.value) == null || _e.blur();
    };
    return at(Va, {
      props: o,
      emptyValues: d
    }), at(a9, g), t({
      focus: Ae,
      blur: De,
      handleOpen: te,
      handleClose: J,
      onPick: T
    }), (_e, Ze) => (G(), Me(S(al), Ut({
      ref_key: "refPopper",
      ref: f,
      visible: S(w),
      effect: "light",
      pure: "",
      trigger: "click"
    }, _e.$attrs, {
      role: "dialog",
      teleported: "",
      transition: `${S(a).namespace.value}-zoom-in-top`,
      "popper-class": [`${S(a).namespace.value}-picker__popper`, _e.popperClass],
      "popper-style": _e.popperStyle,
      "popper-options": S(u),
      "fallback-placements": _e.fallbackPlacements,
      "gpu-acceleration": !1,
      placement: _e.placement,
      "stop-popper-mouse-event": !1,
      "hide-after": 0,
      persistent: "",
      onBeforeShow: W,
      onShow: Y,
      onHide: U
    }), {
      default: Ee(() => [
        ae.value ? (G(), Me(the, {
          key: 1,
          id: _e.id,
          ref_key: "inputRef",
          ref: p,
          "model-value": re.value,
          name: _e.name,
          disabled: S(h),
          readonly: !_e.editable || _e.readonly,
          "start-placeholder": _e.startPlaceholder,
          "end-placeholder": _e.endPlaceholder,
          class: X(M.value),
          style: gt(_e.$attrs.style),
          "aria-label": _e.ariaLabel,
          tabindex: _e.tabindex,
          autocomplete: "off",
          role: "combobox",
          onClick: ge,
          onFocus: S(z),
          onBlur: S(D),
          onStartInput: Pe,
          onStartChange: Le,
          onEndInput: Re,
          onEndChange: Ue,
          onMousedown: ge,
          onMouseenter: he,
          onMouseleave: $e,
          onTouchstartPassive: ne,
          onKeydown: Ne
        }, {
          prefix: Ee(() => [
            ee.value ? (G(), Me(S(ut), {
              key: 0,
              class: X([S(i).e("icon"), S(s).e("icon")])
            }, {
              default: Ee(() => [
                (G(), Me(Ht(ee.value)))
              ]),
              _: 1
            }, 8, ["class"])) : Ie("v-if", !0)
          ]),
          "range-separator": Ee(() => [
            Oe(_e.$slots, "range-separator", {}, () => [
              ve(
                "span",
                {
                  class: X(S(s).b("separator"))
                },
                qe(_e.rangeSeparator),
                3
              )
            ])
          ]),
          suffix: Ee(() => [
            _e.clearIcon ? (G(), Me(S(ut), {
              key: 0,
              class: X(A.value),
              onMousedown: Et(S(gn), ["prevent"]),
              onClick: me
            }, {
              default: Ee(() => [
                (G(), Me(Ht(_e.clearIcon)))
              ]),
              _: 1
            }, 8, ["class", "onMousedown"])) : Ie("v-if", !0)
          ]),
          _: 3
        }, 8, ["id", "model-value", "name", "disabled", "readonly", "start-placeholder", "end-placeholder", "class", "style", "aria-label", "tabindex", "onFocus", "onBlur"])) : (G(), Me(S(Nl), {
          key: 0,
          id: _e.id,
          ref_key: "inputRef",
          ref: p,
          "container-role": "combobox",
          "model-value": re.value,
          name: _e.name,
          size: S(ce),
          disabled: S(h),
          placeholder: _e.placeholder,
          class: X([
            S(a).b("editor"),
            S(a).bm("editor", _e.type),
            S(a).is("focus", S(w)),
            _e.$attrs.class
          ]),
          style: gt(_e.$attrs.style),
          readonly: !_e.editable || _e.readonly || K.value || se.value || Z.value || _e.type === "week",
          "aria-label": _e.ariaLabel,
          tabindex: _e.tabindex,
          "validate-event": !1,
          onInput: tt,
          onFocus: S(z),
          onBlur: S(D),
          onKeydown: Ne,
          onChange: Se,
          onMousedown: ge,
          onMouseenter: he,
          onMouseleave: $e,
          onTouchstartPassive: ne,
          onClick: Ze[0] || (Ze[0] = Et(() => {
          }, ["stop"]))
        }, {
          prefix: Ee(() => [
            ee.value ? (G(), Me(S(ut), {
              key: 0,
              class: X(S(i).e("icon")),
              onMousedown: Et(ge, ["prevent"]),
              onTouchstartPassive: ne
            }, {
              default: Ee(() => [
                (G(), Me(Ht(ee.value)))
              ]),
              _: 1
            }, 8, ["class"])) : Ie("v-if", !0)
          ]),
          suffix: Ee(() => [
            fe.value && _e.clearIcon ? (G(), Me(S(ut), {
              key: 0,
              class: X(`${S(i).e("icon")} clear-icon`),
              onMousedown: Et(S(gn), ["prevent"]),
              onClick: me
            }, {
              default: Ee(() => [
                (G(), Me(Ht(_e.clearIcon)))
              ]),
              _: 1
            }, 8, ["class", "onMousedown"])) : Ie("v-if", !0)
          ]),
          _: 1
        }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "aria-label", "tabindex", "onFocus", "onBlur"]))
      ]),
      content: Ee(() => [
        Oe(_e.$slots, "default", {
          visible: S(w),
          actualVisible: S(b),
          parsedValue: S(y),
          format: _e.format,
          dateFormat: _e.dateFormat,
          timeFormat: _e.timeFormat,
          unlinkPanels: _e.unlinkPanels,
          type: _e.type,
          defaultValue: _e.defaultValue,
          showNow: _e.showNow,
          showConfirm: _e.showConfirm,
          showFooter: _e.showFooter,
          showWeekNumber: _e.showWeekNumber,
          onPick: Ze[1] || (Ze[1] = (...dt) => S(T) && S(T)(...dt)),
          onSelectRange: j,
          onSetPickerOption: Ze[2] || (Ze[2] = (...dt) => S(P) && S(P)(...dt)),
          onCalendarChange: Ze[3] || (Ze[3] = (...dt) => S(k) && S(k)(...dt)),
          onClear: me,
          onPanelChange: Ze[4] || (Ze[4] = (...dt) => S(N) && S(N)(...dt)),
          onMousedown: Ze[5] || (Ze[5] = Et(() => {
          }, ["stop"]))
        })
      ]),
      _: 3
    }, 16, ["visible", "transition", "popper-class", "popper-style", "popper-options", "fallback-placements", "placement"]));
  }
});
var c9 = /* @__PURE__ */ Je(nhe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/common/picker.vue"]]);
const ohe = Xe(vt(Be({}, s9), {
  datetimeRole: String,
  parsedValue: {
    type: ye(Object)
  }
})), u9 = ({
  getAvailableHours: e,
  getAvailableMinutes: t,
  getAvailableSeconds: n
}) => {
  const o = (a, i, s, c) => {
    const u = {
      hour: e,
      minute: t,
      second: n
    };
    let d = a;
    return ["hour", "minute", "second"].forEach((f) => {
      if (u[f]) {
        let p;
        const m = u[f];
        switch (f) {
          case "minute": {
            p = m(
              d.hour(),
              i,
              c
            );
            break;
          }
          case "second": {
            p = m(
              d.hour(),
              d.minute(),
              i,
              c
            );
            break;
          }
          default: {
            p = m(
              i,
              c
            );
            break;
          }
        }
        if (p != null && p.length && !p.includes(d[f]())) {
          const v = s ? 0 : p.length - 1;
          d = d[f](p[v]);
        }
      }
    }), d;
  }, l = {};
  return {
    timePickerOptions: l,
    getAvailableTime: o,
    onSetOption: ([a, i]) => {
      l[a] = i;
    }
  };
}, qC = (e) => {
  const t = (o, l) => o || l, n = (o) => o !== !0;
  return e.map(t).filter(n);
}, d9 = (e, t, n) => ({
  getHoursList: (a, i) => KC(24, e && (() => e == null ? void 0 : e(a, i))),
  getMinutesList: (a, i, s) => KC(
    60,
    t && (() => t == null ? void 0 : t(a, i, s))
  ),
  getSecondsList: (a, i, s, c) => KC(
    60,
    n && (() => n == null ? void 0 : n(a, i, s, c))
  )
}), f9 = (e, t, n) => {
  const { getHoursList: o, getMinutesList: l, getSecondsList: r } = d9(
    e,
    t,
    n
  );
  return {
    getAvailableHours: (c, u) => qC(o(c, u)),
    getAvailableMinutes: (c, u, d) => qC(l(c, u, d)),
    getAvailableSeconds: (c, u, d, f) => qC(r(c, u, d, f))
  };
}, p9 = (e) => {
  const t = /* @__PURE__ */ H(e.parsedValue);
  return pe(
    () => e.visible,
    (n) => {
      n || (t.value = e.parsedValue);
    }
  ), t;
}, lhe = Xe(Be({
  role: {
    type: String,
    required: !0
  },
  spinnerDate: {
    type: ye(Object),
    required: !0
  },
  showSeconds: {
    type: Boolean,
    default: !0
  },
  arrowControl: Boolean,
  amPmMode: {
    type: ye(String),
    default: ""
  }
}, a_)), rhe = 100, ahe = 600, ug = "_RepeatClick", L0 = {
  beforeMount(e, t) {
    const n = t.value, { interval: o = rhe, delay: l = ahe } = it(
      n
    ) ? {} : n;
    let r, a;
    const i = () => it(n) ? n() : n.handler(), s = () => {
      a && (clearTimeout(a), a = void 0), r && (clearInterval(r), r = void 0);
    }, c = (u) => {
      u.button === 0 && (s(), i(), document.addEventListener("mouseup", s, { once: !0 }), a = setTimeout(() => {
        r = setInterval(() => {
          i();
        }, o);
      }, l));
    };
    e[ug] = { start: c, clear: s }, e.addEventListener("mousedown", c);
  },
  unmounted(e) {
    if (!e[ug])
      return;
    const { start: t, clear: n } = e[ug];
    t && e.removeEventListener("mousedown", t), n && (n(), document.removeEventListener("mouseup", n)), e[ug] = null;
  }
}, ihe = ["onClick"], she = ["onMouseenter"], che = /* @__PURE__ */ le({
  __name: "basic-time-spinner",
  props: lhe,
  emits: [en, "select-range", "set-option"],
  setup(e, { emit: t }) {
    const n = e, o = ze(Va), { isRange: l, format: r } = o.props, a = t, i = Ve("time"), { getHoursList: s, getMinutesList: c, getSecondsList: u } = d9(
      n.disabledHours,
      n.disabledMinutes,
      n.disabledSeconds
    );
    let d = !1;
    const f = /* @__PURE__ */ H(), h = {
      hours: /* @__PURE__ */ H(),
      minutes: /* @__PURE__ */ H(),
      seconds: /* @__PURE__ */ H()
    }, g = O(() => n.showSeconds ? dN : dN.slice(0, 2)), y = O(() => {
      const { spinnerDate: W } = n, Y = W.hour(), U = W.minute(), te = W.second();
      return { hours: Y, minutes: U, seconds: te };
    }), b = O(() => {
      const { hours: W, minutes: Y } = S(y), { role: U, spinnerDate: te } = n, J = l ? void 0 : te;
      return {
        hours: s(U, J),
        minutes: c(W, U, J),
        seconds: u(W, Y, U, J)
      };
    }), C = O(() => {
      const { hours: W, minutes: Y, seconds: U } = S(y);
      return {
        hours: WC(W, 23),
        minutes: WC(Y, 59),
        seconds: WC(U, 59)
      };
    }), w = Dr((W) => {
      d = !1, I(W);
    }, 200), x = (W) => {
      if (!!!n.amPmMode)
        return "";
      const U = n.amPmMode === "A";
      let te = W < 12 ? " am" : " pm";
      return U && (te = te.toUpperCase()), te;
    }, E = (W) => {
      let Y = [0, 0];
      const U = r || Xf, te = U.indexOf("HH"), J = U.indexOf("mm"), re = U.indexOf("ss");
      switch (W) {
        case "hours":
          te !== -1 && (Y = [te, te + 2]);
          break;
        case "minutes":
          J !== -1 && (Y = [J, J + 2]);
          break;
        case "seconds":
          re !== -1 && (Y = [re, re + 2]);
          break;
      }
      const [oe, q] = Y;
      a("select-range", oe, q), f.value = W;
    }, I = (W) => {
      k(W, S(y)[W]);
    }, T = () => {
      I("hours"), I("minutes"), I("seconds");
    }, P = (W) => W.querySelector(`.${i.namespace.value}-scrollbar__wrap`), k = (W, Y) => {
      if (n.arrowControl)
        return;
      const U = S(h[W]);
      U && U.$el && (P(U.$el).scrollTop = Math.max(
        0,
        Y * N(W)
      ));
    }, N = (W) => {
      const Y = S(h[W]), U = Y == null ? void 0 : Y.$el.querySelector("li");
      return U && Number.parseFloat(ts(U, "height")) || 0;
    }, R = () => {
      D(1);
    }, z = () => {
      D(-1);
    }, D = (W) => {
      f.value || E("hours");
      const Y = f.value, U = S(y)[Y], te = f.value === "hours" ? 24 : 60, J = F(Y, U, W, te);
      M(Y, J), k(Y, J), Ke(() => E(Y));
    }, F = (W, Y, U, te) => {
      let J = (Y + U + te) % te;
      const re = S(b)[W];
      for (; re[J] && J !== Y; )
        J = (J + U + te) % te;
      return J;
    }, M = (W, Y) => {
      if (S(b)[W][Y])
        return;
      const { hours: J, minutes: re, seconds: oe } = S(y);
      let q;
      switch (W) {
        case "hours":
          q = n.spinnerDate.hour(Y).minute(re).second(oe);
          break;
        case "minutes":
          q = n.spinnerDate.hour(J).minute(Y).second(oe);
          break;
        case "seconds":
          q = n.spinnerDate.hour(J).minute(re).second(Y);
          break;
      }
      a(en, q);
    }, A = (W, { value: Y, disabled: U }) => {
      U || (M(W, Y), E(W), k(W, Y));
    }, L = (W) => {
      const Y = S(h[W]);
      if (!Y)
        return;
      d = !0, w(W);
      const U = Math.min(
        Math.round(
          (P(Y.$el).scrollTop - (B(W) * 0.5 - 10) / N(W) + 3) / N(W)
        ),
        W === "hours" ? 23 : 59
      );
      M(W, U);
    }, B = (W) => S(h[W]).$el.offsetHeight, V = () => {
      const W = (Y) => {
        const U = S(h[Y]);
        U && U.$el && (P(U.$el).onscroll = () => {
          L(Y);
        });
      };
      W("hours"), W("minutes"), W("seconds");
    };
    nt(() => {
      Ke(() => {
        !n.arrowControl && V(), T(), n.role === "start" && E("hours");
      });
    });
    const j = (W, Y) => {
      h[Y].value = W != null ? W : void 0;
    };
    return a("set-option", [`${n.role}_scrollDown`, D]), a("set-option", [`${n.role}_emitSelectRange`, E]), pe(
      () => n.spinnerDate,
      () => {
        d || T();
      }
    ), (W, Y) => (G(), ue(
      "div",
      {
        class: X([S(i).b("spinner"), { "has-seconds": W.showSeconds }])
      },
      [
        W.arrowControl ? Ie("v-if", !0) : (G(!0), ue(
          Ge,
          { key: 0 },
          on(g.value, (U) => (G(), Me(S(Ba), {
            key: U,
            ref_for: !0,
            ref: (te) => j(te, U),
            class: X(S(i).be("spinner", "wrapper")),
            "wrap-style": "max-height: inherit;",
            "view-class": S(i).be("spinner", "list"),
            noresize: "",
            tag: "ul",
            onMouseenter: (te) => E(U),
            onMousemove: (te) => I(U)
          }, {
            default: Ee(() => [
              (G(!0), ue(
                Ge,
                null,
                on(b.value[U], (te, J) => (G(), ue("li", {
                  key: J,
                  class: X([
                    S(i).be("spinner", "item"),
                    S(i).is("active", J === y.value[U]),
                    S(i).is("disabled", te)
                  ]),
                  onClick: (re) => A(U, { value: J, disabled: te })
                }, [
                  U === "hours" ? (G(), ue(
                    Ge,
                    { key: 0 },
                    [
                      Ft(
                        qe(("0" + (W.amPmMode ? J % 12 || 12 : J)).slice(-2)) + qe(x(J)),
                        1
                      )
                    ],
                    64
                  )) : (G(), ue(
                    Ge,
                    { key: 1 },
                    [
                      Ft(
                        qe(("0" + J).slice(-2)),
                        1
                      )
                    ],
                    64
                  ))
                ], 10, ihe))),
                128
              ))
            ]),
            _: 2
          }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]))),
          128
        )),
        W.arrowControl ? (G(!0), ue(
          Ge,
          { key: 1 },
          on(g.value, (U) => (G(), ue("div", {
            key: U,
            class: X([S(i).be("spinner", "wrapper"), S(i).is("arrow")]),
            onMouseenter: (te) => E(U)
          }, [
            _t((G(), Me(S(ut), {
              class: X(["arrow-up", S(i).be("spinner", "arrow")])
            }, {
              default: Ee(() => [
                $(S(A1))
              ]),
              _: 1
            }, 8, ["class"])), [
              [S(L0), z]
            ]),
            _t((G(), Me(S(ut), {
              class: X(["arrow-down", S(i).be("spinner", "arrow")])
            }, {
              default: Ee(() => [
                $(S(Ni))
              ]),
              _: 1
            }, 8, ["class"])), [
              [S(L0), R]
            ]),
            ve(
              "ul",
              {
                class: X(S(i).be("spinner", "list"))
              },
              [
                (G(!0), ue(
                  Ge,
                  null,
                  on(C.value[U], (te, J) => (G(), ue(
                    "li",
                    {
                      key: J,
                      class: X([
                        S(i).be("spinner", "item"),
                        S(i).is("active", te === y.value[U]),
                        S(i).is("disabled", b.value[U][te])
                      ])
                    },
                    [
                      S(mt)(te) ? (G(), ue(
                        Ge,
                        { key: 0 },
                        [
                          U === "hours" ? (G(), ue(
                            Ge,
                            { key: 0 },
                            [
                              Ft(
                                qe(("0" + (W.amPmMode ? te % 12 || 12 : te)).slice(-2)) + qe(x(te)),
                                1
                              )
                            ],
                            64
                          )) : (G(), ue(
                            Ge,
                            { key: 1 },
                            [
                              Ft(
                                qe(("0" + te).slice(-2)),
                                1
                              )
                            ],
                            64
                          ))
                        ],
                        64
                      )) : Ie("v-if", !0)
                    ],
                    2
                  ))),
                  128
                ))
              ],
              2
            )
          ], 42, she))),
          128
        )) : Ie("v-if", !0)
      ],
      2
    ));
  }
});
var bx = /* @__PURE__ */ Je(che, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue"]]);
const uhe = /* @__PURE__ */ le({
  __name: "panel-time-pick",
  props: ohe,
  emits: ["pick", "select-range", "set-picker-option"],
  setup(e, { emit: t }) {
    const n = e, o = t, l = ze(Va), {
      arrowControl: r,
      disabledHours: a,
      disabledMinutes: i,
      disabledSeconds: s,
      defaultValue: c
    } = l.props, { getAvailableHours: u, getAvailableMinutes: d, getAvailableSeconds: f } = f9(a, i, s), p = Ve("time"), { t: m, lang: v } = an(), h = /* @__PURE__ */ H([0, 2]), g = p9(n), y = O(() => fn(n.actualVisible) ? `${p.namespace.value}-zoom-in-top` : ""), b = O(() => n.format.includes("ss")), C = O(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), w = (A) => {
      const L = wt(A).locale(v.value), B = D(L);
      return L.isSame(B);
    }, x = () => {
      const A = g.value;
      o("pick", A, !1), Ke(() => {
        g.value = A;
      });
    }, E = (A = !1, L = !1) => {
      L || o("pick", n.parsedValue, A);
    }, I = (A) => {
      if (!n.visible)
        return;
      const L = D(A).millisecond(0);
      o("pick", L, !0);
    }, T = (A, L) => {
      o("select-range", A, L), h.value = [A, L];
    }, P = (A) => {
      const L = n.format, B = L.indexOf("HH"), V = L.indexOf("mm"), j = L.indexOf("ss"), W = [], Y = [];
      B !== -1 && (W.push(B), Y.push("hours")), V !== -1 && (W.push(V), Y.push("minutes")), j !== -1 && b.value && (W.push(j), Y.push("seconds"));
      const te = (W.indexOf(h.value[0]) + A + W.length) % W.length;
      N.start_emitSelectRange(Y[te]);
    }, k = (A) => {
      const L = Nn(A), { left: B, right: V, up: j, down: W } = Ye;
      if ([B, V].includes(L)) {
        P(L === B ? -1 : 1), A.preventDefault();
        return;
      }
      if ([j, W].includes(L)) {
        const Y = L === j ? -1 : 1;
        N.start_scrollDown(Y), A.preventDefault();
        return;
      }
    }, { timePickerOptions: N, onSetOption: R, getAvailableTime: z } = u9({
      getAvailableHours: u,
      getAvailableMinutes: d,
      getAvailableSeconds: f
    }), D = (A) => z(A, n.datetimeRole || "", !0), F = (A) => A ? wt(A, n.format).locale(v.value) : null, M = () => wt(c).locale(v.value);
    return o("set-picker-option", ["isValidValue", w]), o("set-picker-option", ["parseUserInput", F]), o("set-picker-option", ["handleKeydownInput", k]), o("set-picker-option", ["getRangeAvailableTime", D]), o("set-picker-option", ["getDefaultValue", M]), (A, L) => (G(), Me(Vn, { name: y.value }, {
      default: Ee(() => [
        A.actualVisible || A.visible ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(p).b("panel"))
          },
          [
            ve(
              "div",
              {
                class: X([S(p).be("panel", "content"), { "has-seconds": b.value }])
              },
              [
                $(bx, {
                  ref: "spinner",
                  role: A.datetimeRole || "start",
                  "arrow-control": S(r),
                  "show-seconds": b.value,
                  "am-pm-mode": C.value,
                  "spinner-date": A.parsedValue,
                  "disabled-hours": S(a),
                  "disabled-minutes": S(i),
                  "disabled-seconds": S(s),
                  onChange: I,
                  onSetOption: S(R),
                  onSelectRange: T
                }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])
              ],
              2
            ),
            ve(
              "div",
              {
                class: X(S(p).be("panel", "footer"))
              },
              [
                ve(
                  "button",
                  {
                    type: "button",
                    class: X([S(p).be("panel", "btn"), "cancel"]),
                    onClick: x
                  },
                  qe(S(m)("el.datepicker.cancel")),
                  3
                ),
                ve(
                  "button",
                  {
                    type: "button",
                    class: X([S(p).be("panel", "btn"), "confirm"]),
                    onClick: L[0] || (L[0] = (B) => E())
                  },
                  qe(S(m)("el.datepicker.confirm")),
                  3
                )
              ],
              2
            )
          ],
          2
        )) : Ie("v-if", !0)
      ]),
      _: 1
    }, 8, ["name"]));
  }
});
var B0 = /* @__PURE__ */ Je(uhe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-pick.vue"]]);
const dhe = Xe(vt(Be({}, s9), {
  parsedValue: {
    type: ye(Array)
  }
})), fhe = ["disabled"], phe = /* @__PURE__ */ le({
  __name: "panel-time-range",
  props: dhe,
  emits: ["pick", "select-range", "set-picker-option"],
  setup(e, { emit: t }) {
    const n = e, o = t, l = (K, se) => {
      const Z = [];
      for (let ee = K; ee <= se; ee++)
        Z.push(ee);
      return Z;
    }, { t: r, lang: a } = an(), i = Ve("time"), s = Ve("picker"), c = ze(Va), {
      arrowControl: u,
      disabledHours: d,
      disabledMinutes: f,
      disabledSeconds: p,
      defaultValue: m
    } = c.props, v = O(() => [
      i.be("range-picker", "body"),
      i.be("panel", "content"),
      i.is("arrow", u),
      w.value ? "has-seconds" : ""
    ]), h = O(() => [
      i.be("range-picker", "body"),
      i.be("panel", "content"),
      i.is("arrow", u),
      w.value ? "has-seconds" : ""
    ]), g = O(() => n.parsedValue[0]), y = O(() => n.parsedValue[1]), b = p9(n), C = () => {
      const K = b.value;
      o("pick", K, !1), Ke(() => {
        b.value = K;
      });
    }, w = O(() => n.format.includes("ss")), x = O(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), E = (K = !1) => {
      o("pick", [g.value, y.value], K);
    }, I = (K) => {
      k(K.millisecond(0), y.value);
    }, T = (K) => {
      k(g.value, K.millisecond(0));
    }, P = (K) => {
      const se = K.map((ee) => wt(ee).locale(a.value)), Z = j(se);
      return se[0].isSame(Z[0]) && se[1].isSame(Z[1]);
    }, k = (K, se) => {
      n.visible && o("pick", [K, se], !0);
    }, N = O(() => g.value > y.value), R = /* @__PURE__ */ H([0, 2]), z = (K, se) => {
      o("select-range", K, se, "min"), R.value = [K, se];
    }, D = O(() => w.value ? 11 : 8), F = (K, se) => {
      o("select-range", K, se, "max");
      const Z = S(D);
      R.value = [K + Z, se + Z];
    }, M = (K) => {
      const se = w.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11], Z = ["hours", "minutes"].concat(
        w.value ? ["seconds"] : []
      ), fe = (se.indexOf(R.value[0]) + K + se.length) % se.length, me = se.length / 2;
      fe < me ? te.start_emitSelectRange(Z[fe]) : te.end_emitSelectRange(Z[fe - me]);
    }, A = (K) => {
      const se = Nn(K), { left: Z, right: ee, up: fe, down: me } = Ye;
      if ([Z, ee].includes(se)) {
        M(se === Z ? -1 : 1), K.preventDefault();
        return;
      }
      if ([fe, me].includes(se)) {
        const ge = se === fe ? -1 : 1, he = R.value[0] < D.value ? "start" : "end";
        te[`${he}_scrollDown`](ge), K.preventDefault();
        return;
      }
    }, L = (K, se) => {
      const Z = d ? d(K) : [], ee = K === "start", me = (se || (ee ? y.value : g.value)).hour(), ge = ee ? l(me + 1, 23) : l(0, me - 1);
      return RC(Z, ge);
    }, B = (K, se, Z) => {
      const ee = f ? f(K, se) : [], fe = se === "start", me = Z || (fe ? y.value : g.value), ge = me.hour();
      if (K !== ge)
        return ee;
      const he = me.minute(), $e = fe ? l(he + 1, 59) : l(0, he - 1);
      return RC(ee, $e);
    }, V = (K, se, Z, ee) => {
      const fe = p ? p(K, se, Z) : [], me = Z === "start", ge = ee || (me ? y.value : g.value), he = ge.hour(), $e = ge.minute();
      if (K !== he || se !== $e)
        return fe;
      const ne = ge.second(), ae = me ? l(ne + 1, 59) : l(0, ne - 1);
      return RC(fe, ae);
    }, j = ([K, se]) => [
      J(K, "start", !0, se),
      J(se, "end", !1, K)
    ], { getAvailableHours: W, getAvailableMinutes: Y, getAvailableSeconds: U } = f9(
      L,
      B,
      V
    ), {
      timePickerOptions: te,
      getAvailableTime: J,
      onSetOption: re
    } = u9({
      getAvailableHours: W,
      getAvailableMinutes: Y,
      getAvailableSeconds: U
    }), oe = (K) => K ? We(K) ? K.map((se) => wt(se, n.format).locale(a.value)) : wt(K, n.format).locale(a.value) : null, q = () => {
      if (We(m))
        return m.map((se) => wt(se).locale(a.value));
      const K = wt(m).locale(a.value);
      return [K, K.add(60, "m")];
    };
    return o("set-picker-option", ["parseUserInput", oe]), o("set-picker-option", ["isValidValue", P]), o("set-picker-option", ["handleKeydownInput", A]), o("set-picker-option", ["getDefaultValue", q]), o("set-picker-option", ["getRangeAvailableTime", j]), (K, se) => K.actualVisible ? (G(), ue(
      "div",
      {
        key: 0,
        class: X([S(i).b("range-picker"), S(s).b("panel")])
      },
      [
        ve(
          "div",
          {
            class: X(S(i).be("range-picker", "content"))
          },
          [
            ve(
              "div",
              {
                class: X(S(i).be("range-picker", "cell"))
              },
              [
                ve(
                  "div",
                  {
                    class: X(S(i).be("range-picker", "header"))
                  },
                  qe(S(r)("el.datepicker.startTime")),
                  3
                ),
                ve(
                  "div",
                  {
                    class: X(v.value)
                  },
                  [
                    $(bx, {
                      ref: "minSpinner",
                      role: "start",
                      "show-seconds": w.value,
                      "am-pm-mode": x.value,
                      "arrow-control": S(u),
                      "spinner-date": g.value,
                      "disabled-hours": L,
                      "disabled-minutes": B,
                      "disabled-seconds": V,
                      onChange: I,
                      onSetOption: S(re),
                      onSelectRange: z
                    }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
                  ],
                  2
                )
              ],
              2
            ),
            ve(
              "div",
              {
                class: X(S(i).be("range-picker", "cell"))
              },
              [
                ve(
                  "div",
                  {
                    class: X(S(i).be("range-picker", "header"))
                  },
                  qe(S(r)("el.datepicker.endTime")),
                  3
                ),
                ve(
                  "div",
                  {
                    class: X(h.value)
                  },
                  [
                    $(bx, {
                      ref: "maxSpinner",
                      role: "end",
                      "show-seconds": w.value,
                      "am-pm-mode": x.value,
                      "arrow-control": S(u),
                      "spinner-date": y.value,
                      "disabled-hours": L,
                      "disabled-minutes": B,
                      "disabled-seconds": V,
                      onChange: T,
                      onSetOption: S(re),
                      onSelectRange: F
                    }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
                  ],
                  2
                )
              ],
              2
            )
          ],
          2
        ),
        ve(
          "div",
          {
            class: X(S(i).be("panel", "footer"))
          },
          [
            ve(
              "button",
              {
                type: "button",
                class: X([S(i).be("panel", "btn"), "cancel"]),
                onClick: se[0] || (se[0] = (Z) => C())
              },
              qe(S(r)("el.datepicker.cancel")),
              3
            ),
            ve("button", {
              type: "button",
              class: X([S(i).be("panel", "btn"), "confirm"]),
              disabled: N.value,
              onClick: se[1] || (se[1] = (Z) => E())
            }, qe(S(r)("el.datepicker.confirm")), 11, fhe)
          ],
          2
        )
      ],
      2
    )) : Ie("v-if", !0);
  }
});
var vhe = /* @__PURE__ */ Je(phe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-range.vue"]]);
wt.extend(W1);
var mhe = /* @__PURE__ */ le({
  name: "ElTimePicker",
  install: null,
  props: vt(Be({}, i_), {
    isRange: Boolean
  }),
  emits: [It],
  setup(e, t) {
    const n = /* @__PURE__ */ H(), [o, l] = e.isRange ? ["timerange", vhe] : ["time", B0], r = (a) => t.emit(It, a);
    return at(r_, e.popperOptions), t.expose({
      focus: () => {
        var a;
        (a = n.value) == null || a.focus();
      },
      blur: () => {
        var a;
        (a = n.value) == null || a.blur();
      },
      handleOpen: () => {
        var a;
        (a = n.value) == null || a.handleOpen();
      },
      handleClose: () => {
        var a;
        (a = n.value) == null || a.handleClose();
      }
    }), () => {
      var a;
      const i = (a = e.format) != null ? a : Xf;
      return $(c9, Ut(e, {
        ref: n,
        type: o,
        format: i,
        "onUpdate:modelValue": r
      }), {
        default: (s) => $(l, s, null)
      });
    };
  }
});
const hhe = Dt(mhe);
var v9 = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Ya, function() {
    return function(n, o) {
      var l = o.prototype, r = l.format;
      l.format = function(a) {
        var i = this, s = this.$locale();
        if (!this.isValid()) return r.bind(this)(a);
        var c = this.$utils(), u = (a || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(d) {
          switch (d) {
            case "Q":
              return Math.ceil((i.$M + 1) / 3);
            case "Do":
              return s.ordinal(i.$D);
            case "gggg":
              return i.weekYear();
            case "GGGG":
              return i.isoWeekYear();
            case "wo":
              return s.ordinal(i.week(), "W");
            case "w":
            case "ww":
              return c.s(i.week(), d === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return c.s(i.isoWeek(), d === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return c.s(String(i.$H === 0 ? 24 : i.$H), d === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(i.$d.getTime() / 1e3);
            case "x":
              return i.$d.getTime();
            case "z":
              return "[" + i.offsetName() + "]";
            case "zzz":
              return "[" + i.offsetName("long") + "]";
            default:
              return d;
          }
        });
        return r.bind(this)(u);
      };
    };
  });
})(v9);
var ghe = v9.exports;
const m9 = /* @__PURE__ */ Xa(ghe);
var h9 = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Ya, function() {
    var n = "week", o = "year";
    return function(l, r, a) {
      var i = r.prototype;
      i.week = function(s) {
        if (s === void 0 && (s = null), s !== null) return this.add(7 * (s - this.week()), "day");
        var c = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var u = a(this).startOf(o).add(1, o).date(c), d = a(this).endOf(n);
          if (u.isBefore(d)) return 1;
        }
        var f = a(this).startOf(o).date(c).startOf(n).subtract(1, "millisecond"), p = this.diff(f, n, !0);
        return p < 0 ? a(this).startOf("week").week() : Math.ceil(p);
      }, i.weeks = function(s) {
        return s === void 0 && (s = null), this.week(s);
      };
    };
  });
})(h9);
var bhe = h9.exports;
const g9 = /* @__PURE__ */ Xa(bhe);
var b9 = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Ya, function() {
    return function(n, o) {
      o.prototype.weekYear = function() {
        var l = this.month(), r = this.week(), a = this.year();
        return r === 1 && l === 11 ? a + 1 : l === 0 && r >= 52 ? a - 1 : a;
      };
    };
  });
})(b9);
var yhe = b9.exports;
const y9 = /* @__PURE__ */ Xa(yhe);
var S9 = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Ya, function() {
    return function(n, o, l) {
      o.prototype.dayOfYear = function(r) {
        var a = Math.round((l(this).startOf("day") - l(this).startOf("year")) / 864e5) + 1;
        return r == null ? a : this.add(r - a, "day");
      };
    };
  });
})(S9);
var She = S9.exports;
const Che = /* @__PURE__ */ Xa(She);
var C9 = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Ya, function() {
    return function(n, o) {
      o.prototype.isSameOrAfter = function(l, r) {
        return this.isSame(l, r) || this.isAfter(l, r);
      };
    };
  });
})(C9);
var whe = C9.exports;
const $he = /* @__PURE__ */ Xa(whe);
var w9 = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Ya, function() {
    return function(n, o) {
      o.prototype.isSameOrBefore = function(l, r) {
        return this.isSame(l, r) || this.isBefore(l, r);
      };
    };
  });
})(w9);
var xhe = w9.exports;
const Ehe = /* @__PURE__ */ Xa(xhe), Ohe = Xe(vt(Be({
  valueFormat: String,
  dateFormat: String,
  timeFormat: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  modelValue: {
    type: ye([Date, Array, String, Number]),
    default: ""
  },
  defaultValue: {
    type: ye([Date, Array])
  },
  defaultTime: {
    type: ye([Date, Array])
  },
  isRange: Boolean
}, a_), {
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  arrowControl: Boolean,
  unlinkPanels: Boolean,
  showNow: {
    type: Boolean,
    default: !0
  },
  showConfirm: Boolean,
  showFooter: Boolean,
  showWeekNumber: Boolean,
  type: {
    type: ye(String),
    default: "date"
  },
  clearable: {
    type: Boolean,
    default: !0
  },
  border: {
    type: Boolean,
    default: !0
  },
  editable: {
    type: Boolean,
    default: !0
  }
})), s_ = Symbol("rootPickerContextKey"), gh = "ElIsDefaultFormat", _he = [
  "date",
  "dates",
  "year",
  "years",
  "month",
  "months",
  "week",
  "range"
], c_ = Xe({
  cellClassName: {
    type: ye(Function)
  },
  disabledDate: {
    type: ye(Function)
  },
  date: {
    type: ye(Object),
    required: !0
  },
  minDate: {
    type: ye(Object)
  },
  maxDate: {
    type: ye(Object)
  },
  parsedValue: {
    type: ye([Object, Array])
  },
  rangeState: {
    type: ye(Object),
    default: () => ({
      endDate: null,
      selecting: !1
    })
  },
  disabled: Boolean
}), $9 = Xe({
  type: {
    type: ye(String),
    required: !0,
    values: kfe
  },
  dateFormat: String,
  timeFormat: String,
  showNow: {
    type: Boolean,
    default: !0
  },
  showConfirm: Boolean,
  showFooter: {
    type: Boolean,
    default: !0
  },
  showWeekNumber: Boolean,
  border: Boolean,
  disabled: Boolean,
  editable: {
    type: Boolean,
    default: !0
  }
}), u_ = Xe({
  unlinkPanels: Boolean,
  visible: {
    type: Boolean,
    default: !0
  },
  showConfirm: Boolean,
  showFooter: {
    type: Boolean,
    default: !0
  },
  border: Boolean,
  disabled: Boolean,
  parsedValue: {
    type: ye(Array)
  }
}), d_ = (e) => ({
  type: String,
  values: _he,
  default: e
}), Ihe = Xe(vt(Be({}, $9), {
  parsedValue: {
    type: ye([Object, Array])
  },
  visible: {
    type: Boolean,
    default: !0
  },
  format: {
    type: String,
    default: ""
  }
})), vm = (e) => {
  if (!We(e))
    return !1;
  const [t, n] = e;
  return wt.isDayjs(t) && wt.isDayjs(n) && wt(t).isValid() && wt(n).isValid() && t.isSameOrBefore(n);
}, K1 = (e, { lang: t, step: n = 1, unit: o, unlinkPanels: l }) => {
  let r;
  if (We(e)) {
    let [a, i] = e.map((s) => wt(s).locale(t));
    return l || (i = a.add(n, o)), [a, i];
  } else e ? r = wt(e) : r = wt();
  return r = r.locale(t), [r, r.add(n, o)];
}, The = (e, t, {
  columnIndexOffset: n,
  startDate: o,
  nextEndDate: l,
  now: r,
  unit: a,
  relativeDateGetter: i,
  setCellMetadata: s,
  setRowMetadata: c
}) => {
  for (let u = 0; u < e.row; u++) {
    const d = t[u];
    for (let f = 0; f < e.column; f++) {
      let p = d[f + n];
      p || (p = {
        row: u,
        column: f,
        type: "normal",
        inRange: !1,
        start: !1,
        end: !1
      });
      const m = u * e.column + f, v = i(m);
      p.dayjs = v, p.date = v.toDate(), p.timestamp = v.valueOf(), p.type = "normal", p.inRange = !!(o && v.isSameOrAfter(o, a) && l && v.isSameOrBefore(l, a)) || !!(o && v.isSameOrBefore(o, a) && l && v.isSameOrAfter(l, a)), o != null && o.isSameOrAfter(l) ? (p.start = !!l && v.isSame(l, a), p.end = o && v.isSame(o, a)) : (p.start = !!o && v.isSame(o, a), p.end = !!l && v.isSame(l, a)), v.isSame(r, a) && (p.type = "today"), s == null || s(p, { rowIndex: u, columnIndex: f }), d[f + n] = p;
    }
    c == null || c(d);
  }
}, F0 = (e, t, n, o) => {
  const l = wt().locale(o).startOf("month").month(n).year(t).hour(e.hour()).minute(e.minute()).second(e.second()), r = l.daysInMonth();
  return cc(r).map((a) => l.add(a, "day").toDate());
}, qf = (e, t, n, o, l) => {
  const r = wt().year(t).month(n).startOf("month").hour(e.hour()).minute(e.minute()).second(e.second()), a = F0(e, t, n, o).find((i) => !(l != null && l(i)));
  return a ? wt(a).locale(o) : r.locale(o);
}, V0 = (e, t, n) => {
  const o = e.year();
  if (!(n != null && n(e.toDate())))
    return e.locale(t);
  const l = e.month();
  if (!F0(e, o, l, t).every(n))
    return qf(e, o, l, t, n);
  for (let r = 0; r < 12; r++)
    if (!F0(e, o, r, t).every(n))
      return qf(e, o, r, t, n);
  return e;
}, Jf = (e, t, n, o) => {
  if (We(e))
    return e.map(
      (l) => Jf(l, t, n, o)
    );
  if (rt(e)) {
    const l = o != null && o.value ? wt(e) : wt(e, t);
    if (!l.isValid())
      return l;
  }
  return wt(e, t).locale(n);
}, Phe = Xe(vt(Be({}, c_), {
  showWeekNumber: Boolean,
  selectionMode: d_("date")
})), khe = ["changerange", "pick", "select"], z0 = (e = "") => ["normal", "today"].includes(e), Nhe = (e, t) => {
  const { lang: n } = an(), o = /* @__PURE__ */ H(), l = /* @__PURE__ */ H(), r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H(), i = /* @__PURE__ */ H([[], [], [], [], [], []]);
  let s = !1;
  const c = e.date.$locale().weekStart || 7, u = e.date.locale("en").localeData().weekdaysShort().map((L) => L.toLowerCase()), d = O(() => c > 3 ? 7 - c : -c), f = O(() => {
    const L = e.date.startOf("month");
    return L.subtract(L.day() || 7, "day");
  }), p = O(() => u.concat(u).slice(
    c,
    c + 7
  )), m = O(() => I0(S(C)).some((L) => L.isCurrent)), v = O(() => {
    const L = e.date.startOf("month"), B = L.day() || 7, V = L.daysInMonth(), j = L.subtract(1, "month").daysInMonth();
    return {
      startOfMonthDay: B,
      dateCountOfMonth: V,
      dateCountOfLastMonth: j
    };
  }), h = O(() => e.selectionMode === "dates" ? kl(e.parsedValue) : []), g = (L, { count: B, rowIndex: V, columnIndex: j }) => {
    const { startOfMonthDay: W, dateCountOfMonth: Y, dateCountOfLastMonth: U } = S(v), te = S(d);
    if (V >= 0 && V <= 1) {
      const J = W + te < 0 ? 7 + W + te : W + te;
      if (j + V * 7 >= J)
        return L.text = B, !0;
      L.text = U - (J - j % 7) + 1 + V * 7, L.type = "prev-month";
    } else
      return B <= Y ? L.text = B : (L.text = B - Y, L.type = "next-month"), !0;
    return !1;
  }, y = (L, { columnIndex: B, rowIndex: V }, j) => {
    const { disabledDate: W, cellClassName: Y } = e, U = S(h), te = g(L, { count: j, rowIndex: V, columnIndex: B }), J = L.dayjs.toDate();
    return L.selected = U.find((re) => re.isSame(L.dayjs, "day")), L.isSelected = !!L.selected, L.isCurrent = x(L), L.disabled = W == null ? void 0 : W(J), L.customClass = Y == null ? void 0 : Y(J), te;
  }, b = (L) => {
    if (e.selectionMode === "week") {
      const [B, V] = e.showWeekNumber ? [1, 7] : [0, 6], j = A(L[B + 1]);
      L[B].inRange = j, L[B].start = j, L[V].inRange = j, L[V].end = j;
    }
  }, C = O(() => {
    const { minDate: L, maxDate: B, rangeState: V, showWeekNumber: j } = e, W = S(d), Y = S(i), U = "day";
    let te = 1;
    if (The({ row: 6, column: 7 }, Y, {
      startDate: L,
      columnIndexOffset: j ? 1 : 0,
      nextEndDate: V.endDate || B || V.selecting && L || null,
      now: wt().locale(S(n)).startOf(U),
      unit: U,
      relativeDateGetter: (J) => S(f).add(J - W, U),
      setCellMetadata: (...J) => {
        y(...J, te) && (te += 1);
      },
      setRowMetadata: b
    }), j)
      for (let J = 0; J < 6; J++)
        Y[J][1].dayjs && (Y[J][0] = {
          type: "week",
          text: Y[J][1].dayjs.week()
        });
    return Y;
  });
  pe(
    () => e.date,
    () => Rt(void 0, null, function* () {
      var L;
      (L = S(o)) != null && L.contains(document.activeElement) && (yield Ke(), yield w());
    })
  );
  const w = () => Rt(void 0, null, function* () {
    var L;
    return (L = S(l)) == null ? void 0 : L.focus();
  }), x = (L) => e.selectionMode === "date" && z0(L.type) && E(L, e.parsedValue), E = (L, B) => B ? wt(B).locale(S(n)).isSame(e.date.date(Number(L.text)), "day") : !1, I = (L, B) => {
    const V = L * 7 + (B - (e.showWeekNumber ? 1 : 0)) - S(d);
    return S(f).add(V, "day");
  }, T = (L) => {
    var B;
    if (!e.rangeState.selecting)
      return;
    let V = L.target;
    if (V.tagName === "SPAN" && (V = (B = V.parentNode) == null ? void 0 : B.parentNode), V.tagName === "DIV" && (V = V.parentNode), V.tagName !== "TD")
      return;
    const j = V.parentNode.rowIndex - 1, W = V.cellIndex;
    S(C)[j][W].disabled || (j !== S(r) || W !== S(a)) && (r.value = j, a.value = W, t("changerange", {
      selecting: !0,
      endDate: I(j, W)
    }));
  }, P = (L) => !S(m) && (L == null ? void 0 : L.text) === 1 && z0(L.type) || L.isCurrent, k = (L) => {
    s || S(m) || e.selectionMode !== "date" || M(L, !0);
  }, N = (L) => {
    L.target.closest("td") && (s = !0);
  }, R = (L) => {
    L.target.closest("td") && (s = !1);
  }, z = (L) => {
    !e.rangeState.selecting || !e.minDate ? (t("pick", { minDate: L, maxDate: null }), t("select", !0)) : (L >= e.minDate ? t("pick", { minDate: e.minDate, maxDate: L }) : t("pick", { minDate: L, maxDate: e.minDate }), t("select", !1));
  }, D = (L) => {
    const B = L.week(), V = `${L.year()}w${B}`;
    t("pick", {
      year: L.year(),
      week: B,
      value: V,
      date: L.startOf("week")
    });
  }, F = (L, B) => {
    const V = B ? kl(e.parsedValue).filter(
      (j) => (j == null ? void 0 : j.valueOf()) !== L.valueOf()
    ) : kl(e.parsedValue).concat([L]);
    t("pick", V);
  }, M = (L, B = !1) => {
    if (e.disabled)
      return;
    const V = L.target.closest("td");
    if (!V)
      return;
    const j = V.parentNode.rowIndex - 1, W = V.cellIndex, Y = S(C)[j][W];
    if (Y.disabled || Y.type === "week")
      return;
    const U = I(j, W);
    switch (e.selectionMode) {
      case "range": {
        z(U);
        break;
      }
      case "date": {
        t("pick", U, B);
        break;
      }
      case "week": {
        D(U);
        break;
      }
      case "dates": {
        F(U, !!Y.selected);
        break;
      }
    }
  }, A = (L) => {
    if (e.selectionMode !== "week")
      return !1;
    let B = e.date.startOf("day");
    if (L.type === "prev-month" && (B = B.subtract(1, "month")), L.type === "next-month" && (B = B.add(1, "month")), B = B.date(Number.parseInt(L.text, 10)), e.parsedValue && !We(e.parsedValue)) {
      const V = (e.parsedValue.day() - c + 7) % 7 - 1;
      return e.parsedValue.subtract(V, "day").isSame(B, "day");
    }
    return !1;
  };
  return {
    WEEKS: p,
    rows: C,
    tbodyRef: o,
    currentCellRef: l,
    focus: w,
    isCurrent: x,
    isWeekActive: A,
    isSelectedCell: P,
    handlePickDate: M,
    handleMouseUp: R,
    handleMouseDown: N,
    handleMouseMove: T,
    handleFocus: k
  };
}, Mhe = (e, {
  isCurrent: t,
  isWeekActive: n
}) => {
  const o = Ve("date-table"), { t: l } = an(), r = O(() => [
    o.b(),
    o.is("week-mode", e.selectionMode === "week" && !e.disabled)
  ]), a = O(() => l("el.datepicker.dateTablePrompt")), i = (c) => {
    const u = [];
    return z0(c.type) && !c.disabled ? (u.push("available"), c.type === "today" && u.push("today")) : u.push(c.type), t(c) && u.push("current"), c.inRange && (z0(c.type) || e.selectionMode === "week") && (u.push("in-range"), c.start && u.push("start-date"), c.end && u.push("end-date")), (c.disabled || e.disabled) && u.push("disabled"), c.selected && u.push("selected"), c.customClass && u.push(c.customClass), u.join(" ");
  }, s = (c) => [
    o.e("row"),
    { current: n(c) }
  ];
  return {
    tableKls: r,
    tableLabel: a,
    weekHeaderClass: o.e("week-header"),
    getCellClasses: i,
    getRowKls: s,
    t: l
  };
}, Ahe = Xe({
  cell: {
    type: ye(Object)
  }
});
var f_ = /* @__PURE__ */ le({
  name: "ElDatePickerCell",
  props: Ahe,
  setup(e) {
    const t = Ve("date-table-cell"), {
      slots: n
    } = ze(s_);
    return () => {
      const {
        cell: o
      } = e;
      return Oe(n, "default", Be({}, o), () => {
        var l;
        return [$("div", {
          class: t.b()
        }, [$("span", {
          class: t.e("text")
        }, [(l = o == null ? void 0 : o.renderText) != null ? l : o == null ? void 0 : o.text])])];
      });
    };
  }
});
const Rhe = ["aria-label"], Dhe = ["aria-label"], Lhe = ["aria-current", "aria-selected", "tabindex", "aria-disabled"], Bhe = /* @__PURE__ */ le({
  __name: "basic-date-table",
  props: Phe,
  emits: khe,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, {
      WEEKS: r,
      rows: a,
      tbodyRef: i,
      currentCellRef: s,
      focus: c,
      isCurrent: u,
      isWeekActive: d,
      isSelectedCell: f,
      handlePickDate: p,
      handleMouseUp: m,
      handleMouseDown: v,
      handleMouseMove: h,
      handleFocus: g
    } = Nhe(o, l), { tableLabel: y, tableKls: b, getCellClasses: C, getRowKls: w, weekHeaderClass: x, t: E } = Mhe(o, {
      isCurrent: u,
      isWeekActive: d
    });
    let I = !1;
    return yt(() => {
      I = !0;
    }), t({
      focus: c
    }), (T, P) => (G(), ue("table", {
      "aria-label": S(y),
      class: X(S(b)),
      cellspacing: "0",
      cellpadding: "0",
      role: "grid",
      onClick: P[1] || (P[1] = (...k) => S(p) && S(p)(...k)),
      onMousemove: P[2] || (P[2] = (...k) => S(h) && S(h)(...k)),
      onMousedown: P[3] || (P[3] = (...k) => S(v) && S(v)(...k)),
      onMouseup: P[4] || (P[4] = (...k) => S(m) && S(m)(...k))
    }, [
      ve(
        "tbody",
        {
          ref_key: "tbodyRef",
          ref: i
        },
        [
          ve("tr", null, [
            T.showWeekNumber ? (G(), ue(
              "th",
              {
                key: 0,
                scope: "col",
                class: X(S(x))
              },
              null,
              2
            )) : Ie("v-if", !0),
            (G(!0), ue(
              Ge,
              null,
              on(S(r), (k, N) => (G(), ue("th", {
                key: N,
                "aria-label": S(E)("el.datepicker.weeksFull." + k),
                scope: "col"
              }, qe(S(E)("el.datepicker.weeks." + k)), 9, Dhe))),
              128
            ))
          ]),
          (G(!0), ue(
            Ge,
            null,
            on(S(a), (k, N) => (G(), ue(
              "tr",
              {
                key: N,
                class: X(S(w)(T.showWeekNumber ? k[2] : k[1]))
              },
              [
                (G(!0), ue(
                  Ge,
                  null,
                  on(k, (R, z) => (G(), ue("td", {
                    key: `${N}.${z}`,
                    ref_for: !0,
                    ref: (D) => !S(I) && S(f)(R) && (s.value = D),
                    class: X(S(C)(R)),
                    "aria-current": R.isCurrent ? "date" : void 0,
                    "aria-selected": R.isCurrent,
                    tabindex: T.disabled ? void 0 : S(f)(R) ? 0 : -1,
                    "aria-disabled": T.disabled,
                    onFocus: P[0] || (P[0] = (...D) => S(g) && S(g)(...D))
                  }, [
                    $(S(f_), { cell: R }, null, 8, ["cell"])
                  ], 42, Lhe))),
                  128
                ))
              ],
              2
            ))),
            128
          ))
        ],
        512
      )
    ], 42, Rhe));
  }
});
var yx = /* @__PURE__ */ Je(Bhe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker-panel/src/date-picker-com/basic-date-table.vue"]]);
const Fhe = Xe(vt(Be({}, c_), {
  selectionMode: d_("month")
})), Vhe = ["aria-label"], zhe = ["aria-selected", "aria-label", "tabindex", "onKeydown"], Hhe = /* @__PURE__ */ le({
  __name: "basic-month-table",
  props: Fhe,
  emits: ["changerange", "pick", "select"],
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = Ve("month-table"), { t: a, lang: i } = an(), s = /* @__PURE__ */ H(), c = /* @__PURE__ */ H(), u = /* @__PURE__ */ H(
      o.date.locale("en").localeData().monthsShort().map((C) => C.toLowerCase())
    ), d = /* @__PURE__ */ H([[], [], []]), f = /* @__PURE__ */ H(), p = /* @__PURE__ */ H(), m = O(() => {
      var C, w, x;
      const E = d.value, I = wt().locale(i.value).startOf("month");
      for (let T = 0; T < 3; T++) {
        const P = E[T];
        for (let k = 0; k < 4; k++) {
          const N = P[k] || (P[k] = {
            row: T,
            column: k,
            type: "normal",
            inRange: !1,
            start: !1,
            end: !1,
            text: -1,
            disabled: !1,
            isSelected: !1,
            customClass: void 0,
            date: void 0,
            dayjs: void 0,
            isCurrent: void 0,
            selected: void 0,
            renderText: void 0,
            timestamp: void 0
          });
          N.type = "normal";
          const R = T * 4 + k, z = o.date.startOf("year").month(R), D = o.rangeState.endDate || o.maxDate || o.rangeState.selecting && o.minDate || null;
          N.inRange = !!(o.minDate && z.isSameOrAfter(o.minDate, "month") && D && z.isSameOrBefore(D, "month")) || !!(o.minDate && z.isSameOrBefore(o.minDate, "month") && D && z.isSameOrAfter(D, "month")), (C = o.minDate) != null && C.isSameOrAfter(D) ? (N.start = !!(D && z.isSame(D, "month")), N.end = o.minDate && z.isSame(o.minDate, "month")) : (N.start = !!(o.minDate && z.isSame(o.minDate, "month")), N.end = !!(D && z.isSame(D, "month"))), I.isSame(z) && (N.type = "today");
          const M = z.toDate();
          N.text = R, N.disabled = ((w = o.disabledDate) == null ? void 0 : w.call(o, M)) || !1, N.date = M, N.customClass = (x = o.cellClassName) == null ? void 0 : x.call(o, M), N.dayjs = z, N.timestamp = z.valueOf(), N.isSelected = g(N);
        }
      }
      return E;
    }), v = () => {
      var C;
      (C = c.value) == null || C.focus();
    }, h = (C) => {
      const w = {}, x = o.date.year(), E = /* @__PURE__ */ new Date(), I = C.text;
      return w.disabled = o.disabled || (o.disabledDate ? F0(o.date, x, I, i.value).every(
        o.disabledDate
      ) : !1), w.current = kl(o.parsedValue).some(
        (T) => wt.isDayjs(T) && T.year() === x && T.month() === I
      ), w.today = E.getFullYear() === x && E.getMonth() === I, C.customClass && (w[C.customClass] = !0), C.inRange && (w["in-range"] = !0, C.start && (w["start-date"] = !0), C.end && (w["end-date"] = !0)), w;
    }, g = (C) => {
      const w = o.date.year(), x = C.text;
      return kl(o.date).some(
        (E) => E.year() === w && E.month() === x
      );
    }, y = (C) => {
      var w;
      if (!o.rangeState.selecting)
        return;
      let x = C.target;
      if (x.tagName === "SPAN" && (x = (w = x.parentNode) == null ? void 0 : w.parentNode), x.tagName === "DIV" && (x = x.parentNode), x.tagName !== "TD")
        return;
      const E = x.parentNode.rowIndex, I = x.cellIndex;
      m.value[E][I].disabled || (E !== f.value || I !== p.value) && (f.value = E, p.value = I, l("changerange", {
        selecting: !0,
        endDate: o.date.startOf("year").month(E * 4 + I)
      }));
    }, b = (C) => {
      var w;
      if (o.disabled)
        return;
      const x = (w = C.target) == null ? void 0 : w.closest(
        "td"
      );
      if ((x == null ? void 0 : x.tagName) !== "TD" || pi(x, "disabled"))
        return;
      const E = x.cellIndex, T = x.parentNode.rowIndex * 4 + E, P = o.date.startOf("year").month(T);
      if (o.selectionMode === "months") {
        if (C.type === "keydown") {
          l("pick", kl(o.parsedValue), !1);
          return;
        }
        const k = qf(
          o.date,
          o.date.year(),
          T,
          i.value,
          o.disabledDate
        ), N = pi(x, "current") ? kl(o.parsedValue).filter(
          (R) => (R == null ? void 0 : R.year()) !== k.year() || (R == null ? void 0 : R.month()) !== k.month()
        ) : kl(o.parsedValue).concat([wt(k)]);
        l("pick", N);
      } else o.selectionMode === "range" ? o.rangeState.selecting ? (o.minDate && P >= o.minDate ? l("pick", { minDate: o.minDate, maxDate: P }) : l("pick", { minDate: P, maxDate: o.minDate }), l("select", !1)) : (l("pick", { minDate: P, maxDate: null }), l("select", !0)) : l("pick", T);
    };
    return pe(
      () => o.date,
      () => Rt(this, null, function* () {
        var C, w;
        (C = s.value) != null && C.contains(document.activeElement) && (yield Ke(), (w = c.value) == null || w.focus());
      })
    ), t({
      focus: v
    }), (C, w) => (G(), ue("table", {
      role: "grid",
      "aria-label": S(a)("el.datepicker.monthTablePrompt"),
      class: X(S(r).b()),
      onClick: b,
      onMousemove: y
    }, [
      ve(
        "tbody",
        {
          ref_key: "tbodyRef",
          ref: s
        },
        [
          (G(!0), ue(
            Ge,
            null,
            on(m.value, (x, E) => (G(), ue("tr", { key: E }, [
              (G(!0), ue(
                Ge,
                null,
                on(x, (I, T) => (G(), ue("td", {
                  key: T,
                  ref_for: !0,
                  ref: (P) => I.isSelected && (c.value = P),
                  class: X(h(I)),
                  "aria-selected": !!I.isSelected,
                  "aria-label": S(a)(`el.datepicker.month${+I.text + 1}`),
                  tabindex: I.isSelected ? 0 : -1,
                  onKeydown: [
                    uo(Et(b, ["prevent", "stop"]), ["space"]),
                    uo(Et(b, ["prevent", "stop"]), ["enter"])
                  ]
                }, [
                  $(S(f_), {
                    cell: vt(Be({}, I), {
                      renderText: S(a)("el.datepicker.months." + u.value[I.text])
                    })
                  }, null, 8, ["cell"])
                ], 42, zhe))),
                128
              ))
            ]))),
            128
          ))
        ],
        512
      )
    ], 42, Vhe));
  }
});
var mm = /* @__PURE__ */ Je(Hhe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker-panel/src/date-picker-com/basic-month-table.vue"]]);
const jhe = Xe(vt(Be({}, c_), {
  selectionMode: d_("year")
})), Whe = ["aria-label"], Khe = ["aria-selected", "aria-label", "tabindex", "onKeydown"], Uhe = /* @__PURE__ */ le({
  __name: "basic-year-table",
  props: jhe,
  emits: ["changerange", "pick", "select"],
  setup(e, { expose: t, emit: n }) {
    const o = (w, x) => {
      const E = wt(String(w)).locale(x).startOf("year"), T = E.endOf("year").dayOfYear();
      return cc(T).map((P) => E.add(P, "day").toDate());
    }, l = e, r = n, a = Ve("year-table"), { t: i, lang: s } = an(), c = /* @__PURE__ */ H(), u = /* @__PURE__ */ H(), d = O(() => Math.floor(l.date.year() / 10) * 10), f = /* @__PURE__ */ H([[], [], []]), p = /* @__PURE__ */ H(), m = /* @__PURE__ */ H(), v = O(() => {
      var w, x, E;
      const I = f.value, T = wt().locale(s.value).startOf("year");
      for (let P = 0; P < 3; P++) {
        const k = I[P];
        for (let N = 0; N < 4 && !(P * 4 + N >= 10); N++) {
          let R = k[N];
          R || (R = {
            row: P,
            column: N,
            type: "normal",
            inRange: !1,
            start: !1,
            end: !1,
            text: -1,
            disabled: !1,
            isSelected: !1,
            customClass: void 0,
            date: void 0,
            dayjs: void 0,
            isCurrent: void 0,
            selected: void 0,
            renderText: void 0,
            timestamp: void 0
          }), R.type = "normal";
          const z = P * 4 + N + d.value, D = wt().year(z), F = l.rangeState.endDate || l.maxDate || l.rangeState.selecting && l.minDate || null;
          R.inRange = !!(l.minDate && D.isSameOrAfter(l.minDate, "year") && F && D.isSameOrBefore(F, "year")) || !!(l.minDate && D.isSameOrBefore(l.minDate, "year") && F && D.isSameOrAfter(F, "year")), (w = l.minDate) != null && w.isSameOrAfter(F) ? (R.start = !!(F && D.isSame(F, "year")), R.end = !!(l.minDate && D.isSame(l.minDate, "year"))) : (R.start = !!(l.minDate && D.isSame(l.minDate, "year")), R.end = !!(F && D.isSame(F, "year"))), T.isSame(D) && (R.type = "today"), R.text = z;
          const A = D.toDate();
          R.disabled = ((x = l.disabledDate) == null ? void 0 : x.call(l, A)) || !1, R.date = A, R.customClass = (E = l.cellClassName) == null ? void 0 : E.call(l, A), R.dayjs = D, R.timestamp = D.valueOf(), R.isSelected = y(R), k[N] = R;
        }
      }
      return I;
    }), h = () => {
      var w;
      (w = u.value) == null || w.focus();
    }, g = (w) => {
      const x = {}, E = wt().locale(s.value), I = w.text;
      return x.disabled = l.disabled || (l.disabledDate ? o(I, s.value).every(l.disabledDate) : !1), x.today = E.year() === I, x.current = kl(l.parsedValue).some((T) => T.year() === I), w.customClass && (x[w.customClass] = !0), w.inRange && (x["in-range"] = !0, w.start && (x["start-date"] = !0), w.end && (x["end-date"] = !0)), x;
    }, y = (w) => {
      const x = w.text;
      return kl(l.date).some((E) => E.year() === x);
    }, b = (w) => {
      var x;
      if (l.disabled)
        return;
      const E = (x = w.target) == null ? void 0 : x.closest(
        "td"
      );
      if (!E || !E.textContent || pi(E, "disabled"))
        return;
      const I = E.cellIndex, P = E.parentNode.rowIndex * 4 + I + d.value, k = wt().year(P);
      if (l.selectionMode === "range")
        l.rangeState.selecting ? (l.minDate && k >= l.minDate ? r("pick", { minDate: l.minDate, maxDate: k }) : r("pick", { minDate: k, maxDate: l.minDate }), r("select", !1)) : (r("pick", { minDate: k, maxDate: null }), r("select", !0));
      else if (l.selectionMode === "years") {
        if (w.type === "keydown") {
          r("pick", kl(l.parsedValue), !1);
          return;
        }
        const N = V0(
          k.startOf("year"),
          s.value,
          l.disabledDate
        ), R = pi(E, "current") ? kl(l.parsedValue).filter((z) => (z == null ? void 0 : z.year()) !== P) : kl(l.parsedValue).concat([N]);
        r("pick", R);
      } else
        r("pick", P);
    }, C = (w) => {
      var x;
      if (!l.rangeState.selecting)
        return;
      const E = (x = w.target) == null ? void 0 : x.closest(
        "td"
      );
      if (!E)
        return;
      const I = E.parentNode.rowIndex, T = E.cellIndex;
      v.value[I][T].disabled || (I !== p.value || T !== m.value) && (p.value = I, m.value = T, r("changerange", {
        selecting: !0,
        endDate: wt().year(d.value).add(I * 4 + T, "year")
      }));
    };
    return pe(
      () => l.date,
      () => Rt(this, null, function* () {
        var w, x;
        (w = c.value) != null && w.contains(document.activeElement) && (yield Ke(), (x = u.value) == null || x.focus());
      })
    ), t({
      focus: h
    }), (w, x) => (G(), ue("table", {
      role: "grid",
      "aria-label": S(i)("el.datepicker.yearTablePrompt"),
      class: X(S(a).b()),
      onClick: b,
      onMousemove: C
    }, [
      ve(
        "tbody",
        {
          ref_key: "tbodyRef",
          ref: c
        },
        [
          (G(!0), ue(
            Ge,
            null,
            on(v.value, (E, I) => (G(), ue("tr", { key: I }, [
              (G(!0), ue(
                Ge,
                null,
                on(E, (T, P) => (G(), ue("td", {
                  key: `${I}_${P}`,
                  ref_for: !0,
                  ref: (k) => T.isSelected && (u.value = k),
                  class: X(["available", g(T)]),
                  "aria-selected": T.isSelected,
                  "aria-label": String(T.text),
                  tabindex: T.isSelected ? 0 : -1,
                  onKeydown: [
                    uo(Et(b, ["prevent", "stop"]), ["space"]),
                    uo(Et(b, ["prevent", "stop"]), ["enter"])
                  ]
                }, [
                  $(S(f_), { cell: T }, null, 8, ["cell"])
                ], 42, Khe))),
                128
              ))
            ]))),
            128
          ))
        ],
        512
      )
    ], 42, Whe));
  }
});
var hm = /* @__PURE__ */ Je(Uhe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker-panel/src/date-picker-com/basic-year-table.vue"]]);
const Ghe = ["disabled", "onClick"], Yhe = ["aria-label", "disabled"], Xhe = ["aria-label", "disabled"], qhe = ["tabindex", "aria-disabled"], Jhe = ["tabindex", "aria-disabled"], Zhe = ["aria-label", "disabled"], Qhe = ["aria-label", "disabled"], ege = /* @__PURE__ */ le({
  __name: "panel-date-pick",
  props: Ihe,
  emits: ["pick", "set-picker-option", "panel-change"],
  setup(e, { emit: t }) {
    const n = (Ae, De, _e) => !0, o = e, l = t, r = Ve("picker-panel"), a = Ve("date-picker"), i = Ti(), s = So(), { t: c, lang: u } = an(), d = ze(Va), f = ze(
      gh,
      void 0
    ), { shortcuts: p, disabledDate: m, cellClassName: v, defaultTime: h } = d.props, g = /* @__PURE__ */ ft(d.props, "defaultValue"), y = /* @__PURE__ */ H(), b = /* @__PURE__ */ H(wt().locale(u.value)), C = /* @__PURE__ */ H(!1);
    let w = !1;
    const x = O(() => wt(h).locale(u.value)), E = O(() => b.value.month()), I = O(() => b.value.year()), T = /* @__PURE__ */ H([]), P = /* @__PURE__ */ H(null), k = /* @__PURE__ */ H(null), N = (Ae) => T.value.length > 0 ? n(Ae, T.value, o.format || "HH:mm:ss") : !0, R = (Ae) => h && !he.value && !C.value && !w ? x.value.year(Ae.year()).month(Ae.month()).date(Ae.date()) : oe.value ? Ae.millisecond(0) : Ae.startOf("day"), z = (Ae, ...De) => {
      if (!Ae)
        l("pick", Ae, ...De);
      else if (We(Ae)) {
        const _e = Ae.map(R);
        l("pick", _e, ...De);
      } else
        l("pick", R(Ae), ...De);
      P.value = null, k.value = null, C.value = !1, w = !1;
    }, D = (Ae, De) => Rt(this, null, function* () {
      if (V.value === "date" && wt.isDayjs(Ae)) {
        const _e = Qp(o.parsedValue);
        let Ze = _e ? _e.year(Ae.year()).month(Ae.month()).date(Ae.date()) : Ae;
        N(Ze), b.value = Ze, z(Ze, oe.value || De);
      } else V.value === "week" ? z(Ae.date) : V.value === "dates" && z(Ae, !0);
    }), F = (Ae) => {
      const De = Ae ? "add" : "subtract";
      b.value = b.value[De](1, "month"), Ue("month");
    }, M = (Ae) => {
      const De = b.value, _e = Ae ? "add" : "subtract";
      b.value = A.value === "year" ? De[_e](10, "year") : De[_e](1, "year"), Ue("year");
    }, A = /* @__PURE__ */ H("date"), L = O(() => {
      const Ae = c("el.datepicker.year");
      if (A.value === "year") {
        const De = Math.floor(I.value / 10) * 10;
        return Ae ? `${De} ${Ae} - ${De + 9} ${Ae}` : `${De} - ${De + 9}`;
      }
      return `${I.value} ${Ae}`;
    }), B = (Ae) => {
      const De = it(Ae.value) ? Ae.value() : Ae.value;
      if (De) {
        w = !0, z(wt(De).locale(u.value));
        return;
      }
      Ae.onClick && Ae.onClick({
        attrs: i,
        slots: s,
        emit: l
      });
    }, V = O(() => {
      const { type: Ae } = o;
      return ["week", "month", "months", "year", "years", "dates"].includes(Ae) ? Ae : "date";
    }), j = O(() => V.value === "dates" || V.value === "months" || V.value === "years"), W = O(() => V.value === "date" ? A.value : V.value), Y = O(() => !!p.length), U = (Ae, De) => Rt(this, null, function* () {
      V.value === "month" ? (b.value = qf(
        b.value,
        b.value.year(),
        Ae,
        u.value,
        m
      ), z(b.value, !1)) : V.value === "months" ? z(Ae, De != null ? De : !0) : (b.value = qf(
        b.value,
        b.value.year(),
        Ae,
        u.value,
        m
      ), A.value = "date", ["month", "year", "date", "week"].includes(V.value) && (z(b.value, !0), yield Ke(), tt())), Ue("month");
    }), te = (Ae, De) => Rt(this, null, function* () {
      if (V.value === "year") {
        const _e = b.value.startOf("year").year(Ae);
        b.value = V0(_e, u.value, m), z(b.value, !1);
      } else if (V.value === "years")
        z(Ae, De != null ? De : !0);
      else {
        const _e = b.value.year(Ae);
        b.value = V0(_e, u.value, m), A.value = "month", ["month", "year", "date", "week"].includes(V.value) && (z(b.value, !0), yield Ke(), tt());
      }
      Ue("year");
    }), J = io(), re = (Ae) => Rt(this, null, function* () {
      J.value || (A.value = Ae, yield Ke(), tt());
    }), oe = O(
      () => o.type === "datetime" || o.type === "datetimerange"
    ), q = O(() => {
      const Ae = oe.value || V.value === "dates", De = V.value === "years", _e = V.value === "months", Ze = A.value === "date", dt = A.value === "year", Tt = A.value === "month";
      return Ae && Ze || De && dt || _e && Tt;
    }), K = O(
      () => !j.value && o.showNow || o.showConfirm
    ), se = O(() => m ? o.parsedValue ? We(o.parsedValue) ? m(o.parsedValue[0].toDate()) : m(o.parsedValue.toDate()) : !0 : !1), Z = () => {
      if (j.value)
        z(o.parsedValue);
      else {
        let Ae = Qp(o.parsedValue);
        if (!Ae) {
          const De = wt(h).locale(u.value), _e = Ne();
          Ae = De.year(_e.year()).month(_e.month()).date(_e.date());
        }
        b.value = Ae, z(Ae);
      }
    }, ee = O(() => m ? m(wt().locale(u.value).toDate()) : !1), fe = () => {
      const De = wt().locale(u.value).toDate();
      C.value = !0, (!m || !m(De)) && N(De) && (b.value = wt().locale(u.value), z(b.value));
    }, me = O(() => o.timeFormat || yF(o.format) || Xf), ge = O(() => o.dateFormat || bF(o.format) || Ys), he = O(() => k.value ? k.value : !o.parsedValue && !g.value ? void 0 : (Qp(o.parsedValue) || b.value).format(me.value)), $e = O(() => P.value ? P.value : !o.parsedValue && !g.value ? void 0 : (Qp(o.parsedValue) || b.value).format(ge.value)), ne = /* @__PURE__ */ H(!1), ae = () => {
      ne.value = !0;
    }, ce = () => {
      ne.value = !1;
    }, xe = (Ae) => ({
      hour: Ae.hour(),
      minute: Ae.minute(),
      second: Ae.second(),
      year: Ae.year(),
      month: Ae.month(),
      date: Ae.date()
    }), Te = (Ae, De, _e) => {
      const { hour: Ze, minute: dt, second: Tt } = xe(Ae), jt = Qp(o.parsedValue), Qt = jt ? jt.hour(Ze).minute(dt).second(Tt) : Ae;
      b.value = Qt, z(b.value, !0), _e || (ne.value = De);
    }, Se = (Ae) => {
      const De = wt(Ae, me.value).locale(u.value);
      if (De.isValid() && N(De)) {
        const { year: _e, month: Ze, date: dt } = xe(b.value);
        b.value = De.year(_e).month(Ze).date(dt), k.value = null, ne.value = !1, z(b.value, !0);
      }
    }, be = (Ae) => {
      const De = Jf(
        Ae,
        ge.value,
        u.value,
        f
      );
      if (De.isValid()) {
        if (m && m(De.toDate()))
          return;
        const { hour: _e, minute: Ze, second: dt } = xe(b.value);
        b.value = De.hour(_e).minute(Ze).second(dt), P.value = null, z(b.value, !0);
      }
    }, ie = (Ae) => wt.isDayjs(Ae) && Ae.isValid() && (m ? !m(Ae.toDate()) : !0), we = (Ae) => Jf(
      Ae,
      o.format,
      u.value,
      f
    ), Ne = () => {
      const Ae = wt(g.value).locale(u.value);
      if (!g.value) {
        const De = x.value;
        return wt().hour(De.hour()).minute(De.minute()).second(De.second()).locale(u.value);
      }
      return Ae;
    }, tt = () => {
      var Ae;
      ["week", "month", "year", "date"].includes(V.value) && ((Ae = y.value) == null || Ae.focus());
    }, Pe = () => {
      tt(), V.value === "week" && Le(Ye.down);
    }, Re = (Ae) => {
      const De = Nn(Ae);
      [
        Ye.up,
        Ye.down,
        Ye.left,
        Ye.right,
        Ye.home,
        Ye.end,
        Ye.pageUp,
        Ye.pageDown
      ].includes(De) && (Le(De), Ae.stopPropagation(), Ae.preventDefault()), [Ye.enter, Ye.space, Ye.numpadEnter].includes(
        De
      ) && P.value === null && k.value === null && (Ae.preventDefault(), z(b.value, !1));
    }, Le = (Ae) => {
      var De;
      const { up: _e, down: Ze, left: dt, right: Tt, home: jt, end: Qt, pageUp: je, pageDown: lt } = Ye, Ct = {
        year: {
          [_e]: -4,
          [Ze]: 4,
          [dt]: -1,
          [Tt]: 1,
          offset: (tn, ct) => tn.setFullYear(tn.getFullYear() + ct)
        },
        month: {
          [_e]: -4,
          [Ze]: 4,
          [dt]: -1,
          [Tt]: 1,
          offset: (tn, ct) => tn.setMonth(tn.getMonth() + ct)
        },
        week: {
          [_e]: -1,
          [Ze]: 1,
          [dt]: -1,
          [Tt]: 1,
          offset: (tn, ct) => tn.setDate(tn.getDate() + ct * 7)
        },
        date: {
          [_e]: -7,
          [Ze]: 7,
          [dt]: -1,
          [Tt]: 1,
          [jt]: (tn) => -tn.getDay(),
          [Qt]: (tn) => -tn.getDay() + 6,
          [je]: (tn) => -new Date(tn.getFullYear(), tn.getMonth(), 0).getDate(),
          [lt]: (tn) => new Date(tn.getFullYear(), tn.getMonth() + 1, 0).getDate(),
          offset: (tn, ct) => tn.setDate(tn.getDate() + ct)
        }
      }, vn = b.value.toDate();
      for (; Math.abs(b.value.diff(vn, "year", !0)) < 1; ) {
        const tn = Ct[W.value];
        if (!tn)
          return;
        if (tn.offset(
          vn,
          it(tn[Ae]) ? tn[Ae](vn) : (De = tn[Ae]) != null ? De : 0
        ), m && m(vn))
          break;
        const ct = wt(vn).locale(u.value);
        b.value = ct, l("pick", ct, !0);
        break;
      }
    }, Ue = (Ae) => {
      l("panel-change", b.value.toDate(), Ae, A.value);
    };
    return pe(
      () => V.value,
      (Ae) => {
        if (["month", "year"].includes(Ae)) {
          A.value = Ae;
          return;
        } else if (Ae === "years") {
          A.value = "year";
          return;
        } else if (Ae === "months") {
          A.value = "month";
          return;
        }
        A.value = "date";
      },
      { immediate: !0 }
    ), pe(
      () => g.value,
      (Ae) => {
        Ae && (b.value = Ne());
      },
      { immediate: !0 }
    ), pe(
      () => o.parsedValue,
      (Ae) => {
        if (Ae) {
          if (j.value || We(Ae))
            return;
          b.value = Ae;
        } else
          b.value = Ne();
      },
      { immediate: !0 }
    ), l("set-picker-option", ["isValidValue", ie]), l("set-picker-option", ["parseUserInput", we]), l("set-picker-option", ["handleFocusPicker", Pe]), (Ae, De) => (G(), ue(
      "div",
      {
        class: X([
          S(r).b(),
          S(a).b(),
          S(r).is("border", Ae.border),
          S(r).is("disabled", S(J)),
          {
            "has-sidebar": Ae.$slots.sidebar || Y.value,
            "has-time": oe.value
          }
        ])
      },
      [
        ve(
          "div",
          {
            class: X(S(r).e("body-wrapper"))
          },
          [
            Oe(Ae.$slots, "sidebar", {
              class: X(S(r).e("sidebar"))
            }),
            Y.value ? (G(), ue(
              "div",
              {
                key: 0,
                class: X(S(r).e("sidebar"))
              },
              [
                (G(!0), ue(
                  Ge,
                  null,
                  on(S(p), (_e, Ze) => (G(), ue("button", {
                    key: Ze,
                    type: "button",
                    disabled: S(J),
                    class: X(S(r).e("shortcut")),
                    onClick: (dt) => B(_e)
                  }, qe(_e.text), 11, Ghe))),
                  128
                ))
              ],
              2
            )) : Ie("v-if", !0),
            ve(
              "div",
              {
                class: X(S(r).e("body"))
              },
              [
                oe.value ? (G(), ue(
                  "div",
                  {
                    key: 0,
                    class: X(S(a).e("time-header"))
                  },
                  [
                    ve(
                      "span",
                      {
                        class: X(S(a).e("editor-wrap"))
                      },
                      [
                        $(S(Nl), {
                          placeholder: S(c)("el.datepicker.selectDate"),
                          "model-value": $e.value,
                          size: "small",
                          "validate-event": !1,
                          disabled: S(J),
                          readonly: !Ae.editable,
                          onInput: De[0] || (De[0] = (_e) => P.value = _e),
                          onChange: be
                        }, null, 8, ["placeholder", "model-value", "disabled", "readonly"])
                      ],
                      2
                    ),
                    _t((G(), ue(
                      "span",
                      {
                        class: X(S(a).e("editor-wrap"))
                      },
                      [
                        $(S(Nl), {
                          placeholder: S(c)("el.datepicker.selectTime"),
                          "model-value": he.value,
                          size: "small",
                          "validate-event": !1,
                          disabled: S(J),
                          readonly: !Ae.editable,
                          onFocus: ae,
                          onInput: De[1] || (De[1] = (_e) => k.value = _e),
                          onChange: Se
                        }, null, 8, ["placeholder", "model-value", "disabled", "readonly"]),
                        $(S(B0), {
                          visible: ne.value,
                          format: me.value,
                          "parsed-value": b.value,
                          onPick: Te
                        }, null, 8, ["visible", "format", "parsed-value"])
                      ],
                      2
                    )), [
                      [S(Cc), ce]
                    ])
                  ],
                  2
                )) : Ie("v-if", !0),
                _t(ve(
                  "div",
                  {
                    class: X([
                      S(a).e("header"),
                      (A.value === "year" || A.value === "month") && S(a).em("header", "bordered")
                    ])
                  },
                  [
                    ve(
                      "span",
                      {
                        class: X(S(a).e("prev-btn"))
                      },
                      [
                        ve("button", {
                          type: "button",
                          "aria-label": S(c)("el.datepicker.prevYear"),
                          class: X(["d-arrow-left", S(r).e("icon-btn")]),
                          disabled: S(J),
                          onClick: De[2] || (De[2] = (_e) => M(!1))
                        }, [
                          Oe(Ae.$slots, "prev-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(bc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, Yhe),
                        _t(ve("button", {
                          type: "button",
                          "aria-label": S(c)("el.datepicker.prevMonth"),
                          class: X([S(r).e("icon-btn"), "arrow-left"]),
                          disabled: S(J),
                          onClick: De[3] || (De[3] = (_e) => F(!1))
                        }, [
                          Oe(Ae.$slots, "prev-month", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(ms))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, Xhe), [
                          [Jt, A.value === "date"]
                        ])
                      ],
                      2
                    ),
                    ve("span", {
                      role: "button",
                      class: X(S(a).e("header-label")),
                      "aria-live": "polite",
                      tabindex: Ae.disabled ? void 0 : 0,
                      "aria-disabled": Ae.disabled,
                      onKeydown: De[4] || (De[4] = uo((_e) => re("year"), ["enter"])),
                      onClick: De[5] || (De[5] = (_e) => re("year"))
                    }, qe(L.value), 43, qhe),
                    _t(ve("span", {
                      role: "button",
                      "aria-live": "polite",
                      tabindex: Ae.disabled ? void 0 : 0,
                      "aria-disabled": Ae.disabled,
                      class: X([
                        S(a).e("header-label"),
                        { active: A.value === "month" }
                      ]),
                      onKeydown: De[6] || (De[6] = uo((_e) => re("month"), ["enter"])),
                      onClick: De[7] || (De[7] = (_e) => re("month"))
                    }, qe(S(c)(`el.datepicker.month${E.value + 1}`)), 43, Jhe), [
                      [Jt, A.value === "date"]
                    ]),
                    ve(
                      "span",
                      {
                        class: X(S(a).e("next-btn"))
                      },
                      [
                        _t(ve("button", {
                          type: "button",
                          "aria-label": S(c)("el.datepicker.nextMonth"),
                          class: X([S(r).e("icon-btn"), "arrow-right"]),
                          disabled: S(J),
                          onClick: De[8] || (De[8] = (_e) => F(!0))
                        }, [
                          Oe(Ae.$slots, "next-month", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(Rl))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, Zhe), [
                          [Jt, A.value === "date"]
                        ]),
                        ve("button", {
                          type: "button",
                          "aria-label": S(c)("el.datepicker.nextYear"),
                          class: X([S(r).e("icon-btn"), "d-arrow-right"]),
                          disabled: S(J),
                          onClick: De[9] || (De[9] = (_e) => M(!0))
                        }, [
                          Oe(Ae.$slots, "next-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(yc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, Qhe)
                      ],
                      2
                    )
                  ],
                  2
                ), [
                  [Jt, A.value !== "time"]
                ]),
                ve(
                  "div",
                  {
                    class: X(S(r).e("content")),
                    onKeydown: Re
                  },
                  [
                    A.value === "date" ? (G(), Me(yx, {
                      key: 0,
                      ref_key: "currentViewRef",
                      ref: y,
                      "selection-mode": V.value,
                      date: b.value,
                      "parsed-value": Ae.parsedValue,
                      "disabled-date": S(m),
                      disabled: S(J),
                      "cell-class-name": S(v),
                      "show-week-number": Ae.showWeekNumber,
                      onPick: D
                    }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "disabled", "cell-class-name", "show-week-number"])) : Ie("v-if", !0),
                    A.value === "year" ? (G(), Me(hm, {
                      key: 1,
                      ref_key: "currentViewRef",
                      ref: y,
                      "selection-mode": V.value,
                      date: b.value,
                      "disabled-date": S(m),
                      disabled: S(J),
                      "parsed-value": Ae.parsedValue,
                      "cell-class-name": S(v),
                      onPick: te
                    }, null, 8, ["selection-mode", "date", "disabled-date", "disabled", "parsed-value", "cell-class-name"])) : Ie("v-if", !0),
                    A.value === "month" ? (G(), Me(mm, {
                      key: 2,
                      ref_key: "currentViewRef",
                      ref: y,
                      "selection-mode": V.value,
                      date: b.value,
                      "parsed-value": Ae.parsedValue,
                      "disabled-date": S(m),
                      disabled: S(J),
                      "cell-class-name": S(v),
                      onPick: U
                    }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "disabled", "cell-class-name"])) : Ie("v-if", !0)
                  ],
                  34
                )
              ],
              2
            )
          ],
          2
        ),
        Ae.showFooter && q.value && K.value ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(r).e("footer"))
          },
          [
            _t($(S(Qo), {
              text: "",
              size: "small",
              class: X(S(r).e("link-btn")),
              disabled: ee.value,
              onClick: fe
            }, {
              default: Ee(() => [
                Ft(
                  qe(S(c)("el.datepicker.now")),
                  1
                )
              ]),
              _: 1
            }, 8, ["class", "disabled"]), [
              [Jt, !j.value && Ae.showNow]
            ]),
            Ae.showConfirm ? (G(), Me(S(Qo), {
              key: 0,
              plain: "",
              size: "small",
              class: X(S(r).e("link-btn")),
              disabled: se.value,
              onClick: Z
            }, {
              default: Ee(() => [
                Ft(
                  qe(S(c)("el.datepicker.confirm")),
                  1
                )
              ]),
              _: 1
            }, 8, ["class", "disabled"])) : Ie("v-if", !0)
          ],
          2
        )) : Ie("v-if", !0)
      ],
      2
    ));
  }
});
var tge = /* @__PURE__ */ Je(ege, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker-panel/src/date-picker-com/panel-date-pick.vue"]]);
const nge = Xe(Be(Be({}, $9), u_)), oge = (e) => {
  const { emit: t } = xt(), n = Ti(), o = So();
  return (r) => {
    const a = it(r.value) ? r.value() : r.value;
    if (a) {
      t("pick", [
        wt(a[0]).locale(e.value),
        wt(a[1]).locale(e.value)
      ]);
      return;
    }
    r.onClick && r.onClick({
      attrs: n,
      slots: o,
      emit: t
    });
  };
}, p_ = (e, {
  defaultValue: t,
  defaultTime: n,
  leftDate: o,
  rightDate: l,
  step: r,
  unit: a,
  sortDates: i
}) => {
  const { emit: s } = xt(), { pickerNs: c } = ze(s_), u = Ve("date-range-picker"), { t: d, lang: f } = an(), p = oge(f), m = /* @__PURE__ */ H(), v = /* @__PURE__ */ H(), h = /* @__PURE__ */ H({
    endDate: null,
    selecting: !1
  }), g = (x) => {
    h.value = x;
  }, y = (x = !1) => {
    const E = S(m), I = S(v);
    vm([E, I]) && s("pick", [E, I], x);
  }, b = (x) => {
    h.value.selecting = x, x || (h.value.endDate = null);
  }, C = (x) => {
    if (We(x) && x.length === 2) {
      const [E, I] = x;
      m.value = E, o.value = E, v.value = I, i(S(m), S(v));
    } else
      w();
  }, w = () => {
    let [x, E] = K1(S(t), {
      lang: S(f),
      step: r,
      unit: a,
      unlinkPanels: e.unlinkPanels
    });
    const I = (P) => P.diff(P.startOf("d"), "ms"), T = S(n);
    if (T) {
      let P = 0, k = 0;
      if (We(T)) {
        const [N, R] = T.map(wt);
        P = I(N), k = I(R);
      } else {
        const N = I(wt(T));
        P = N, k = N;
      }
      x = x.startOf("d").add(P, "ms"), E = E.startOf("d").add(k, "ms");
    }
    m.value = void 0, v.value = void 0, o.value = x, l.value = E;
  };
  return pe(
    t,
    (x) => {
      x && w();
    },
    { immediate: !0 }
  ), pe(
    () => e.parsedValue,
    (x) => {
      (!(x != null && x.length) || !Jn(x, [m.value, v.value])) && C(x);
    },
    {
      immediate: !0
    }
  ), pe(
    () => e.visible,
    () => {
      e.visible && C(e.parsedValue);
    },
    { immediate: !0 }
  ), {
    minDate: m,
    maxDate: v,
    rangeState: h,
    lang: f,
    ppNs: c,
    drpNs: u,
    handleChangeRange: g,
    handleRangeConfirm: y,
    handleShortcutClick: p,
    onSelect: b,
    parseValue: C,
    t: d
  };
}, lge = (e, t, n, o) => {
  const l = /* @__PURE__ */ H("date"), r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H("date"), i = /* @__PURE__ */ H(), s = ze(Va), { disabledDate: c } = s.props, { t: u, lang: d } = an(), f = O(() => n.value.year()), p = O(() => n.value.month()), m = O(() => o.value.year()), v = O(() => o.value.month());
  function h(x, E) {
    const I = u("el.datepicker.year");
    if (x.value === "year") {
      const T = Math.floor(E.value / 10) * 10;
      return I ? `${T} ${I} - ${T + 9} ${I}` : `${T} - ${T + 9}`;
    }
    return `${E.value} ${I}`;
  }
  function g(x) {
    x == null || x.focus();
  }
  function y(x, E) {
    return Rt(this, null, function* () {
      if (e.disabled)
        return;
      const I = x === "left" ? l : a, T = x === "left" ? r : i;
      I.value = E, yield Ke(), g(T.value);
    });
  }
  function b(x, E, I) {
    return Rt(this, null, function* () {
      if (e.disabled)
        return;
      const T = E === "left", P = T ? n : o, k = T ? o : n, N = T ? l : a, R = T ? r : i;
      if (x === "year") {
        const z = P.value.year(I);
        P.value = V0(z, d.value, c);
      }
      x === "month" && (P.value = qf(
        P.value,
        P.value.year(),
        I,
        d.value,
        c
      )), e.unlinkPanels || (k.value = E === "left" ? P.value.add(1, "month") : P.value.subtract(1, "month")), N.value = x === "year" ? "month" : "date", yield Ke(), g(R.value), C(x);
    });
  }
  function C(x) {
    t(
      "panel-change",
      [n.value.toDate(), o.value.toDate()],
      x
    );
  }
  function w(x, E, I) {
    const T = I ? "add" : "subtract";
    return x === "year" ? E[T](10, "year") : E[T](1, "year");
  }
  return {
    leftCurrentView: l,
    rightCurrentView: a,
    leftCurrentViewRef: r,
    rightCurrentViewRef: i,
    leftYear: f,
    rightYear: m,
    leftMonth: p,
    rightMonth: v,
    leftYearLabel: O(() => h(l, f)),
    rightYearLabel: O(
      () => h(a, m)
    ),
    showLeftPicker: (x) => y("left", x),
    showRightPicker: (x) => y("right", x),
    handleLeftYearPick: (x) => b("year", "left", x),
    handleRightYearPick: (x) => b("year", "right", x),
    handleLeftMonthPick: (x) => b("month", "left", x),
    handleRightMonthPick: (x) => b("month", "right", x),
    handlePanelChange: C,
    adjustDateByView: w
  };
}, rge = ["disabled", "onClick"], age = ["aria-label", "disabled"], ige = ["aria-label", "disabled"], sge = ["disabled", "aria-label"], cge = ["disabled", "aria-label"], uge = ["tabindex", "aria-disabled"], dge = ["tabindex", "aria-disabled"], fge = ["disabled", "aria-label"], pge = ["disabled", "aria-label"], vge = ["aria-label", "disabled"], mge = ["disabled", "aria-label"], hge = ["tabindex", "aria-disabled"], gge = ["tabindex", "aria-disabled"], dg = "month", bge = /* @__PURE__ */ le({
  __name: "panel-date-range",
  props: nge,
  emits: [
    "pick",
    "set-picker-option",
    "calendar-change",
    "panel-change",
    "clear"
  ],
  setup(e, { emit: t }) {
    const n = e, o = t, l = ze(Va), r = ze(
      gh,
      void 0
    ), { disabledDate: a, cellClassName: i, defaultTime: s, clearable: c } = l.props, u = /* @__PURE__ */ ft(l.props, "format"), d = /* @__PURE__ */ ft(l.props, "shortcuts"), f = /* @__PURE__ */ ft(l.props, "defaultValue"), { lang: p } = an(), m = /* @__PURE__ */ H(wt().locale(p.value)), v = /* @__PURE__ */ H(wt().locale(p.value).add(1, dg)), {
      minDate: h,
      maxDate: g,
      rangeState: y,
      ppNs: b,
      drpNs: C,
      handleChangeRange: w,
      handleRangeConfirm: x,
      handleShortcutClick: E,
      onSelect: I,
      parseValue: T,
      t: P
    } = p_(n, {
      defaultValue: f,
      defaultTime: s,
      leftDate: m,
      rightDate: v,
      unit: dg,
      sortDates: tn
    });
    pe(
      () => n.visible,
      (ct) => {
        !ct && y.value.selecting && (T(n.parsedValue), I(!1));
      }
    );
    const k = /* @__PURE__ */ H({
      min: null,
      max: null
    }), N = /* @__PURE__ */ H({
      min: null,
      max: null
    }), {
      leftCurrentView: R,
      rightCurrentView: z,
      leftCurrentViewRef: D,
      rightCurrentViewRef: F,
      leftYear: M,
      rightYear: A,
      leftMonth: L,
      rightMonth: B,
      leftYearLabel: V,
      rightYearLabel: j,
      showLeftPicker: W,
      showRightPicker: Y,
      handleLeftYearPick: U,
      handleRightYearPick: te,
      handleLeftMonthPick: J,
      handleRightMonthPick: re,
      handlePanelChange: oe,
      adjustDateByView: q
    } = lge(n, o, m, v), K = O(() => !!d.value.length), se = O(() => k.value.min !== null ? k.value.min : h.value ? h.value.format(ge.value) : ""), Z = O(() => k.value.max !== null ? k.value.max : g.value || h.value ? (g.value || h.value).format(ge.value) : ""), ee = O(() => N.value.min !== null ? N.value.min : h.value ? h.value.format(me.value) : ""), fe = O(() => N.value.max !== null ? N.value.max : g.value || h.value ? (g.value || h.value).format(me.value) : ""), me = O(() => n.timeFormat || yF(u.value || "") || Xf), ge = O(() => n.dateFormat || bF(u.value || "") || Ys), he = (ct) => vm(ct) && (a ? !a(ct[0].toDate()) && !a(ct[1].toDate()) : !0), $e = () => {
      m.value = q(
        R.value,
        m.value,
        !1
      ), n.unlinkPanels || (v.value = m.value.add(1, "month")), oe("year");
    }, ne = () => {
      m.value = m.value.subtract(1, "month"), n.unlinkPanels || (v.value = m.value.add(1, "month")), oe("month");
    }, ae = () => {
      n.unlinkPanels ? v.value = q(
        z.value,
        v.value,
        !0
      ) : (m.value = q(
        z.value,
        m.value,
        !0
      ), v.value = m.value.add(1, "month")), oe("year");
    }, ce = () => {
      n.unlinkPanels ? v.value = v.value.add(1, "month") : (m.value = m.value.add(1, "month"), v.value = m.value.add(1, "month")), oe("month");
    }, xe = () => {
      m.value = q(R.value, m.value, !0), oe("year");
    }, Te = () => {
      m.value = m.value.add(1, "month"), oe("month");
    }, Se = () => {
      v.value = q(
        z.value,
        v.value,
        !1
      ), oe("year");
    }, be = () => {
      v.value = v.value.subtract(1, "month"), oe("month");
    }, ie = O(() => {
      const ct = (L.value + 1) % 12, pt = L.value + 1 >= 12 ? 1 : 0;
      return n.unlinkPanels && new Date(M.value + pt, ct) < new Date(A.value, B.value);
    }), we = O(() => n.unlinkPanels && A.value * 12 + B.value - (M.value * 12 + L.value + 1) >= 12), Ne = io(), tt = O(() => !(h.value && g.value && !y.value.selecting && vm([h.value, g.value]) && !Ne.value)), Pe = O(
      () => n.type === "datetime" || n.type === "datetimerange"
    ), Re = (ct, pt) => {
      if (ct)
        return s ? wt(
          s[pt] || s
        ).locale(p.value).year(ct.year()).month(ct.month()).date(ct.date()) : ct;
    }, Le = (ct, pt = !0) => {
      const Lt = ct.minDate, Gn = ct.maxDate, To = Re(Lt, 0), st = Re(Gn, 1);
      g.value === st && h.value === To || (o("calendar-change", [Lt.toDate(), Gn && Gn.toDate()]), g.value = st, h.value = To, !Pe.value && pt && (pt = !To || !st), x(pt));
    }, Ue = /* @__PURE__ */ H(!1), Ae = /* @__PURE__ */ H(!1), De = () => {
      Ue.value = !1;
    }, _e = () => {
      Ae.value = !1;
    }, Ze = (ct, pt) => {
      k.value[pt] = ct;
      const Lt = wt(ct, ge.value).locale(p.value);
      if (Lt.isValid()) {
        if (a && a(Lt.toDate()))
          return;
        pt === "min" ? (m.value = Lt, h.value = (h.value || m.value).year(Lt.year()).month(Lt.month()).date(Lt.date()), !n.unlinkPanels && (!g.value || g.value.isBefore(h.value)) && (v.value = Lt.add(1, "month"), g.value = h.value.add(1, "month"))) : (v.value = Lt, g.value = (g.value || v.value).year(Lt.year()).month(Lt.month()).date(Lt.date()), !n.unlinkPanels && (!h.value || h.value.isAfter(g.value)) && (m.value = Lt.subtract(1, "month"), h.value = g.value.subtract(1, "month"))), tn(h.value, g.value), x(!0);
      }
    }, dt = (ct, pt) => {
      k.value[pt] = null;
    }, Tt = (ct, pt) => {
      N.value[pt] = ct;
      const Lt = wt(ct, me.value).locale(p.value);
      Lt.isValid() && (pt === "min" ? (Ue.value = !0, h.value = (h.value || m.value).hour(Lt.hour()).minute(Lt.minute()).second(Lt.second()), m.value = h.value) : (Ae.value = !0, g.value = (g.value || v.value).hour(Lt.hour()).minute(Lt.minute()).second(Lt.second()), v.value = g.value));
    }, jt = (ct, pt) => {
      N.value[pt] = null, pt === "min" ? (m.value = h.value, Ue.value = !1, (!g.value || g.value.isBefore(h.value)) && (g.value = h.value)) : (v.value = g.value, Ae.value = !1, g.value && g.value.isBefore(h.value) && (h.value = g.value)), x(!0);
    }, Qt = (ct, pt, Lt) => {
      N.value.min || (ct && (h.value = (h.value || m.value).hour(ct.hour()).minute(ct.minute()).second(ct.second())), Lt || (Ue.value = pt), (!g.value || g.value.isBefore(h.value)) && (g.value = h.value, v.value = ct, Ke(() => {
        T(n.parsedValue);
      })), x(!0));
    }, je = (ct, pt, Lt) => {
      N.value.max || (ct && (g.value = (g.value || v.value).hour(ct.hour()).minute(ct.minute()).second(ct.second())), Lt || (Ae.value = pt), g.value && g.value.isBefore(h.value) && (h.value = g.value), x(!0));
    }, lt = () => {
      Ct(), o("clear");
    }, Ct = () => {
      let ct = null;
      l != null && l.emptyValues && (ct = l.emptyValues.valueOnClear.value), m.value = K1(S(f), {
        lang: S(p),
        unit: "month",
        unlinkPanels: n.unlinkPanels
      })[0], v.value = m.value.add(1, "month"), g.value = void 0, h.value = void 0, x(!0), o("pick", ct);
    }, vn = (ct) => Jf(
      ct,
      u.value || "",
      p.value,
      r
    );
    function tn(ct, pt) {
      if (n.unlinkPanels && pt) {
        const Lt = (ct == null ? void 0 : ct.year()) || 0, Gn = (ct == null ? void 0 : ct.month()) || 0, To = pt.year(), st = pt.month();
        v.value = Lt === To && Gn === st ? pt.add(1, dg) : pt;
      } else
        v.value = m.value.add(1, dg), pt && (v.value = v.value.hour(pt.hour()).minute(pt.minute()).second(pt.second()));
    }
    return o("set-picker-option", ["isValidValue", he]), o("set-picker-option", ["parseUserInput", vn]), o("set-picker-option", ["handleClear", Ct]), (ct, pt) => (G(), ue(
      "div",
      {
        class: X([
          S(b).b(),
          S(C).b(),
          S(b).is("border", ct.border),
          S(b).is("disabled", S(Ne)),
          {
            "has-sidebar": ct.$slots.sidebar || K.value,
            "has-time": Pe.value
          }
        ])
      },
      [
        ve(
          "div",
          {
            class: X(S(b).e("body-wrapper"))
          },
          [
            Oe(ct.$slots, "sidebar", {
              class: X(S(b).e("sidebar"))
            }),
            K.value ? (G(), ue(
              "div",
              {
                key: 0,
                class: X(S(b).e("sidebar"))
              },
              [
                (G(!0), ue(
                  Ge,
                  null,
                  on(d.value, (Lt, Gn) => (G(), ue("button", {
                    key: Gn,
                    type: "button",
                    disabled: S(Ne),
                    class: X(S(b).e("shortcut")),
                    onClick: (To) => S(E)(Lt)
                  }, qe(Lt.text), 11, rge))),
                  128
                ))
              ],
              2
            )) : Ie("v-if", !0),
            ve(
              "div",
              {
                class: X(S(b).e("body"))
              },
              [
                Pe.value ? (G(), ue(
                  "div",
                  {
                    key: 0,
                    class: X(S(C).e("time-header"))
                  },
                  [
                    ve(
                      "span",
                      {
                        class: X(S(C).e("editors-wrap"))
                      },
                      [
                        ve(
                          "span",
                          {
                            class: X(S(C).e("time-picker-wrap"))
                          },
                          [
                            $(S(Nl), {
                              size: "small",
                              disabled: S(y).selecting || S(Ne),
                              placeholder: S(P)("el.datepicker.startDate"),
                              class: X(S(C).e("editor")),
                              "model-value": se.value,
                              "validate-event": !1,
                              readonly: !ct.editable,
                              onInput: pt[0] || (pt[0] = (Lt) => Ze(Lt, "min")),
                              onChange: pt[1] || (pt[1] = (Lt) => dt(Lt, "min"))
                            }, null, 8, ["disabled", "placeholder", "class", "model-value", "readonly"])
                          ],
                          2
                        ),
                        _t((G(), ue(
                          "span",
                          {
                            class: X(S(C).e("time-picker-wrap"))
                          },
                          [
                            $(S(Nl), {
                              size: "small",
                              class: X(S(C).e("editor")),
                              disabled: S(y).selecting || S(Ne),
                              placeholder: S(P)("el.datepicker.startTime"),
                              "model-value": ee.value,
                              "validate-event": !1,
                              readonly: !ct.editable,
                              onFocus: pt[2] || (pt[2] = (Lt) => Ue.value = !0),
                              onInput: pt[3] || (pt[3] = (Lt) => Tt(Lt, "min")),
                              onChange: pt[4] || (pt[4] = (Lt) => jt(Lt, "min"))
                            }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"]),
                            $(S(B0), {
                              visible: Ue.value,
                              format: me.value,
                              "datetime-role": "start",
                              "parsed-value": S(h) || m.value,
                              onPick: Qt
                            }, null, 8, ["visible", "format", "parsed-value"])
                          ],
                          2
                        )), [
                          [S(Cc), De]
                        ])
                      ],
                      2
                    ),
                    ve("span", null, [
                      $(S(ut), null, {
                        default: Ee(() => [
                          $(S(Rl))
                        ]),
                        _: 1
                      })
                    ]),
                    ve(
                      "span",
                      {
                        class: X([S(C).e("editors-wrap"), "is-right"])
                      },
                      [
                        ve(
                          "span",
                          {
                            class: X(S(C).e("time-picker-wrap"))
                          },
                          [
                            $(S(Nl), {
                              size: "small",
                              class: X(S(C).e("editor")),
                              disabled: S(y).selecting || S(Ne),
                              placeholder: S(P)("el.datepicker.endDate"),
                              "model-value": Z.value,
                              readonly: !S(h) || !ct.editable,
                              "validate-event": !1,
                              onInput: pt[5] || (pt[5] = (Lt) => Ze(Lt, "max")),
                              onChange: pt[6] || (pt[6] = (Lt) => dt(Lt, "max"))
                            }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"])
                          ],
                          2
                        ),
                        _t((G(), ue(
                          "span",
                          {
                            class: X(S(C).e("time-picker-wrap"))
                          },
                          [
                            $(S(Nl), {
                              size: "small",
                              class: X(S(C).e("editor")),
                              disabled: S(y).selecting || S(Ne),
                              placeholder: S(P)("el.datepicker.endTime"),
                              "model-value": fe.value,
                              readonly: !S(h) || !ct.editable,
                              "validate-event": !1,
                              onFocus: pt[7] || (pt[7] = (Lt) => S(h) && (Ae.value = !0)),
                              onInput: pt[8] || (pt[8] = (Lt) => Tt(Lt, "max")),
                              onChange: pt[9] || (pt[9] = (Lt) => jt(Lt, "max"))
                            }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"]),
                            $(S(B0), {
                              "datetime-role": "end",
                              visible: Ae.value,
                              format: me.value,
                              "parsed-value": S(g) || v.value,
                              onPick: je
                            }, null, 8, ["visible", "format", "parsed-value"])
                          ],
                          2
                        )), [
                          [S(Cc), _e]
                        ])
                      ],
                      2
                    )
                  ],
                  2
                )) : Ie("v-if", !0),
                ve(
                  "div",
                  {
                    class: X([[S(b).e("content"), S(C).e("content")], "is-left"])
                  },
                  [
                    ve(
                      "div",
                      {
                        class: X(S(C).e("header"))
                      },
                      [
                        ve("button", {
                          type: "button",
                          class: X([S(b).e("icon-btn"), "d-arrow-left"]),
                          "aria-label": S(P)("el.datepicker.prevYear"),
                          disabled: S(Ne),
                          onClick: $e
                        }, [
                          Oe(ct.$slots, "prev-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(bc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, age),
                        _t(ve("button", {
                          type: "button",
                          class: X([S(b).e("icon-btn"), "arrow-left"]),
                          "aria-label": S(P)("el.datepicker.prevMonth"),
                          disabled: S(Ne),
                          onClick: ne
                        }, [
                          Oe(ct.$slots, "prev-month", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(ms))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, ige), [
                          [Jt, S(R) === "date"]
                        ]),
                        ct.unlinkPanels ? (G(), ue("button", {
                          key: 0,
                          type: "button",
                          disabled: !we.value || S(Ne),
                          class: X([[
                            S(b).e("icon-btn"),
                            S(b).is("disabled", !we.value || S(Ne))
                          ], "d-arrow-right"]),
                          "aria-label": S(P)("el.datepicker.nextYear"),
                          onClick: xe
                        }, [
                          Oe(ct.$slots, "next-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(yc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, sge)) : Ie("v-if", !0),
                        ct.unlinkPanels && S(R) === "date" ? (G(), ue("button", {
                          key: 1,
                          type: "button",
                          disabled: !ie.value || S(Ne),
                          class: X([[
                            S(b).e("icon-btn"),
                            S(b).is("disabled", !ie.value || S(Ne))
                          ], "arrow-right"]),
                          "aria-label": S(P)("el.datepicker.nextMonth"),
                          onClick: Te
                        }, [
                          Oe(ct.$slots, "next-month", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(Rl))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, cge)) : Ie("v-if", !0),
                        ve("div", null, [
                          ve("span", {
                            role: "button",
                            class: X(S(C).e("header-label")),
                            "aria-live": "polite",
                            tabindex: ct.disabled ? void 0 : 0,
                            "aria-disabled": ct.disabled,
                            onKeydown: pt[10] || (pt[10] = uo((Lt) => S(W)("year"), ["enter"])),
                            onClick: pt[11] || (pt[11] = (Lt) => S(W)("year"))
                          }, qe(S(V)), 43, uge),
                          _t(ve("span", {
                            role: "button",
                            "aria-live": "polite",
                            tabindex: ct.disabled ? void 0 : 0,
                            "aria-disabled": ct.disabled,
                            class: X([
                              S(C).e("header-label"),
                              { active: S(R) === "month" }
                            ]),
                            onKeydown: pt[12] || (pt[12] = uo((Lt) => S(W)("month"), ["enter"])),
                            onClick: pt[13] || (pt[13] = (Lt) => S(W)("month"))
                          }, qe(S(P)(`el.datepicker.month${m.value.month() + 1}`)), 43, dge), [
                            [Jt, S(R) === "date"]
                          ])
                        ])
                      ],
                      2
                    ),
                    S(R) === "date" ? (G(), Me(yx, {
                      key: 0,
                      ref_key: "leftCurrentViewRef",
                      ref: D,
                      "selection-mode": "range",
                      date: m.value,
                      "min-date": S(h),
                      "max-date": S(g),
                      "range-state": S(y),
                      "disabled-date": S(a),
                      "cell-class-name": S(i),
                      "show-week-number": ct.showWeekNumber,
                      disabled: S(Ne),
                      onChangerange: S(w),
                      onPick: Le,
                      onSelect: S(I)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "show-week-number", "disabled", "onChangerange", "onSelect"])) : Ie("v-if", !0),
                    S(R) === "year" ? (G(), Me(hm, {
                      key: 1,
                      ref_key: "leftCurrentViewRef",
                      ref: D,
                      "selection-mode": "year",
                      date: m.value,
                      "disabled-date": S(a),
                      "parsed-value": ct.parsedValue,
                      disabled: S(Ne),
                      onPick: S(U)
                    }, null, 8, ["date", "disabled-date", "parsed-value", "disabled", "onPick"])) : Ie("v-if", !0),
                    S(R) === "month" ? (G(), Me(mm, {
                      key: 2,
                      ref_key: "leftCurrentViewRef",
                      ref: D,
                      "selection-mode": "month",
                      date: m.value,
                      "parsed-value": ct.parsedValue,
                      "disabled-date": S(a),
                      disabled: S(Ne),
                      onPick: S(J)
                    }, null, 8, ["date", "parsed-value", "disabled-date", "disabled", "onPick"])) : Ie("v-if", !0)
                  ],
                  2
                ),
                ve(
                  "div",
                  {
                    class: X([[S(b).e("content"), S(C).e("content")], "is-right"])
                  },
                  [
                    ve(
                      "div",
                      {
                        class: X(S(C).e("header"))
                      },
                      [
                        ct.unlinkPanels ? (G(), ue("button", {
                          key: 0,
                          type: "button",
                          disabled: !we.value || S(Ne),
                          class: X([S(b).e("icon-btn"), "d-arrow-left"]),
                          "aria-label": S(P)("el.datepicker.prevYear"),
                          onClick: Se
                        }, [
                          Oe(ct.$slots, "prev-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(bc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, fge)) : Ie("v-if", !0),
                        ct.unlinkPanels && S(z) === "date" ? (G(), ue("button", {
                          key: 1,
                          type: "button",
                          disabled: !ie.value || S(Ne),
                          class: X([S(b).e("icon-btn"), "arrow-left"]),
                          "aria-label": S(P)("el.datepicker.prevMonth"),
                          onClick: be
                        }, [
                          Oe(ct.$slots, "prev-month", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(ms))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, pge)) : Ie("v-if", !0),
                        ve("button", {
                          type: "button",
                          "aria-label": S(P)("el.datepicker.nextYear"),
                          class: X([S(b).e("icon-btn"), "d-arrow-right"]),
                          disabled: S(Ne),
                          onClick: ae
                        }, [
                          Oe(ct.$slots, "next-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(yc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, vge),
                        _t(ve("button", {
                          type: "button",
                          class: X([S(b).e("icon-btn"), "arrow-right"]),
                          disabled: S(Ne),
                          "aria-label": S(P)("el.datepicker.nextMonth"),
                          onClick: ce
                        }, [
                          Oe(ct.$slots, "next-month", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(Rl))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, mge), [
                          [Jt, S(z) === "date"]
                        ]),
                        ve("div", null, [
                          ve("span", {
                            role: "button",
                            class: X(S(C).e("header-label")),
                            "aria-live": "polite",
                            tabindex: ct.disabled ? void 0 : 0,
                            "aria-disabled": ct.disabled,
                            onKeydown: pt[14] || (pt[14] = uo((Lt) => S(Y)("year"), ["enter"])),
                            onClick: pt[15] || (pt[15] = (Lt) => S(Y)("year"))
                          }, qe(S(j)), 43, hge),
                          _t(ve("span", {
                            role: "button",
                            "aria-live": "polite",
                            tabindex: ct.disabled ? void 0 : 0,
                            "aria-disabled": ct.disabled,
                            class: X([
                              S(C).e("header-label"),
                              { active: S(z) === "month" }
                            ]),
                            onKeydown: pt[16] || (pt[16] = uo((Lt) => S(Y)("month"), ["enter"])),
                            onClick: pt[17] || (pt[17] = (Lt) => S(Y)("month"))
                          }, qe(S(P)(`el.datepicker.month${v.value.month() + 1}`)), 43, gge), [
                            [Jt, S(z) === "date"]
                          ])
                        ])
                      ],
                      2
                    ),
                    S(z) === "date" ? (G(), Me(yx, {
                      key: 0,
                      ref_key: "rightCurrentViewRef",
                      ref: F,
                      "selection-mode": "range",
                      date: v.value,
                      "min-date": S(h),
                      "max-date": S(g),
                      "range-state": S(y),
                      "disabled-date": S(a),
                      "cell-class-name": S(i),
                      "show-week-number": ct.showWeekNumber,
                      disabled: S(Ne),
                      onChangerange: S(w),
                      onPick: Le,
                      onSelect: S(I)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "show-week-number", "disabled", "onChangerange", "onSelect"])) : Ie("v-if", !0),
                    S(z) === "year" ? (G(), Me(hm, {
                      key: 1,
                      ref_key: "rightCurrentViewRef",
                      ref: F,
                      "selection-mode": "year",
                      date: v.value,
                      "disabled-date": S(a),
                      "parsed-value": ct.parsedValue,
                      disabled: S(Ne),
                      onPick: S(te)
                    }, null, 8, ["date", "disabled-date", "parsed-value", "disabled", "onPick"])) : Ie("v-if", !0),
                    S(z) === "month" ? (G(), Me(mm, {
                      key: 2,
                      ref_key: "rightCurrentViewRef",
                      ref: F,
                      "selection-mode": "month",
                      date: v.value,
                      "parsed-value": ct.parsedValue,
                      "disabled-date": S(a),
                      disabled: S(Ne),
                      onPick: S(re)
                    }, null, 8, ["date", "parsed-value", "disabled-date", "disabled", "onPick"])) : Ie("v-if", !0)
                  ],
                  2
                )
              ],
              2
            )
          ],
          2
        ),
        ct.showFooter && Pe.value && (ct.showConfirm || S(c)) ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(b).e("footer"))
          },
          [
            S(c) ? (G(), Me(S(Qo), {
              key: 0,
              text: "",
              size: "small",
              class: X(S(b).e("link-btn")),
              onClick: lt
            }, {
              default: Ee(() => [
                Ft(
                  qe(S(P)("el.datepicker.clear")),
                  1
                )
              ]),
              _: 1
            }, 8, ["class"])) : Ie("v-if", !0),
            ct.showConfirm ? (G(), Me(S(Qo), {
              key: 1,
              plain: "",
              size: "small",
              class: X(S(b).e("link-btn")),
              disabled: tt.value,
              onClick: pt[18] || (pt[18] = (Lt) => S(x)(!1))
            }, {
              default: Ee(() => [
                Ft(
                  qe(S(P)("el.datepicker.confirm")),
                  1
                )
              ]),
              _: 1
            }, 8, ["class", "disabled"])) : Ie("v-if", !0)
          ],
          2
        )) : Ie("v-if", !0)
      ],
      2
    ));
  }
});
var yge = /* @__PURE__ */ Je(bge, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker-panel/src/date-picker-com/panel-date-range.vue"]]);
const Sge = Xe(Be({}, u_)), Cge = [
  "pick",
  "set-picker-option",
  "calendar-change"
], wge = ({
  unlinkPanels: e,
  leftDate: t,
  rightDate: n
}) => {
  const { t: o } = an(), l = () => {
    t.value = t.value.subtract(1, "year"), e.value || (n.value = n.value.subtract(1, "year"));
  }, r = () => {
    e.value || (t.value = t.value.add(1, "year")), n.value = n.value.add(1, "year");
  }, a = () => {
    t.value = t.value.add(1, "year");
  }, i = () => {
    n.value = n.value.subtract(1, "year");
  }, s = O(() => `${t.value.year()} ${o("el.datepicker.year")}`), c = O(() => `${n.value.year()} ${o("el.datepicker.year")}`), u = O(() => t.value.year()), d = O(() => n.value.year() === t.value.year() ? t.value.year() + 1 : n.value.year());
  return {
    leftPrevYear: l,
    rightNextYear: r,
    leftNextYear: a,
    rightPrevYear: i,
    leftLabel: s,
    rightLabel: c,
    leftYear: u,
    rightYear: d
  };
}, $ge = ["disabled", "onClick"], xge = ["disabled"], Ege = ["disabled"], Oge = ["disabled"], _ge = ["disabled"], fg = "year", Ige = /* @__PURE__ */ le({
  name: "DatePickerMonthRange",
  __name: "panel-month-range",
  props: Sge,
  emits: Cge,
  setup(e, { emit: t }) {
    const n = e, o = t, { lang: l } = an(), r = ze(Va), a = ze(
      gh,
      void 0
    ), { shortcuts: i, disabledDate: s, cellClassName: c } = r.props, u = /* @__PURE__ */ ft(r.props, "format"), d = /* @__PURE__ */ ft(r.props, "defaultValue"), f = /* @__PURE__ */ H(wt().locale(l.value)), p = /* @__PURE__ */ H(wt().locale(l.value).add(1, fg)), {
      minDate: m,
      maxDate: v,
      rangeState: h,
      ppNs: g,
      drpNs: y,
      handleChangeRange: b,
      handleRangeConfirm: C,
      handleShortcutClick: w,
      onSelect: x,
      parseValue: E
    } = p_(n, {
      defaultValue: d,
      leftDate: f,
      rightDate: p,
      unit: fg,
      sortDates: V
    }), I = O(() => !!i.length), {
      leftPrevYear: T,
      rightNextYear: P,
      leftNextYear: k,
      rightPrevYear: N,
      leftLabel: R,
      rightLabel: z,
      leftYear: D,
      rightYear: F
    } = wge({
      unlinkPanels: /* @__PURE__ */ ft(n, "unlinkPanels"),
      leftDate: f,
      rightDate: p
    }), M = O(() => n.unlinkPanels && F.value > D.value + 1), A = (W, Y = !0) => {
      const U = W.minDate, te = W.maxDate;
      v.value === te && m.value === U || (o("calendar-change", [U.toDate(), te && te.toDate()]), v.value = te, m.value = U, Y && C());
    }, L = () => {
      let W = null;
      r != null && r.emptyValues && (W = r.emptyValues.valueOnClear.value), f.value = K1(S(d), {
        lang: S(l),
        unit: "year",
        unlinkPanels: n.unlinkPanels
      })[0], p.value = f.value.add(1, "year"), o("pick", W);
    }, B = (W) => Jf(
      W,
      u.value,
      l.value,
      a
    );
    function V(W, Y) {
      if (n.unlinkPanels && Y) {
        const U = (W == null ? void 0 : W.year()) || 0, te = Y.year();
        p.value = U === te ? Y.add(1, fg) : Y;
      } else
        p.value = f.value.add(1, fg);
    }
    const j = io();
    return pe(
      () => n.visible,
      (W) => {
        !W && h.value.selecting && (E(n.parsedValue), x(!1));
      }
    ), o("set-picker-option", ["isValidValue", vm]), o("set-picker-option", ["parseUserInput", B]), o("set-picker-option", ["handleClear", L]), (W, Y) => (G(), ue(
      "div",
      {
        class: X([
          S(g).b(),
          S(y).b(),
          S(g).is("border", W.border),
          S(g).is("disabled", S(j)),
          {
            "has-sidebar": !!W.$slots.sidebar || I.value
          }
        ])
      },
      [
        ve(
          "div",
          {
            class: X(S(g).e("body-wrapper"))
          },
          [
            Oe(W.$slots, "sidebar", {
              class: X(S(g).e("sidebar"))
            }),
            I.value ? (G(), ue(
              "div",
              {
                key: 0,
                class: X(S(g).e("sidebar"))
              },
              [
                (G(!0), ue(
                  Ge,
                  null,
                  on(S(i), (U, te) => (G(), ue("button", {
                    key: te,
                    type: "button",
                    class: X(S(g).e("shortcut")),
                    disabled: S(j),
                    onClick: (J) => S(w)(U)
                  }, qe(U.text), 11, $ge))),
                  128
                ))
              ],
              2
            )) : Ie("v-if", !0),
            ve(
              "div",
              {
                class: X(S(g).e("body"))
              },
              [
                ve(
                  "div",
                  {
                    class: X([[S(g).e("content"), S(y).e("content")], "is-left"])
                  },
                  [
                    ve(
                      "div",
                      {
                        class: X(S(y).e("header"))
                      },
                      [
                        ve("button", {
                          type: "button",
                          class: X([S(g).e("icon-btn"), "d-arrow-left"]),
                          disabled: S(j),
                          onClick: Y[0] || (Y[0] = (...U) => S(T) && S(T)(...U))
                        }, [
                          Oe(W.$slots, "prev-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(bc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, xge),
                        W.unlinkPanels ? (G(), ue("button", {
                          key: 0,
                          type: "button",
                          disabled: !M.value || S(j),
                          class: X([[
                            S(g).e("icon-btn"),
                            S(g).is("disabled", !M.value || S(j))
                          ], "d-arrow-right"]),
                          onClick: Y[1] || (Y[1] = (...U) => S(k) && S(k)(...U))
                        }, [
                          Oe(W.$slots, "next-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(yc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, Ege)) : Ie("v-if", !0),
                        ve(
                          "div",
                          null,
                          qe(S(R)),
                          1
                        )
                      ],
                      2
                    ),
                    $(mm, {
                      "selection-mode": "range",
                      date: f.value,
                      "min-date": S(m),
                      "max-date": S(v),
                      "range-state": S(h),
                      "disabled-date": S(s),
                      disabled: S(j),
                      "cell-class-name": S(c),
                      onChangerange: S(b),
                      onPick: A,
                      onSelect: S(x)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "disabled", "cell-class-name", "onChangerange", "onSelect"])
                  ],
                  2
                ),
                ve(
                  "div",
                  {
                    class: X([[S(g).e("content"), S(y).e("content")], "is-right"])
                  },
                  [
                    ve(
                      "div",
                      {
                        class: X(S(y).e("header"))
                      },
                      [
                        W.unlinkPanels ? (G(), ue("button", {
                          key: 0,
                          type: "button",
                          disabled: !M.value || S(j),
                          class: X([[
                            S(g).e("icon-btn"),
                            S(g).is("disabled", !M.value || S(j))
                          ], "d-arrow-left"]),
                          onClick: Y[2] || (Y[2] = (...U) => S(N) && S(N)(...U))
                        }, [
                          Oe(W.$slots, "prev-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(bc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, Oge)) : Ie("v-if", !0),
                        ve("button", {
                          type: "button",
                          class: X([S(g).e("icon-btn"), "d-arrow-right"]),
                          disabled: S(j),
                          onClick: Y[3] || (Y[3] = (...U) => S(P) && S(P)(...U))
                        }, [
                          Oe(W.$slots, "next-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(yc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, _ge),
                        ve(
                          "div",
                          null,
                          qe(S(z)),
                          1
                        )
                      ],
                      2
                    ),
                    $(mm, {
                      "selection-mode": "range",
                      date: p.value,
                      "min-date": S(m),
                      "max-date": S(v),
                      "range-state": S(h),
                      "disabled-date": S(s),
                      disabled: S(j),
                      "cell-class-name": S(c),
                      onChangerange: S(b),
                      onPick: A,
                      onSelect: S(x)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "disabled", "cell-class-name", "onChangerange", "onSelect"])
                  ],
                  2
                )
              ],
              2
            )
          ],
          2
        )
      ],
      2
    ));
  }
});
var Tge = /* @__PURE__ */ Je(Ige, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker-panel/src/date-picker-com/panel-month-range.vue"]]);
const Pge = Xe(Be({}, u_)), kge = [
  "pick",
  "set-picker-option",
  "calendar-change"
], Nge = ({
  unlinkPanels: e,
  leftDate: t,
  rightDate: n
}) => {
  const o = () => {
    t.value = t.value.subtract(10, "year"), e.value || (n.value = n.value.subtract(10, "year"));
  }, l = () => {
    e.value || (t.value = t.value.add(10, "year")), n.value = n.value.add(10, "year");
  }, r = () => {
    t.value = t.value.add(10, "year");
  }, a = () => {
    n.value = n.value.subtract(10, "year");
  }, i = O(() => {
    const d = Math.floor(t.value.year() / 10) * 10;
    return `${d}-${d + 9}`;
  }), s = O(() => {
    const d = Math.floor(n.value.year() / 10) * 10;
    return `${d}-${d + 9}`;
  }), c = O(() => Math.floor(t.value.year() / 10) * 10 + 9), u = O(() => Math.floor(n.value.year() / 10) * 10);
  return {
    leftPrevYear: o,
    rightNextYear: l,
    leftNextYear: r,
    rightPrevYear: a,
    leftLabel: i,
    rightLabel: s,
    leftYear: c,
    rightYear: u
  };
}, Mge = ["disabled", "onClick"], Age = ["disabled"], Rge = ["disabled"], Dge = ["disabled"], Lge = ["disabled"], Od = 10, ev = "year", Bge = /* @__PURE__ */ le({
  name: "DatePickerYearRange",
  __name: "panel-year-range",
  props: Pge,
  emits: kge,
  setup(e, { emit: t }) {
    const n = e, o = t, { lang: l } = an(), r = /* @__PURE__ */ H(wt().locale(l.value)), a = /* @__PURE__ */ H(wt().locale(l.value).add(Od, ev)), i = ze(
      gh,
      void 0
    ), s = ze(Va), { shortcuts: c, disabledDate: u, cellClassName: d } = s.props, f = /* @__PURE__ */ ft(s.props, "format"), p = /* @__PURE__ */ ft(s.props, "defaultValue"), {
      minDate: m,
      maxDate: v,
      rangeState: h,
      ppNs: g,
      drpNs: y,
      handleChangeRange: b,
      handleRangeConfirm: C,
      handleShortcutClick: w,
      onSelect: x,
      parseValue: E
    } = p_(n, {
      defaultValue: p,
      leftDate: r,
      rightDate: a,
      step: Od,
      unit: ev,
      sortDates: te
    }), {
      leftPrevYear: I,
      rightNextYear: T,
      leftNextYear: P,
      rightPrevYear: k,
      leftLabel: N,
      rightLabel: R,
      leftYear: z,
      rightYear: D
    } = Nge({
      unlinkPanels: /* @__PURE__ */ ft(n, "unlinkPanels"),
      leftDate: r,
      rightDate: a
    }), F = io(), M = O(() => !!c.length), A = O(() => [
      g.b(),
      y.b(),
      g.is("border", n.border),
      g.is("disabled", F.value),
      {
        "has-sidebar": !!So().sidebar || M.value
      }
    ]), L = O(() => ({
      content: [g.e("content"), y.e("content"), "is-left"],
      arrowLeftBtn: [g.e("icon-btn"), "d-arrow-left"],
      arrowRightBtn: [
        g.e("icon-btn"),
        g.is("disabled", !V.value || F.value),
        "d-arrow-right"
      ]
    })), B = O(() => ({
      content: [g.e("content"), y.e("content"), "is-right"],
      arrowLeftBtn: [
        g.e("icon-btn"),
        g.is("disabled", !V.value || F.value),
        "d-arrow-left"
      ],
      arrowRightBtn: [g.e("icon-btn"), "d-arrow-right"]
    })), V = O(() => n.unlinkPanels && D.value > z.value + 1), j = (J, re = !0) => {
      const oe = J.minDate, q = J.maxDate;
      v.value === q && m.value === oe || (o("calendar-change", [oe.toDate(), q && q.toDate()]), v.value = q, m.value = oe, re && C());
    }, W = (J) => Jf(
      J,
      f.value,
      l.value,
      i
    ), Y = (J) => vm(J) && (u ? !u(J[0].toDate()) && !u(J[1].toDate()) : !0), U = () => {
      let J = null;
      s != null && s.emptyValues && (J = s.emptyValues.valueOnClear.value);
      const re = K1(S(p), {
        lang: S(l),
        step: Od,
        unit: ev,
        unlinkPanels: n.unlinkPanels
      });
      r.value = re[0], a.value = re[1], o("pick", J);
    };
    function te(J, re) {
      if (n.unlinkPanels && re) {
        const oe = (J == null ? void 0 : J.year()) || 0, q = re.year();
        a.value = oe + Od > q ? re.add(Od, ev) : re;
      } else
        a.value = r.value.add(Od, ev);
    }
    return pe(
      () => n.visible,
      (J) => {
        !J && h.value.selecting && (E(n.parsedValue), x(!1));
      }
    ), o("set-picker-option", ["isValidValue", Y]), o("set-picker-option", ["parseUserInput", W]), o("set-picker-option", ["handleClear", U]), (J, re) => (G(), ue(
      "div",
      {
        class: X(A.value)
      },
      [
        ve(
          "div",
          {
            class: X(S(g).e("body-wrapper"))
          },
          [
            Oe(J.$slots, "sidebar", {
              class: X(S(g).e("sidebar"))
            }),
            M.value ? (G(), ue(
              "div",
              {
                key: 0,
                class: X(S(g).e("sidebar"))
              },
              [
                (G(!0), ue(
                  Ge,
                  null,
                  on(S(c), (oe, q) => (G(), ue("button", {
                    key: q,
                    type: "button",
                    class: X(S(g).e("shortcut")),
                    disabled: S(F),
                    onClick: (K) => S(w)(oe)
                  }, qe(oe.text), 11, Mge))),
                  128
                ))
              ],
              2
            )) : Ie("v-if", !0),
            ve(
              "div",
              {
                class: X(S(g).e("body"))
              },
              [
                ve(
                  "div",
                  {
                    class: X(L.value.content)
                  },
                  [
                    ve(
                      "div",
                      {
                        class: X(S(y).e("header"))
                      },
                      [
                        ve("button", {
                          type: "button",
                          class: X(L.value.arrowLeftBtn),
                          disabled: S(F),
                          onClick: re[0] || (re[0] = (...oe) => S(I) && S(I)(...oe))
                        }, [
                          Oe(J.$slots, "prev-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(bc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, Age),
                        J.unlinkPanels ? (G(), ue("button", {
                          key: 0,
                          type: "button",
                          disabled: !V.value || S(F),
                          class: X(L.value.arrowRightBtn),
                          onClick: re[1] || (re[1] = (...oe) => S(P) && S(P)(...oe))
                        }, [
                          Oe(J.$slots, "next-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(yc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, Rge)) : Ie("v-if", !0),
                        ve(
                          "div",
                          null,
                          qe(S(N)),
                          1
                        )
                      ],
                      2
                    ),
                    $(hm, {
                      "selection-mode": "range",
                      date: r.value,
                      "min-date": S(m),
                      "max-date": S(v),
                      "range-state": S(h),
                      "disabled-date": S(u),
                      disabled: S(F),
                      "cell-class-name": S(d),
                      onChangerange: S(b),
                      onPick: j,
                      onSelect: S(x)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "disabled", "cell-class-name", "onChangerange", "onSelect"])
                  ],
                  2
                ),
                ve(
                  "div",
                  {
                    class: X(B.value.content)
                  },
                  [
                    ve(
                      "div",
                      {
                        class: X(S(y).e("header"))
                      },
                      [
                        J.unlinkPanels ? (G(), ue("button", {
                          key: 0,
                          type: "button",
                          disabled: !V.value || S(F),
                          class: X(B.value.arrowLeftBtn),
                          onClick: re[2] || (re[2] = (...oe) => S(k) && S(k)(...oe))
                        }, [
                          Oe(J.$slots, "prev-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(bc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, Dge)) : Ie("v-if", !0),
                        ve("button", {
                          type: "button",
                          class: X(B.value.arrowRightBtn),
                          disabled: S(F),
                          onClick: re[3] || (re[3] = (...oe) => S(T) && S(T)(...oe))
                        }, [
                          Oe(J.$slots, "next-year", {}, () => [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(yc))
                              ]),
                              _: 1
                            })
                          ])
                        ], 10, Lge),
                        ve(
                          "div",
                          null,
                          qe(S(R)),
                          1
                        )
                      ],
                      2
                    ),
                    $(hm, {
                      "selection-mode": "range",
                      date: a.value,
                      "min-date": S(m),
                      "max-date": S(v),
                      "range-state": S(h),
                      "disabled-date": S(u),
                      disabled: S(F),
                      "cell-class-name": S(d),
                      onChangerange: S(b),
                      onPick: j,
                      onSelect: S(x)
                    }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "disabled", "cell-class-name", "onChangerange", "onSelect"])
                  ],
                  2
                )
              ],
              2
            )
          ],
          2
        )
      ],
      2
    ));
  }
});
var Fge = /* @__PURE__ */ Je(Bge, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker-panel/src/date-picker-com/panel-year-range.vue"]]);
const Vge = function(e) {
  switch (e) {
    case "daterange":
    case "datetimerange":
      return yge;
    case "monthrange":
      return Tge;
    case "yearrange":
      return Fge;
    default:
      return tge;
  }
};
function zge(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !dn(e);
}
wt.extend(JO);
wt.extend(m9);
wt.extend(W1);
wt.extend(g9);
wt.extend(y9);
wt.extend(Che);
wt.extend($he);
wt.extend(Ehe);
var Hge = /* @__PURE__ */ le({
  name: "ElDatePickerPanel",
  install: null,
  inheritAttrs: !1,
  props: Ohe,
  emits: [It, "calendar-change", "panel-change", "visible-change", "clear"],
  setup(e, {
    slots: t,
    emit: n,
    attrs: o
  }) {
    const l = Ve("picker-panel"), r = ze(Va, void 0);
    if (fn(r)) {
      const d = /* @__PURE__ */ kt(Be({}, /* @__PURE__ */ to(e)));
      at(Va, {
        props: d
      });
    }
    at(s_, {
      slots: t,
      pickerNs: l
    });
    const {
      parsedValue: a,
      onCalendarChange: i,
      onPanelChange: s,
      onSetPickerOption: c,
      onPick: u
    } = ze(a9, () => i9(e, n), !0);
    return () => {
      const d = Vge(e.type);
      return $(d, Ut(Cp(o, "onPick"), e, {
        parsedValue: a.value,
        "onSet-picker-option": c,
        "onCalendar-change": i,
        "onPanel-change": s,
        onClear: () => n("clear"),
        onPick: u
      }), zge(t) ? t : {
        default: () => [t]
      });
    };
  }
});
const x9 = Dt(Hge), jge = Xe(vt(Be({}, i_), {
  type: {
    type: ye(String),
    default: "date"
  }
}));
function Wge(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !dn(e);
}
var Kge = /* @__PURE__ */ le({
  name: "ElDatePicker",
  install: null,
  props: jge,
  emits: [It],
  setup(e, {
    expose: t,
    emit: n,
    slots: o
  }) {
    const l = O(() => !e.format);
    at(gh, l), at(r_, /* @__PURE__ */ kt(/* @__PURE__ */ ft(e, "popperOptions")));
    const r = /* @__PURE__ */ H();
    t({
      focus: () => {
        var s;
        (s = r.value) == null || s.focus();
      },
      blur: () => {
        var s;
        (s = r.value) == null || s.blur();
      },
      handleOpen: () => {
        var s;
        (s = r.value) == null || s.handleOpen();
      },
      handleClose: () => {
        var s;
        (s = r.value) == null || s.handleClose();
      }
    });
    const i = (s) => {
      n(It, s);
    };
    return () => {
      var s;
      const c = (s = e.format) != null ? s : qme[e.type] || Ys;
      return $(c9, Ut(e, {
        format: c,
        type: e.type,
        ref: r,
        "onUpdate:modelValue": i
      }), {
        default: (u) => $(x9, Ut({
          disabled: e.disabled,
          editable: e.editable,
          border: !1
        }, u), Wge(o) ? o : {
          default: () => [o]
        }),
        "range-separator": o["range-separator"]
      });
    };
  }
});
const Uge = Dt(Kge), v_ = Symbol("elDescriptions");
var tv = /* @__PURE__ */ le({
  name: "ElDescriptionsCell",
  props: {
    cell: {
      type: Object
    },
    tag: {
      type: String,
      default: "td"
    },
    type: {
      type: String
    }
  },
  setup() {
    return {
      descriptions: ze(v_, {})
    };
  },
  render() {
    var e, t, n, o;
    const l = Yse(
      this.cell
    ), r = (((e = this.cell) == null ? void 0 : e.dirs) || []).map((C) => {
      const { dir: w, arg: x, modifiers: E, value: I } = C;
      return [w, I, x, E];
    }), { border: a, direction: i } = this.descriptions, s = i === "vertical", c = () => {
      var C, w, x;
      return ((x = (w = (C = this.cell) == null ? void 0 : C.children) == null ? void 0 : w.label) == null ? void 0 : x.call(w)) || l.label;
    }, u = () => {
      var C, w, x;
      return (x = (w = (C = this.cell) == null ? void 0 : C.children) == null ? void 0 : w.default) == null ? void 0 : x.call(w);
    }, d = l.span, f = l.rowspan, p = l.align ? `is-${l.align}` : "", m = l.labelAlign ? `is-${l.labelAlign}` : p, v = l.className, h = l.labelClassName, g = this.type === "label" && (n = (t = l.labelWidth) != null ? t : this.descriptions.labelWidth) != null ? n : l.width, y = {
      width: ao(g),
      minWidth: ao(l.minWidth)
    }, b = Ve("descriptions");
    switch (this.type) {
      case "label":
        return _t(
          ht(
            this.tag,
            {
              style: y,
              class: [
                b.e("cell"),
                b.e("label"),
                b.is("bordered-label", a),
                b.is("vertical-label", s),
                m,
                h
              ],
              colSpan: s ? d : 1,
              rowspan: s ? 1 : f
            },
            c()
          ),
          r
        );
      case "content":
        return _t(
          ht(
            this.tag,
            {
              style: y,
              class: [
                b.e("cell"),
                b.e("content"),
                b.is("bordered-content", a),
                b.is("vertical-content", s),
                p,
                v
              ],
              colSpan: s ? d : d * 2 - 1,
              rowspan: s ? f * 2 - 1 : f
            },
            u()
          ),
          r
        );
      default: {
        const C = c(), w = {}, x = ao((o = l.labelWidth) != null ? o : this.descriptions.labelWidth);
        return x && (w.width = x, w.display = "inline-block"), _t(
          ht(
            "td",
            {
              style: y,
              class: [b.e("cell"), p],
              colSpan: d,
              rowspan: f
            },
            [
              wo(C) ? void 0 : ht(
                "span",
                {
                  style: w,
                  class: [b.e("label"), h]
                },
                C
              ),
              ht(
                "span",
                {
                  class: [b.e("content"), v]
                },
                u()
              )
            ]
          ),
          r
        );
      }
    }
  }
});
const Gge = Xe({
  row: {
    type: ye(Array),
    default: () => []
  }
}), Yge = { key: 1 }, Xge = /* @__PURE__ */ le({
  name: "ElDescriptionsRow",
  __name: "descriptions-row",
  props: Gge,
  setup(e) {
    const t = ze(v_, {});
    return (n, o) => S(t).direction === "vertical" ? (G(), ue(
      Ge,
      { key: 0 },
      [
        ve("tr", null, [
          (G(!0), ue(
            Ge,
            null,
            on(n.row, (l, r) => (G(), Me(S(tv), {
              key: `tr1-${r}`,
              cell: l,
              tag: "th",
              type: "label"
            }, null, 8, ["cell"]))),
            128
          ))
        ]),
        ve("tr", null, [
          (G(!0), ue(
            Ge,
            null,
            on(n.row, (l, r) => (G(), Me(S(tv), {
              key: `tr2-${r}`,
              cell: l,
              tag: "td",
              type: "content"
            }, null, 8, ["cell"]))),
            128
          ))
        ])
      ],
      64
    )) : (G(), ue("tr", Yge, [
      (G(!0), ue(
        Ge,
        null,
        on(n.row, (l, r) => (G(), ue(
          Ge,
          {
            key: `tr3-${r}`
          },
          [
            S(t).border ? (G(), ue(
              Ge,
              { key: 0 },
              [
                $(S(tv), {
                  cell: l,
                  tag: "td",
                  type: "label"
                }, null, 8, ["cell"]),
                $(S(tv), {
                  cell: l,
                  tag: "td",
                  type: "content"
                }, null, 8, ["cell"])
              ],
              64
            )) : (G(), Me(S(tv), {
              key: 1,
              cell: l,
              tag: "td",
              type: "both"
            }, null, 8, ["cell"]))
          ],
          64
        ))),
        128
      ))
    ]));
  }
});
var qge = /* @__PURE__ */ Je(Xge, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/descriptions-row.vue"]]);
const Jge = Xe({
  border: Boolean,
  column: {
    type: Number,
    default: 3
  },
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  size: Bo,
  title: {
    type: String,
    default: ""
  },
  extra: {
    type: String,
    default: ""
  },
  labelWidth: {
    type: [String, Number]
  }
}), E9 = "ElDescriptionsItem", Zge = /* @__PURE__ */ le({
  name: "ElDescriptions",
  __name: "description",
  props: Jge,
  setup(e) {
    const t = e, n = Ve("descriptions"), o = Mo(), l = So();
    at(v_, t);
    const r = O(() => [n.b(), n.m(o.value)]), a = (s, c, u, d = !1) => (s.props || (s.props = {}), c > u && (s.props.span = u), d && (s.props.span = c), s), i = () => {
      if (!l.default)
        return [];
      const s = Nr(l.default()).filter(
        (m) => {
          var v;
          return ((v = m == null ? void 0 : m.type) == null ? void 0 : v.name) === E9;
        }
      ), c = [];
      let u = [], d = t.column, f = 0;
      const p = [];
      return s.forEach((m, v) => {
        var h, g, y;
        const b = ((h = m.props) == null ? void 0 : h.span) || 1, C = ((g = m.props) == null ? void 0 : g.rowspan) || 1, w = c.length;
        if (p[w] || (p[w] = 0), C > 1)
          for (let x = 1; x < C; x++)
            p[y = w + x] || (p[y] = 0), p[w + x]++, f++;
        if (p[w] > 0 && (d -= p[w], p[w] = 0), v < s.length - 1 && (f += b > d ? d : b), v === s.length - 1) {
          const x = t.column - f % t.column;
          u.push(a(m, x, d, !0)), c.push(u);
          return;
        }
        b < d ? (d -= b, u.push(m)) : (u.push(a(m, b, d)), c.push(u), d = t.column, u = []);
      }), c;
    };
    return (s, c) => (G(), ue(
      "div",
      {
        class: X(r.value)
      },
      [
        s.title || s.extra || s.$slots.title || s.$slots.extra ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(n).e("header"))
          },
          [
            ve(
              "div",
              {
                class: X(S(n).e("title"))
              },
              [
                Oe(s.$slots, "title", {}, () => [
                  Ft(
                    qe(s.title),
                    1
                  )
                ])
              ],
              2
            ),
            ve(
              "div",
              {
                class: X(S(n).e("extra"))
              },
              [
                Oe(s.$slots, "extra", {}, () => [
                  Ft(
                    qe(s.extra),
                    1
                  )
                ])
              ],
              2
            )
          ],
          2
        )) : Ie("v-if", !0),
        ve(
          "div",
          {
            class: X(S(n).e("body"))
          },
          [
            ve(
              "table",
              {
                class: X([S(n).e("table"), S(n).is("bordered", s.border)])
              },
              [
                ve("tbody", null, [
                  (G(!0), ue(
                    Ge,
                    null,
                    on(i(), (u, d) => (G(), Me(qge, {
                      key: d,
                      row: u
                    }, null, 8, ["row"]))),
                    128
                  ))
                ])
              ],
              2
            )
          ],
          2
        )
      ],
      2
    ));
  }
});
var Qge = /* @__PURE__ */ Je(Zge, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/descriptions/src/description.vue"]]);
const fN = ["left", "center", "right"], ebe = Xe({
  label: {
    type: String,
    default: ""
  },
  span: {
    type: Number,
    default: 1
  },
  rowspan: {
    type: Number,
    default: 1
  },
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  labelWidth: {
    type: [String, Number]
  },
  align: {
    type: String,
    values: fN,
    default: "left"
  },
  labelAlign: {
    type: String,
    values: fN
  },
  className: {
    type: String,
    default: ""
  },
  labelClassName: {
    type: String,
    default: ""
  }
}), O9 = /* @__PURE__ */ le({
  name: E9,
  props: ebe
}), tbe = Dt(Qge, {
  DescriptionsItem: O9
}), nbe = oo(O9), m_ = (e) => {
  if (!e)
    return { onClick: gn, onMousedown: gn, onMouseup: gn };
  let t = !1, n = !1;
  return { onClick: (a) => {
    t && n && e(a), t = n = !1;
  }, onMousedown: (a) => {
    t = a.target === a.currentTarget;
  }, onMouseup: (a) => {
    n = a.target === a.currentTarget;
  } };
}, obe = Xe({
  mask: {
    type: Boolean,
    default: !0
  },
  customMaskEvent: Boolean,
  overlayClass: {
    type: ye([
      String,
      Array,
      Object
    ])
  },
  zIndex: {
    type: ye([String, Number])
  }
}), lbe = {
  click: (e) => e instanceof MouseEvent
}, rbe = "overlay";
var abe = /* @__PURE__ */ le({
  name: "ElOverlay",
  props: obe,
  emits: lbe,
  setup(e, { slots: t, emit: n }) {
    const o = Ve(rbe), l = (s) => {
      n("click", s);
    }, { onClick: r, onMousedown: a, onMouseup: i } = m_(
      e.customMaskEvent ? void 0 : l
    );
    return () => e.mask ? $(
      "div",
      {
        class: [o.b(), e.overlayClass],
        style: {
          zIndex: e.zIndex
        },
        onClick: r,
        onMousedown: a,
        onMouseup: i
      },
      [Oe(t, "default")],
      Yr.STYLE | Yr.CLASS | Yr.PROPS,
      ["onClick", "onMouseup", "onMousedown"]
    ) : ht(
      "div",
      {
        class: e.overlayClass,
        style: {
          zIndex: e.zIndex,
          position: "fixed",
          top: "0px",
          right: "0px",
          bottom: "0px",
          left: "0px"
        }
      },
      [Oe(t, "default")]
    );
  }
});
const h_ = abe, _9 = Symbol("dialogInjectionKey"), JC = "dialog-fade", I9 = Xe({
  center: Boolean,
  alignCenter: {
    type: Boolean,
    default: void 0
  },
  closeIcon: {
    type: Pn
  },
  draggable: {
    type: Boolean,
    default: void 0
  },
  overflow: {
    type: Boolean,
    default: void 0
  },
  fullscreen: Boolean,
  headerClass: String,
  bodyClass: String,
  footerClass: String,
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  ariaLevel: {
    type: String,
    default: "2"
  }
}), ibe = {
  close: () => !0
}, T9 = (e, t, n, o) => {
  const l = {
    offsetX: 0,
    offsetY: 0
  }, r = /* @__PURE__ */ H(!1), a = (f, p) => {
    if (e.value) {
      const { offsetX: m, offsetY: v } = l, h = e.value.getBoundingClientRect(), g = h.left, y = h.top, b = h.width, C = h.height, w = document.documentElement.clientWidth, x = document.documentElement.clientHeight, E = -g + m, I = -y + v, T = w - g - b + m, P = x - y - (C < x ? C : 0) + v;
      o != null && o.value || (f = Math.min(Math.max(f, E), T), p = Math.min(Math.max(p, I), P)), l.offsetX = f, l.offsetY = p, e.value.style.transform = `translate(${ao(f)}, ${ao(
        p
      )})`;
    }
  }, i = (f) => {
    const p = f.clientX, m = f.clientY, { offsetX: v, offsetY: h } = l, g = (b) => {
      r.value || (r.value = !0);
      const C = v + b.clientX - p, w = h + b.clientY - m;
      a(C, w);
    }, y = () => {
      r.value = !1, document.removeEventListener("mousemove", g), document.removeEventListener("mouseup", y);
    };
    document.addEventListener("mousemove", g), document.addEventListener("mouseup", y);
  }, s = () => {
    t.value && e.value && (t.value.addEventListener("mousedown", i), window.addEventListener("resize", d));
  }, c = () => {
    t.value && e.value && (t.value.removeEventListener("mousedown", i), window.removeEventListener("resize", d));
  }, u = () => {
    l.offsetX = 0, l.offsetY = 0, e.value && (e.value.style.transform = "");
  }, d = () => {
    const { offsetX: f, offsetY: p } = l;
    a(f, p);
  };
  return nt(() => {
    Ot(() => {
      n.value ? s() : c();
    });
  }), yt(() => {
    c();
  }), {
    isDragging: r,
    resetPosition: u,
    updatePosition: d
  };
}, g_ = (...e) => (t) => {
  e.forEach((n) => {
    n.value = t;
  });
}, sbe = ["aria-level"], cbe = ["aria-label"], ube = ["id"], dbe = /* @__PURE__ */ le({
  name: "ElDialogContent",
  __name: "dialog-content",
  props: I9,
  emits: ibe,
  setup(e, { expose: t }) {
    const { t: n } = an(), { Close: o } = I7, l = e, { dialogRef: r, headerRef: a, bodyId: i, ns: s, style: c } = ze(_9), { focusTrapRef: u } = ze(j7), d = g_(u, r), f = O(() => !!l.draggable), p = O(() => !!l.overflow), { resetPosition: m, updatePosition: v, isDragging: h } = T9(
      r,
      a,
      f,
      p
    ), g = O(() => [
      s.b(),
      s.is("fullscreen", l.fullscreen),
      s.is("draggable", f.value),
      s.is("dragging", h.value),
      s.is("align-center", !!l.alignCenter),
      { [s.m("center")]: l.center }
    ]);
    return t({
      resetPosition: m,
      updatePosition: v
    }), (y, b) => (G(), ue(
      "div",
      {
        ref: S(d),
        class: X(g.value),
        style: gt(S(c)),
        tabindex: "-1"
      },
      [
        ve(
          "header",
          {
            ref_key: "headerRef",
            ref: a,
            class: X([S(s).e("header"), y.headerClass, { "show-close": y.showClose }])
          },
          [
            Oe(y.$slots, "header", {}, () => [
              ve("span", {
                role: "heading",
                "aria-level": y.ariaLevel,
                class: X(S(s).e("title"))
              }, qe(y.title), 11, sbe)
            ]),
            y.showClose ? (G(), ue("button", {
              key: 0,
              "aria-label": S(n)("el.dialog.close"),
              class: X(S(s).e("headerbtn")),
              type: "button",
              onClick: b[0] || (b[0] = (C) => y.$emit("close"))
            }, [
              $(S(ut), {
                class: X(S(s).e("close"))
              }, {
                default: Ee(() => [
                  (G(), Me(Ht(y.closeIcon || S(o))))
                ]),
                _: 1
              }, 8, ["class"])
            ], 10, cbe)) : Ie("v-if", !0)
          ],
          2
        ),
        ve("div", {
          id: S(i),
          class: X([S(s).e("body"), y.bodyClass])
        }, [
          Oe(y.$slots, "default")
        ], 10, ube),
        y.$slots.footer ? (G(), ue(
          "footer",
          {
            key: 0,
            class: X([S(s).e("footer"), y.footerClass])
          },
          [
            Oe(y.$slots, "footer")
          ],
          2
        )) : Ie("v-if", !0)
      ],
      6
    ));
  }
});
var fbe = /* @__PURE__ */ Je(dbe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog-content.vue"]]);
const P9 = Xe(vt(Be({}, I9), {
  appendToBody: Boolean,
  appendTo: {
    type: sh.to.type,
    default: "body"
  },
  beforeClose: {
    type: ye(Function)
  },
  destroyOnClose: Boolean,
  closeOnClickModal: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  lockScroll: {
    type: Boolean,
    default: !0
  },
  modal: {
    type: Boolean,
    default: !0
  },
  modalPenetrable: Boolean,
  openDelay: {
    type: Number,
    default: 0
  },
  closeDelay: {
    type: Number,
    default: 0
  },
  top: {
    type: String
  },
  modelValue: Boolean,
  modalClass: String,
  headerClass: String,
  bodyClass: String,
  footerClass: String,
  width: {
    type: [String, Number]
  },
  zIndex: {
    type: Number
  },
  trapFocus: Boolean,
  headerAriaLevel: {
    type: String,
    default: "2"
  },
  transition: {
    type: ye([String, Object]),
    default: void 0
  }
})), k9 = {
  open: () => !0,
  opened: () => !0,
  close: () => !0,
  closed: () => !0,
  [It]: (e) => Tn(e),
  openAutoFocus: () => !0,
  closeAutoFocus: () => !0
}, U1 = (e, t = {}) => {
  /* @__PURE__ */ kn(e) || no(
    "[useLockscreen]",
    "You need to pass a ref param to this function"
  );
  const n = t.ns || Ve("popup"), o = O(() => n.bm("parent", "hidden"));
  let l = 0, r = !1, a = "0", i = !1;
  const s = () => {
    i || (i = !0, setTimeout(() => {
      typeof document != "undefined" && r && document && (document.body.style.width = a, Al(document.body, o.value));
    }, 200));
  };
  pe(e, (c) => {
    if (!c) {
      s();
      return;
    }
    i = !1, r = !pi(document.body, o.value), r && (a = document.body.style.width, Zr(document.body, o.value)), l = w7(n.namespace.value);
    const u = document.documentElement.clientHeight < document.body.scrollHeight, d = ts(document.body, "overflowY");
    l > 0 && (u || d === "scroll") && r && (document.body.style.width = `calc(100% - ${l}px)`);
  }), ME(() => s());
}, pbe = "ElDialog", N9 = (e, t) => {
  var n;
  const l = xt().emit, { nextZIndex: r } = ah();
  let a = "";
  const i = ml(), s = ml(), c = /* @__PURE__ */ H(!1), u = /* @__PURE__ */ H(!1), d = /* @__PURE__ */ H(!1), f = /* @__PURE__ */ H((n = e.zIndex) != null ? n : r()), p = /* @__PURE__ */ H(!1);
  let m, v;
  const h = wp(), g = O(() => {
    var j, W;
    return (W = (j = h.value) == null ? void 0 : j.namespace) != null ? W : _v;
  }), y = O(() => {
    var j;
    return (j = h.value) == null ? void 0 : j.dialog;
  }), b = O(() => {
    const j = {}, W = `--${g.value}-dialog`;
    if (!e.fullscreen) {
      e.top && (j[`${W}-margin-top`] = e.top);
      const Y = ao(e.width);
      Y && (j[`${W}-width`] = Y);
    }
    return j;
  }), C = O(
    () => {
      var j, W, Y;
      return ((Y = (W = e.draggable) != null ? W : (j = y.value) == null ? void 0 : j.draggable) != null ? Y : !1) && !e.fullscreen;
    }
  ), w = O(
    () => {
      var j, W, Y;
      return (Y = (W = e.alignCenter) != null ? W : (j = y.value) == null ? void 0 : j.alignCenter) != null ? Y : !1;
    }
  ), x = O(
    () => {
      var j, W, Y;
      return (Y = (W = e.overflow) != null ? W : (j = y.value) == null ? void 0 : j.overflow) != null ? Y : !1;
    }
  ), E = O(() => w.value ? { display: "flex" } : {}), I = O(() => {
    var j, W, Y;
    const U = (Y = (W = e.transition) != null ? W : (j = y.value) == null ? void 0 : j.transition) != null ? Y : JC, te = {
      name: U,
      onAfterEnter: T,
      onBeforeLeave: k,
      onAfterLeave: P
    };
    if (Mt(U)) {
      const J = Be({}, U), re = (oe, q) => (K) => {
        We(oe) ? oe.forEach((se) => {
          it(se) && se(K);
        }) : it(oe) && oe(K), q();
      };
      return J.onAfterEnter = re(J.onAfterEnter, T), J.onBeforeLeave = re(J.onBeforeLeave, k), J.onAfterLeave = re(J.onAfterLeave, P), J.name || (J.name = JC, Gt(
        pbe,
        `transition.name is missing when using object syntax, fallback to '${JC}'`
      )), J;
    }
    return te;
  });
  function T() {
    l("opened");
  }
  function P() {
    l("closed"), l(It, !1), e.destroyOnClose && (d.value = !1), p.value = !1;
  }
  function k() {
    p.value = !0, l("close");
  }
  function N() {
    v == null || v(), m == null || m(), e.openDelay && e.openDelay > 0 ? { stop: m } = jf(() => F(), e.openDelay) : F();
  }
  function R() {
    m == null || m(), v == null || v(), e.closeDelay && e.closeDelay > 0 ? { stop: v } = jf(() => M(), e.closeDelay) : M();
  }
  function z() {
    function j(W) {
      W || (u.value = !0, c.value = !1);
    }
    e.beforeClose ? e.beforeClose(j) : R();
  }
  function D() {
    e.closeOnClickModal && z();
  }
  function F() {
    Sn && (c.value = !0);
  }
  function M() {
    c.value = !1;
  }
  function A() {
    l("openAutoFocus");
  }
  function L() {
    l("closeAutoFocus");
  }
  function B(j) {
    var W;
    ((W = j.detail) == null ? void 0 : W.focusReason) === "pointer" && j.preventDefault();
  }
  e.lockScroll && U1(c);
  function V() {
    e.closeOnPressEscape && z();
  }
  return pe(
    () => e.zIndex,
    () => {
      var j;
      f.value = (j = e.zIndex) != null ? j : r();
    }
  ), pe(
    () => e.modelValue,
    (j) => {
      var W;
      j ? (u.value = !1, p.value = !1, N(), d.value = !0, f.value = (W = e.zIndex) != null ? W : r(), Ke(() => {
        l("open"), t.value && (t.value.parentElement.scrollTop = 0, t.value.parentElement.scrollLeft = 0, t.value.scrollTop = 0);
      })) : c.value && R();
    }
  ), pe(
    () => e.fullscreen,
    (j) => {
      t.value && (j ? (a = t.value.style.transform, t.value.style.transform = "") : t.value.style.transform = a);
    }
  ), nt(() => {
    e.modelValue && (c.value = !0, d.value = !0, N());
  }), {
    afterEnter: T,
    afterLeave: P,
    beforeLeave: k,
    handleClose: z,
    onModalClick: D,
    close: R,
    doClose: M,
    onOpenAutoFocus: A,
    onCloseAutoFocus: L,
    onCloseRequested: V,
    onFocusoutPrevented: B,
    titleId: i,
    bodyId: s,
    closed: u,
    style: b,
    overlayDialogStyle: E,
    rendered: d,
    visible: c,
    zIndex: f,
    transitionConfig: I,
    _draggable: C,
    _alignCenter: w,
    _overflow: x,
    closing: p
  };
}, vbe = ["aria-label", "aria-labelledby", "aria-describedby"], mbe = /* @__PURE__ */ le({
  name: "ElDialog",
  inheritAttrs: !1,
  __name: "dialog",
  props: P9,
  emits: k9,
  setup(e, { expose: t }) {
    const n = e, o = So();
    hi(
      {
        scope: "el-dialog",
        from: "the title slot",
        replacement: "the header slot",
        version: "3.0.0",
        ref: "https://element-plus.org/en-US/component/dialog.html#slots"
      },
      O(() => !!o.title)
    );
    const l = Ve("dialog"), r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H(), i = /* @__PURE__ */ H(), {
      visible: s,
      titleId: c,
      bodyId: u,
      style: d,
      overlayDialogStyle: f,
      rendered: p,
      transitionConfig: m,
      zIndex: v,
      _draggable: h,
      _alignCenter: g,
      _overflow: y,
      handleClose: b,
      onModalClick: C,
      onOpenAutoFocus: w,
      onCloseAutoFocus: x,
      onCloseRequested: E,
      onFocusoutPrevented: I,
      closing: T
    } = N9(n, r);
    at(_9, {
      dialogRef: r,
      headerRef: a,
      bodyId: u,
      ns: l,
      rendered: p,
      style: d
    });
    const P = m_(C), k = O(
      () => n.modalPenetrable && !n.modal && !n.fullscreen
    );
    return t({
      visible: s,
      dialogContentRef: i,
      resetPosition: () => {
        var R;
        (R = i.value) == null || R.resetPosition();
      },
      handleClose: b
    }), (R, z) => (G(), Me(S($p), {
      to: R.appendTo,
      disabled: R.appendTo !== "body" ? !1 : !R.appendToBody
    }, {
      default: Ee(() => [
        $(
          Vn,
          Ut(S(m), { persisted: "" }),
          {
            default: Ee(() => {
              var D;
              return [
                _t($(S(h_), {
                  "custom-mask-event": "",
                  mask: R.modal,
                  "overlay-class": [
                    (D = R.modalClass) != null ? D : "",
                    `${S(l).namespace.value}-modal-dialog`,
                    S(l).is("penetrable", k.value)
                  ],
                  "z-index": S(v)
                }, {
                  default: Ee(() => [
                    ve("div", {
                      role: "dialog",
                      "aria-modal": "true",
                      "aria-label": R.title || void 0,
                      "aria-labelledby": R.title ? void 0 : S(c),
                      "aria-describedby": S(u),
                      class: X([
                        `${S(l).namespace.value}-overlay-dialog`,
                        S(l).is("closing", S(T))
                      ]),
                      style: gt(S(f)),
                      onClick: z[0] || (z[0] = (...F) => S(P).onClick && S(P).onClick(...F)),
                      onMousedown: z[1] || (z[1] = (...F) => S(P).onMousedown && S(P).onMousedown(...F)),
                      onMouseup: z[2] || (z[2] = (...F) => S(P).onMouseup && S(P).onMouseup(...F))
                    }, [
                      $(S(xp), {
                        loop: "",
                        trapped: S(s),
                        "focus-start-el": "container",
                        onFocusAfterTrapped: S(w),
                        onFocusAfterReleased: S(x),
                        onFocusoutPrevented: S(I),
                        onReleaseRequested: S(E)
                      }, {
                        default: Ee(() => [
                          S(p) ? (G(), Me(fbe, Ut({
                            key: 0,
                            ref_key: "dialogContentRef",
                            ref: i
                          }, R.$attrs, {
                            center: R.center,
                            "align-center": S(g),
                            "close-icon": R.closeIcon,
                            draggable: S(h),
                            overflow: S(y),
                            fullscreen: R.fullscreen,
                            "header-class": R.headerClass,
                            "body-class": R.bodyClass,
                            "footer-class": R.footerClass,
                            "show-close": R.showClose,
                            title: R.title,
                            "aria-level": R.headerAriaLevel,
                            onClose: S(b)
                          }), or({
                            header: Ee(() => [
                              R.$slots.title ? Oe(R.$slots, "title", { key: 1 }) : Oe(R.$slots, "header", {
                                key: 0,
                                close: S(b),
                                titleId: S(c),
                                titleClass: S(l).e("title")
                              })
                            ]),
                            default: Ee(() => [
                              Oe(R.$slots, "default")
                            ]),
                            _: 2
                          }, [
                            R.$slots.footer ? {
                              name: "footer",
                              fn: Ee(() => [
                                Oe(R.$slots, "footer")
                              ]),
                              key: "0"
                            } : void 0
                          ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "header-class", "body-class", "footer-class", "show-close", "title", "aria-level", "onClose"])) : Ie("v-if", !0)
                        ]),
                        _: 3
                      }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                    ], 46, vbe)
                  ]),
                  _: 3
                }, 8, ["mask", "overlay-class", "z-index"]), [
                  [Jt, S(s)]
                ])
              ];
            }),
            _: 3
          },
          16
        )
      ]),
      _: 3
    }, 8, ["to", "disabled"]));
  }
});
var hbe = /* @__PURE__ */ Je(mbe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/dialog/src/dialog.vue"]]);
const gbe = Dt(hbe), bbe = Xe({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  contentPosition: {
    type: String,
    values: ["left", "center", "right"],
    default: "center"
  },
  borderStyle: {
    type: ye(String),
    default: "solid"
  }
}), ybe = /* @__PURE__ */ le({
  name: "ElDivider",
  __name: "divider",
  props: bbe,
  setup(e) {
    const t = e, n = Ve("divider"), o = O(() => n.cssVar({
      "border-style": t.borderStyle
    }));
    return (l, r) => (G(), ue(
      "div",
      {
        class: X([S(n).b(), S(n).m(l.direction)]),
        style: gt(o.value),
        role: "separator"
      },
      [
        l.$slots.default && l.direction !== "vertical" ? (G(), ue(
          "div",
          {
            key: 0,
            class: X([S(n).e("text"), S(n).is(l.contentPosition)])
          },
          [
            Oe(l.$slots, "default")
          ],
          2
        )) : Ie("v-if", !0)
      ],
      6
    ));
  }
});
var Sbe = /* @__PURE__ */ Je(ybe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/divider/src/divider.vue"]]);
const M9 = Dt(Sbe), Cbe = Xe(vt(Be({}, P9), {
  direction: {
    type: String,
    default: "rtl",
    values: ["ltr", "rtl", "ttb", "btt"]
  },
  resizable: Boolean,
  size: {
    type: [String, Number],
    default: "30%"
  },
  withHeader: {
    type: Boolean,
    default: !0
  },
  modalFade: {
    type: Boolean,
    default: !0
  },
  headerAriaLevel: {
    type: String,
    default: "2"
  }
})), wbe = vt(Be({}, k9), {
  "resize-start": (e, t) => e instanceof MouseEvent && typeof t == "number",
  resize: (e, t) => e instanceof MouseEvent && typeof t == "number",
  "resize-end": (e, t) => e instanceof MouseEvent && typeof t == "number"
});
function $be(e, t, n) {
  const { width: o, height: l } = TO(), r = O(() => ["ltr", "rtl"].includes(e.direction)), a = O(
    () => ["ltr", "ttb"].includes(e.direction) ? 1 : -1
  ), i = O(
    () => r.value ? o.value : l.value
  ), s = O(() => a7(
    c.value + a.value * u.value,
    4,
    i.value
  )), c = /* @__PURE__ */ H(0), u = /* @__PURE__ */ H(0), d = /* @__PURE__ */ H(!1), f = /* @__PURE__ */ H(!1);
  let p = [], m = [];
  const v = () => {
    var C;
    const w = (C = t.value) == null ? void 0 : C.closest('[aria-modal="true"]');
    return w ? r.value ? w.offsetWidth : w.offsetHeight : 100;
  };
  pe(
    () => [e.size, e.resizable],
    () => {
      f.value = !1, c.value = 0, u.value = 0, y();
    }
  );
  const h = (C) => {
    e.resizable && (f.value || (c.value = v(), f.value = !0), p = [C.pageX, C.pageY], d.value = !0, n("resize-start", C, c.value), m.push(
      wn(window, "mouseup", y),
      wn(window, "mousemove", g)
    ));
  }, g = (C) => {
    const { pageX: w, pageY: x } = C, E = w - p[0], I = x - p[1];
    u.value = r.value ? E : I, n("resize", C, s.value);
  }, y = (C) => {
    d.value && (p = [], c.value = s.value, u.value = 0, d.value = !1, m.forEach((w) => w == null ? void 0 : w()), m = [], C && n("resize-end", C, c.value));
  }, b = wn(t, "mousedown", h);
  return yt(() => {
    b(), y();
  }), {
    size: O(() => f.value ? `${s.value}px` : ao(e.size)),
    isResizing: d,
    isHorizontal: r
  };
}
const xbe = ["aria-label", "aria-labelledby", "aria-describedby"], Ebe = ["id", "aria-level"], Obe = ["aria-label"], _be = ["id"], Ibe = /* @__PURE__ */ le({
  name: "ElDrawer",
  inheritAttrs: !1,
  __name: "drawer",
  props: Cbe,
  emits: wbe,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = So();
    hi(
      {
        scope: "el-drawer",
        from: "the title slot",
        replacement: "the header slot",
        version: "3.0.0",
        ref: "https://element-plus.org/en-US/component/drawer.html#slots"
      },
      O(() => !!r.title)
    );
    const a = /* @__PURE__ */ H(), i = /* @__PURE__ */ H(), s = /* @__PURE__ */ H(), c = Ve("drawer"), { t: u } = an(), {
      afterEnter: d,
      afterLeave: f,
      beforeLeave: p,
      visible: m,
      rendered: v,
      titleId: h,
      bodyId: g,
      zIndex: y,
      onModalClick: b,
      onOpenAutoFocus: C,
      onCloseAutoFocus: w,
      onFocusoutPrevented: x,
      onCloseRequested: E,
      handleClose: I
    } = N9(o, a), { isHorizontal: T, size: P, isResizing: k } = $be(o, s, l), N = O(() => o.modalPenetrable && !o.modal);
    return t({
      handleClose: I,
      afterEnter: d,
      afterLeave: f
    }), (R, z) => (G(), Me(S($p), {
      to: R.appendTo,
      disabled: R.appendTo !== "body" ? !1 : !R.appendToBody
    }, {
      default: Ee(() => [
        $(Vn, {
          name: S(c).b("fade"),
          onAfterEnter: S(d),
          onAfterLeave: S(f),
          onBeforeLeave: S(p),
          persisted: ""
        }, {
          default: Ee(() => {
            var D;
            return [
              _t($(S(h_), {
                mask: R.modal,
                "overlay-class": [
                  S(c).is("drawer"),
                  (D = R.modalClass) != null ? D : "",
                  `${S(c).namespace.value}-modal-drawer`,
                  S(c).is("penetrable", N.value)
                ],
                "z-index": S(y),
                onClick: S(b)
              }, {
                default: Ee(() => [
                  $(S(xp), {
                    loop: "",
                    trapped: S(m),
                    "focus-trap-el": a.value,
                    "focus-start-el": i.value,
                    onFocusAfterTrapped: S(C),
                    onFocusAfterReleased: S(w),
                    onFocusoutPrevented: S(x),
                    onReleaseRequested: S(E)
                  }, {
                    default: Ee(() => [
                      ve("div", Ut({
                        ref_key: "drawerRef",
                        ref: a,
                        "aria-modal": "true",
                        "aria-label": R.title || void 0,
                        "aria-labelledby": R.title ? void 0 : S(h),
                        "aria-describedby": S(g)
                      }, R.$attrs, {
                        class: [
                          S(c).b(),
                          R.direction,
                          S(m) && "open",
                          S(c).is("dragging", S(k))
                        ],
                        style: { [S(T) ? "width" : "height"]: S(P) },
                        role: "dialog",
                        onClick: z[1] || (z[1] = Et(() => {
                        }, ["stop"]))
                      }), [
                        ve(
                          "span",
                          {
                            ref_key: "focusStartRef",
                            ref: i,
                            class: X(S(c).e("sr-focus")),
                            tabindex: "-1"
                          },
                          null,
                          2
                        ),
                        R.withHeader ? (G(), ue(
                          "header",
                          {
                            key: 0,
                            class: X([S(c).e("header"), R.headerClass])
                          },
                          [
                            R.$slots.title ? Oe(R.$slots, "title", { key: 1 }, () => [
                              Ie(" DEPRECATED SLOT ")
                            ]) : Oe(R.$slots, "header", {
                              key: 0,
                              close: S(I),
                              titleId: S(h),
                              titleClass: S(c).e("title")
                            }, () => [
                              ve("span", {
                                id: S(h),
                                role: "heading",
                                "aria-level": R.headerAriaLevel,
                                class: X(S(c).e("title"))
                              }, qe(R.title), 11, Ebe)
                            ]),
                            R.showClose ? (G(), ue("button", {
                              key: 2,
                              "aria-label": S(u)("el.drawer.close"),
                              class: X(S(c).e("close-btn")),
                              type: "button",
                              onClick: z[0] || (z[0] = (...F) => S(I) && S(I)(...F))
                            }, [
                              $(S(ut), {
                                class: X(S(c).e("close"))
                              }, {
                                default: Ee(() => [
                                  $(S(aa))
                                ]),
                                _: 1
                              }, 8, ["class"])
                            ], 10, Obe)) : Ie("v-if", !0)
                          ],
                          2
                        )) : Ie("v-if", !0),
                        S(v) ? (G(), ue("div", {
                          key: 1,
                          id: S(g),
                          class: X([S(c).e("body"), R.bodyClass])
                        }, [
                          Oe(R.$slots, "default")
                        ], 10, _be)) : Ie("v-if", !0),
                        R.$slots.footer ? (G(), ue(
                          "div",
                          {
                            key: 2,
                            class: X([S(c).e("footer"), R.footerClass])
                          },
                          [
                            Oe(R.$slots, "footer")
                          ],
                          2
                        )) : Ie("v-if", !0),
                        R.resizable ? (G(), ue(
                          "div",
                          {
                            key: 3,
                            ref_key: "draggerRef",
                            ref: s,
                            style: gt({ zIndex: S(y) }),
                            class: X(S(c).e("dragger"))
                          },
                          null,
                          6
                        )) : Ie("v-if", !0)
                      ], 16, xbe)
                    ]),
                    _: 3
                  }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                ]),
                _: 3
              }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
                [Jt, S(m)]
              ])
            ];
          }),
          _: 3
        }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])
      ]),
      _: 3
    }, 8, ["to", "disabled"]));
  }
});
var Tbe = /* @__PURE__ */ Je(Ibe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/drawer/src/drawer.vue"]]);
const Pbe = Dt(Tbe), kbe = /* @__PURE__ */ le({
  inheritAttrs: !1
});
function Nbe(e, t, n, o, l, r) {
  return Oe(e.$slots, "default");
}
var Mbe = /* @__PURE__ */ Je(kbe, [["render", Nbe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection.vue"]]);
const Abe = /* @__PURE__ */ le({
  name: "ElCollectionItem",
  inheritAttrs: !1
});
function Rbe(e, t, n, o, l, r) {
  return Oe(e.$slots, "default");
}
var Dbe = /* @__PURE__ */ Je(Abe, [["render", Rbe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/collection/src/collection-item.vue"]]);
const A9 = "data-el-collection-item", Lbe = (e) => {
  const t = `El${e}Collection`, n = `${t}Item`, o = Symbol(t), l = Symbol(n), r = Object.assign({}, Mbe, {
    name: t,
    setup() {
      const i = /* @__PURE__ */ H(), s = /* @__PURE__ */ new Map();
      at(o, {
        itemMap: s,
        getItems: () => {
          const u = S(i);
          if (!u)
            return [];
          const d = Array.from(
            u.querySelectorAll(`[${A9}]`)
          );
          return [...s.values()].sort(
            (p, m) => d.indexOf(p.ref) - d.indexOf(m.ref)
          );
        },
        collectionRef: i
      });
    }
  }), a = Object.assign({}, Dbe, {
    name: n,
    setup(i, { attrs: s }) {
      const c = /* @__PURE__ */ H(), u = ze(o, void 0);
      at(l, {
        collectionItemRef: c
      }), nt(() => {
        const d = S(c);
        d && u.itemMap.set(d, Be({
          ref: d
        }, s));
      }), yt(() => {
        const d = S(c);
        u.itemMap.delete(d);
      });
    }
  });
  return {
    COLLECTION_INJECTION_KEY: o,
    COLLECTION_ITEM_INJECTION_KEY: l,
    ElCollection: r,
    ElCollectionItem: a
  };
}, Bbe = Xe({
  style: { type: ye([String, Array, Object]) },
  currentTabId: {
    type: ye(String)
  },
  defaultCurrentTabId: String,
  loop: Boolean,
  dir: {
    type: String,
    values: ["ltr", "rtl"],
    default: "ltr"
  },
  orientation: {
    type: ye(String)
  },
  onBlur: Function,
  onFocus: Function,
  onMousedown: Function
}), {
  ElCollection: Fbe,
  ElCollectionItem: Vbe,
  COLLECTION_INJECTION_KEY: R9,
  COLLECTION_ITEM_INJECTION_KEY: zbe
} = Lbe("RovingFocusGroup"), b_ = Symbol("elRovingFocusGroup"), D9 = Symbol("elRovingFocusGroupItem"), Hbe = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
}, jbe = (e, t) => e, Wbe = (e, t, n) => {
  const o = Nn(e), l = jbe(o);
  return Hbe[l];
}, Kbe = (e, t) => e.map((n, o) => e[(o + t) % e.length]), pN = (e) => {
  const { activeElement: t } = document;
  for (const n of e)
    if (n === t || (n.focus(), t !== document.activeElement))
      return;
}, vN = "currentTabIdChange", mN = "rovingFocusGroup.entryFocus", Ube = { bubbles: !1, cancelable: !0 }, Gbe = /* @__PURE__ */ le({
  name: "ElRovingFocusGroupImpl",
  inheritAttrs: !1,
  props: Bbe,
  emits: [vN, "entryFocus"],
  setup(e, { emit: t }) {
    var n;
    const o = /* @__PURE__ */ H(
      (n = e.currentTabId || e.defaultCurrentTabId) != null ? n : null
    ), l = /* @__PURE__ */ H(!1), r = /* @__PURE__ */ H(!1), a = /* @__PURE__ */ H(), { getItems: i } = ze(
      R9,
      void 0
    ), s = O(() => [
      {
        outline: "none"
      },
      e.style
    ]), c = (h) => {
      t(vN, h);
    }, u = () => {
      l.value = !0;
    }, d = qo(
      (h) => {
        var g;
        (g = e.onMousedown) == null || g.call(e, h);
      },
      () => {
        r.value = !0;
      }
    ), f = qo(
      (h) => {
        var g;
        (g = e.onFocus) == null || g.call(e, h);
      },
      (h) => {
        const g = !S(r), { target: y, currentTarget: b } = h;
        if (y === b && g && !S(l)) {
          const C = new Event(mN, Ube);
          if (b == null || b.dispatchEvent(C), !C.defaultPrevented) {
            const w = i().filter((P) => P.focusable), x = w.find((P) => P.active), E = w.find(
              (P) => P.id === S(o)
            ), T = [x, E, ...w].filter(
              Boolean
            ).map((P) => P.ref);
            pN(T);
          }
        }
        r.value = !1;
      }
    ), p = qo(
      (h) => {
        var g;
        (g = e.onBlur) == null || g.call(e, h);
      },
      () => {
        l.value = !1;
      }
    ), m = (...h) => {
      t("entryFocus", ...h);
    }, v = (h) => {
      const g = Wbe(h);
      if (g) {
        h.preventDefault();
        let b = i().filter((C) => C.focusable).map((C) => C.ref);
        switch (g) {
          case "last": {
            b.reverse();
            break;
          }
          case "prev":
          case "next": {
            g === "prev" && b.reverse();
            const C = b.indexOf(h.currentTarget);
            b = e.loop ? Kbe(b, C + 1) : b.slice(C + 1);
            break;
          }
        }
        Ke(() => {
          pN(b);
        });
      }
    };
    at(b_, {
      currentTabbedId: /* @__PURE__ */ Du(o),
      loop: /* @__PURE__ */ ft(e, "loop"),
      tabIndex: O(() => S(l) ? -1 : 0),
      rovingFocusGroupRef: a,
      rovingFocusGroupRootStyle: s,
      orientation: /* @__PURE__ */ ft(e, "orientation"),
      dir: /* @__PURE__ */ ft(e, "dir"),
      onItemFocus: c,
      onItemShiftTab: u,
      onBlur: p,
      onFocus: f,
      onMousedown: d,
      onKeydown: v
    }), pe(
      () => e.currentTabId,
      (h) => {
        o.value = h != null ? h : null;
      }
    ), wn(a, mN, m);
  }
});
function Ybe(e, t, n, o, l, r) {
  return Oe(e.$slots, "default");
}
var Xbe = /* @__PURE__ */ Je(Gbe, [["render", Ybe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group-impl.vue"]]);
const qbe = /* @__PURE__ */ le({
  name: "ElRovingFocusGroup",
  components: {
    ElFocusGroupCollection: Fbe,
    ElRovingFocusGroupImpl: Xbe
  }
});
function Jbe(e, t, n, o, l, r) {
  const a = yn("el-roving-focus-group-impl"), i = yn("el-focus-group-collection");
  return G(), Me(i, null, {
    default: Ee(() => [
      $(
        a,
        cs(us(e.$attrs)),
        {
          default: Ee(() => [
            Oe(e.$slots, "default")
          ]),
          _: 3
        },
        16
      )
    ]),
    _: 3
  });
}
var Zbe = /* @__PURE__ */ Je(qbe, [["render", Jbe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-group.vue"]]);
const pb = Xe({
  trigger: vt(Be({}, mi.trigger), {
    type: ye([
      String,
      Array
    ])
  }),
  triggerKeys: {
    type: ye(Array),
    default: () => [
      Ye.enter,
      Ye.numpadEnter,
      Ye.space,
      Ye.down
    ]
  },
  virtualTriggering: mi.virtualTriggering,
  virtualRef: mi.virtualRef,
  effect: vt(Be({}, In.effect), {
    default: "light"
  }),
  type: {
    type: ye(String)
  },
  placement: {
    type: ye(String),
    default: "bottom"
  },
  popperOptions: {
    type: ye(Object),
    default: () => ({})
  },
  id: String,
  size: {
    type: String,
    default: ""
  },
  splitButton: Boolean,
  hideOnClick: {
    type: Boolean,
    default: !0
  },
  loop: {
    type: Boolean,
    default: !0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  showTimeout: {
    type: Number,
    default: 150
  },
  hideTimeout: {
    type: Number,
    default: 150
  },
  tabindex: {
    type: ye([Number, String]),
    default: 0
  },
  maxHeight: {
    type: ye([Number, String]),
    default: ""
  },
  popperClass: In.popperClass,
  popperStyle: In.popperStyle,
  disabled: Boolean,
  role: {
    type: String,
    values: L7,
    default: "menu"
  },
  buttonProps: {
    type: ye(Object)
  },
  teleported: In.teleported,
  appendTo: In.appendTo,
  persistent: {
    type: Boolean,
    default: !0
  }
}), L9 = Xe({
  command: {
    type: [Object, String, Number],
    default: () => ({})
  },
  disabled: Boolean,
  divided: Boolean,
  textValue: String,
  icon: {
    type: Pn
  }
}), Qbe = Xe({
  onKeydown: { type: ye(Function) }
}), G1 = Symbol("elDropdown"), B9 = "elDropdown", { ButtonGroup: e0e } = Qo, t0e = /* @__PURE__ */ le({
  name: "ElDropdown",
  components: {
    ElButton: Qo,
    ElButtonGroup: e0e,
    ElScrollbar: Ba,
    ElTooltip: al,
    ElRovingFocusGroup: Zbe,
    ElOnlyChild: z7,
    ElIcon: ut,
    ArrowDown: Ni
  },
  props: pb,
  emits: ["visible-change", "click", "command"],
  setup(e, { emit: t }) {
    const n = xt(), o = Ve("dropdown"), { t: l } = an(), r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H(), i = /* @__PURE__ */ H(), s = /* @__PURE__ */ H(), c = /* @__PURE__ */ H(null), u = /* @__PURE__ */ H(null), d = /* @__PURE__ */ H(!1), f = O(() => ({
      maxHeight: ao(e.maxHeight)
    })), p = O(() => [o.m(C.value)]), m = O(() => ll(e.trigger)), v = ml().value, h = O(() => e.id || v);
    function g() {
      var R;
      (R = i.value) == null || R.onClose(void 0, 0);
    }
    function y() {
      var R;
      (R = i.value) == null || R.onClose();
    }
    function b() {
      var R;
      (R = i.value) == null || R.onOpen();
    }
    const C = Mo();
    function w(...R) {
      t("command", ...R);
    }
    function x() {
    }
    function E() {
      const R = S(s);
      m.value.includes("hover") && (R == null || R.focus({
        preventScroll: !0
      })), u.value = null;
    }
    function I(R) {
      u.value = R;
    }
    function T() {
      t("visible-change", !0);
    }
    function P(R) {
      var z;
      d.value = (R == null ? void 0 : R.type) === "keydown", (z = s.value) == null || z.focus();
    }
    function k() {
      t("visible-change", !1);
    }
    return at(G1, {
      contentRef: s,
      role: O(() => e.role),
      triggerId: h,
      isUsingKeyboard: d,
      onItemEnter: x,
      onItemLeave: E,
      handleClose: y
    }), at(B9, {
      instance: n,
      dropdownSize: C,
      handleClick: g,
      commandHandler: w,
      trigger: /* @__PURE__ */ ft(e, "trigger"),
      hideOnClick: /* @__PURE__ */ ft(e, "hideOnClick")
    }), {
      t: l,
      ns: o,
      scrollbar: c,
      wrapStyle: f,
      dropdownTriggerKls: p,
      dropdownSize: C,
      triggerId: h,
      currentTabId: u,
      handleCurrentTabIdChange: I,
      handlerMainButtonClick: (R) => {
        t("click", R);
      },
      handleClose: y,
      handleOpen: b,
      handleBeforeShowTooltip: T,
      handleShowTooltip: P,
      handleBeforeHideTooltip: k,
      popperRef: i,
      contentRef: s,
      triggeringElementRef: r,
      referenceElementRef: a
    };
  }
});
function n0e(e, t, n, o, l, r) {
  var a;
  const i = yn("el-roving-focus-group"), s = yn("el-scrollbar"), c = yn("el-only-child"), u = yn("el-tooltip"), d = yn("el-button"), f = yn("arrow-down"), p = yn("el-icon"), m = yn("el-button-group");
  return G(), ue(
    "div",
    {
      class: X([e.ns.b(), e.ns.is("disabled", e.disabled)])
    },
    [
      $(u, {
        ref: "popperRef",
        role: e.role,
        effect: e.effect,
        "fallback-placements": ["bottom", "top"],
        "popper-options": e.popperOptions,
        "gpu-acceleration": !1,
        placement: e.placement,
        "popper-class": [e.ns.e("popper"), e.popperClass],
        "popper-style": e.popperStyle,
        trigger: e.trigger,
        "trigger-keys": e.triggerKeys,
        "trigger-target-el": e.contentRef,
        "show-arrow": e.showArrow,
        "show-after": e.trigger === "hover" ? e.showTimeout : 0,
        "hide-after": e.trigger === "hover" ? e.hideTimeout : 0,
        "virtual-ref": (a = e.virtualRef) != null ? a : e.triggeringElementRef,
        "virtual-triggering": e.virtualTriggering || e.splitButton,
        disabled: e.disabled,
        transition: `${e.ns.namespace.value}-zoom-in-top`,
        teleported: e.teleported,
        "append-to": e.appendTo,
        pure: "",
        "focus-on-target": "",
        persistent: e.persistent,
        onBeforeShow: e.handleBeforeShowTooltip,
        onShow: e.handleShowTooltip,
        onBeforeHide: e.handleBeforeHideTooltip
      }, or({
        content: Ee(() => [
          $(s, {
            ref: "scrollbar",
            "wrap-style": e.wrapStyle,
            tag: "div",
            "view-class": e.ns.e("list")
          }, {
            default: Ee(() => [
              $(i, {
                loop: e.loop,
                "current-tab-id": e.currentTabId,
                orientation: "horizontal",
                onCurrentTabIdChange: e.handleCurrentTabIdChange
              }, {
                default: Ee(() => [
                  Oe(e.$slots, "dropdown")
                ]),
                _: 3
              }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange"])
            ]),
            _: 3
          }, 8, ["wrap-style", "view-class"])
        ]),
        _: 2
      }, [
        e.splitButton ? void 0 : {
          name: "default",
          fn: Ee(() => [
            $(c, {
              id: e.triggerId,
              ref: "triggeringElementRef",
              role: "button",
              tabindex: e.tabindex
            }, {
              default: Ee(() => [
                Oe(e.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "tabindex"])
          ]),
          key: "0"
        }
      ]), 1032, ["role", "effect", "popper-options", "placement", "popper-class", "popper-style", "trigger", "trigger-keys", "trigger-target-el", "show-arrow", "show-after", "hide-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "append-to", "persistent", "onBeforeShow", "onShow", "onBeforeHide"]),
      e.splitButton ? (G(), Me(m, { key: 0 }, {
        default: Ee(() => [
          $(d, Ut({ ref: "referenceElementRef" }, e.buttonProps, {
            size: e.dropdownSize,
            type: e.type,
            disabled: e.disabled,
            tabindex: e.tabindex,
            onClick: e.handlerMainButtonClick
          }), {
            default: Ee(() => [
              Oe(e.$slots, "default")
            ]),
            _: 3
          }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
          $(d, Ut({
            id: e.triggerId,
            ref: "triggeringElementRef"
          }, e.buttonProps, {
            role: "button",
            size: e.dropdownSize,
            type: e.type,
            class: e.ns.e("caret-button"),
            disabled: e.disabled,
            tabindex: e.tabindex,
            "aria-label": e.t("el.dropdown.toggleDropdown")
          }), {
            default: Ee(() => [
              $(p, {
                class: X(e.ns.e("icon"))
              }, {
                default: Ee(() => [
                  $(f)
                ]),
                _: 1
              }, 8, ["class"])
            ]),
            _: 1
          }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
        ]),
        _: 3
      })) : Ie("v-if", !0)
    ],
    2
  );
}
var o0e = /* @__PURE__ */ Je(t0e, [["render", n0e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown.vue"]]);
const l0e = /* @__PURE__ */ le({
  components: {
    ElRovingFocusCollectionItem: Vbe
  },
  props: {
    focusable: {
      type: Boolean,
      default: !0
    },
    active: Boolean
  },
  emits: ["mousedown", "focus", "keydown"],
  setup(e, { emit: t }) {
    const { currentTabbedId: n, onItemFocus: o, onItemShiftTab: l, onKeydown: r } = ze(
      b_,
      void 0
    ), a = ml(), i = /* @__PURE__ */ H(), s = qo(
      (f) => {
        t("mousedown", f);
      },
      (f) => {
        e.focusable ? o(S(a)) : f.preventDefault();
      }
    ), c = qo(
      (f) => {
        t("focus", f);
      },
      () => {
        o(S(a));
      }
    ), u = qo(
      (f) => {
        t("keydown", f);
      },
      (f) => {
        const { shiftKey: p, target: m, currentTarget: v } = f;
        if (Nn(f) === Ye.tab && p) {
          l();
          return;
        }
        m === v && r(f);
      }
    ), d = O(() => n.value === S(a));
    return at(D9, {
      rovingFocusGroupItemRef: i,
      tabIndex: O(() => S(d) ? 0 : -1),
      handleMousedown: s,
      handleFocus: c,
      handleKeydown: u
    }), {
      id: a,
      handleKeydown: u,
      handleFocus: c,
      handleMousedown: s
    };
  }
});
function r0e(e, t, n, o, l, r) {
  const a = yn("el-roving-focus-collection-item");
  return G(), Me(a, {
    id: e.id,
    focusable: e.focusable,
    active: e.active
  }, {
    default: Ee(() => [
      Oe(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["id", "focusable", "active"]);
}
var a0e = /* @__PURE__ */ Je(l0e, [["render", r0e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/roving-focus-group/src/roving-focus-item.vue"]]);
const i0e = /* @__PURE__ */ le({
  name: "DropdownItemImpl",
  components: {
    ElIcon: ut
  },
  props: L9,
  emits: ["pointermove", "pointerleave", "click", "clickimpl"],
  setup(e, { emit: t }) {
    const n = Ve("dropdown"), { role: o } = ze(G1, void 0), { collectionItemRef: l } = ze(
      zbe,
      void 0
    ), {
      rovingFocusGroupItemRef: r,
      tabIndex: a,
      handleFocus: i,
      handleKeydown: s,
      handleMousedown: c
    } = ze(D9, void 0), u = g_(
      l,
      r
    ), d = O(() => o.value === "menu" ? "menuitem" : o.value === "navigation" ? "link" : "button"), f = qo((p) => {
      const m = Nn(p);
      if ([Ye.enter, Ye.numpadEnter, Ye.space].includes(
        m
      ))
        return p.preventDefault(), p.stopImmediatePropagation(), t("clickimpl", p), !0;
    }, s);
    return {
      ns: n,
      itemRef: u,
      dataset: {
        [A9]: ""
      },
      role: d,
      tabIndex: a,
      handleFocus: i,
      handleKeydown: f,
      handleMousedown: c
    };
  }
}), s0e = ["aria-disabled", "tabindex", "role"];
function c0e(e, t, n, o, l, r) {
  const a = yn("el-icon");
  return G(), ue(
    Ge,
    null,
    [
      e.divided ? (G(), ue(
        "li",
        {
          key: 0,
          role: "separator",
          class: X(e.ns.bem("menu", "item", "divided"))
        },
        null,
        2
      )) : Ie("v-if", !0),
      ve("li", Ut({ ref: e.itemRef }, Be(Be({}, e.dataset), e.$attrs), {
        "aria-disabled": e.disabled,
        class: [e.ns.be("menu", "item"), e.ns.is("disabled", e.disabled)],
        tabindex: e.tabIndex,
        role: e.role,
        onClick: t[0] || (t[0] = (i) => e.$emit("clickimpl", i)),
        onFocus: t[1] || (t[1] = (...i) => e.handleFocus && e.handleFocus(...i)),
        onKeydown: t[2] || (t[2] = Et((...i) => e.handleKeydown && e.handleKeydown(...i), ["self"])),
        onMousedown: t[3] || (t[3] = (...i) => e.handleMousedown && e.handleMousedown(...i)),
        onPointermove: t[4] || (t[4] = (i) => e.$emit("pointermove", i)),
        onPointerleave: t[5] || (t[5] = (i) => e.$emit("pointerleave", i))
      }), [
        e.icon || e.$slots.icon ? (G(), Me(a, { key: 0 }, {
          default: Ee(() => [
            Oe(e.$slots, "icon", {}, () => [
              (G(), Me(Ht(e.icon)))
            ])
          ]),
          _: 3
        })) : Ie("v-if", !0),
        Oe(e.$slots, "default")
      ], 16, s0e)
    ],
    64
  );
}
var u0e = /* @__PURE__ */ Je(i0e, [["render", c0e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item-impl.vue"]]);
const F9 = () => {
  const e = ze(
    B9,
    {}
  ), t = O(() => e == null ? void 0 : e.dropdownSize);
  return {
    elDropdown: e,
    _elDropdownSize: t
  };
}, d0e = /* @__PURE__ */ le({
  name: "ElDropdownItem",
  components: {
    ElRovingFocusItem: a0e,
    ElDropdownItemImpl: u0e
  },
  inheritAttrs: !1,
  props: L9,
  emits: ["pointermove", "pointerleave", "click"],
  setup(e, { emit: t, attrs: n }) {
    const { elDropdown: o } = F9(), l = xt(), { onItemEnter: r, onItemLeave: a } = ze(
      G1,
      void 0
    ), i = qo(
      (d) => (t("pointermove", d), d.defaultPrevented),
      P3((d) => {
        if (e.disabled) {
          a(d);
          return;
        }
        const f = d.currentTarget;
        f === document.activeElement || f.contains(document.activeElement) || (r(d), d.defaultPrevented || f == null || f.focus({
          preventScroll: !0
        }));
      })
    ), s = qo((d) => (t("pointerleave", d), d.defaultPrevented), P3(a)), c = qo(
      (d) => {
        if (!e.disabled)
          return t("click", d), d.type !== "keydown" && d.defaultPrevented;
      },
      (d) => {
        var f, p, m;
        if (e.disabled) {
          d.stopImmediatePropagation();
          return;
        }
        (f = o == null ? void 0 : o.hideOnClick) != null && f.value && ((p = o.handleClick) == null || p.call(o)), (m = o.commandHandler) == null || m.call(o, e.command, l, d);
      }
    ), u = O(() => Be(Be({}, e), n));
    return {
      handleClick: c,
      handlePointerMove: i,
      handlePointerLeave: s,
      propsAndAttrs: u
    };
  }
});
function f0e(e, t, n, o, l, r) {
  const a = yn("el-dropdown-item-impl"), i = yn("el-roving-focus-item");
  return G(), Me(i, {
    focusable: !e.disabled
  }, {
    default: Ee(() => [
      $(a, Ut(e.propsAndAttrs, {
        onPointerleave: e.handlePointerLeave,
        onPointermove: e.handlePointerMove,
        onClickimpl: e.handleClick
      }), or({
        default: Ee(() => [
          Oe(e.$slots, "default")
        ]),
        _: 2
      }, [
        e.$slots.icon ? {
          name: "icon",
          fn: Ee(() => [
            Oe(e.$slots, "icon")
          ]),
          key: "0"
        } : void 0
      ]), 1040, ["onPointerleave", "onPointermove", "onClickimpl"])
    ]),
    _: 3
  }, 8, ["focusable"]);
}
var V9 = /* @__PURE__ */ Je(d0e, [["render", f0e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-item.vue"]]);
const p0e = /* @__PURE__ */ le({
  name: "ElDropdownMenu",
  props: Qbe,
  setup(e) {
    const t = Ve("dropdown"), { _elDropdownSize: n } = F9(), o = n.value, { contentRef: l, role: r, triggerId: a, isUsingKeyboard: i, handleClose: s } = ze(G1, void 0), {
      rovingFocusGroupRef: c,
      rovingFocusGroupRootStyle: u,
      onBlur: d,
      onFocus: f,
      onKeydown: p,
      onMousedown: m
    } = ze(b_, void 0), { collectionRef: v } = ze(
      R9,
      void 0
    ), h = O(() => [t.b("menu"), t.bm("menu", o == null ? void 0 : o.value)]), g = g_(
      l,
      c,
      v
    ), y = qo(
      (C) => {
        var w;
        (w = e.onKeydown) == null || w.call(e, C);
      },
      (C) => {
        const { currentTarget: w, target: x } = C, E = Nn(C);
        if (w.contains(
          x
        ), Ye.tab === E)
          return s();
        p(C);
      }
    );
    function b(C) {
      i.value && f(C);
    }
    return {
      size: o,
      rovingFocusGroupRootStyle: u,
      dropdownKls: h,
      role: r,
      triggerId: a,
      dropdownListWrapperRef: g,
      handleKeydown: y,
      onBlur: d,
      handleFocus: b,
      onMousedown: m
    };
  }
}), v0e = ["role", "aria-labelledby"];
function m0e(e, t, n, o, l, r) {
  return G(), ue("ul", {
    ref: e.dropdownListWrapperRef,
    class: X(e.dropdownKls),
    style: gt(e.rovingFocusGroupRootStyle),
    tabindex: -1,
    role: e.role,
    "aria-labelledby": e.triggerId,
    onFocusin: t[0] || (t[0] = (...a) => e.handleFocus && e.handleFocus(...a)),
    onFocusout: t[1] || (t[1] = (...a) => e.onBlur && e.onBlur(...a)),
    onKeydown: t[2] || (t[2] = Et((...a) => e.handleKeydown && e.handleKeydown(...a), ["self"])),
    onMousedown: t[3] || (t[3] = Et((...a) => e.onMousedown && e.onMousedown(...a), ["self"]))
  }, [
    Oe(e.$slots, "default")
  ], 46, v0e);
}
var z9 = /* @__PURE__ */ Je(p0e, [["render", m0e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/dropdown/src/dropdown-menu.vue"]]);
const h0e = Dt(o0e, {
  DropdownItem: V9,
  DropdownMenu: z9
}), g0e = oo(V9), b0e = oo(z9), y0e = {
  viewBox: "0 0 79 86",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
}, S0e = ["id"], C0e = ["stop-color"], w0e = ["stop-color"], $0e = ["id"], x0e = ["stop-color"], E0e = ["stop-color"], O0e = ["id"], _0e = {
  stroke: "none",
  "stroke-width": "1",
  fill: "none",
  "fill-rule": "evenodd"
}, I0e = { transform: "translate(-1268.000000, -535.000000)" }, T0e = { transform: "translate(1268.000000, 535.000000)" }, P0e = ["fill"], k0e = ["fill"], N0e = { transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)" }, M0e = ["fill"], A0e = ["fill"], R0e = ["fill"], D0e = ["fill"], L0e = ["fill"], B0e = { transform: "translate(53.000000, 45.000000)" }, F0e = ["fill", "xlink:href"], V0e = ["fill", "mask"], z0e = ["fill"], H0e = /* @__PURE__ */ le({
  name: "ImgEmpty",
  __name: "img-empty",
  setup(e) {
    const t = Ve("empty"), n = ml();
    return (o, l) => (G(), ue("svg", y0e, [
      ve("defs", null, [
        ve("linearGradient", {
          id: `linearGradient-1-${S(n)}`,
          x1: "38.8503086%",
          y1: "0%",
          x2: "61.1496914%",
          y2: "100%"
        }, [
          ve("stop", {
            "stop-color": `var(${S(t).cssVarBlockName("fill-color-1")})`,
            offset: "0%"
          }, null, 8, C0e),
          ve("stop", {
            "stop-color": `var(${S(t).cssVarBlockName("fill-color-4")})`,
            offset: "100%"
          }, null, 8, w0e)
        ], 8, S0e),
        ve("linearGradient", {
          id: `linearGradient-2-${S(n)}`,
          x1: "0%",
          y1: "9.5%",
          x2: "100%",
          y2: "90.5%"
        }, [
          ve("stop", {
            "stop-color": `var(${S(t).cssVarBlockName("fill-color-1")})`,
            offset: "0%"
          }, null, 8, x0e),
          ve("stop", {
            "stop-color": `var(${S(t).cssVarBlockName("fill-color-6")})`,
            offset: "100%"
          }, null, 8, E0e)
        ], 8, $0e),
        ve("rect", {
          id: `path-3-${S(n)}`,
          x: "0",
          y: "0",
          width: "17",
          height: "36"
        }, null, 8, O0e)
      ]),
      ve("g", _0e, [
        ve("g", I0e, [
          ve("g", T0e, [
            ve("path", {
              d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
              fill: `var(${S(t).cssVarBlockName("fill-color-3")})`
            }, null, 8, P0e),
            ve("polygon", {
              fill: `var(${S(t).cssVarBlockName("fill-color-7")})`,
              transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
              points: "13 58 53 58 42 45 2 45"
            }, null, 8, k0e),
            ve("g", N0e, [
              ve("polygon", {
                fill: `var(${S(t).cssVarBlockName("fill-color-7")})`,
                transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
                points: "2.84078316e-14 3 18 3 23 7 5 7"
              }, null, 8, M0e),
              ve("polygon", {
                fill: `var(${S(t).cssVarBlockName("fill-color-5")})`,
                points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
              }, null, 8, A0e),
              ve("rect", {
                fill: `url(#linearGradient-1-${S(n)})`,
                transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
                x: "38",
                y: "7",
                width: "17",
                height: "36"
              }, null, 8, R0e),
              ve("polygon", {
                fill: `var(${S(t).cssVarBlockName("fill-color-2")})`,
                transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
                points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
              }, null, 8, D0e)
            ]),
            ve("rect", {
              fill: `url(#linearGradient-2-${S(n)})`,
              x: "13",
              y: "45",
              width: "40",
              height: "36"
            }, null, 8, L0e),
            ve("g", B0e, [
              ve("use", {
                fill: `var(${S(t).cssVarBlockName("fill-color-8")})`,
                transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
                "xlink:href": `#path-3-${S(n)}`
              }, null, 8, F0e),
              ve("polygon", {
                fill: `var(${S(t).cssVarBlockName("fill-color-9")})`,
                mask: `url(#mask-4-${S(n)})`,
                transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
                points: "7 0 24 0 20 18 7 16.5"
              }, null, 8, V0e)
            ]),
            ve("polygon", {
              fill: `var(${S(t).cssVarBlockName("fill-color-2")})`,
              transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
              points: "62 45 79 45 70 58 53 58"
            }, null, 8, z0e)
          ])
        ])
      ])
    ]));
  }
});
var j0e = /* @__PURE__ */ Je(H0e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/img-empty.vue"]]);
const W0e = Xe({
  image: {
    type: String,
    default: ""
  },
  imageSize: Number,
  description: {
    type: String,
    default: ""
  }
}), K0e = ["src"], U0e = { key: 1 }, G0e = /* @__PURE__ */ le({
  name: "ElEmpty",
  __name: "empty",
  props: W0e,
  setup(e) {
    const t = e, { t: n } = an(), o = Ve("empty"), l = O(
      () => t.description || n("el.table.emptyText")
    ), r = O(() => ({
      width: ao(t.imageSize)
    }));
    return (a, i) => (G(), ue(
      "div",
      {
        class: X(S(o).b())
      },
      [
        ve(
          "div",
          {
            class: X(S(o).e("image")),
            style: gt(r.value)
          },
          [
            a.image ? (G(), ue("img", {
              key: 0,
              src: a.image,
              ondragstart: "return false"
            }, null, 8, K0e)) : Oe(a.$slots, "image", { key: 1 }, () => [
              $(j0e)
            ])
          ],
          6
        ),
        ve(
          "div",
          {
            class: X(S(o).e("description"))
          },
          [
            a.$slots.description ? Oe(a.$slots, "description", { key: 0 }) : (G(), ue(
              "p",
              U0e,
              qe(l.value),
              1
            ))
          ],
          2
        ),
        a.$slots.default ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(o).e("bottom"))
          },
          [
            Oe(a.$slots, "default")
          ],
          2
        )) : Ie("v-if", !0)
      ],
      2
    ));
  }
});
var Y0e = /* @__PURE__ */ Je(G0e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/empty/src/empty.vue"]]);
const H9 = Dt(Y0e), X0e = Xe({
  size: {
    type: String,
    values: ki
  },
  disabled: Boolean
}), q0e = Xe(vt(Be({}, X0e), {
  model: Object,
  rules: {
    type: ye(Object)
  },
  labelPosition: {
    type: String,
    values: ["left", "right", "top"],
    default: "right"
  },
  requireAsteriskPosition: {
    type: String,
    values: ["left", "right"],
    default: "left"
  },
  labelWidth: {
    type: [String, Number],
    default: ""
  },
  labelSuffix: {
    type: String,
    default: ""
  },
  inline: Boolean,
  inlineMessage: Boolean,
  statusIcon: Boolean,
  showMessage: {
    type: Boolean,
    default: !0
  },
  validateOnRuleChange: {
    type: Boolean,
    default: !0
  },
  hideRequiredAsterisk: Boolean,
  scrollToError: Boolean,
  scrollIntoViewOptions: {
    type: ye([Object, Boolean]),
    default: !0
  }
})), J0e = {
  validate: (e, t, n) => (We(e) || rt(e)) && Tn(t) && rt(n)
}, Z0e = "ElForm";
function Q0e() {
  const e = /* @__PURE__ */ H([]), t = O(() => {
    if (!e.value.length)
      return "0";
    const r = Math.max(...e.value);
    return r ? `${r}px` : "";
  });
  function n(r) {
    const a = e.value.indexOf(r);
    return a === -1 && t.value === "0" && Gt(Z0e, `unexpected width ${r}`), a;
  }
  function o(r, a) {
    if (r && a) {
      const i = n(a);
      e.value.splice(i, 1, r);
    } else r && e.value.push(r);
  }
  function l(r) {
    const a = n(r);
    a > -1 && e.value.splice(a, 1);
  }
  return {
    autoLabelWidth: t,
    registerLabelWidth: o,
    deregisterLabelWidth: l
  };
}
const pg = (e, t) => {
  const n = ll(t).map(
    (o) => We(o) ? o.join(".") : o
  );
  return n.length > 0 ? e.filter(
    (o) => o.propString && n.includes(o.propString)
  ) : e;
}, _d = "ElForm", eye = /* @__PURE__ */ le({
  name: _d,
  __name: "form",
  props: q0e,
  emits: J0e,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = /* @__PURE__ */ H(), a = /* @__PURE__ */ kt([]), i = Mo(), s = Ve("form"), c = O(() => {
      const { labelPosition: x, inline: E } = o;
      return [
        s.b(),
        s.m(i.value || "default"),
        {
          [s.m(`label-${x}`)]: x,
          [s.m("inline")]: E
        }
      ];
    }), u = (x) => pg(a, [x])[0], d = (x) => {
      a.push(x);
    }, f = (x) => {
      x.prop && a.splice(a.indexOf(x), 1);
    }, p = (x) => {
      if (!o.model) {
        Gt(_d, "model is required for setInitialValues to work.");
        return;
      }
      if (!x) {
        Gt(
          _d,
          "initModel is required for setInitialValues to work."
        );
        return;
      }
      a.forEach((E) => {
        if (E.prop && mae(x, E.prop)) {
          const I = ff(x, E.prop).value;
          E.setInitialValue(I);
        }
      });
    }, m = (x = []) => {
      if (!o.model) {
        Gt(_d, "model is required for resetFields to work.");
        return;
      }
      pg(a, x).forEach((E) => E.resetField());
    }, v = (x = []) => {
      pg(a, x).forEach((E) => E.clearValidate());
    }, h = O(() => {
      const x = !!o.model;
      return x || Gt(_d, "model is required for validate to work."), x;
    }), g = (x) => {
      if (a.length === 0)
        return [];
      const E = pg(a, x);
      return E.length ? E : (Gt(_d, "please pass correct props!"), []);
    }, y = (x) => Rt(this, null, function* () {
      return C(void 0, x);
    }), b = (...E) => Rt(this, [...E], function* (x = []) {
      if (!h.value)
        return !1;
      const I = g(x);
      if (I.length === 0)
        return !0;
      let T = {};
      for (const P of I)
        try {
          yield P.validate(""), P.validateState === "error" && !P.error && P.resetField();
        } catch (k) {
          T = Be(Be({}, T), k);
        }
      return Object.keys(T).length === 0 ? !0 : Promise.reject(T);
    }), C = (...I) => Rt(this, [...I], function* (x = [], E) {
      let T = !1;
      const P = !it(E);
      try {
        return T = yield b(x), T === !0 && (yield E == null ? void 0 : E(T)), T;
      } catch (k) {
        if (k instanceof Error)
          throw k;
        const N = k;
        if (o.scrollToError && r.value) {
          const R = r.value.querySelector(`.${s.b()}-item.is-error`);
          R == null || R.scrollIntoView(o.scrollIntoViewOptions);
        }
        return !T && (yield E == null ? void 0 : E(!1, N)), P && Promise.reject(N);
      }
    }), w = (x) => {
      var E;
      const I = u(x);
      I && ((E = I.$el) == null || E.scrollIntoView(o.scrollIntoViewOptions));
    };
    return pe(
      () => o.rules,
      () => {
        o.validateOnRuleChange && y().catch((x) => Gt(x));
      },
      { deep: !0, flush: "post" }
    ), at(
      id,
      /* @__PURE__ */ kt(Be(vt(Be({}, /* @__PURE__ */ to(o)), {
        emit: l,
        resetFields: m,
        clearValidate: v,
        validateField: C,
        getField: u,
        addField: d,
        removeField: f,
        setInitialValues: p
      }), Q0e()))
    ), t({
      validate: y,
      validateField: C,
      resetFields: m,
      clearValidate: v,
      scrollToField: w,
      getField: u,
      fields: a,
      setInitialValues: p
    }), (x, E) => (G(), ue(
      "form",
      {
        ref_key: "formRef",
        ref: r,
        class: X(c.value)
      },
      [
        Oe(x.$slots, "default")
      ],
      2
    ));
  }
});
var tye = /* @__PURE__ */ Je(eye, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form.vue"]]);
function fu() {
  return fu = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, fu.apply(this, arguments);
}
function nye(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, gm(e, t);
}
function Sx(e) {
  return Sx = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, Sx(e);
}
function gm(e, t) {
  return gm = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, gm(e, t);
}
function oye() {
  if (typeof Reflect == "undefined" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch (e) {
    return !1;
  }
}
function vb(e, t, n) {
  return oye() ? vb = Reflect.construct.bind() : vb = function(l, r, a) {
    var i = [null];
    i.push.apply(i, r);
    var s = Function.bind.apply(l, i), c = new s();
    return a && gm(c, a.prototype), c;
  }, vb.apply(null, arguments);
}
function lye(e) {
  return Function.toString.call(e).indexOf("[native code]") !== -1;
}
function Cx(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Cx = function(o) {
    if (o === null || !lye(o)) return o;
    if (typeof o != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t != "undefined") {
      if (t.has(o)) return t.get(o);
      t.set(o, l);
    }
    function l() {
      return vb(o, arguments, Sx(this).constructor);
    }
    return l.prototype = Object.create(o.prototype, {
      constructor: {
        value: l,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), gm(l, o);
  }, Cx(e);
}
var rye = /%[sdj%]/g, j9 = function() {
};
typeof process != "undefined" && process.env && process.env.NODE_ENV !== "production" && typeof window != "undefined" && typeof document != "undefined" && (j9 = function(t, n) {
  typeof console != "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING == "undefined" && n.every(function(o) {
    return typeof o == "string";
  }) && console.warn(t, n);
});
function wx(e) {
  if (!e || !e.length) return null;
  var t = {};
  return e.forEach(function(n) {
    var o = n.field;
    t[o] = t[o] || [], t[o].push(n);
  }), t;
}
function Mr(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o];
  var l = 0, r = n.length;
  if (typeof e == "function")
    return e.apply(null, n);
  if (typeof e == "string") {
    var a = e.replace(rye, function(i) {
      if (i === "%%")
        return "%";
      if (l >= r)
        return i;
      switch (i) {
        case "%s":
          return String(n[l++]);
        case "%d":
          return Number(n[l++]);
        case "%j":
          try {
            return JSON.stringify(n[l++]);
          } catch (s) {
            return "[Circular]";
          }
          break;
        default:
          return i;
      }
    });
    return a;
  }
  return e;
}
function aye(e) {
  return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
}
function il(e, t) {
  return !!(e == null || t === "array" && Array.isArray(e) && !e.length || aye(t) && typeof e == "string" && !e);
}
function iye(e, t, n) {
  var o = [], l = 0, r = e.length;
  function a(i) {
    o.push.apply(o, i || []), l++, l === r && n(o);
  }
  e.forEach(function(i) {
    t(i, a);
  });
}
function hN(e, t, n) {
  var o = 0, l = e.length;
  function r(a) {
    if (a && a.length) {
      n(a);
      return;
    }
    var i = o;
    o = o + 1, i < l ? t(e[i], r) : n([]);
  }
  r([]);
}
function sye(e) {
  var t = [];
  return Object.keys(e).forEach(function(n) {
    t.push.apply(t, e[n] || []);
  }), t;
}
var gN = /* @__PURE__ */ function(e) {
  nye(t, e);
  function t(n, o) {
    var l;
    return l = e.call(this, "Async Validation Error") || this, l.errors = n, l.fields = o, l;
  }
  return t;
}(/* @__PURE__ */ Cx(Error));
function cye(e, t, n, o, l) {
  if (t.first) {
    var r = new Promise(function(f, p) {
      var m = function(g) {
        return o(g), g.length ? p(new gN(g, wx(g))) : f(l);
      }, v = sye(e);
      hN(v, n, m);
    });
    return r.catch(function(f) {
      return f;
    }), r;
  }
  var a = t.firstFields === !0 ? Object.keys(e) : t.firstFields || [], i = Object.keys(e), s = i.length, c = 0, u = [], d = new Promise(function(f, p) {
    var m = function(h) {
      if (u.push.apply(u, h), c++, c === s)
        return o(u), u.length ? p(new gN(u, wx(u))) : f(l);
    };
    i.length || (o(u), f(l)), i.forEach(function(v) {
      var h = e[v];
      a.indexOf(v) !== -1 ? hN(h, n, m) : iye(h, n, m);
    });
  });
  return d.catch(function(f) {
    return f;
  }), d;
}
function uye(e) {
  return !!(e && e.message !== void 0);
}
function dye(e, t) {
  for (var n = e, o = 0; o < t.length; o++) {
    if (n == null)
      return n;
    n = n[t[o]];
  }
  return n;
}
function bN(e, t) {
  return function(n) {
    var o;
    return e.fullFields ? o = dye(t, e.fullFields) : o = t[n.field || e.fullField], uye(n) ? (n.field = n.field || e.fullField, n.fieldValue = o, n) : {
      message: typeof n == "function" ? n() : n,
      fieldValue: o,
      field: n.field || e.fullField
    };
  };
}
function yN(e, t) {
  if (t) {
    for (var n in t)
      if (t.hasOwnProperty(n)) {
        var o = t[n];
        typeof o == "object" && typeof e[n] == "object" ? e[n] = fu({}, e[n], o) : e[n] = o;
      }
  }
  return e;
}
var W9 = function(t, n, o, l, r, a) {
  t.required && (!o.hasOwnProperty(t.field) || il(n, a || t.type)) && l.push(Mr(r.messages.required, t.fullField));
}, fye = function(t, n, o, l, r) {
  (/^\s+$/.test(n) || n === "") && l.push(Mr(r.messages.whitespace, t.fullField));
}, vg, pye = function() {
  if (vg)
    return vg;
  var e = "[a-fA-F\\d:]", t = function(C) {
    return C && C.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : "";
  }, n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", o = "[a-fA-F\\d]{1,4}", l = (`
(?:
(?:` + o + ":){7}(?:" + o + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + o + ":){6}(?:" + n + "|:" + o + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + o + ":){5}(?::" + n + "|(?::" + o + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + o + ":){4}(?:(?::" + o + "){0,1}:" + n + "|(?::" + o + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + o + ":){3}(?:(?::" + o + "){0,2}:" + n + "|(?::" + o + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + o + ":){2}(?:(?::" + o + "){0,3}:" + n + "|(?::" + o + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + o + ":){1}(?:(?::" + o + "){0,4}:" + n + "|(?::" + o + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + o + "){0,5}:" + n + "|(?::" + o + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), r = new RegExp("(?:^" + n + "$)|(?:^" + l + "$)"), a = new RegExp("^" + n + "$"), i = new RegExp("^" + l + "$"), s = function(C) {
    return C && C.exact ? r : new RegExp("(?:" + t(C) + n + t(C) + ")|(?:" + t(C) + l + t(C) + ")", "g");
  };
  s.v4 = function(b) {
    return b && b.exact ? a : new RegExp("" + t(b) + n + t(b), "g");
  }, s.v6 = function(b) {
    return b && b.exact ? i : new RegExp("" + t(b) + l + t(b), "g");
  };
  var c = "(?:(?:[a-z]+:)?//)", u = "(?:\\S+(?::\\S*)?@)?", d = s.v4().source, f = s.v6().source, p = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", m = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", v = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", h = "(?::\\d{2,5})?", g = '(?:[/?#][^\\s"]*)?', y = "(?:" + c + "|www\\.)" + u + "(?:localhost|" + d + "|" + f + "|" + p + m + v + ")" + h + g;
  return vg = new RegExp("(?:^" + y + "$)", "i"), vg;
}, SN = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, pv = {
  integer: function(t) {
    return pv.number(t) && parseInt(t, 10) === t;
  },
  float: function(t) {
    return pv.number(t) && !pv.integer(t);
  },
  array: function(t) {
    return Array.isArray(t);
  },
  regexp: function(t) {
    if (t instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(t);
    } catch (n) {
      return !1;
    }
  },
  date: function(t) {
    return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
  },
  number: function(t) {
    return isNaN(t) ? !1 : typeof t == "number";
  },
  object: function(t) {
    return typeof t == "object" && !pv.array(t);
  },
  method: function(t) {
    return typeof t == "function";
  },
  email: function(t) {
    return typeof t == "string" && t.length <= 320 && !!t.match(SN.email);
  },
  url: function(t) {
    return typeof t == "string" && t.length <= 2048 && !!t.match(pye());
  },
  hex: function(t) {
    return typeof t == "string" && !!t.match(SN.hex);
  }
}, vye = function(t, n, o, l, r) {
  if (t.required && n === void 0) {
    W9(t, n, o, l, r);
    return;
  }
  var a = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], i = t.type;
  a.indexOf(i) > -1 ? pv[i](n) || l.push(Mr(r.messages.types[i], t.fullField, t.type)) : i && typeof n !== t.type && l.push(Mr(r.messages.types[i], t.fullField, t.type));
}, mye = function(t, n, o, l, r) {
  var a = typeof t.len == "number", i = typeof t.min == "number", s = typeof t.max == "number", c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, u = n, d = null, f = typeof n == "number", p = typeof n == "string", m = Array.isArray(n);
  if (f ? d = "number" : p ? d = "string" : m && (d = "array"), !d)
    return !1;
  m && (u = n.length), p && (u = n.replace(c, "_").length), a ? u !== t.len && l.push(Mr(r.messages[d].len, t.fullField, t.len)) : i && !s && u < t.min ? l.push(Mr(r.messages[d].min, t.fullField, t.min)) : s && !i && u > t.max ? l.push(Mr(r.messages[d].max, t.fullField, t.max)) : i && s && (u < t.min || u > t.max) && l.push(Mr(r.messages[d].range, t.fullField, t.min, t.max));
}, Id = "enum", hye = function(t, n, o, l, r) {
  t[Id] = Array.isArray(t[Id]) ? t[Id] : [], t[Id].indexOf(n) === -1 && l.push(Mr(r.messages[Id], t.fullField, t[Id].join(", ")));
}, gye = function(t, n, o, l, r) {
  if (t.pattern) {
    if (t.pattern instanceof RegExp)
      t.pattern.lastIndex = 0, t.pattern.test(n) || l.push(Mr(r.messages.pattern.mismatch, t.fullField, n, t.pattern));
    else if (typeof t.pattern == "string") {
      var a = new RegExp(t.pattern);
      a.test(n) || l.push(Mr(r.messages.pattern.mismatch, t.fullField, n, t.pattern));
    }
  }
}, zn = {
  required: W9,
  whitespace: fye,
  type: vye,
  range: mye,
  enum: hye,
  pattern: gye
}, bye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (il(n, "string") && !t.required)
      return o();
    zn.required(t, n, l, a, r, "string"), il(n, "string") || (zn.type(t, n, l, a, r), zn.range(t, n, l, a, r), zn.pattern(t, n, l, a, r), t.whitespace === !0 && zn.whitespace(t, n, l, a, r));
  }
  o(a);
}, yye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (il(n) && !t.required)
      return o();
    zn.required(t, n, l, a, r), n !== void 0 && zn.type(t, n, l, a, r);
  }
  o(a);
}, Sye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (n === "" && (n = void 0), il(n) && !t.required)
      return o();
    zn.required(t, n, l, a, r), n !== void 0 && (zn.type(t, n, l, a, r), zn.range(t, n, l, a, r));
  }
  o(a);
}, Cye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (il(n) && !t.required)
      return o();
    zn.required(t, n, l, a, r), n !== void 0 && zn.type(t, n, l, a, r);
  }
  o(a);
}, wye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (il(n) && !t.required)
      return o();
    zn.required(t, n, l, a, r), il(n) || zn.type(t, n, l, a, r);
  }
  o(a);
}, $ye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (il(n) && !t.required)
      return o();
    zn.required(t, n, l, a, r), n !== void 0 && (zn.type(t, n, l, a, r), zn.range(t, n, l, a, r));
  }
  o(a);
}, xye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (il(n) && !t.required)
      return o();
    zn.required(t, n, l, a, r), n !== void 0 && (zn.type(t, n, l, a, r), zn.range(t, n, l, a, r));
  }
  o(a);
}, Eye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (n == null && !t.required)
      return o();
    zn.required(t, n, l, a, r, "array"), n != null && (zn.type(t, n, l, a, r), zn.range(t, n, l, a, r));
  }
  o(a);
}, Oye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (il(n) && !t.required)
      return o();
    zn.required(t, n, l, a, r), n !== void 0 && zn.type(t, n, l, a, r);
  }
  o(a);
}, _ye = "enum", Iye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (il(n) && !t.required)
      return o();
    zn.required(t, n, l, a, r), n !== void 0 && zn[_ye](t, n, l, a, r);
  }
  o(a);
}, Tye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (il(n, "string") && !t.required)
      return o();
    zn.required(t, n, l, a, r), il(n, "string") || zn.pattern(t, n, l, a, r);
  }
  o(a);
}, Pye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (il(n, "date") && !t.required)
      return o();
    if (zn.required(t, n, l, a, r), !il(n, "date")) {
      var s;
      n instanceof Date ? s = n : s = new Date(n), zn.type(t, s, l, a, r), s && zn.range(t, s.getTime(), l, a, r);
    }
  }
  o(a);
}, kye = function(t, n, o, l, r) {
  var a = [], i = Array.isArray(n) ? "array" : typeof n;
  zn.required(t, n, l, a, r, i), o(a);
}, ZC = function(t, n, o, l, r) {
  var a = t.type, i = [], s = t.required || !t.required && l.hasOwnProperty(t.field);
  if (s) {
    if (il(n, a) && !t.required)
      return o();
    zn.required(t, n, l, i, r, a), il(n, a) || zn.type(t, n, l, i, r);
  }
  o(i);
}, Nye = function(t, n, o, l, r) {
  var a = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
  if (i) {
    if (il(n) && !t.required)
      return o();
    zn.required(t, n, l, a, r);
  }
  o(a);
}, kv = {
  string: bye,
  method: yye,
  number: Sye,
  boolean: Cye,
  regexp: wye,
  integer: $ye,
  float: xye,
  array: Eye,
  object: Oye,
  enum: Iye,
  pattern: Tye,
  date: Pye,
  url: ZC,
  hex: ZC,
  email: ZC,
  required: kye,
  any: Nye
};
function $x() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var t = JSON.parse(JSON.stringify(this));
      return t.clone = this.clone, t;
    }
  };
}
var xx = $x(), Op = /* @__PURE__ */ function() {
  function e(n) {
    this.rules = null, this._messages = xx, this.define(n);
  }
  var t = e.prototype;
  return t.define = function(o) {
    var l = this;
    if (!o)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof o != "object" || Array.isArray(o))
      throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(o).forEach(function(r) {
      var a = o[r];
      l.rules[r] = Array.isArray(a) ? a : [a];
    });
  }, t.messages = function(o) {
    return o && (this._messages = yN($x(), o)), this._messages;
  }, t.validate = function(o, l, r) {
    var a = this;
    l === void 0 && (l = {}), r === void 0 && (r = function() {
    });
    var i = o, s = l, c = r;
    if (typeof s == "function" && (c = s, s = {}), !this.rules || Object.keys(this.rules).length === 0)
      return c && c(null, i), Promise.resolve(i);
    function u(v) {
      var h = [], g = {};
      function y(C) {
        if (Array.isArray(C)) {
          var w;
          h = (w = h).concat.apply(w, C);
        } else
          h.push(C);
      }
      for (var b = 0; b < v.length; b++)
        y(v[b]);
      h.length ? (g = wx(h), c(h, g)) : c(null, i);
    }
    if (s.messages) {
      var d = this.messages();
      d === xx && (d = $x()), yN(d, s.messages), s.messages = d;
    } else
      s.messages = this.messages();
    var f = {}, p = s.keys || Object.keys(this.rules);
    p.forEach(function(v) {
      var h = a.rules[v], g = i[v];
      h.forEach(function(y) {
        var b = y;
        typeof b.transform == "function" && (i === o && (i = fu({}, i)), g = i[v] = b.transform(g)), typeof b == "function" ? b = {
          validator: b
        } : b = fu({}, b), b.validator = a.getValidationMethod(b), b.validator && (b.field = v, b.fullField = b.fullField || v, b.type = a.getType(b), f[v] = f[v] || [], f[v].push({
          rule: b,
          value: g,
          source: i,
          field: v
        }));
      });
    });
    var m = {};
    return cye(f, s, function(v, h) {
      var g = v.rule, y = (g.type === "object" || g.type === "array") && (typeof g.fields == "object" || typeof g.defaultField == "object");
      y = y && (g.required || !g.required && v.value), g.field = v.field;
      function b(x, E) {
        return fu({}, E, {
          fullField: g.fullField + "." + x,
          fullFields: g.fullFields ? [].concat(g.fullFields, [x]) : [x]
        });
      }
      function C(x) {
        x === void 0 && (x = []);
        var E = Array.isArray(x) ? x : [x];
        !s.suppressWarning && E.length && e.warning("async-validator:", E), E.length && g.message !== void 0 && (E = [].concat(g.message));
        var I = E.map(bN(g, i));
        if (s.first && I.length)
          return m[g.field] = 1, h(I);
        if (!y)
          h(I);
        else {
          if (g.required && !v.value)
            return g.message !== void 0 ? I = [].concat(g.message).map(bN(g, i)) : s.error && (I = [s.error(g, Mr(s.messages.required, g.field))]), h(I);
          var T = {};
          g.defaultField && Object.keys(v.value).map(function(N) {
            T[N] = g.defaultField;
          }), T = fu({}, T, v.rule.fields);
          var P = {};
          Object.keys(T).forEach(function(N) {
            var R = T[N], z = Array.isArray(R) ? R : [R];
            P[N] = z.map(b.bind(null, N));
          });
          var k = new e(P);
          k.messages(s.messages), v.rule.options && (v.rule.options.messages = s.messages, v.rule.options.error = s.error), k.validate(v.value, v.rule.options || s, function(N) {
            var R = [];
            I && I.length && R.push.apply(R, I), N && N.length && R.push.apply(R, N), h(R.length ? R : null);
          });
        }
      }
      var w;
      if (g.asyncValidator)
        w = g.asyncValidator(g, v.value, C, v.source, s);
      else if (g.validator) {
        try {
          w = g.validator(g, v.value, C, v.source, s);
        } catch (x) {
          console.error == null || console.error(x), s.suppressValidatorError || setTimeout(function() {
            throw x;
          }, 0), C(x.message);
        }
        w === !0 ? C() : w === !1 ? C(typeof g.message == "function" ? g.message(g.fullField || g.field) : g.message || (g.fullField || g.field) + " fails") : w instanceof Array ? C(w) : w instanceof Error && C(w.message);
      }
      w && w.then && w.then(function() {
        return C();
      }, function(x) {
        return C(x);
      });
    }, function(v) {
      u(v);
    }, i);
  }, t.getType = function(o) {
    if (o.type === void 0 && o.pattern instanceof RegExp && (o.type = "pattern"), typeof o.validator != "function" && o.type && !kv.hasOwnProperty(o.type))
      throw new Error(Mr("Unknown rule type %s", o.type));
    return o.type || "string";
  }, t.getValidationMethod = function(o) {
    if (typeof o.validator == "function")
      return o.validator;
    var l = Object.keys(o), r = l.indexOf("message");
    return r !== -1 && l.splice(r, 1), l.length === 1 && l[0] === "required" ? kv.required : kv[this.getType(o)] || void 0;
  }, e;
}();
Op.register = function(t, n) {
  if (typeof n != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  kv[t] = n;
};
Op.warning = j9;
Op.messages = xx;
Op.validators = kv;
const Mye = [
  "",
  "error",
  "validating",
  "success"
], Aye = Xe({
  label: String,
  labelWidth: {
    type: [String, Number]
  },
  labelPosition: {
    type: String,
    values: ["left", "right", "top", ""],
    default: ""
  },
  prop: {
    type: ye([String, Array])
  },
  required: {
    type: Boolean,
    default: void 0
  },
  rules: {
    type: ye([Object, Array])
  },
  error: String,
  validateStatus: {
    type: String,
    values: Mye
  },
  for: String,
  inlineMessage: {
    type: Boolean,
    default: void 0
  },
  showMessage: {
    type: Boolean,
    default: !0
  },
  size: {
    type: String,
    values: ki
  }
}), CN = "ElLabelWrap";
var Rye = /* @__PURE__ */ le({
  name: CN,
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },
  setup(e, {
    slots: t
  }) {
    const n = ze(id, void 0), o = ze($i);
    o || no(CN, "usage: <el-form-item><label-wrap /></el-form-item>");
    const l = Ve("form"), r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H(0), i = () => {
      var u;
      if ((u = r.value) != null && u.firstElementChild) {
        const d = window.getComputedStyle(r.value.firstElementChild).width;
        return Math.ceil(Number.parseFloat(d));
      } else
        return 0;
    }, s = (u = "update") => {
      Ke(() => {
        t.default && e.isAutoWidth && (u === "update" ? a.value = i() : u === "remove" && (n == null || n.deregisterLabelWidth(a.value)));
      });
    }, c = () => s("update");
    return nt(() => {
      c();
    }), yt(() => {
      s("remove");
    }), $o(() => c()), pe(a, (u, d) => {
      e.updateAll && (n == null || n.registerLabelWidth(u, d));
    }), Xn(O(() => {
      var u, d;
      return (d = (u = r.value) == null ? void 0 : u.firstElementChild) != null ? d : null;
    }), c), () => {
      var u, d;
      if (!t)
        return null;
      const {
        isAutoWidth: f
      } = e;
      if (f) {
        const p = n == null ? void 0 : n.autoLabelWidth, m = o == null ? void 0 : o.hasLabel, v = {};
        if (m && p && p !== "auto") {
          const h = Math.max(0, Number.parseInt(p, 10) - a.value), y = (o.labelPosition || n.labelPosition) === "left" ? "marginRight" : "marginLeft";
          h && (v[y] = `${h}px`);
        }
        return $("div", {
          ref: r,
          class: [l.be("item", "label-wrap")],
          style: v
        }, [(u = t.default) == null ? void 0 : u.call(t)]);
      } else
        return $(Ge, {
          ref: r
        }, [(d = t.default) == null ? void 0 : d.call(t)]);
    };
  }
});
const Dye = ["role", "aria-labelledby"], Lye = /* @__PURE__ */ le({
  name: "ElFormItem",
  __name: "form-item",
  props: Aye,
  setup(e, { expose: t }) {
    const n = e, o = So(), l = ze(id, void 0), r = ze($i, void 0), a = Mo(void 0, { formItem: !1 }), i = Ve("form-item"), s = ml().value, c = /* @__PURE__ */ H([]), u = /* @__PURE__ */ H(""), d = Qae(u, 100), f = /* @__PURE__ */ H(""), p = /* @__PURE__ */ H();
    let m, v = !1;
    const h = O(
      () => n.labelPosition || (l == null ? void 0 : l.labelPosition)
    ), g = O(() => {
      var oe;
      return h.value === "top" ? {} : { width: ao((oe = n.labelWidth) != null ? oe : l == null ? void 0 : l.labelWidth) };
    }), y = O(() => {
      var oe;
      if (h.value === "top" || l != null && l.inline)
        return {};
      if (!n.label && !n.labelWidth && P)
        return {};
      const q = ao((oe = n.labelWidth) != null ? oe : l == null ? void 0 : l.labelWidth);
      return !n.label && !o.label ? { marginLeft: q } : {};
    }), b = O(() => [
      i.b(),
      i.m(a.value),
      i.is("error", u.value === "error"),
      i.is("validating", u.value === "validating"),
      i.is("success", u.value === "success"),
      i.is("required", D.value || n.required),
      i.is("no-asterisk", l == null ? void 0 : l.hideRequiredAsterisk),
      (l == null ? void 0 : l.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
      {
        [i.m("feedback")]: l == null ? void 0 : l.statusIcon,
        [i.m(`label-${h.value}`)]: h.value
      }
    ]), C = O(
      () => Tn(n.inlineMessage) ? n.inlineMessage : (l == null ? void 0 : l.inlineMessage) || !1
    ), w = O(() => [
      i.e("error"),
      { [i.em("error", "inline")]: C.value }
    ]), x = O(() => n.prop ? We(n.prop) ? n.prop.join(".") : n.prop : ""), E = O(() => !!(n.label || o.label)), I = O(() => {
      var oe;
      return (oe = n.for) != null ? oe : c.value.length === 1 ? c.value[0] : void 0;
    }), T = O(() => !I.value && E.value), P = !!r, k = O(() => {
      const oe = l == null ? void 0 : l.model;
      if (!(!oe || !n.prop))
        return ff(oe, n.prop).value;
    }), N = O(() => {
      const { required: oe } = n, q = [];
      n.rules && q.push(...ll(n.rules));
      const K = l == null ? void 0 : l.rules;
      if (K && n.prop) {
        const se = ff(
          K,
          n.prop
        ).value;
        se && q.push(...ll(se));
      }
      if (oe !== void 0) {
        const se = q.map((Z, ee) => [Z, ee]).filter(([Z]) => "required" in Z);
        if (se.length > 0)
          for (const [Z, ee] of se)
            Z.required !== oe && (q[ee] = vt(Be({}, Z), { required: oe }));
        else
          q.push({ required: oe });
      }
      return q;
    }), R = O(() => N.value.length > 0), z = (oe) => N.value.filter((K) => !K.trigger || !oe ? !0 : We(K.trigger) ? K.trigger.includes(oe) : K.trigger === oe).map((Z) => {
      var ee = Z, { trigger: K } = ee, se = Hr(ee, ["trigger"]);
      return se;
    }), D = O(
      () => N.value.some((oe) => oe.required)
    ), F = O(
      () => {
        var oe;
        return d.value === "error" && n.showMessage && ((oe = l == null ? void 0 : l.showMessage) != null ? oe : !0);
      }
    ), M = O(
      () => `${n.label || ""}${(l == null ? void 0 : l.labelSuffix) || ""}`
    ), A = (oe) => {
      u.value = oe;
    }, L = (oe) => {
      var q, K;
      const { errors: se, fields: Z } = oe;
      (!se || !Z) && console.error(oe), A("error"), f.value = se ? (K = (q = se == null ? void 0 : se[0]) == null ? void 0 : q.message) != null ? K : `${n.prop} is required` : "", l == null || l.emit("validate", n.prop, !1, f.value);
    }, B = () => {
      A("success"), l == null || l.emit("validate", n.prop, !0, "");
    }, V = (oe) => Rt(this, null, function* () {
      const q = x.value;
      return new Op({
        [q]: oe
      }).validate({ [q]: k.value }, { firstFields: !0 }).then(() => (B(), !0)).catch((se) => (L(se), Promise.reject(se)));
    }), j = (oe, q) => Rt(this, null, function* () {
      if (v || !n.prop)
        return !1;
      const K = it(q);
      if (!R.value)
        return q == null || q(!1), !1;
      const se = z(oe);
      return se.length === 0 ? (q == null || q(!0), !0) : (A("validating"), V(se).then(() => (q == null || q(!0), !0)).catch((Z) => {
        const { fields: ee } = Z;
        return q == null || q(!1, ee), K ? !1 : Promise.reject(ee);
      }));
    }), W = () => {
      A(""), f.value = "", v = !1;
    }, Y = () => Rt(this, null, function* () {
      const oe = l == null ? void 0 : l.model;
      if (!oe || !n.prop)
        return;
      const q = ff(oe, n.prop);
      v = !0, q.value = NC(m), yield Ke(), W(), v = !1;
    }), U = (oe) => {
      c.value.includes(oe) || c.value.push(oe);
    }, te = (oe) => {
      c.value = c.value.filter((q) => q !== oe);
    }, J = (oe) => {
      m = NC(oe);
    };
    pe(
      () => n.error,
      (oe) => {
        f.value = oe || "", A(oe ? "error" : "");
      },
      { immediate: !0 }
    ), pe(
      () => n.validateStatus,
      (oe) => A(oe || "")
    );
    const re = /* @__PURE__ */ kt(vt(Be({}, /* @__PURE__ */ to(n)), {
      $el: p,
      size: a,
      validateMessage: f,
      validateState: u,
      labelId: s,
      inputIds: c,
      isGroup: T,
      hasLabel: E,
      fieldValue: k,
      addInputId: U,
      removeInputId: te,
      resetField: Y,
      clearValidate: W,
      validate: j,
      propString: x,
      setInitialValue: J
    }));
    return at($i, re), nt(() => {
      n.prop && (l == null || l.addField(re), m = NC(k.value));
    }), yt(() => {
      l == null || l.removeField(re);
    }), t({
      size: a,
      validateMessage: f,
      validateState: u,
      validate: j,
      clearValidate: W,
      resetField: Y,
      setInitialValue: J
    }), (oe, q) => {
      var K;
      return G(), ue("div", {
        ref_key: "formItemRef",
        ref: p,
        class: X(b.value),
        role: T.value ? "group" : void 0,
        "aria-labelledby": T.value ? S(s) : void 0
      }, [
        $(S(Rye), {
          "is-auto-width": g.value.width === "auto",
          "update-all": ((K = S(l)) == null ? void 0 : K.labelWidth) === "auto"
        }, {
          default: Ee(() => [
            oe.label || oe.$slots.label ? (G(), Me(Ht(I.value ? "label" : "div"), {
              key: 0,
              id: S(s),
              for: I.value,
              class: X(S(i).e("label")),
              style: gt(g.value)
            }, {
              default: Ee(() => [
                Oe(oe.$slots, "label", { label: M.value }, () => [
                  Ft(
                    qe(M.value),
                    1
                  )
                ])
              ]),
              _: 3
            }, 8, ["id", "for", "class", "style"])) : Ie("v-if", !0)
          ]),
          _: 3
        }, 8, ["is-auto-width", "update-all"]),
        ve(
          "div",
          {
            class: X(S(i).e("content")),
            style: gt(y.value)
          },
          [
            Oe(oe.$slots, "default"),
            $(mp, {
              name: `${S(i).namespace.value}-zoom-in-top`
            }, {
              default: Ee(() => [
                F.value ? Oe(oe.$slots, "error", {
                  key: 0,
                  error: f.value
                }, () => [
                  ve(
                    "div",
                    {
                      class: X(w.value)
                    },
                    qe(f.value),
                    3
                  )
                ]) : Ie("v-if", !0)
              ]),
              _: 3
            }, 8, ["name"])
          ],
          6
        )
      ], 10, Dye);
    };
  }
});
var K9 = /* @__PURE__ */ Je(Lye, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/form/src/form-item.vue"]]);
const Bye = Dt(tye, {
  FormItem: K9
}), Fye = oo(K9), Vye = Xe({
  urlList: {
    type: ye(Array),
    default: () => lo([])
  },
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  hideOnClickModal: Boolean,
  teleported: Boolean,
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  scale: {
    type: Number,
    default: 1
  },
  minScale: {
    type: Number,
    default: 0.2
  },
  maxScale: {
    type: Number,
    default: 7
  },
  showProgress: Boolean,
  crossorigin: {
    type: ye(String)
  }
}), zye = {
  close: () => !0,
  error: (e) => e instanceof Event,
  switch: (e) => mt(e),
  rotate: (e) => mt(e)
}, Hye = ["src", "crossorigin"], jye = /* @__PURE__ */ le({
  name: "ElImageViewer",
  __name: "image-viewer",
  props: Vye,
  emits: zye,
  setup(e, { expose: t, emit: n }) {
    var o;
    const l = {
      CONTAIN: {
        name: "contain",
        icon: wa(ase)
      },
      ORIGINAL: {
        name: "original",
        icon: wa(Ose)
      }
    }, r = e, a = n;
    let i;
    const { t: s } = an(), c = Ve("image-viewer"), { nextZIndex: u } = ah(), d = /* @__PURE__ */ H(), f = /* @__PURE__ */ H(), p = kE(), m = O(() => {
      const { scale: q, minScale: K, maxScale: se } = r;
      return a7(q, K, se);
    }), v = /* @__PURE__ */ H(!0), h = /* @__PURE__ */ H(!1), g = /* @__PURE__ */ H(!1), y = /* @__PURE__ */ H(r.initialIndex), b = /* @__PURE__ */ Ce(l.CONTAIN), C = /* @__PURE__ */ H({
      scale: m.value,
      deg: 0,
      offsetX: 0,
      offsetY: 0,
      enableTransition: !1
    }), w = /* @__PURE__ */ H((o = r.zIndex) != null ? o : u());
    U1(g, { ns: c });
    const x = O(() => {
      const { urlList: q } = r;
      return q.length <= 1;
    }), E = O(() => y.value === 0), I = O(() => y.value === r.urlList.length - 1), T = O(() => r.urlList[y.value]), P = O(() => [
      c.e("btn"),
      c.e("prev"),
      c.is("disabled", !r.infinite && E.value)
    ]), k = O(() => [
      c.e("btn"),
      c.e("next"),
      c.is("disabled", !r.infinite && I.value)
    ]), N = O(() => {
      const { scale: q, deg: K, offsetX: se, offsetY: Z, enableTransition: ee } = C.value;
      let fe = se / q, me = Z / q;
      const ge = K * Math.PI / 180, he = Math.cos(ge), $e = Math.sin(ge);
      fe = fe * he + me * $e, me = me * he - se / q * $e;
      const ne = {
        transform: `scale(${q}) rotate(${K}deg) translate(${fe}px, ${me}px)`,
        transition: ee ? "transform .3s" : ""
      };
      return b.value.name === l.CONTAIN.name && (ne.maxWidth = ne.maxHeight = "100%"), ne;
    }), R = O(
      () => `${y.value + 1} / ${r.urlList.length}`
    );
    function z() {
      F(), i == null || i(), g.value = !1, a("close");
    }
    function D() {
      const q = Qs((se) => {
        switch (Nn(se)) {
          case Ye.esc:
            r.closeOnPressEscape && z();
            break;
          case Ye.space:
            j();
            break;
          case Ye.left:
            Y();
            break;
          case Ye.up:
            te("zoomIn");
            break;
          case Ye.right:
            U();
            break;
          case Ye.down:
            te("zoomOut");
            break;
        }
      }), K = Qs((se) => {
        const Z = se.deltaY || se.deltaX;
        te(Z < 0 ? "zoomIn" : "zoomOut", {
          zoomRate: r.zoomRate,
          enableTransition: !1
        });
      });
      p.run(() => {
        wn(document, "keydown", q), wn(d, "wheel", K);
      });
    }
    function F() {
      p.stop();
    }
    function M() {
      v.value = !1;
    }
    function A(q) {
      h.value = !0, v.value = !1, a("error", q), q.target.alt = s("el.image.error");
    }
    function L(q) {
      if (v.value || q.button !== 0 || !d.value)
        return;
      C.value.enableTransition = !1;
      const { offsetX: K, offsetY: se } = C.value, Z = q.pageX, ee = q.pageY, fe = Qs((he) => {
        C.value = vt(Be({}, C.value), {
          offsetX: K + he.pageX - Z,
          offsetY: se + he.pageY - ee
        });
      }), me = wn(document, "mousemove", fe), ge = wn(document, "mouseup", () => {
        me(), ge();
      });
      q.preventDefault();
    }
    function B(q) {
      if (v.value || !d.value || q.touches.length !== 1)
        return;
      C.value.enableTransition = !1;
      const { offsetX: K, offsetY: se } = C.value, { pageX: Z, pageY: ee } = q.touches[0], fe = Qs((he) => {
        const $e = he.touches[0];
        C.value = vt(Be({}, C.value), {
          offsetX: K + $e.pageX - Z,
          offsetY: se + $e.pageY - ee
        });
      }), me = wn(document, "touchmove", fe), ge = wn(document, "touchend", () => {
        me(), ge();
      });
      q.preventDefault();
    }
    function V() {
      C.value = {
        scale: m.value,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: !1
      };
    }
    function j() {
      if (v.value || h.value)
        return;
      const q = im(l), K = Object.values(l), se = b.value.name, ee = (K.findIndex((fe) => fe.name === se) + 1) % q.length;
      b.value = l[q[ee]], V();
    }
    function W(q) {
      h.value = !1;
      const K = r.urlList.length;
      y.value = (q + K) % K;
    }
    function Y() {
      E.value && !r.infinite || W(y.value - 1);
    }
    function U() {
      I.value && !r.infinite || W(y.value + 1);
    }
    function te(q, K = {}) {
      if (v.value || h.value)
        return;
      const { minScale: se, maxScale: Z } = r, { zoomRate: ee, rotateDeg: fe, enableTransition: me } = Be({
        zoomRate: r.zoomRate,
        rotateDeg: 90,
        enableTransition: !0
      }, K);
      switch (q) {
        case "zoomOut":
          C.value.scale > se && (C.value.scale = Number.parseFloat(
            (C.value.scale / ee).toFixed(3)
          ));
          break;
        case "zoomIn":
          C.value.scale < Z && (C.value.scale = Number.parseFloat(
            (C.value.scale * ee).toFixed(3)
          ));
          break;
        case "clockwise":
          C.value.deg += fe, a("rotate", C.value.deg);
          break;
        case "anticlockwise":
          C.value.deg -= fe, a("rotate", C.value.deg);
          break;
      }
      C.value.enableTransition = me;
    }
    function J(q) {
      var K;
      ((K = q.detail) == null ? void 0 : K.focusReason) === "pointer" && q.preventDefault();
    }
    function re() {
      r.closeOnPressEscape && z();
    }
    function oe(q) {
      if (q.ctrlKey) {
        if (q.deltaY < 0)
          return q.preventDefault(), !1;
        if (q.deltaY > 0)
          return q.preventDefault(), !1;
      }
    }
    return pe(
      () => m.value,
      (q) => {
        C.value.scale = q;
      }
    ), pe(T, () => {
      Ke(() => {
        const q = f.value;
        q != null && q.complete || (v.value = !0);
      });
    }), pe(y, (q) => {
      V(), a("switch", q);
    }), nt(() => {
      g.value = !0, D(), i = wn("wheel", oe, {
        passive: !1
      });
    }), t({
      setActiveItem: W
    }), (q, K) => (G(), Me(S($p), {
      to: "body",
      disabled: !q.teleported
    }, {
      default: Ee(() => [
        $(Vn, {
          name: "viewer-fade",
          appear: ""
        }, {
          default: Ee(() => [
            ve(
              "div",
              {
                ref_key: "wrapper",
                ref: d,
                tabindex: -1,
                class: X(S(c).e("wrapper")),
                style: gt({ zIndex: w.value })
              },
              [
                $(S(xp), {
                  loop: "",
                  trapped: "",
                  "focus-trap-el": d.value,
                  "focus-start-el": "container",
                  onFocusoutPrevented: J,
                  onReleaseRequested: re
                }, {
                  default: Ee(() => [
                    ve(
                      "div",
                      {
                        class: X(S(c).e("mask")),
                        onClick: K[0] || (K[0] = Et((se) => q.hideOnClickModal && z(), ["self"]))
                      },
                      null,
                      2
                    ),
                    Ie(" CLOSE "),
                    ve(
                      "span",
                      {
                        class: X([S(c).e("btn"), S(c).e("close")]),
                        onClick: z
                      },
                      [
                        $(S(ut), null, {
                          default: Ee(() => [
                            $(S(aa))
                          ]),
                          _: 1
                        })
                      ],
                      2
                    ),
                    Ie(" ARROW "),
                    x.value ? Ie("v-if", !0) : (G(), ue(
                      Ge,
                      { key: 0 },
                      [
                        ve(
                          "span",
                          {
                            class: X(P.value),
                            onClick: Y
                          },
                          [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(ms))
                              ]),
                              _: 1
                            })
                          ],
                          2
                        ),
                        ve(
                          "span",
                          {
                            class: X(k.value),
                            onClick: U
                          },
                          [
                            $(S(ut), null, {
                              default: Ee(() => [
                                $(S(Rl))
                              ]),
                              _: 1
                            })
                          ],
                          2
                        )
                      ],
                      64
                    )),
                    q.$slots.progress || q.showProgress ? (G(), ue(
                      "div",
                      {
                        key: 1,
                        class: X([S(c).e("btn"), S(c).e("progress")])
                      },
                      [
                        Oe(q.$slots, "progress", {
                          activeIndex: y.value,
                          total: q.urlList.length
                        }, () => [
                          Ft(
                            qe(R.value),
                            1
                          )
                        ])
                      ],
                      2
                    )) : Ie("v-if", !0),
                    Ie(" ACTIONS "),
                    ve(
                      "div",
                      {
                        class: X([S(c).e("btn"), S(c).e("actions")])
                      },
                      [
                        ve(
                          "div",
                          {
                            class: X(S(c).e("actions__inner"))
                          },
                          [
                            Oe(q.$slots, "toolbar", {
                              actions: te,
                              prev: Y,
                              next: U,
                              reset: j,
                              activeIndex: y.value,
                              setActiveItem: W
                            }, () => [
                              $(S(ut), {
                                onClick: K[1] || (K[1] = (se) => te("zoomOut"))
                              }, {
                                default: Ee(() => [
                                  $(S(Hse))
                                ]),
                                _: 1
                              }),
                              $(S(ut), {
                                onClick: K[2] || (K[2] = (se) => te("zoomIn"))
                              }, {
                                default: Ee(() => [
                                  $(S(_7))
                                ]),
                                _: 1
                              }),
                              ve(
                                "i",
                                {
                                  class: X(S(c).e("actions__divider"))
                                },
                                null,
                                2
                              ),
                              $(S(ut), { onClick: j }, {
                                default: Ee(() => [
                                  (G(), Me(Ht(b.value.icon)))
                                ]),
                                _: 1
                              }),
                              ve(
                                "i",
                                {
                                  class: X(S(c).e("actions__divider"))
                                },
                                null,
                                2
                              ),
                              $(S(ut), {
                                onClick: K[3] || (K[3] = (se) => te("anticlockwise"))
                              }, {
                                default: Ee(() => [
                                  $(S(wse))
                                ]),
                                _: 1
                              }),
                              $(S(ut), {
                                onClick: K[4] || (K[4] = (se) => te("clockwise"))
                              }, {
                                default: Ee(() => [
                                  $(S(xse))
                                ]),
                                _: 1
                              })
                            ])
                          ],
                          2
                        )
                      ],
                      2
                    ),
                    Ie(" CANVAS "),
                    ve(
                      "div",
                      {
                        class: X(S(c).e("canvas"))
                      },
                      [
                        h.value && q.$slots["viewer-error"] ? Oe(q.$slots, "viewer-error", {
                          key: 0,
                          activeIndex: y.value,
                          src: T.value
                        }) : (G(), ue("img", {
                          ref_key: "imgRef",
                          ref: f,
                          key: T.value,
                          src: T.value,
                          style: gt(N.value),
                          class: X(S(c).e("img")),
                          crossorigin: q.crossorigin,
                          onLoad: M,
                          onError: A,
                          onMousedown: L,
                          onTouchstart: B
                        }, null, 46, Hye))
                      ],
                      2
                    ),
                    Oe(q.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["focus-trap-el"])
              ],
              6
            )
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["disabled"]));
  }
});
var Wye = /* @__PURE__ */ Je(jye, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image-viewer/src/image-viewer.vue"]]);
const U9 = Dt(Wye), Kye = Xe({
  hideOnClickModal: Boolean,
  src: {
    type: String,
    default: ""
  },
  fit: {
    type: String,
    values: ["", "contain", "cover", "fill", "none", "scale-down"],
    default: ""
  },
  loading: {
    type: String,
    values: ["eager", "lazy"]
  },
  lazy: Boolean,
  scrollContainer: {
    type: ye([String, Object])
  },
  previewSrcList: {
    type: ye(Array),
    default: () => lo([])
  },
  previewTeleported: Boolean,
  zIndex: {
    type: Number
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  zoomRate: {
    type: Number,
    default: 1.2
  },
  scale: {
    type: Number,
    default: 1
  },
  minScale: {
    type: Number,
    default: 0.2
  },
  maxScale: {
    type: Number,
    default: 7
  },
  showProgress: Boolean,
  crossorigin: {
    type: ye(String)
  }
}), Uye = {
  load: (e) => e instanceof Event,
  error: (e) => e instanceof Event,
  switch: (e) => mt(e),
  close: () => !0,
  show: () => !0
}, Gye = ["src", "loading", "crossorigin"], Yye = { key: 0 }, Xye = /* @__PURE__ */ le({
  name: "ElImage",
  inheritAttrs: !1,
  __name: "image",
  props: Kye,
  emits: Uye,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, { t: r } = an(), a = Ve("image"), i = Ti(), s = O(() => Hf(
      Object.entries(i).filter(
        ([M]) => /^(data-|on[A-Z])/i.test(M) || ["id", "style"].includes(M)
      )
    )), c = L1({
      excludeListeners: !0,
      excludeKeys: O(() => Object.keys(s.value))
    }), u = /* @__PURE__ */ H(), d = /* @__PURE__ */ H(!1), f = /* @__PURE__ */ H(!0), p = /* @__PURE__ */ H(!1), m = /* @__PURE__ */ H(), v = /* @__PURE__ */ H(), h = Sn && "loading" in HTMLImageElement.prototype;
    let g;
    const y = O(() => [
      a.e("inner"),
      C.value && a.e("preview"),
      f.value && a.is("loading")
    ]), b = O(() => {
      const { fit: M } = o;
      return Sn && M ? { objectFit: M } : {};
    }), C = O(() => {
      const { previewSrcList: M } = o;
      return We(M) && M.length > 0;
    }), w = O(() => {
      const { previewSrcList: M, initialIndex: A } = o;
      let L = A;
      return A > M.length - 1 && (L = 0), L;
    }), x = O(() => o.loading === "eager" ? !1 : !h && o.loading === "lazy" || o.lazy), E = () => {
      Sn && (f.value = !0, d.value = !1, u.value = o.src);
    };
    function I(M) {
      f.value = !1, d.value = !1, l("load", M);
    }
    function T(M) {
      f.value = !1, d.value = !0, l("error", M);
    }
    function P(M) {
      M && (E(), R());
    }
    const k = s7(P, 200, !0);
    function N() {
      return Rt(this, null, function* () {
        var M;
        if (!Sn)
          return;
        yield Ke();
        const { scrollContainer: A } = o;
        if (tr(A))
          v.value = A;
        else if (rt(A) && A !== "")
          v.value = (M = document.querySelector(A)) != null ? M : void 0;
        else if (m.value) {
          const B = kO(m.value);
          v.value = oh(B) ? void 0 : B;
        }
        const { stop: L } = iie(
          m,
          ([B]) => {
            k(B.isIntersecting);
          },
          { root: v }
        );
        g = L;
      });
    }
    function R() {
      !Sn || !k || (g == null || g(), v.value = void 0, g = void 0);
    }
    function z() {
      C.value && (p.value = !0, l("show"));
    }
    function D() {
      p.value = !1, l("close");
    }
    function F(M) {
      l("switch", M);
    }
    return pe(
      () => o.src,
      () => {
        x.value ? (f.value = !0, d.value = !1, R(), N()) : E();
      }
    ), nt(() => {
      x.value ? N() : E();
    }), t({
      showPreview: z
    }), (M, A) => (G(), ue(
      "div",
      Ut({
        ref_key: "container",
        ref: m
      }, s.value, {
        class: [S(a).b(), M.$attrs.class]
      }),
      [
        d.value ? Oe(M.$slots, "error", { key: 0 }, () => [
          ve(
            "div",
            {
              class: X(S(a).e("error"))
            },
            qe(S(r)("el.image.error")),
            3
          )
        ]) : (G(), ue(
          Ge,
          { key: 1 },
          [
            u.value !== void 0 ? (G(), ue("img", Ut({ key: 0 }, S(c), {
              src: u.value,
              loading: M.loading,
              style: b.value,
              class: y.value,
              crossorigin: M.crossorigin,
              onClick: z,
              onLoad: I,
              onError: T
            }), null, 16, Gye)) : Ie("v-if", !0),
            f.value ? (G(), ue(
              "div",
              {
                key: 1,
                class: X(S(a).e("wrapper"))
              },
              [
                Oe(M.$slots, "placeholder", {}, () => [
                  ve(
                    "div",
                    {
                      class: X(S(a).e("placeholder"))
                    },
                    null,
                    2
                  )
                ])
              ],
              2
            )) : Ie("v-if", !0)
          ],
          64
        )),
        C.value ? (G(), ue(
          Ge,
          { key: 2 },
          [
            p.value ? (G(), Me(S(U9), {
              key: 0,
              "z-index": M.zIndex,
              "initial-index": w.value,
              infinite: M.infinite,
              "zoom-rate": M.zoomRate,
              "min-scale": M.minScale,
              "max-scale": M.maxScale,
              "show-progress": M.showProgress,
              "url-list": M.previewSrcList,
              scale: M.scale,
              crossorigin: M.crossorigin,
              "hide-on-click-modal": M.hideOnClickModal,
              teleported: M.previewTeleported,
              "close-on-press-escape": M.closeOnPressEscape,
              onClose: D,
              onSwitch: F
            }, or({
              toolbar: Ee((L) => [
                Oe(M.$slots, "toolbar", cs(us(L)))
              ]),
              default: Ee(() => [
                M.$slots.viewer ? (G(), ue("div", Yye, [
                  Oe(M.$slots, "viewer")
                ])) : Ie("v-if", !0)
              ]),
              _: 2
            }, [
              M.$slots.progress ? {
                name: "progress",
                fn: Ee((L) => [
                  Oe(M.$slots, "progress", cs(us(L)))
                ]),
                key: "0"
              } : void 0,
              M.$slots["viewer-error"] ? {
                name: "viewer-error",
                fn: Ee((L) => [
                  Oe(M.$slots, "viewer-error", cs(us(L)))
                ]),
                key: "1"
              } : void 0
            ]), 1032, ["z-index", "initial-index", "infinite", "zoom-rate", "min-scale", "max-scale", "show-progress", "url-list", "scale", "crossorigin", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : Ie("v-if", !0)
          ],
          64
        )) : Ie("v-if", !0)
      ],
      16
    ));
  }
});
var qye = /* @__PURE__ */ Je(Xye, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/image/src/image.vue"]]);
const Jye = Dt(qye), Zye = Xe(vt(Be({
  id: {
    type: String,
    default: void 0
  },
  step: {
    type: Number,
    default: 1
  },
  stepStrictly: Boolean,
  max: {
    type: Number,
    default: Number.MAX_SAFE_INTEGER
  },
  min: {
    type: Number,
    default: Number.MIN_SAFE_INTEGER
  },
  modelValue: {
    type: [Number, null]
  },
  readonly: Boolean,
  disabled: {
    type: Boolean,
    default: void 0
  },
  size: Bo,
  controls: {
    type: Boolean,
    default: !0
  },
  controlsPosition: {
    type: String,
    default: "",
    values: ["", "right"]
  },
  valueOnClear: {
    type: ye([String, Number, null]),
    validator: (e) => e === null || mt(e) || ["min", "max"].includes(e),
    default: null
  },
  name: String,
  placeholder: String,
  precision: {
    type: Number,
    validator: (e) => e >= 0 && e === Number.parseInt(`${e}`, 10)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}, zl(["ariaLabel"])), {
  inputmode: {
    type: ye(String),
    default: void 0
  },
  align: {
    type: ye(String),
    default: "center"
  },
  disabledScientific: Boolean
})), Qye = {
  [en]: (e, t) => t !== e,
  blur: (e) => e instanceof FocusEvent,
  focus: (e) => e instanceof FocusEvent,
  [Po]: (e) => mt(e) || wo(e),
  [It]: (e) => mt(e) || wo(e)
}, e1e = ["aria-label"], t1e = ["aria-label"], n1e = /* @__PURE__ */ le({
  name: "ElInputNumber",
  __name: "input-number",
  props: Zye,
  emits: Qye,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, { t: r } = an(), a = Ve("input-number"), i = /* @__PURE__ */ H(), s = /* @__PURE__ */ kt({
      currentValue: o.modelValue,
      userInput: null
    }), { formItem: c } = cl(), u = O(
      () => mt(o.modelValue) && o.modelValue <= o.min
    ), d = O(
      () => mt(o.modelValue) && o.modelValue >= o.max
    ), f = O(() => {
      const M = y(o.step);
      return fn(o.precision) ? Math.max(y(o.modelValue), M) : (M > o.precision && Gt(
        "InputNumber",
        "precision should not be less than the decimal places of step"
      ), o.precision);
    }), p = O(() => o.controls && o.controlsPosition === "right"), m = Mo(), v = io(), h = O(() => {
      if (s.userInput !== null)
        return s.userInput;
      let M = s.currentValue;
      if (wo(M))
        return "";
      if (mt(M)) {
        if (Number.isNaN(M))
          return "";
        fn(o.precision) || (M = M.toFixed(o.precision));
      }
      return M;
    }), g = (M, A) => {
      if (fn(A) && (A = f.value), A === 0)
        return Math.round(M);
      let L = String(M);
      const B = L.indexOf(".");
      if (B === -1 || !L.replace(".", "").split("")[B + A])
        return M;
      const W = L.length;
      return L.charAt(W - 1) === "5" && (L = `${L.slice(0, Math.max(0, W - 1))}6`), Number.parseFloat(Number(L).toFixed(A));
    }, y = (M) => {
      if (wo(M))
        return 0;
      const A = M.toString(), L = A.indexOf(".");
      let B = 0;
      return L !== -1 && (B = A.length - L - 1), B;
    }, b = (M, A = 1) => mt(M) ? M >= Number.MAX_SAFE_INTEGER && A === 1 ? (Gt(
      "InputNumber",
      "The value has reached the maximum safe integer limit."
    ), M) : M <= Number.MIN_SAFE_INTEGER && A === -1 ? (Gt(
      "InputNumber",
      "The value has reached the minimum safe integer limit."
    ), M) : g(M + o.step * A) : s.currentValue, C = (M) => {
      const A = Nn(M), L = K7(M);
      if (o.disabledScientific && ["e", "E"].includes(L)) {
        M.preventDefault();
        return;
      }
      switch (A) {
        case Ye.up: {
          M.preventDefault(), w();
          break;
        }
        case Ye.down: {
          M.preventDefault(), x();
          break;
        }
      }
    }, w = () => {
      if (o.readonly || v.value || d.value)
        return;
      const M = Number(h.value) || 0, A = b(M);
      I(A), l(Po, s.currentValue), D();
    }, x = () => {
      if (o.readonly || v.value || u.value)
        return;
      const M = Number(h.value) || 0, A = b(M, -1);
      I(A), l(Po, s.currentValue), D();
    }, E = (M, A) => {
      const { max: L, min: B, step: V, precision: j, stepStrictly: W, valueOnClear: Y } = o;
      L < B && no("InputNumber", "min should not be greater than max.");
      let U = Number(M);
      if (wo(M) || Number.isNaN(U))
        return null;
      if (M === "") {
        if (Y === null)
          return null;
        U = rt(Y) ? { min: B, max: L }[Y] : Y;
      }
      return W && (U = g(
        Math.round(g(U / V)) * V,
        j
      ), U !== M && A && l(It, U)), fn(j) || (U = g(U, j)), (U > L || U < B) && (U = U > L ? L : B, A && l(It, U)), U;
    }, I = (M, A = !0) => {
      var L;
      const B = s.currentValue, V = E(M);
      if (!A) {
        l(It, V);
        return;
      }
      s.userInput = null, !(B === V && M) && (l(It, V), B !== V && l(en, V, B), o.validateEvent && ((L = c == null ? void 0 : c.validate) == null || L.call(c, "change").catch((j) => Gt(j))), s.currentValue = V);
    }, T = (M) => {
      s.userInput = M;
      const A = M === "" ? null : Number(M);
      l(Po, A), I(A, !1);
    }, P = (M) => {
      const A = M !== "" ? Number(M) : "";
      (mt(A) && !Number.isNaN(A) || M === "") && I(A), D(), s.userInput = null;
    }, k = () => {
      var M, A;
      (A = (M = i.value) == null ? void 0 : M.focus) == null || A.call(M);
    }, N = () => {
      var M, A;
      (A = (M = i.value) == null ? void 0 : M.blur) == null || A.call(M);
    }, R = (M) => {
      l("focus", M);
    }, z = (M) => {
      var A, L;
      s.userInput = null, s.currentValue === null && ((A = i.value) != null && A.input) && (i.value.input.value = ""), l("blur", M), o.validateEvent && ((L = c == null ? void 0 : c.validate) == null || L.call(c, "blur").catch((B) => Gt(B)));
    }, D = () => {
      s.currentValue !== o.modelValue && (s.currentValue = o.modelValue);
    }, F = (M) => {
      document.activeElement === M.target && M.preventDefault();
    };
    return pe(
      () => o.modelValue,
      (M, A) => {
        const L = E(M, !0);
        s.userInput === null && L !== A && (s.currentValue = L);
      },
      { immediate: !0 }
    ), pe(
      () => o.precision,
      () => {
        s.currentValue = E(o.modelValue);
      }
    ), nt(() => {
      var M;
      const { min: A, max: L, modelValue: B } = o, V = (M = i.value) == null ? void 0 : M.input;
      if (V.setAttribute("role", "spinbutton"), Number.isFinite(L) ? V.setAttribute("aria-valuemax", String(L)) : V.removeAttribute("aria-valuemax"), Number.isFinite(A) ? V.setAttribute("aria-valuemin", String(A)) : V.removeAttribute("aria-valuemin"), V.setAttribute(
        "aria-valuenow",
        s.currentValue || s.currentValue === 0 ? String(s.currentValue) : ""
      ), V.setAttribute("aria-disabled", String(v.value)), !mt(B) && B != null) {
        let j = Number(B);
        Number.isNaN(j) && (j = null), l(It, j);
      }
      V.addEventListener("wheel", F, { passive: !1 });
    }), $o(() => {
      var M, A;
      const L = (M = i.value) == null ? void 0 : M.input;
      L == null || L.setAttribute("aria-valuenow", `${(A = s.currentValue) != null ? A : ""}`);
    }), t({
      focus: k,
      blur: N
    }), (M, A) => (G(), ue(
      "div",
      {
        class: X([
          S(a).b(),
          S(a).m(S(m)),
          S(a).is("disabled", S(v)),
          S(a).is("without-controls", !M.controls),
          S(a).is("controls-right", p.value),
          S(a).is(M.align, !!M.align)
        ]),
        onDragstart: A[0] || (A[0] = Et(() => {
        }, ["prevent"]))
      },
      [
        M.controls ? _t((G(), ue("span", {
          key: 0,
          role: "button",
          "aria-label": S(r)("el.inputNumber.decrease"),
          class: X([S(a).e("decrease"), S(a).is("disabled", u.value)]),
          onKeydown: uo(x, ["enter"])
        }, [
          Oe(M.$slots, "decrease-icon", {}, () => [
            $(S(ut), null, {
              default: Ee(() => [
                p.value ? (G(), Me(S(Ni), { key: 0 })) : (G(), Me(S(fse), { key: 1 }))
              ]),
              _: 1
            })
          ])
        ], 42, e1e)), [
          [S(L0), x]
        ]) : Ie("v-if", !0),
        M.controls ? _t((G(), ue("span", {
          key: 1,
          role: "button",
          "aria-label": S(r)("el.inputNumber.increase"),
          class: X([S(a).e("increase"), S(a).is("disabled", d.value)]),
          onKeydown: uo(w, ["enter"])
        }, [
          Oe(M.$slots, "increase-icon", {}, () => [
            $(S(ut), null, {
              default: Ee(() => [
                p.value ? (G(), Me(S(A1), { key: 0 })) : (G(), Me(S(E7), { key: 1 }))
              ]),
              _: 1
            })
          ])
        ], 42, t1e)), [
          [S(L0), w]
        ]) : Ie("v-if", !0),
        $(S(Nl), {
          id: M.id,
          ref_key: "input",
          ref: i,
          type: "number",
          step: M.step,
          "model-value": h.value,
          placeholder: M.placeholder,
          readonly: M.readonly,
          disabled: S(v),
          size: S(m),
          max: M.max,
          min: M.min,
          name: M.name,
          "aria-label": M.ariaLabel,
          "validate-event": !1,
          inputmode: M.inputmode,
          onKeydown: C,
          onBlur: z,
          onFocus: R,
          onInput: T,
          onChange: P
        }, or({
          _: 2
        }, [
          M.$slots.prefix ? {
            name: "prefix",
            fn: Ee(() => [
              Oe(M.$slots, "prefix")
            ]),
            key: "0"
          } : void 0,
          M.$slots.suffix ? {
            name: "suffix",
            fn: Ee(() => [
              Oe(M.$slots, "suffix")
            ]),
            key: "1"
          } : void 0
        ]), 1032, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "aria-label", "inputmode"])
      ],
      34
    ));
  }
});
var o1e = /* @__PURE__ */ Je(n1e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-number/src/input-number.vue"]]);
const G9 = Dt(o1e), l1e = Xe({
  modelValue: {
    type: ye(Array)
  },
  max: Number,
  tagType: vt(Be({}, gs.type), { default: "info" }),
  tagEffect: gs.effect,
  trigger: {
    type: ye(String),
    default: Ye.enter
  },
  draggable: Boolean,
  delimiter: {
    type: [String, RegExp],
    default: ""
  },
  size: Bo,
  clearable: Boolean,
  clearIcon: {
    type: Pn,
    default: Es
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  readonly: Boolean,
  autofocus: Boolean,
  id: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  maxlength: {
    type: [String, Number]
  },
  minlength: {
    type: [String, Number]
  },
  placeholder: String,
  autocomplete: {
    type: ye(String),
    default: "off"
  },
  saveOnBlur: {
    type: Boolean,
    default: !0
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  ariaLabel: String
}), r1e = {
  [It]: (e) => We(e) || fn(e),
  [en]: (e) => We(e) || fn(e),
  [Po]: (e) => rt(e),
  "add-tag": (e) => rt(e) || We(e),
  "remove-tag": (e, t) => rt(e) && mt(t),
  "drag-tag": (e, t, n) => mt(e) && mt(t) && rt(n),
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  clear: () => !0
};
function a1e({ props: e, emit: t, formItem: n }) {
  const o = io(), l = Mo(), r = /* @__PURE__ */ Ce(), a = /* @__PURE__ */ H(), i = /* @__PURE__ */ H(), s = O(() => ["small"].includes(l.value) ? "small" : "default"), c = O(() => {
    var D;
    return (D = e.modelValue) != null && D.length ? void 0 : e.placeholder;
  }), u = O(() => !(e.readonly || o.value)), d = O(() => {
    var D, F;
    return fn(e.max) ? !1 : ((F = (D = e.modelValue) == null ? void 0 : D.length) != null ? F : 0) >= e.max;
  }), f = O(() => {
    var D;
    return e.collapseTags ? (D = e.modelValue) == null ? void 0 : D.slice(0, e.maxCollapseTags) : e.modelValue;
  }), p = O(() => {
    var D;
    return e.collapseTags ? (D = e.modelValue) == null ? void 0 : D.slice(e.maxCollapseTags) : [];
  }), m = (D) => {
    var F;
    const M = [...(F = e.modelValue) != null ? F : [], ...ll(D)];
    t(It, M), t(en, M), t("add-tag", D), a.value = void 0;
  }, v = (D) => {
    var F, M;
    const A = D.split(e.delimiter).filter((L) => L && L !== D);
    if (e.max) {
      const L = e.max - ((M = (F = e.modelValue) == null ? void 0 : F.length) != null ? M : 0);
      A.splice(L);
    }
    return A.length === 1 ? A[0] : A;
  }, h = (D) => {
    if (d.value) {
      a.value = void 0;
      return;
    }
    if (!k.value) {
      if (e.delimiter && a.value) {
        const F = v(a.value);
        F.length && m(F);
      }
      t(Po, D.target.value);
    }
  }, g = (D) => {
    var F;
    if (k.value)
      return;
    switch (Nn(D)) {
      case e.trigger:
        D.preventDefault(), D.stopPropagation(), b();
        break;
      case Ye.numpadEnter:
        e.trigger === Ye.enter && (D.preventDefault(), D.stopPropagation(), b());
        break;
      case Ye.backspace:
        !a.value && ((F = e.modelValue) != null && F.length) && (D.preventDefault(), D.stopPropagation(), C(e.modelValue.length - 1));
        break;
    }
  }, y = (D) => {
    if (k.value || !P7())
      return;
    switch (Nn(D)) {
      case Ye.space:
        e.trigger === Ye.space && (D.preventDefault(), D.stopPropagation(), b());
        break;
    }
  }, b = () => {
    var D;
    const F = (D = a.value) == null ? void 0 : D.trim();
    !F || d.value || m(F);
  }, C = (D) => {
    var F;
    const M = ((F = e.modelValue) != null ? F : []).slice(), [A] = M.splice(D, 1);
    t(It, M), t(en, M), t("remove-tag", A, D);
  }, w = () => {
    a.value = void 0, t(It, void 0), t(en, void 0), t("clear");
  }, x = (D, F, M) => {
    var A;
    const L = ((A = e.modelValue) != null ? A : []).slice(), [B] = L.splice(D, 1), V = F > D && M === "before" ? -1 : F < D && M === "after" ? 1 : 0;
    L.splice(F + V, 0, B), t(It, L), t(en, L), t("drag-tag", D, F + V, B);
  }, E = () => {
    var D;
    (D = r.value) == null || D.focus();
  }, I = () => {
    var D;
    (D = r.value) == null || D.blur();
  }, { wrapperRef: T, isFocused: P } = Os(r, {
    disabled: o,
    beforeBlur(D) {
      var F;
      return (F = i.value) == null ? void 0 : F.isFocusInsideContent(D);
    },
    afterBlur() {
      var D;
      e.saveOnBlur ? b() : a.value = void 0, e.validateEvent && ((D = n == null ? void 0 : n.validate) == null || D.call(n, "blur").catch((F) => Gt(F)));
    }
  }), {
    isComposing: k,
    handleCompositionStart: N,
    handleCompositionUpdate: R,
    handleCompositionEnd: z
  } = fh({ afterComposition: h });
  return pe(
    () => e.modelValue,
    () => {
      var D;
      e.validateEvent && ((D = n == null ? void 0 : n.validate) == null || D.call(n, en).catch((F) => Gt(F)));
    }
  ), {
    inputRef: r,
    wrapperRef: T,
    tagTooltipRef: i,
    isFocused: P,
    isComposing: k,
    inputValue: a,
    size: l,
    tagSize: s,
    placeholder: c,
    closable: u,
    disabled: o,
    inputLimit: d,
    showTagList: f,
    collapseTagList: p,
    handleDragged: x,
    handleInput: h,
    handleKeydown: g,
    handleKeyup: y,
    handleAddTag: b,
    handleRemoveTag: C,
    handleClear: w,
    handleCompositionStart: N,
    handleCompositionUpdate: R,
    handleCompositionEnd: z,
    focus: E,
    blur: I
  };
}
function i1e() {
  const e = /* @__PURE__ */ H(!1);
  return {
    hovering: e,
    handleMouseEnter: () => {
      e.value = !0;
    },
    handleMouseLeave: () => {
      e.value = !1;
    }
  };
}
function s1e({
  wrapperRef: e,
  handleDragged: t,
  afterDragged: n
}) {
  const o = Ve("input-tag"), l = /* @__PURE__ */ Ce(), r = /* @__PURE__ */ H(!1);
  let a, i, s, c;
  function u(m) {
    return `.${o.e("inner")} .${o.namespace.value}-tag:nth-child(${m + 1})`;
  }
  function d(m, v) {
    a = v, i = e.value.querySelector(
      u(v)
    ), i && (i.style.opacity = "0.5"), m.dataTransfer.effectAllowed = "move";
  }
  function f(m, v) {
    if (s = v, m.preventDefault(), m.dataTransfer.dropEffect = "move", fn(a) || a === v) {
      r.value = !1;
      return;
    }
    const h = e.value.querySelector(u(v)).getBoundingClientRect(), g = a + 1 !== v, y = a - 1 !== v, b = m.clientX - h.left, C = g ? y ? 0.5 : 1 : -1, w = y ? g ? 0.5 : 0 : 1;
    b <= h.width * C ? c = "before" : b > h.width * w ? c = "after" : c = void 0;
    const x = e.value.querySelector(
      `.${o.e("inner")}`
    ), E = x.getBoundingClientRect(), I = Number.parseFloat(ts(x, "gap")) / 2, T = h.top - E.top;
    let P = -9999;
    if (c === "before")
      P = Math.max(
        h.left - E.left - I,
        Math.floor(-I / 2)
      );
    else if (c === "after") {
      const k = h.right - E.left;
      P = k + (E.width === k ? Math.floor(I / 2) : I);
    }
    C7(l.value, {
      top: `${T}px`,
      left: `${P}px`
    }), r.value = !!c;
  }
  function p(m) {
    m.preventDefault(), i && (i.style.opacity = ""), c && !fn(a) && !fn(s) && a !== s && t(a, s, c), r.value = !1, a = void 0, i = null, s = void 0, c = void 0, n == null || n();
  }
  return {
    dropIndicatorRef: l,
    showDropIndicator: r,
    handleDragStart: d,
    handleDragOver: f,
    handleDragEnd: p
  };
}
function c1e({
  props: e,
  isFocused: t,
  hovering: n,
  disabled: o,
  inputValue: l,
  size: r,
  validateState: a,
  validateIcon: i,
  needStatusIcon: s
}) {
  const c = Ti(), u = So(), d = Ve("input-tag"), f = Ve("input"), p = /* @__PURE__ */ H(), m = /* @__PURE__ */ H(), v = O(() => [
    d.b(),
    d.is("focused", t.value),
    d.is("hovering", n.value),
    d.is("disabled", o.value),
    d.m(r.value),
    d.e("wrapper"),
    c.class
  ]), h = O(() => [c.style]), g = O(() => {
    var T, P;
    return [
      d.e("inner"),
      d.is("draggable", e.draggable),
      d.is("left-space", !((T = e.modelValue) != null && T.length) && !u.prefix),
      d.is("right-space", !((P = e.modelValue) != null && P.length) && !b.value)
    ];
  }), y = O(() => {
    var T;
    return e.clearable && !o.value && !e.readonly && (((T = e.modelValue) == null ? void 0 : T.length) || l.value) && (t.value || n.value);
  }), b = O(() => u.suffix || y.value || a.value && i.value && s.value), C = /* @__PURE__ */ kt({
    innerWidth: 0,
    collapseItemWidth: 0
  }), w = () => {
    if (!m.value)
      return 0;
    const T = window.getComputedStyle(m.value);
    return Number.parseFloat(T.gap || "6px");
  }, x = () => {
    C.innerWidth = Number.parseFloat(
      window.getComputedStyle(m.value).width
    );
  }, E = () => {
    C.collapseItemWidth = p.value.getBoundingClientRect().width;
  }, I = O(() => {
    if (!e.collapseTags)
      return {};
    const T = w(), P = T + V1, k = p.value && e.maxCollapseTags === 1 ? C.innerWidth - C.collapseItemWidth - T - P : C.innerWidth - P;
    return { maxWidth: `${Math.max(k, 0)}px` };
  });
  return Xn(m, x), Xn(p, E), {
    ns: d,
    nsInput: f,
    containerKls: v,
    containerStyle: h,
    innerKls: g,
    showClear: y,
    showSuffix: b,
    tagStyle: I,
    collapseItemRef: p,
    innerRef: m
  };
}
const u1e = ["id", "minlength", "maxlength", "disabled", "readonly", "autocomplete", "tabindex", "placeholder", "autofocus", "ariaLabel"], d1e = ["textContent"], f1e = /* @__PURE__ */ le({
  name: "ElInputTag",
  inheritAttrs: !1,
  __name: "input-tag",
  props: l1e,
  emits: r1e,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = L1(), a = So(), { form: i, formItem: s } = cl(), { inputId: c } = zr(o, { formItemContext: s }), u = O(() => {
      var ne;
      return (ne = i == null ? void 0 : i.statusIcon) != null ? ne : !1;
    }), d = O(() => (s == null ? void 0 : s.validateState) || ""), f = O(() => d.value && D1[d.value]), {
      inputRef: p,
      wrapperRef: m,
      tagTooltipRef: v,
      isFocused: h,
      inputValue: g,
      size: y,
      tagSize: b,
      placeholder: C,
      closable: w,
      disabled: x,
      showTagList: E,
      collapseTagList: I,
      handleDragged: T,
      handleInput: P,
      handleKeydown: k,
      handleKeyup: N,
      handleRemoveTag: R,
      handleClear: z,
      handleCompositionStart: D,
      handleCompositionUpdate: F,
      handleCompositionEnd: M,
      focus: A,
      blur: L
    } = a1e({ props: o, emit: l, formItem: s }), { hovering: B, handleMouseEnter: V, handleMouseLeave: j } = i1e(), { calculatorRef: W, inputStyle: Y } = t_(), {
      dropIndicatorRef: U,
      showDropIndicator: te,
      handleDragStart: J,
      handleDragOver: re,
      handleDragEnd: oe
    } = s1e({ wrapperRef: m, handleDragged: T, afterDragged: A }), {
      ns: q,
      nsInput: K,
      containerKls: se,
      containerStyle: Z,
      innerKls: ee,
      showClear: fe,
      showSuffix: me,
      tagStyle: ge,
      collapseItemRef: he,
      innerRef: $e
    } = c1e({
      props: o,
      hovering: B,
      isFocused: h,
      inputValue: g,
      disabled: x,
      size: y,
      validateState: d,
      validateIcon: f,
      needStatusIcon: u
    });
    return t({
      focus: A,
      blur: L
    }), (ne, ae) => (G(), ue(
      "div",
      {
        ref_key: "wrapperRef",
        ref: m,
        class: X(S(se)),
        style: gt(S(Z)),
        onMouseenter: ae[8] || (ae[8] = (...ce) => S(V) && S(V)(...ce)),
        onMouseleave: ae[9] || (ae[9] = (...ce) => S(j) && S(j)(...ce))
      },
      [
        S(a).prefix ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(q).e("prefix"))
          },
          [
            Oe(ne.$slots, "prefix")
          ],
          2
        )) : Ie("v-if", !0),
        ve(
          "div",
          {
            ref_key: "innerRef",
            ref: $e,
            class: X(S(ee))
          },
          [
            (G(!0), ue(
              Ge,
              null,
              on(S(E), (ce, xe) => (G(), Me(S(fs), {
                key: xe,
                size: S(b),
                closable: S(w),
                type: ne.tagType,
                effect: ne.tagEffect,
                draggable: S(w) && ne.draggable,
                style: gt(S(ge)),
                "disable-transitions": "",
                onClose: (Te) => S(R)(xe),
                onDragstart: (Te) => S(J)(Te, xe),
                onDragover: (Te) => S(re)(Te, xe),
                onDragend: S(oe),
                onDrop: ae[0] || (ae[0] = Et(() => {
                }, ["stop"]))
              }, {
                default: Ee(() => [
                  Oe(ne.$slots, "tag", {
                    value: ce,
                    index: xe
                  }, () => [
                    Ft(
                      qe(ce),
                      1
                    )
                  ])
                ]),
                _: 2
              }, 1032, ["size", "closable", "type", "effect", "draggable", "style", "onClose", "onDragstart", "onDragover", "onDragend"]))),
              128
            )),
            ne.collapseTags && ne.modelValue && ne.modelValue.length > ne.maxCollapseTags ? (G(), Me(S(al), {
              key: 0,
              ref_key: "tagTooltipRef",
              ref: v,
              disabled: !ne.collapseTagsTooltip,
              "fallback-placements": ["bottom", "top", "right", "left"],
              effect: ne.tagEffect,
              placement: "bottom"
            }, {
              default: Ee(() => [
                ve(
                  "div",
                  {
                    ref_key: "collapseItemRef",
                    ref: he
                  },
                  [
                    $(S(fs), {
                      closable: !1,
                      size: S(b),
                      type: ne.tagType,
                      effect: ne.tagEffect,
                      "disable-transitions": ""
                    }, {
                      default: Ee(() => [
                        Ft(
                          " + " + qe(ne.modelValue.length - ne.maxCollapseTags),
                          1
                        )
                      ]),
                      _: 1
                    }, 8, ["size", "type", "effect"])
                  ],
                  512
                )
              ]),
              content: Ee(() => [
                ve(
                  "div",
                  {
                    class: X(S(q).e("input-tag-list"))
                  },
                  [
                    (G(!0), ue(
                      Ge,
                      null,
                      on(S(I), (ce, xe) => (G(), Me(S(fs), {
                        key: xe,
                        size: S(b),
                        closable: S(w),
                        type: ne.tagType,
                        effect: ne.tagEffect,
                        "disable-transitions": "",
                        onClose: (Te) => S(R)(xe + ne.maxCollapseTags)
                      }, {
                        default: Ee(() => [
                          Oe(ne.$slots, "tag", {
                            value: ce,
                            index: xe + ne.maxCollapseTags
                          }, () => [
                            Ft(
                              qe(ce),
                              1
                            )
                          ])
                        ]),
                        _: 2
                      }, 1032, ["size", "closable", "type", "effect", "onClose"]))),
                      128
                    ))
                  ],
                  2
                )
              ]),
              _: 3
            }, 8, ["disabled", "effect"])) : Ie("v-if", !0),
            ve(
              "div",
              {
                class: X(S(q).e("input-wrapper"))
              },
              [
                _t(ve("input", Ut({
                  id: S(c),
                  ref_key: "inputRef",
                  ref: p,
                  "onUpdate:modelValue": ae[1] || (ae[1] = (ce) => /* @__PURE__ */ kn(g) ? g.value = ce : null)
                }, S(r), {
                  type: "text",
                  minlength: ne.minlength,
                  maxlength: ne.maxlength,
                  disabled: S(x),
                  readonly: ne.readonly,
                  autocomplete: ne.autocomplete,
                  tabindex: ne.tabindex,
                  placeholder: S(C),
                  autofocus: ne.autofocus,
                  ariaLabel: ne.ariaLabel,
                  class: S(q).e("input"),
                  style: S(Y),
                  onCompositionstart: ae[2] || (ae[2] = (...ce) => S(D) && S(D)(...ce)),
                  onCompositionupdate: ae[3] || (ae[3] = (...ce) => S(F) && S(F)(...ce)),
                  onCompositionend: ae[4] || (ae[4] = (...ce) => S(M) && S(M)(...ce)),
                  onInput: ae[5] || (ae[5] = (...ce) => S(P) && S(P)(...ce)),
                  onKeydown: ae[6] || (ae[6] = (...ce) => S(k) && S(k)(...ce)),
                  onKeyup: ae[7] || (ae[7] = (...ce) => S(N) && S(N)(...ce))
                }), null, 16, u1e), [
                  [d1, S(g)]
                ]),
                ve("span", {
                  ref_key: "calculatorRef",
                  ref: W,
                  "aria-hidden": "true",
                  class: X(S(q).e("input-calculator")),
                  textContent: qe(S(g))
                }, null, 10, d1e)
              ],
              2
            ),
            _t(ve(
              "div",
              {
                ref_key: "dropIndicatorRef",
                ref: U,
                class: X(S(q).e("drop-indicator"))
              },
              null,
              2
            ), [
              [Jt, S(te)]
            ])
          ],
          2
        ),
        S(me) ? (G(), ue(
          "div",
          {
            key: 1,
            class: X(S(q).e("suffix"))
          },
          [
            Oe(ne.$slots, "suffix"),
            S(fe) ? (G(), Me(S(ut), {
              key: 0,
              class: X([S(q).e("icon"), S(q).e("clear")]),
              onMousedown: Et(S(gn), ["prevent"]),
              onClick: S(z)
            }, {
              default: Ee(() => [
                (G(), Me(Ht(ne.clearIcon)))
              ]),
              _: 1
            }, 8, ["class", "onMousedown", "onClick"])) : Ie("v-if", !0),
            d.value && f.value && u.value ? (G(), Me(S(ut), {
              key: 1,
              class: X([
                S(K).e("icon"),
                S(K).e("validateIcon"),
                S(K).is("loading", d.value === "validating")
              ])
            }, {
              default: Ee(() => [
                (G(), Me(Ht(f.value)))
              ]),
              _: 1
            }, 8, ["class"])) : Ie("v-if", !0)
          ],
          2
        )) : Ie("v-if", !0)
      ],
      38
    ));
  }
});
var p1e = /* @__PURE__ */ Je(f1e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input-tag/src/input-tag.vue"]]);
const v1e = Dt(p1e), m1e = Xe({
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger", "default"],
    default: void 0
  },
  underline: {
    type: [Boolean, String],
    values: [!0, !1, "always", "never", "hover"],
    default: void 0
  },
  disabled: Boolean,
  href: { type: String, default: "" },
  target: {
    type: String,
    default: "_self"
  },
  icon: {
    type: Pn
  }
}), h1e = {
  click: (e) => e instanceof MouseEvent
}, g1e = ["href", "target"], b1e = /* @__PURE__ */ le({
  name: "ElLink",
  __name: "link",
  props: m1e,
  emits: h1e,
  setup(e, { emit: t }) {
    const n = e, o = t, l = wp("link");
    hi(
      {
        scope: "el-link",
        from: "The underline option (boolean)",
        replacement: "'always' | 'hover' | 'never'",
        version: "3.0.0",
        ref: "https://element-plus.org/en-US/component/link.html#underline"
      },
      O(() => Tn(n.underline))
    );
    const r = Ve("link"), a = O(() => {
      var c, u, d;
      return [
        r.b(),
        r.m((d = (u = n.type) != null ? u : (c = l.value) == null ? void 0 : c.type) != null ? d : "default"),
        r.is("disabled", n.disabled),
        r.is("underline", i.value === "always"),
        r.is("hover-underline", i.value === "hover" && !n.disabled)
      ];
    }), i = O(() => {
      var c, u, d;
      return Tn(n.underline) ? n.underline ? "hover" : "never" : (d = (u = n.underline) != null ? u : (c = l.value) == null ? void 0 : c.underline) != null ? d : "hover";
    });
    function s(c) {
      n.disabled || o("click", c);
    }
    return (c, u) => (G(), ue("a", {
      class: X(a.value),
      href: c.disabled || !c.href ? void 0 : c.href,
      target: c.disabled || !c.href ? void 0 : c.target,
      onClick: s
    }, [
      c.icon ? (G(), Me(S(ut), { key: 0 }, {
        default: Ee(() => [
          (G(), Me(Ht(c.icon)))
        ]),
        _: 1
      })) : Ie("v-if", !0),
      c.$slots.default ? (G(), ue(
        "span",
        {
          key: 1,
          class: X(S(r).e("inner"))
        },
        [
          Oe(c.$slots, "default")
        ],
        2
      )) : Ie("v-if", !0),
      c.$slots.icon ? Oe(c.$slots, "icon", { key: 2 }) : Ie("v-if", !0)
    ], 10, g1e));
  }
});
var y1e = /* @__PURE__ */ Je(b1e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/link/src/link.vue"]]);
const S1e = Dt(y1e);
let C1e = class {
  constructor(t, n) {
    this.parent = t, this.domNode = n, this.subIndex = 0, this.subIndex = 0, this.init();
  }
  init() {
    this.subMenuItems = this.domNode.querySelectorAll("li"), this.addListeners();
  }
  gotoSubIndex(t) {
    t === this.subMenuItems.length ? t = 0 : t < 0 && (t = this.subMenuItems.length - 1), this.subMenuItems[t].focus(), this.subIndex = t;
  }
  addListeners() {
    const t = this.parent.domNode;
    Array.prototype.forEach.call(this.subMenuItems, (n) => {
      n.addEventListener("keydown", (o) => {
        const l = Nn(o);
        let r = !1;
        switch (l) {
          case Ye.down: {
            this.gotoSubIndex(this.subIndex + 1), r = !0;
            break;
          }
          case Ye.up: {
            this.gotoSubIndex(this.subIndex - 1), r = !0;
            break;
          }
          case Ye.tab: {
            cb(t, "mouseleave");
            break;
          }
          case Ye.enter:
          case Ye.numpadEnter:
          case Ye.space: {
            r = !0, o.currentTarget.click();
            break;
          }
        }
        return r && (o.preventDefault(), o.stopPropagation()), !1;
      });
    });
  }
}, w1e = class {
  constructor(t, n) {
    this.domNode = t, this.submenu = null, this.submenu = null, this.init(n);
  }
  init(t) {
    this.domNode.setAttribute("tabindex", "0");
    const n = this.domNode.querySelector(`.${t}-menu`);
    n && (this.submenu = new C1e(this, n)), this.addListeners();
  }
  addListeners() {
    this.domNode.addEventListener("keydown", (t) => {
      const n = Nn(t);
      let o = !1;
      switch (n) {
        case Ye.down: {
          cb(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(0), o = !0;
          break;
        }
        case Ye.up: {
          cb(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1), o = !0;
          break;
        }
        case Ye.tab: {
          cb(t.currentTarget, "mouseleave");
          break;
        }
        case Ye.enter:
        case Ye.numpadEnter:
        case Ye.space: {
          o = !0, t.currentTarget.click();
          break;
        }
      }
      o && t.preventDefault();
    });
  }
}, $1e = class {
  constructor(t, n) {
    this.domNode = t, this.init(n);
  }
  init(t) {
    const n = this.domNode.childNodes;
    Array.from(n).forEach((o) => {
      o.nodeType === 1 && new w1e(o, t);
    });
  }
};
const x1e = /* @__PURE__ */ le({
  name: "ElMenuCollapseTransition",
  __name: "menu-collapse-transition",
  setup(e) {
    const t = Ve("menu"), n = {
      onBeforeEnter: (o) => o.style.opacity = "0.2",
      onEnter(o, l) {
        Zr(o, `${t.namespace.value}-opacity-transition`), o.style.opacity = "1", l();
      },
      onAfterEnter(o) {
        Al(o, `${t.namespace.value}-opacity-transition`), o.style.opacity = "";
      },
      onBeforeLeave(o) {
        o.dataset || (o.dataset = {}), pi(o, t.m("collapse")) ? (Al(o, t.m("collapse")), o.dataset.oldOverflow = o.style.overflow, o.dataset.scrollWidth = o.clientWidth.toString(), Zr(o, t.m("collapse"))) : (Zr(o, t.m("collapse")), o.dataset.oldOverflow = o.style.overflow, o.dataset.scrollWidth = o.clientWidth.toString(), Al(o, t.m("collapse"))), o.style.width = `${o.scrollWidth}px`, o.style.overflow = "hidden";
      },
      onLeave(o) {
        Zr(o, "horizontal-collapse-transition"), o.style.width = `${o.dataset.scrollWidth}px`;
      }
    };
    return (o, l) => (G(), Me(
      Vn,
      Ut({ mode: "out-in" }, n),
      {
        default: Ee(() => [
          Oe(o.$slots, "default")
        ]),
        _: 3
      },
      16
    ));
  }
});
var E1e = /* @__PURE__ */ Je(x1e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-collapse-transition.vue"]]);
function Y9(e, t) {
  const n = O(() => {
    let l = e.parent;
    const r = [t.value];
    for (; l.type.name !== "ElMenu"; )
      l.props.index && r.unshift(l.props.index), l = l.parent;
    return r;
  });
  return {
    parentMenu: O(() => {
      let l = e.parent;
      for (; l && !["ElMenu", "ElSubMenu"].includes(l.type.name); )
        l = l.parent;
      return l;
    }),
    indexPath: n
  };
}
function O1e(e) {
  return O(() => {
    const n = e.backgroundColor;
    return n ? new xn(n).shade(20).toString() : "";
  });
}
const X9 = (e, t) => {
  const n = Ve("menu");
  return O(
    () => n.cssVarBlock({
      "text-color": e.textColor || "",
      "hover-text-color": e.textColor || "",
      "bg-color": e.backgroundColor || "",
      "hover-bg-color": O1e(e).value || "",
      "active-color": e.activeTextColor || "",
      level: `${t}`
    })
  );
}, y_ = "rootMenu", H0 = "subMenu:", _1e = Xe({
  index: {
    type: String,
    required: !0
  },
  showTimeout: Number,
  hideTimeout: Number,
  popperClass: String,
  popperStyle: {
    type: ye([String, Object])
  },
  disabled: Boolean,
  teleported: {
    type: Boolean,
    default: void 0
  },
  popperOffset: Number,
  expandCloseIcon: {
    type: Pn
  },
  expandOpenIcon: {
    type: Pn
  },
  collapseCloseIcon: {
    type: Pn
  },
  collapseOpenIcon: {
    type: Pn
  }
}), QC = "ElSubMenu";
var S_ = /* @__PURE__ */ le({
  name: QC,
  props: _1e,
  setup(e, { slots: t, expose: n }) {
    const o = xt(), { indexPath: l, parentMenu: r } = Y9(
      o,
      O(() => e.index)
    ), a = Ve("menu"), i = Ve("sub-menu"), s = ze(y_);
    s || no(QC, "can not inject root menu");
    const c = ze(
      `${H0}${r.value.uid}`
    );
    c || no(QC, "can not inject sub menu");
    const u = /* @__PURE__ */ H({}), d = /* @__PURE__ */ H({});
    let f;
    const p = /* @__PURE__ */ H(!1), m = /* @__PURE__ */ H(), v = /* @__PURE__ */ H(), h = O(() => c.level === 0), g = O(
      () => I.value === "horizontal" && h.value ? "bottom-start" : "right-start"
    ), y = O(() => I.value === "horizontal" && h.value || I.value === "vertical" && !s.props.collapse ? e.expandCloseIcon && e.expandOpenIcon ? x.value ? e.expandOpenIcon : e.expandCloseIcon : Ni : e.collapseCloseIcon && e.collapseOpenIcon ? x.value ? e.collapseOpenIcon : e.collapseCloseIcon : Rl), b = O(() => {
      const j = e.teleported;
      return fn(j) ? h.value : j;
    }), C = O(
      () => s.props.collapse ? `${a.namespace.value}-zoom-in-left` : `${a.namespace.value}-zoom-in-top`
    ), w = O(
      () => I.value === "horizontal" && h.value ? [
        "bottom-start",
        "bottom-end",
        "top-start",
        "top-end",
        "right-start",
        "left-start"
      ] : [
        "right-start",
        "right",
        "right-end",
        "left-start",
        "bottom-start",
        "bottom-end",
        "top-start",
        "top-end"
      ]
    ), x = O(() => s.openedMenus.includes(e.index)), E = O(
      () => [...Object.values(u.value), ...Object.values(d.value)].some(
        ({ active: j }) => j
      )
    ), I = O(() => s.props.mode), T = O(() => s.props.persistent), P = /* @__PURE__ */ kt({
      index: e.index,
      indexPath: l,
      active: E
    }), k = X9(s.props, c.level + 1), N = O(
      () => {
        var j;
        return (j = e.popperOffset) != null ? j : s.props.popperOffset;
      }
    ), R = O(
      () => {
        var j;
        return (j = e.popperClass) != null ? j : s.props.popperClass;
      }
    ), z = O(
      () => {
        var j;
        return (j = e.popperStyle) != null ? j : s.props.popperStyle;
      }
    ), D = O(
      () => {
        var j;
        return (j = e.showTimeout) != null ? j : s.props.showTimeout;
      }
    ), F = O(
      () => {
        var j;
        return (j = e.hideTimeout) != null ? j : s.props.hideTimeout;
      }
    ), M = () => {
      var j, W, Y;
      return (Y = (W = (j = v.value) == null ? void 0 : j.popperRef) == null ? void 0 : W.popperInstanceRef) == null ? void 0 : Y.destroy();
    }, A = (j) => {
      j || M();
    }, L = () => {
      s.props.menuTrigger === "hover" && s.props.mode === "horizontal" || s.props.collapse && s.props.mode === "vertical" || e.disabled || s.handleSubMenuClick({
        index: e.index,
        indexPath: l.value,
        active: E.value
      });
    }, B = (j, W = D.value) => {
      var Y;
      if (j.type !== "focus") {
        if (s.props.menuTrigger === "click" && s.props.mode === "horizontal" || !s.props.collapse && s.props.mode === "vertical" || e.disabled) {
          c.mouseInChild.value = !0;
          return;
        }
        c.mouseInChild.value = !0, f == null || f(), { stop: f } = jf(() => {
          s.openMenu(e.index, l.value);
        }, W), b.value && ((Y = r.value.vnode.el) == null || Y.dispatchEvent(new MouseEvent("mouseenter"))), j.type === "mouseenter" && j.target && Ke(() => {
          dh(j.target, { preventScroll: !0 });
        });
      }
    }, V = (j = !1) => {
      var W;
      if (s.props.menuTrigger === "click" && s.props.mode === "horizontal" || !s.props.collapse && s.props.mode === "vertical") {
        c.mouseInChild.value = !1;
        return;
      }
      f == null || f(), c.mouseInChild.value = !1, { stop: f } = jf(
        () => !p.value && s.closeMenu(e.index, l.value),
        F.value
      ), b.value && j && ((W = c.handleMouseleave) == null || W.call(c, !0));
    };
    pe(
      () => s.props.collapse,
      (j) => A(!!j)
    );
    {
      const j = (Y) => {
        d.value[Y.index] = Y;
      }, W = (Y) => {
        delete d.value[Y.index];
      };
      at(`${H0}${o.uid}`, {
        addSubMenu: j,
        removeSubMenu: W,
        handleMouseleave: V,
        mouseInChild: p,
        level: c.level + 1
      });
    }
    return n({
      opened: x
    }), nt(() => {
      s.addSubMenu(P), c.addSubMenu(P);
    }), yt(() => {
      c.removeSubMenu(P), s.removeSubMenu(P);
    }), () => {
      var j;
      const W = [
        (j = t.title) == null ? void 0 : j.call(t),
        ht(
          ut,
          {
            class: i.e("icon-arrow"),
            style: {
              transform: x.value ? e.expandCloseIcon && e.expandOpenIcon || e.collapseCloseIcon && e.collapseOpenIcon && s.props.collapse ? "none" : "rotateZ(180deg)" : "none"
            }
          },
          {
            default: () => rt(y.value) ? ht(o.appContext.components[y.value]) : ht(y.value)
          }
        )
      ], Y = s.isMenuPopup ? ht(
        al,
        {
          ref: v,
          visible: x.value,
          effect: "light",
          pure: !0,
          offset: N.value,
          showArrow: !1,
          persistent: T.value,
          popperClass: R.value,
          popperStyle: z.value,
          placement: g.value,
          teleported: b.value,
          fallbackPlacements: w.value,
          transition: C.value,
          gpuAcceleration: !1
        },
        {
          content: () => {
            var U;
            return ht(
              "div",
              {
                class: [
                  a.m(I.value),
                  a.m("popup-container"),
                  R.value
                ],
                onMouseenter: (te) => B(te, 100),
                onMouseleave: () => V(!0),
                onFocus: (te) => B(te, 100)
              },
              [
                ht(
                  "ul",
                  {
                    class: [
                      a.b(),
                      a.m("popup"),
                      a.m(`popup-${g.value}`)
                    ],
                    style: k.value
                  },
                  [(U = t.default) == null ? void 0 : U.call(t)]
                )
              ]
            );
          },
          default: () => ht(
            "div",
            {
              class: i.e("title"),
              onClick: L
            },
            W
          )
        }
      ) : ht(Ge, {}, [
        ht(
          "div",
          {
            class: i.e("title"),
            ref: m,
            onClick: L
          },
          W
        ),
        ht(
          j1,
          {},
          {
            default: () => {
              var U;
              return _t(
                ht(
                  "ul",
                  {
                    role: "menu",
                    class: [a.b(), a.m("inline")],
                    style: k.value
                  },
                  [(U = t.default) == null ? void 0 : U.call(t)]
                ),
                [[Jt, x.value]]
              );
            }
          }
        )
      ]);
      return ht(
        "li",
        {
          class: [
            i.b(),
            i.is("active", E.value),
            i.is("opened", x.value),
            i.is("disabled", e.disabled)
          ],
          role: "menuitem",
          ariaHaspopup: !0,
          ariaExpanded: x.value,
          onMouseenter: B,
          onMouseleave: () => V(),
          onFocus: B
        },
        [Y]
      );
    };
  }
});
const I1e = Xe({
  mode: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "vertical"
  },
  defaultActive: {
    type: String,
    default: ""
  },
  defaultOpeneds: {
    type: ye(Array),
    default: () => lo([])
  },
  uniqueOpened: Boolean,
  router: Boolean,
  menuTrigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  collapse: Boolean,
  backgroundColor: String,
  textColor: String,
  activeTextColor: String,
  closeOnClickOutside: Boolean,
  collapseTransition: {
    type: Boolean,
    default: !0
  },
  ellipsis: {
    type: Boolean,
    default: !0
  },
  popperOffset: {
    type: Number,
    default: 6
  },
  ellipsisIcon: {
    type: Pn,
    default: () => mse
  },
  popperEffect: {
    type: ye(String),
    default: "dark"
  },
  popperClass: String,
  popperStyle: {
    type: ye([String, Object])
  },
  showTimeout: {
    type: Number,
    default: 300
  },
  hideTimeout: {
    type: Number,
    default: 300
  },
  persistent: {
    type: Boolean,
    default: !0
  }
}), ew = (e) => We(e) && e.every((t) => rt(t)), T1e = {
  close: (e, t) => rt(e) && ew(t),
  open: (e, t) => rt(e) && ew(t),
  select: (e, t, n, o) => rt(e) && ew(t) && Mt(n) && (fn(o) || o instanceof Promise)
}, wN = 64;
var P1e = /* @__PURE__ */ le({
  name: "ElMenu",
  props: I1e,
  emits: T1e,
  setup(e, { emit: t, slots: n, expose: o }) {
    const l = xt(), r = l.appContext.config.globalProperties.$router, a = /* @__PURE__ */ H(), i = /* @__PURE__ */ H(), s = Ve("menu"), c = Ve("sub-menu");
    let u = wN;
    const d = /* @__PURE__ */ H(-1), f = /* @__PURE__ */ H(
      e.defaultOpeneds && !e.collapse ? e.defaultOpeneds.slice(0) : []
    ), p = /* @__PURE__ */ H(e.defaultActive), m = /* @__PURE__ */ H({}), v = /* @__PURE__ */ H({}), h = O(
      () => e.mode === "horizontal" || e.mode === "vertical" && e.collapse
    ), g = () => {
      const M = p.value && m.value[p.value];
      if (!M || e.mode === "horizontal" || e.collapse)
        return;
      M.indexPath.forEach((L) => {
        const B = v.value[L];
        B && y(L, B.indexPath);
      });
    }, y = (M, A) => {
      f.value.includes(M) || (e.uniqueOpened && (f.value = f.value.filter(
        (L) => A.includes(L)
      )), f.value.push(M), t("open", M, A));
    }, b = (M) => {
      const A = f.value.indexOf(M);
      A !== -1 && f.value.splice(A, 1);
    }, C = (M, A) => {
      b(M), t("close", M, A);
    }, w = ({
      index: M,
      indexPath: A
    }) => {
      f.value.includes(M) ? C(M, A) : y(M, A);
    }, x = (M) => {
      (e.mode === "horizontal" || e.collapse) && (f.value = []);
      const { index: A, indexPath: L } = M;
      if (!(wo(A) || wo(L)))
        if (e.router && r) {
          const B = M.route || A, V = r.push(B).then((j) => (j || (p.value = A), j));
          t(
            "select",
            A,
            L,
            { index: A, indexPath: L, route: B },
            V
          );
        } else
          p.value = A, t("select", A, L, { index: A, indexPath: L });
    }, E = (M) => {
      var A;
      const L = m.value, B = L[M] || p.value && L[p.value] || L[e.defaultActive];
      p.value = (A = B == null ? void 0 : B.index) != null ? A : M;
    }, I = (M) => {
      const A = getComputedStyle(M), L = Number.parseInt(A.marginLeft, 10), B = Number.parseInt(A.marginRight, 10);
      return M.offsetWidth + L + B || 0;
    }, T = () => {
      if (!a.value)
        return -1;
      const M = Array.from(a.value.childNodes).filter(
        (Y) => Y.nodeName !== "#comment" && (Y.nodeName !== "#text" || Y.nodeValue)
      ), A = getComputedStyle(a.value), L = Number.parseInt(A.paddingLeft, 10), B = Number.parseInt(A.paddingRight, 10), V = a.value.clientWidth - L - B;
      let j = 0, W = 0;
      return M.forEach((Y, U) => {
        j += I(Y), j <= V - u && (W = U + 1);
      }), W === M.length ? -1 : W;
    }, P = (M) => v.value[M].indexPath, k = (M, A = 33.34) => {
      let L;
      return () => {
        L && clearTimeout(L), L = setTimeout(() => {
          M();
        }, A);
      };
    };
    let N = !0;
    const R = () => {
      const M = Lo(i);
      if (M && (u = I(M) || wN), d.value === T())
        return;
      const A = () => {
        d.value = -1, Ke(() => {
          d.value = T();
        });
      };
      N ? A() : k(A)(), N = !1;
    };
    pe(
      () => e.defaultActive,
      (M) => {
        m.value[M] || (p.value = ""), E(M);
      }
    ), pe(
      () => e.collapse,
      (M) => {
        M && (f.value = []);
      }
    ), pe(m.value, g);
    let z;
    Ot(() => {
      e.mode === "horizontal" && e.ellipsis ? z = Xn(a, R).stop : z == null || z();
    });
    const D = /* @__PURE__ */ H(!1);
    {
      const M = (V) => {
        v.value[V.index] = V;
      }, A = (V) => {
        delete v.value[V.index];
      };
      at(
        y_,
        /* @__PURE__ */ kt({
          props: e,
          openedMenus: f,
          items: m,
          subMenus: v,
          activeIndex: p,
          isMenuPopup: h,
          addMenuItem: (V) => {
            m.value[V.index] = V;
          },
          removeMenuItem: (V) => {
            delete m.value[V.index];
          },
          addSubMenu: M,
          removeSubMenu: A,
          openMenu: y,
          closeMenu: C,
          handleMenuItemClick: x,
          handleSubMenuClick: w
        })
      ), at(`${H0}${l.uid}`, {
        addSubMenu: M,
        removeSubMenu: A,
        mouseInChild: D,
        level: 0
      });
    }
    nt(() => {
      e.mode === "horizontal" && new $1e(l.vnode.el, s.namespace.value);
    }), o({
      open: (A) => {
        const { indexPath: L } = v.value[A];
        L.forEach((B) => y(B, L));
      },
      close: b,
      updateActiveIndex: E,
      handleResize: R
    });
    const F = X9(e, 0);
    return () => {
      var M, A;
      let L = (A = (M = n.default) == null ? void 0 : M.call(n)) != null ? A : [];
      const B = [];
      if (e.mode === "horizontal" && a.value) {
        const W = Nr(L).filter((te) => (te == null ? void 0 : te.shapeFlag) !== 8), Y = d.value === -1 ? W : W.slice(0, d.value), U = d.value === -1 ? [] : W.slice(d.value);
        U != null && U.length && e.ellipsis && (L = Y, B.push(
          ht(
            S_,
            {
              ref: i,
              index: "sub-menu-more",
              class: c.e("hide-arrow"),
              popperOffset: e.popperOffset
            },
            {
              title: () => ht(
                ut,
                {
                  class: c.e("icon-more")
                },
                {
                  default: () => ht(e.ellipsisIcon)
                }
              ),
              default: () => U
            }
          )
        ));
      }
      const V = e.closeOnClickOutside ? [
        [
          Cc,
          () => {
            f.value.length && (D.value || (f.value.forEach(
              (W) => t("close", W, P(W))
            ), f.value = []));
          }
        ]
      ] : [], j = _t(
        ht(
          "ul",
          {
            key: String(e.collapse),
            role: "menubar",
            ref: a,
            style: F.value,
            class: {
              [s.b()]: !0,
              [s.m(e.mode)]: !0,
              [s.m("collapse")]: e.collapse
            }
          },
          [...L, ...B]
        ),
        V
      );
      return e.collapseTransition && e.mode === "vertical" ? ht(E1e, () => j) : j;
    };
  }
});
const k1e = Xe({
  index: {
    type: ye([String, null]),
    default: null
  },
  route: {
    type: ye([String, Object])
  },
  disabled: Boolean
}), N1e = {
  click: (e) => rt(e.index) && We(e.indexPath)
}, mg = "ElMenuItem", M1e = /* @__PURE__ */ le({
  name: mg,
  __name: "menu-item",
  props: k1e,
  emits: N1e,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n;
    hr(o.index) && Gt(mg, 'Missing required prop: "index"');
    const r = xt(), a = ze(y_), i = Ve("menu"), s = Ve("menu-item");
    a || no(mg, "can not inject root menu");
    const { parentMenu: c, indexPath: u } = Y9(r, /* @__PURE__ */ ft(o, "index")), d = ze(
      `${H0}${c.value.uid}`
    );
    d || no(mg, "can not inject sub menu");
    const f = O(() => o.index === a.activeIndex), p = /* @__PURE__ */ kt({
      index: o.index,
      indexPath: u,
      active: f
    }), m = () => {
      o.disabled || (a.handleMenuItemClick({
        index: o.index,
        indexPath: u.value,
        route: o.route
      }), l("click", p));
    };
    return nt(() => {
      d.addSubMenu(p), a.addMenuItem(p);
    }), yt(() => {
      d.removeSubMenu(p), a.removeMenuItem(p);
    }), t({
      parentMenu: c,
      rootMenu: a,
      active: f,
      nsMenu: i,
      nsMenuItem: s,
      handleClick: m
    }), (v, h) => (G(), ue(
      "li",
      {
        class: X([
          S(s).b(),
          S(s).is("active", f.value),
          S(s).is("disabled", v.disabled)
        ]),
        role: "menuitem",
        tabindex: "-1",
        onClick: m
      },
      [
        S(c).type.name === "ElMenu" && S(a).props.collapse && v.$slots.title ? (G(), Me(S(al), {
          key: 0,
          effect: S(a).props.popperEffect,
          placement: "right",
          "fallback-placements": ["left"],
          "popper-class": S(a).props.popperClass,
          "popper-style": S(a).props.popperStyle,
          persistent: S(a).props.persistent,
          "focus-on-target": ""
        }, {
          content: Ee(() => [
            Oe(v.$slots, "title")
          ]),
          default: Ee(() => [
            ve(
              "div",
              {
                class: X(S(i).be("tooltip", "trigger"))
              },
              [
                Oe(v.$slots, "default")
              ],
              2
            )
          ]),
          _: 3
        }, 8, ["effect", "popper-class", "popper-style", "persistent"])) : (G(), ue(
          Ge,
          { key: 1 },
          [
            Oe(v.$slots, "default"),
            Oe(v.$slots, "title")
          ],
          64
        ))
      ],
      2
    ));
  }
});
var q9 = /* @__PURE__ */ Je(M1e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item.vue"]]);
const A1e = {
  title: String
}, R1e = /* @__PURE__ */ le({
  name: "ElMenuItemGroup",
  __name: "menu-item-group",
  props: A1e,
  setup(e) {
    const t = Ve("menu-item-group");
    return (n, o) => (G(), ue(
      "li",
      {
        class: X(S(t).b())
      },
      [
        ve(
          "div",
          {
            class: X(S(t).e("title"))
          },
          [
            n.$slots.title ? Oe(n.$slots, "title", { key: 1 }) : (G(), ue(
              Ge,
              { key: 0 },
              [
                Ft(
                  qe(n.title),
                  1
                )
              ],
              64
            ))
          ],
          2
        ),
        ve("ul", null, [
          Oe(n.$slots, "default")
        ])
      ],
      2
    ));
  }
});
var J9 = /* @__PURE__ */ Je(R1e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item-group.vue"]]);
const D1e = Dt(P1e, {
  MenuItem: q9,
  MenuItemGroup: J9,
  SubMenu: S_
}), L1e = oo(q9), B1e = oo(J9), F1e = oo(S_), V1e = Xe({
  icon: {
    type: Pn,
    default: () => Fie
  },
  title: String,
  content: {
    type: String,
    default: ""
  }
}), z1e = {
  back: () => !0
}, H1e = ["aria-label"], j1e = /* @__PURE__ */ le({
  name: "ElPageHeader",
  __name: "page-header",
  props: V1e,
  emits: z1e,
  setup(e, { emit: t }) {
    const n = t, { t: o } = an(), l = Ve("page-header");
    function r() {
      n("back");
    }
    return (a, i) => (G(), ue(
      "div",
      {
        class: X([
          S(l).b(),
          S(l).is("contentful", !!a.$slots.default),
          {
            [S(l).m("has-breadcrumb")]: !!a.$slots.breadcrumb,
            [S(l).m("has-extra")]: !!a.$slots.extra
          }
        ])
      },
      [
        a.$slots.breadcrumb ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(l).e("breadcrumb"))
          },
          [
            Oe(a.$slots, "breadcrumb")
          ],
          2
        )) : Ie("v-if", !0),
        ve(
          "div",
          {
            class: X(S(l).e("header"))
          },
          [
            ve(
              "div",
              {
                class: X(S(l).e("left"))
              },
              [
                ve(
                  "div",
                  {
                    class: X(S(l).e("back")),
                    role: "button",
                    tabindex: "0",
                    onClick: r
                  },
                  [
                    a.icon || a.$slots.icon ? (G(), ue("div", {
                      key: 0,
                      "aria-label": a.title || S(o)("el.pageHeader.title"),
                      class: X(S(l).e("icon"))
                    }, [
                      Oe(a.$slots, "icon", {}, () => [
                        a.icon ? (G(), Me(S(ut), { key: 0 }, {
                          default: Ee(() => [
                            (G(), Me(Ht(a.icon)))
                          ]),
                          _: 1
                        })) : Ie("v-if", !0)
                      ])
                    ], 10, H1e)) : Ie("v-if", !0),
                    ve(
                      "div",
                      {
                        class: X(S(l).e("title"))
                      },
                      [
                        Oe(a.$slots, "title", {}, () => [
                          Ft(
                            qe(a.title || S(o)("el.pageHeader.title")),
                            1
                          )
                        ])
                      ],
                      2
                    )
                  ],
                  2
                ),
                $(S(M9), { direction: "vertical" }),
                ve(
                  "div",
                  {
                    class: X(S(l).e("content"))
                  },
                  [
                    Oe(a.$slots, "content", {}, () => [
                      Ft(
                        qe(a.content),
                        1
                      )
                    ])
                  ],
                  2
                )
              ],
              2
            ),
            a.$slots.extra ? (G(), ue(
              "div",
              {
                key: 0,
                class: X(S(l).e("extra"))
              },
              [
                Oe(a.$slots, "extra")
              ],
              2
            )) : Ie("v-if", !0)
          ],
          2
        ),
        a.$slots.default ? (G(), ue(
          "div",
          {
            key: 1,
            class: X(S(l).e("main"))
          },
          [
            Oe(a.$slots, "default")
          ],
          2
        )) : Ie("v-if", !0)
      ],
      2
    ));
  }
});
var W1e = /* @__PURE__ */ Je(j1e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/page-header/src/page-header.vue"]]);
const K1e = Dt(W1e), Z9 = Symbol("elPaginationKey"), U1e = Xe({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  prevText: {
    type: String
  },
  prevIcon: {
    type: Pn
  }
}), G1e = {
  click: (e) => e instanceof MouseEvent
}, Y1e = ["disabled", "aria-label", "aria-disabled"], X1e = { key: 0 }, q1e = /* @__PURE__ */ le({
  name: "ElPaginationPrev",
  __name: "prev",
  props: U1e,
  emits: G1e,
  setup(e) {
    const t = e, { t: n } = an(), o = O(
      () => t.disabled || t.currentPage <= 1
    );
    return (l, r) => (G(), ue("button", {
      type: "button",
      class: "btn-prev",
      disabled: o.value,
      "aria-label": l.prevText || S(n)("el.pagination.prev"),
      "aria-disabled": o.value,
      onClick: r[0] || (r[0] = (a) => l.$emit("click", a))
    }, [
      l.prevText ? (G(), ue(
        "span",
        X1e,
        qe(l.prevText),
        1
      )) : (G(), Me(S(ut), { key: 1 }, {
        default: Ee(() => [
          (G(), Me(Ht(l.prevIcon)))
        ]),
        _: 1
      }))
    ], 8, Y1e));
  }
});
var J1e = /* @__PURE__ */ Je(q1e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/prev.vue"]]);
const Z1e = Xe({
  disabled: Boolean,
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    default: 50
  },
  nextText: {
    type: String
  },
  nextIcon: {
    type: Pn
  }
}), Q1e = ["disabled", "aria-label", "aria-disabled"], eSe = { key: 0 }, tSe = /* @__PURE__ */ le({
  name: "ElPaginationNext",
  __name: "next",
  props: Z1e,
  emits: ["click"],
  setup(e) {
    const t = e, { t: n } = an(), o = O(
      () => t.disabled || t.currentPage === t.pageCount || t.pageCount === 0
    );
    return (l, r) => (G(), ue("button", {
      type: "button",
      class: "btn-next",
      disabled: o.value,
      "aria-label": l.nextText || S(n)("el.pagination.next"),
      "aria-disabled": o.value,
      onClick: r[0] || (r[0] = (a) => l.$emit("click", a))
    }, [
      l.nextText ? (G(), ue(
        "span",
        eSe,
        qe(l.nextText),
        1
      )) : (G(), Me(S(ut), { key: 1 }, {
        default: Ee(() => [
          (G(), Me(Ht(l.nextIcon)))
        ]),
        _: 1
      }))
    ], 8, Q1e));
  }
});
var nSe = /* @__PURE__ */ Je(tSe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/next.vue"]]);
const C_ = () => ze(Z9, {}), oSe = Xe({
  pageSize: {
    type: Number,
    required: !0
  },
  pageSizes: {
    type: ye(Array),
    default: () => lo([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String
  },
  popperStyle: {
    type: ye([String, Object])
  },
  disabled: Boolean,
  teleported: Boolean,
  size: {
    type: String,
    values: ki
  },
  appendSizeTo: String
}), lSe = /* @__PURE__ */ le({
  name: "ElPaginationSizes",
  __name: "sizes",
  props: oSe,
  emits: ["page-size-change"],
  setup(e, { emit: t }) {
    const n = e, o = t, { t: l } = an(), r = Ve("pagination"), a = C_(), i = /* @__PURE__ */ H(n.pageSize);
    pe(
      () => n.pageSizes,
      (u, d) => {
        if (!Jn(u, d) && We(u)) {
          const f = u.includes(n.pageSize) ? n.pageSize : n.pageSizes[0];
          o("page-size-change", f);
        }
      }
    ), pe(
      () => n.pageSize,
      (u) => {
        i.value = u;
      }
    );
    const s = O(() => n.pageSizes);
    function c(u) {
      var d;
      u !== i.value && (i.value = u, (d = a.handleSizeChange) == null || d.call(a, Number(u)));
    }
    return (u, d) => (G(), ue(
      "span",
      {
        class: X(S(r).e("sizes"))
      },
      [
        $(S(wc), {
          "model-value": i.value,
          disabled: u.disabled,
          "popper-class": u.popperClass,
          "popper-style": u.popperStyle,
          size: u.size,
          teleported: u.teleported,
          "validate-event": !1,
          "append-to": u.appendSizeTo,
          onChange: c
        }, {
          default: Ee(() => [
            (G(!0), ue(
              Ge,
              null,
              on(s.value, (f) => (G(), Me(S(R0), {
                key: f,
                value: f,
                label: f + S(l)("el.pagination.pagesize")
              }, null, 8, ["value", "label"]))),
              128
            ))
          ]),
          _: 1
        }, 8, ["model-value", "disabled", "popper-class", "popper-style", "size", "teleported", "append-to"])
      ],
      2
    ));
  }
});
var rSe = /* @__PURE__ */ Je(lSe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/sizes.vue"]]);
const aSe = Xe({
  size: {
    type: String,
    values: ki
  }
}), iSe = ["disabled"], sSe = /* @__PURE__ */ le({
  name: "ElPaginationJumper",
  __name: "jumper",
  props: aSe,
  setup(e) {
    const { t } = an(), n = Ve("pagination"), { pageCount: o, disabled: l, currentPage: r, changeEvent: a } = C_(), i = /* @__PURE__ */ H(), s = O(() => {
      var d;
      return (d = i.value) != null ? d : r == null ? void 0 : r.value;
    });
    function c(d) {
      i.value = d ? +d : "";
    }
    function u(d) {
      d = Math.trunc(+d), a == null || a(d), i.value = void 0;
    }
    return (d, f) => (G(), ue("span", {
      class: X(S(n).e("jump")),
      disabled: S(l)
    }, [
      ve(
        "span",
        {
          class: X([S(n).e("goto")])
        },
        qe(S(t)("el.pagination.goto")),
        3
      ),
      $(S(Nl), {
        size: d.size,
        class: X([S(n).e("editor"), S(n).is("in-pagination")]),
        min: 1,
        max: S(o),
        disabled: S(l),
        "model-value": s.value,
        "validate-event": !1,
        "aria-label": S(t)("el.pagination.page"),
        type: "number",
        "onUpdate:modelValue": c,
        onChange: u
      }, null, 8, ["size", "class", "max", "disabled", "model-value", "aria-label"]),
      ve(
        "span",
        {
          class: X([S(n).e("classifier")])
        },
        qe(S(t)("el.pagination.pageClassifier")),
        3
      )
    ], 10, iSe));
  }
});
var cSe = /* @__PURE__ */ Je(sSe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/jumper.vue"]]);
const uSe = Xe({
  total: {
    type: Number,
    default: 1e3
  }
}), dSe = ["disabled"], fSe = /* @__PURE__ */ le({
  name: "ElPaginationTotal",
  __name: "total",
  props: uSe,
  setup(e) {
    const { t } = an(), n = Ve("pagination"), { disabled: o } = C_();
    return (l, r) => (G(), ue("span", {
      class: X(S(n).e("total")),
      disabled: S(o)
    }, qe(S(t)("el.pagination.total", {
      total: l.total
    })), 11, dSe));
  }
});
var pSe = /* @__PURE__ */ Je(fSe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/total.vue"]]);
const vSe = Xe({
  currentPage: {
    type: Number,
    default: 1
  },
  pageCount: {
    type: Number,
    required: !0
  },
  pagerCount: {
    type: Number,
    default: 7
  },
  disabled: Boolean
}), mSe = ["aria-current", "aria-label", "tabindex"], hSe = ["tabindex", "aria-label"], gSe = ["aria-current", "aria-label", "tabindex"], bSe = ["tabindex", "aria-label"], ySe = ["aria-current", "aria-label", "tabindex"], SSe = /* @__PURE__ */ le({
  name: "ElPaginationPager",
  __name: "pager",
  props: vSe,
  emits: [en],
  setup(e, { emit: t }) {
    const n = e, o = t, l = Ve("pager"), r = Ve("icon"), { t: a } = an(), i = /* @__PURE__ */ H(!1), s = /* @__PURE__ */ H(!1), c = /* @__PURE__ */ H(!1), u = /* @__PURE__ */ H(!1), d = /* @__PURE__ */ H(!1), f = /* @__PURE__ */ H(!1), p = O(() => {
      const w = n.pagerCount, x = (w - 1) / 2, E = Number(n.currentPage), I = Number(n.pageCount);
      let T = !1, P = !1;
      I > w && (E > w - x && (T = !0), E < I - x && (P = !0));
      const k = [];
      if (T && !P) {
        const N = I - (w - 2);
        for (let R = N; R < I; R++)
          k.push(R);
      } else if (!T && P)
        for (let N = 2; N < w; N++)
          k.push(N);
      else if (T && P) {
        const N = Math.floor(w / 2) - 1;
        for (let R = E - N; R <= E + N; R++)
          k.push(R);
      } else
        for (let N = 2; N < I; N++)
          k.push(N);
      return k;
    }), m = O(() => [
      "more",
      "btn-quickprev",
      r.b(),
      l.is("disabled", n.disabled)
    ]), v = O(() => [
      "more",
      "btn-quicknext",
      r.b(),
      l.is("disabled", n.disabled)
    ]), h = O(() => n.disabled ? -1 : 0);
    pe(
      () => [n.pageCount, n.pagerCount, n.currentPage],
      ([w, x, E]) => {
        const I = (x - 1) / 2;
        let T = !1, P = !1;
        w > x && (T = E > x - I, P = E < w - I), c.value && (c.value = T), u.value && (u.value = P), i.value = T, s.value = P;
      },
      { immediate: !0 }
    );
    function g(w = !1) {
      n.disabled || (w ? c.value = !0 : u.value = !0);
    }
    function y(w = !1) {
      w ? d.value = !0 : f.value = !0;
    }
    function b(w) {
      const x = w.target;
      if (x.tagName.toLowerCase() === "li" && Array.from(x.classList).includes("number")) {
        const E = Number(x.textContent);
        E !== n.currentPage && o(en, E);
      } else x.tagName.toLowerCase() === "li" && Array.from(x.classList).includes("more") && C(w);
    }
    function C(w) {
      const x = w.target;
      if (x.tagName.toLowerCase() === "ul" || n.disabled)
        return;
      let E = Number(x.textContent);
      const I = n.pageCount, T = n.currentPage, P = n.pagerCount - 2;
      x.className.includes("more") && (x.className.includes("quickprev") ? E = T - P : x.className.includes("quicknext") && (E = T + P)), Number.isNaN(+E) || (E < 1 && (E = 1), E > I && (E = I)), E !== T && o(en, E);
    }
    return (w, x) => (G(), ue(
      "ul",
      {
        class: X(S(l).b()),
        onClick: C,
        onKeyup: uo(b, ["enter"])
      },
      [
        w.pageCount > 0 ? (G(), ue("li", {
          key: 0,
          class: X([[
            S(l).is("active", w.currentPage === 1),
            S(l).is("disabled", w.disabled)
          ], "number"]),
          "aria-current": w.currentPage === 1,
          "aria-label": S(a)("el.pagination.currentPage", { pager: 1 }),
          tabindex: h.value
        }, " 1 ", 10, mSe)) : Ie("v-if", !0),
        i.value ? (G(), ue("li", {
          key: 1,
          class: X(m.value),
          tabindex: h.value,
          "aria-label": S(a)("el.pagination.prevPages", { pager: w.pagerCount - 2 }),
          onMouseenter: x[0] || (x[0] = (E) => g(!0)),
          onMouseleave: x[1] || (x[1] = (E) => c.value = !1),
          onFocus: x[2] || (x[2] = (E) => y(!0)),
          onBlur: x[3] || (x[3] = (E) => d.value = !1)
        }, [
          (c.value || d.value) && !w.disabled ? (G(), Me(S(bc), { key: 0 })) : (G(), Me(S(m3), { key: 1 }))
        ], 42, hSe)) : Ie("v-if", !0),
        (G(!0), ue(
          Ge,
          null,
          on(p.value, (E) => (G(), ue("li", {
            key: E,
            class: X([[
              S(l).is("active", w.currentPage === E),
              S(l).is("disabled", w.disabled)
            ], "number"]),
            "aria-current": w.currentPage === E,
            "aria-label": S(a)("el.pagination.currentPage", { pager: E }),
            tabindex: h.value
          }, qe(E), 11, gSe))),
          128
        )),
        s.value ? (G(), ue("li", {
          key: 2,
          class: X(v.value),
          tabindex: h.value,
          "aria-label": S(a)("el.pagination.nextPages", { pager: w.pagerCount - 2 }),
          onMouseenter: x[4] || (x[4] = (E) => g()),
          onMouseleave: x[5] || (x[5] = (E) => u.value = !1),
          onFocus: x[6] || (x[6] = (E) => y()),
          onBlur: x[7] || (x[7] = (E) => f.value = !1)
        }, [
          (u.value || f.value) && !w.disabled ? (G(), Me(S(yc), { key: 0 })) : (G(), Me(S(m3), { key: 1 }))
        ], 42, bSe)) : Ie("v-if", !0),
        w.pageCount > 1 ? (G(), ue("li", {
          key: 3,
          class: X([[
            S(l).is("active", w.currentPage === w.pageCount),
            S(l).is("disabled", w.disabled)
          ], "number"]),
          "aria-current": w.currentPage === w.pageCount,
          "aria-label": S(a)("el.pagination.currentPage", { pager: w.pageCount }),
          tabindex: h.value
        }, qe(w.pageCount), 11, ySe)) : Ie("v-if", !0)
      ],
      34
    ));
  }
});
var CSe = /* @__PURE__ */ Je(SSe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/pagination/src/components/pager.vue"]]);
const Kl = (e) => typeof e != "number", wSe = Xe({
  pageSize: Number,
  defaultPageSize: Number,
  total: Number,
  pageCount: Number,
  pagerCount: {
    type: Number,
    validator: (e) => mt(e) && Math.trunc(e) === e && e > 4 && e < 22 && e % 2 === 1,
    default: 7
  },
  currentPage: Number,
  defaultCurrentPage: Number,
  layout: {
    type: String,
    default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
  },
  pageSizes: {
    type: ye(Array),
    default: () => lo([10, 20, 30, 40, 50, 100])
  },
  popperClass: {
    type: String,
    default: ""
  },
  popperStyle: {
    type: ye([String, Object])
  },
  prevText: {
    type: String,
    default: ""
  },
  prevIcon: {
    type: Pn,
    default: () => ms
  },
  nextText: {
    type: String,
    default: ""
  },
  nextIcon: {
    type: Pn,
    default: () => Rl
  },
  teleported: {
    type: Boolean,
    default: !0
  },
  small: Boolean,
  size: Bo,
  background: Boolean,
  disabled: Boolean,
  hideOnSinglePage: Boolean,
  appendSizeTo: String
}), $Se = {
  "update:current-page": (e) => mt(e),
  "update:page-size": (e) => mt(e),
  "size-change": (e) => mt(e),
  change: (e, t) => mt(e) && mt(t),
  "current-change": (e) => mt(e),
  "prev-click": (e) => mt(e),
  "next-click": (e) => mt(e)
}, $N = "ElPagination";
var xSe = /* @__PURE__ */ le({
  name: $N,
  props: wSe,
  emits: $Se,
  setup(e, { emit: t, slots: n }) {
    const { t: o } = an(), l = Ve("pagination"), r = xt().vnode.props || {}, a = h7(), i = O(
      () => {
        var w;
        return e.small ? "small" : (w = e.size) != null ? w : a.value;
      }
    );
    hi(
      {
        from: "small",
        replacement: "size",
        version: "3.0.0",
        scope: "el-pagination",
        ref: "https://element-plus.org/zh-CN/component/pagination.html"
      },
      O(() => !!e.small)
    );
    const s = "onUpdate:currentPage" in r || "onUpdate:current-page" in r || "onCurrentChange" in r, c = "onUpdate:pageSize" in r || "onUpdate:page-size" in r || "onSizeChange" in r, u = O(() => {
      if (Kl(e.total) && Kl(e.pageCount) || !Kl(e.currentPage) && !s)
        return !1;
      if (e.layout.includes("sizes")) {
        if (Kl(e.pageCount)) {
          if (!Kl(e.total) && !Kl(e.pageSize) && !c)
            return !1;
        } else if (!c)
          return !1;
      }
      return !0;
    }), d = /* @__PURE__ */ H(
      Kl(e.defaultPageSize) ? 10 : e.defaultPageSize
    ), f = /* @__PURE__ */ H(
      Kl(e.defaultCurrentPage) ? 1 : e.defaultCurrentPage
    ), p = O({
      get() {
        return Kl(e.pageSize) ? d.value : e.pageSize;
      },
      set(w) {
        Kl(e.pageSize) && (d.value = w), c && (t("update:page-size", w), t("size-change", w));
      }
    }), m = O(() => {
      let w = 0;
      return Kl(e.pageCount) ? Kl(e.total) || (w = Math.max(1, Math.ceil(e.total / p.value))) : w = e.pageCount, w;
    }), v = O({
      get() {
        return Kl(e.currentPage) ? f.value : e.currentPage;
      },
      set(w) {
        let x = w;
        w < 1 ? x = 1 : w > m.value && (x = m.value), Kl(e.currentPage) && (f.value = x), s && (t("update:current-page", x), t("current-change", x));
      }
    });
    pe(m, (w) => {
      v.value > w && (v.value = w);
    }), pe(
      [v, p],
      (w) => {
        t(en, ...w);
      },
      { flush: "post" }
    );
    function h(w) {
      v.value = w;
    }
    function g(w) {
      p.value = w;
      const x = m.value;
      v.value > x && (v.value = x);
    }
    function y() {
      e.disabled || (v.value -= 1, t("prev-click", v.value));
    }
    function b() {
      e.disabled || (v.value += 1, t("next-click", v.value));
    }
    function C(w, x) {
      w && (w.props || (w.props = {}), w.props.class = [w.props.class, x].join(" "));
    }
    return at(Z9, {
      pageCount: m,
      disabled: O(() => e.disabled),
      currentPage: v,
      changeEvent: h,
      handleSizeChange: g
    }), () => {
      var w, x;
      if (!u.value)
        return Gt($N, o("el.pagination.deprecationWarning")), null;
      if (!e.layout || e.hideOnSinglePage && m.value <= 1)
        return null;
      const E = [], I = [], T = ht(
        "div",
        { class: l.e("rightwrapper") },
        I
      ), P = {
        prev: ht(J1e, {
          disabled: e.disabled,
          currentPage: v.value,
          prevText: e.prevText,
          prevIcon: e.prevIcon,
          onClick: y
        }),
        jumper: ht(cSe, {
          size: i.value
        }),
        pager: ht(CSe, {
          currentPage: v.value,
          pageCount: m.value,
          pagerCount: e.pagerCount,
          onChange: h,
          disabled: e.disabled
        }),
        next: ht(nSe, {
          disabled: e.disabled,
          currentPage: v.value,
          pageCount: m.value,
          nextText: e.nextText,
          nextIcon: e.nextIcon,
          onClick: b
        }),
        sizes: ht(rSe, {
          pageSize: p.value,
          pageSizes: e.pageSizes,
          popperClass: e.popperClass,
          popperStyle: e.popperStyle,
          disabled: e.disabled,
          teleported: e.teleported,
          size: i.value,
          appendSizeTo: e.appendSizeTo
        }),
        slot: (x = (w = n == null ? void 0 : n.default) == null ? void 0 : w.call(n)) != null ? x : null,
        total: ht(pSe, { total: Kl(e.total) ? 0 : e.total })
      }, k = e.layout.split(",").map((R) => R.trim());
      let N = !1;
      return k.forEach((R) => {
        if (R === "->") {
          N = !0;
          return;
        }
        N ? I.push(P[R]) : E.push(P[R]);
      }), C(E[0], l.is("first")), C(E[E.length - 1], l.is("last")), N && I.length > 0 && (C(I[0], l.is("first")), C(
        I[I.length - 1],
        l.is("last")
      ), E.push(T)), ht(
        "div",
        {
          class: [
            l.b(),
            l.is("background", e.background),
            l.m(i.value)
          ]
        },
        E
      );
    };
  }
});
const ESe = Dt(xSe), OSe = Xe({
  title: String,
  confirmButtonText: String,
  cancelButtonText: String,
  confirmButtonType: {
    type: String,
    values: ix,
    default: "primary"
  },
  cancelButtonType: {
    type: String,
    values: ix,
    default: "text"
  },
  icon: {
    type: Pn,
    default: () => Sse
  },
  iconColor: {
    type: String,
    default: "#f90"
  },
  hideIcon: Boolean,
  hideAfter: {
    type: Number,
    default: 200
  },
  effect: vt(Be({}, In.effect), {
    default: "light"
  }),
  teleported: In.teleported,
  persistent: In.persistent,
  width: {
    type: [String, Number],
    default: 150
  },
  virtualTriggering: mi.virtualTriggering,
  virtualRef: mi.virtualRef
}), _Se = {
  confirm: (e) => e instanceof MouseEvent,
  cancel: (e) => e instanceof MouseEvent
}, ISe = /* @__PURE__ */ le({
  name: "ElPopconfirm",
  __name: "popconfirm",
  props: OSe,
  emits: _Se,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, { t: r } = an(), a = Ve("popconfirm"), i = /* @__PURE__ */ H(), s = /* @__PURE__ */ H(), c = O(() => {
      var g;
      return (g = S(i)) == null ? void 0 : g.popperRef;
    }), u = () => {
      var g, y;
      (y = (g = s.value) == null ? void 0 : g.focus) == null || y.call(g);
    }, d = () => {
      var g, y;
      (y = (g = i.value) == null ? void 0 : g.onClose) == null || y.call(g);
    }, f = O(() => ({
      width: ao(o.width)
    })), p = (g) => {
      l("confirm", g), d();
    }, m = (g) => {
      l("cancel", g), d();
    }, v = O(
      () => o.confirmButtonText || r("el.popconfirm.confirmButtonText")
    ), h = O(
      () => o.cancelButtonText || r("el.popconfirm.cancelButtonText")
    );
    return t({
      popperRef: c,
      hide: d
    }), (g, y) => (G(), Me(S(al), Ut({
      ref_key: "tooltipRef",
      ref: i,
      trigger: "click",
      effect: g.effect
    }, g.$attrs, {
      "virtual-triggering": g.virtualTriggering,
      "virtual-ref": g.virtualRef,
      "popper-class": `${S(a).namespace.value}-popover`,
      "popper-style": f.value,
      teleported: g.teleported,
      "fallback-placements": ["bottom", "top", "right", "left"],
      "hide-after": g.hideAfter,
      persistent: g.persistent,
      loop: "",
      onShow: u
    }), {
      content: Ee(() => [
        ve(
          "div",
          {
            ref_key: "rootRef",
            ref: s,
            tabindex: "-1",
            class: X(S(a).b())
          },
          [
            ve(
              "div",
              {
                class: X(S(a).e("main"))
              },
              [
                !g.hideIcon && g.icon ? (G(), Me(S(ut), {
                  key: 0,
                  class: X(S(a).e("icon")),
                  style: gt({ color: g.iconColor })
                }, {
                  default: Ee(() => [
                    (G(), Me(Ht(g.icon)))
                  ]),
                  _: 1
                }, 8, ["class", "style"])) : Ie("v-if", !0),
                Ft(
                  " " + qe(g.title),
                  1
                )
              ],
              2
            ),
            ve(
              "div",
              {
                class: X(S(a).e("action"))
              },
              [
                Oe(g.$slots, "actions", {
                  confirm: p,
                  cancel: m
                }, () => [
                  $(S(Qo), {
                    size: "small",
                    type: g.cancelButtonType === "text" ? "" : g.cancelButtonType,
                    text: g.cancelButtonType === "text",
                    onClick: m
                  }, {
                    default: Ee(() => [
                      Ft(
                        qe(h.value),
                        1
                      )
                    ]),
                    _: 1
                  }, 8, ["type", "text"]),
                  $(S(Qo), {
                    size: "small",
                    type: g.confirmButtonType === "text" ? "" : g.confirmButtonType,
                    text: g.confirmButtonType === "text",
                    onClick: p
                  }, {
                    default: Ee(() => [
                      Ft(
                        qe(v.value),
                        1
                      )
                    ]),
                    _: 1
                  }, 8, ["type", "text"])
                ])
              ],
              2
            )
          ],
          2
        )
      ]),
      default: Ee(() => [
        g.$slots.reference ? Oe(g.$slots, "reference", { key: 0 }) : Ie("v-if", !0)
      ]),
      _: 3
    }, 16, ["effect", "virtual-triggering", "virtual-ref", "popper-class", "popper-style", "teleported", "hide-after", "persistent"]));
  }
});
var TSe = /* @__PURE__ */ Je(ISe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popconfirm/src/popconfirm.vue"]]);
const PSe = Dt(TSe), kSe = Xe({
  trigger: mi.trigger,
  triggerKeys: mi.triggerKeys,
  placement: pb.placement,
  disabled: mi.disabled,
  visible: In.visible,
  transition: In.transition,
  popperOptions: pb.popperOptions,
  tabindex: pb.tabindex,
  content: In.content,
  popperStyle: In.popperStyle,
  popperClass: In.popperClass,
  enterable: vt(Be({}, In.enterable), {
    default: !0
  }),
  effect: vt(Be({}, In.effect), {
    default: "light"
  }),
  teleported: In.teleported,
  appendTo: In.appendTo,
  title: String,
  width: {
    type: [String, Number],
    default: 150
  },
  offset: {
    type: Number,
    default: void 0
  },
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  autoClose: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  persistent: {
    type: Boolean,
    default: !0
  },
  "onUpdate:visible": {
    type: Function
  }
}), NSe = {
  "update:visible": (e) => Tn(e),
  "before-enter": () => !0,
  "before-leave": () => !0,
  "after-enter": () => !0,
  "after-leave": () => !0
}, MSe = "onUpdate:visible", ASe = /* @__PURE__ */ le({
  name: "ElPopover",
  __name: "popover",
  props: kSe,
  emits: NSe,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = O(() => o[MSe]), a = Ve("popover"), i = /* @__PURE__ */ H(), s = O(() => {
      var g;
      return (g = S(i)) == null ? void 0 : g.popperRef;
    }), c = O(() => [
      {
        width: ao(o.width)
      },
      o.popperStyle
    ]), u = O(() => [a.b(), o.popperClass, { [a.m("plain")]: !!o.content }]), d = O(() => o.transition === `${a.namespace.value}-fade-in-linear`), f = () => {
      var g;
      (g = i.value) == null || g.hide();
    }, p = () => {
      l("before-enter");
    }, m = () => {
      l("before-leave");
    }, v = () => {
      l("after-enter");
    }, h = () => {
      l("update:visible", !1), l("after-leave");
    };
    return t({
      popperRef: s,
      hide: f
    }), (g, y) => (G(), Me(S(al), Ut({
      ref_key: "tooltipRef",
      ref: i
    }, g.$attrs, {
      trigger: g.trigger,
      "trigger-keys": g.triggerKeys,
      placement: g.placement,
      disabled: g.disabled,
      visible: g.visible,
      transition: g.transition,
      "popper-options": g.popperOptions,
      tabindex: g.tabindex,
      content: g.content,
      offset: g.offset,
      "show-after": g.showAfter,
      "hide-after": g.hideAfter,
      "auto-close": g.autoClose,
      "show-arrow": g.showArrow,
      "aria-label": g.title,
      effect: g.effect,
      enterable: g.enterable,
      "popper-class": u.value,
      "popper-style": c.value,
      teleported: g.teleported,
      "append-to": g.appendTo,
      persistent: g.persistent,
      "gpu-acceleration": d.value,
      "onUpdate:visible": r.value,
      onBeforeShow: p,
      onBeforeHide: m,
      onShow: v,
      onHide: h
    }), {
      content: Ee(() => [
        g.title ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(a).e("title")),
            role: "title"
          },
          qe(g.title),
          3
        )) : Ie("v-if", !0),
        Oe(g.$slots, "default", {}, () => [
          Ft(
            qe(g.content),
            1
          )
        ])
      ]),
      default: Ee(() => [
        g.$slots.reference ? Oe(g.$slots, "reference", { key: 0 }) : Ie("v-if", !0)
      ]),
      _: 3
    }, 16, ["trigger", "trigger-keys", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "append-to", "persistent", "gpu-acceleration", "onUpdate:visible"]));
  }
});
var RSe = /* @__PURE__ */ Je(ASe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popover/src/popover.vue"]]);
const xN = (e, t) => {
  const n = t.arg || t.value, o = n == null ? void 0 : n.popperRef;
  o && (o.triggerRef = e);
};
var DSe = {
  mounted(e, t) {
    xN(e, t);
  },
  updated(e, t) {
    xN(e, t);
  }
};
const LSe = "popover", Q9 = Cie(DSe, LSe), BSe = Dt(RSe, {
  directive: Q9
}), FSe = Xe({
  type: {
    type: String,
    default: "line",
    values: ["line", "circle", "dashboard"]
  },
  percentage: {
    type: Number,
    default: 0,
    validator: (e) => e >= 0 && e <= 100
  },
  status: {
    type: String,
    default: "",
    values: ["", "success", "exception", "warning"]
  },
  indeterminate: Boolean,
  duration: {
    type: Number,
    default: 3
  },
  strokeWidth: {
    type: Number,
    default: 6
  },
  strokeLinecap: {
    type: ye(String),
    default: "round"
  },
  textInside: Boolean,
  width: {
    type: Number,
    default: 126
  },
  showText: {
    type: Boolean,
    default: !0
  },
  color: {
    type: ye([
      String,
      Array,
      Function
    ]),
    default: ""
  },
  striped: Boolean,
  stripedFlow: Boolean,
  format: {
    type: ye(Function),
    default: (e) => `${e}%`
  }
}), VSe = ["aria-valuenow"], zSe = { viewBox: "0 0 100 100" }, HSe = ["d", "stroke", "stroke-linecap", "stroke-width"], jSe = ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"], WSe = { key: 0 }, KSe = /* @__PURE__ */ le({
  name: "ElProgress",
  __name: "progress",
  props: FSe,
  setup(e) {
    const t = {
      success: "#13ce66",
      exception: "#ff4949",
      warning: "#e6a23c",
      default: "#20a0ff"
    }, n = e, o = Ve("progress"), l = O(() => {
      const b = {
        width: `${n.percentage}%`,
        animationDuration: `${n.duration}s`
      }, C = y(n.percentage);
      return C.includes("gradient") ? b.background = C : b.backgroundColor = C, b;
    }), r = O(
      () => (n.strokeWidth / n.width * 100).toFixed(1)
    ), a = O(() => ["circle", "dashboard"].includes(n.type) ? Number.parseInt(
      `${50 - Number.parseFloat(r.value) / 2}`,
      10
    ) : 0), i = O(() => {
      const b = a.value, C = n.type === "dashboard";
      return `
          M 50 50
          m 0 ${C ? "" : "-"}${b}
          a ${b} ${b} 0 1 1 0 ${C ? "-" : ""}${b * 2}
          a ${b} ${b} 0 1 1 0 ${C ? "" : "-"}${b * 2}
          `;
    }), s = O(() => 2 * Math.PI * a.value), c = O(() => n.type === "dashboard" ? 0.75 : 1), u = O(() => `${-1 * s.value * (1 - c.value) / 2}px`), d = O(() => ({
      strokeDasharray: `${s.value * c.value}px, ${s.value}px`,
      strokeDashoffset: u.value
    })), f = O(() => ({
      strokeDasharray: `${s.value * c.value * (n.percentage / 100)}px, ${s.value}px`,
      strokeDashoffset: u.value,
      transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
    })), p = O(() => {
      let b;
      return n.color ? b = y(n.percentage) : b = t[n.status] || t.default, b;
    }), m = O(() => n.status === "warning" ? R1 : n.type === "line" ? n.status === "success" ? MO : Es : n.status === "success" ? ch : aa), v = O(() => n.type === "line" ? 12 + n.strokeWidth * 0.4 : n.width * 0.111111 + 2), h = O(() => n.format(n.percentage));
    function g(b) {
      const C = 100 / b.length;
      return b.map((x, E) => rt(x) ? {
        color: x,
        percentage: (E + 1) * C
      } : x).sort((x, E) => x.percentage - E.percentage);
    }
    const y = (b) => {
      var C;
      const { color: w } = n;
      if (it(w))
        return w(b);
      if (rt(w))
        return w;
      {
        const x = g(w);
        for (const E of x)
          if (E.percentage > b)
            return E.color;
        return (C = x[x.length - 1]) == null ? void 0 : C.color;
      }
    };
    return (b, C) => (G(), ue("div", {
      class: X([
        S(o).b(),
        S(o).m(b.type),
        S(o).is(b.status),
        {
          [S(o).m("without-text")]: !b.showText,
          [S(o).m("text-inside")]: b.textInside
        }
      ]),
      role: "progressbar",
      "aria-valuenow": b.percentage,
      "aria-valuemin": "0",
      "aria-valuemax": "100"
    }, [
      b.type === "line" ? (G(), ue(
        "div",
        {
          key: 0,
          class: X(S(o).b("bar"))
        },
        [
          ve(
            "div",
            {
              class: X(S(o).be("bar", "outer")),
              style: gt({ height: `${b.strokeWidth}px` })
            },
            [
              ve(
                "div",
                {
                  class: X([
                    S(o).be("bar", "inner"),
                    { [S(o).bem("bar", "inner", "indeterminate")]: b.indeterminate },
                    { [S(o).bem("bar", "inner", "striped")]: b.striped },
                    { [S(o).bem("bar", "inner", "striped-flow")]: b.stripedFlow }
                  ]),
                  style: gt(l.value)
                },
                [
                  (b.showText || b.$slots.default) && b.textInside ? (G(), ue(
                    "div",
                    {
                      key: 0,
                      class: X(S(o).be("bar", "innerText"))
                    },
                    [
                      Oe(b.$slots, "default", { percentage: b.percentage }, () => [
                        ve(
                          "span",
                          null,
                          qe(h.value),
                          1
                        )
                      ])
                    ],
                    2
                  )) : Ie("v-if", !0)
                ],
                6
              )
            ],
            6
          )
        ],
        2
      )) : (G(), ue(
        "div",
        {
          key: 1,
          class: X(S(o).b("circle")),
          style: gt({ height: `${b.width}px`, width: `${b.width}px` })
        },
        [
          (G(), ue("svg", zSe, [
            ve("path", {
              class: X(S(o).be("circle", "track")),
              d: i.value,
              stroke: `var(${S(o).cssVarName("fill-color-light")}, #e5e9f2)`,
              "stroke-linecap": b.strokeLinecap,
              "stroke-width": r.value,
              fill: "none",
              style: gt(d.value)
            }, null, 14, HSe),
            ve("path", {
              class: X(S(o).be("circle", "path")),
              d: i.value,
              stroke: p.value,
              fill: "none",
              opacity: b.percentage ? 1 : 0,
              "stroke-linecap": b.strokeLinecap,
              "stroke-width": r.value,
              style: gt(f.value)
            }, null, 14, jSe)
          ]))
        ],
        6
      )),
      (b.showText || b.$slots.default) && !b.textInside ? (G(), ue(
        "div",
        {
          key: 2,
          class: X(S(o).e("text")),
          style: gt({ fontSize: `${v.value}px` })
        },
        [
          Oe(b.$slots, "default", { percentage: b.percentage }, () => [
            b.status ? (G(), Me(S(ut), { key: 1 }, {
              default: Ee(() => [
                (G(), Me(Ht(m.value)))
              ]),
              _: 1
            })) : (G(), ue(
              "span",
              WSe,
              qe(h.value),
              1
            ))
          ])
        ],
        6
      )) : Ie("v-if", !0)
    ], 10, VSe));
  }
});
var USe = /* @__PURE__ */ Je(KSe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/progress/src/progress.vue"]]);
const eV = Dt(USe), GSe = Xe(Be({
  modelValue: {
    type: Number,
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  lowThreshold: {
    type: Number,
    default: 2
  },
  highThreshold: {
    type: Number,
    default: 4
  },
  max: {
    type: Number,
    default: 5
  },
  colors: {
    type: ye([Array, Object]),
    default: () => lo(["", "", ""])
  },
  voidColor: {
    type: String,
    default: ""
  },
  disabledVoidColor: {
    type: String,
    default: ""
  },
  icons: {
    type: ye([Array, Object]),
    default: () => [og, og, og]
  },
  voidIcon: {
    type: Pn,
    default: () => Rse
  },
  disabledVoidIcon: {
    type: Pn,
    default: () => og
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  allowHalf: Boolean,
  showText: Boolean,
  showScore: Boolean,
  textColor: {
    type: String,
    default: ""
  },
  texts: {
    type: ye(Array),
    default: () => lo([
      "Extremely bad",
      "Disappointed",
      "Fair",
      "Satisfied",
      "Surprise"
    ])
  },
  scoreTemplate: {
    type: String,
    default: "{value}"
  },
  size: Bo,
  clearable: Boolean
}, zl(["ariaLabel"]))), YSe = {
  [en]: (e) => mt(e),
  [It]: (e) => mt(e)
}, XSe = ["id", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuetext", "aria-valuemax"], qSe = ["onMousemove", "onClick"], JSe = /* @__PURE__ */ le({
  name: "ElRate",
  __name: "rate",
  props: GSe,
  emits: YSe,
  setup(e, { expose: t, emit: n }) {
    function o(A, L) {
      const B = (W) => Mt(W), V = Object.keys(L).map((W) => +W).filter((W) => {
        const Y = L[W];
        return (B(Y) ? Y.excluded : !1) ? A < W : A <= W;
      }).sort((W, Y) => W - Y), j = L[V[0]];
      return B(j) && j.value || j;
    }
    const l = e, r = n, a = ze($i, void 0), i = Mo(), s = Ve("rate"), { inputId: c, isLabeledByFormItem: u } = zr(l, {
      formItemContext: a
    }), d = /* @__PURE__ */ H(l.modelValue), f = /* @__PURE__ */ H(-1), p = /* @__PURE__ */ H(!0), m = /* @__PURE__ */ H([]), v = O(
      () => m.value.map((A) => A.$el.clientWidth)
    ), h = O(() => [s.b(), s.m(i.value)]), g = io(), y = O(() => s.cssVarBlock({
      "void-color": l.voidColor,
      "disabled-void-color": l.disabledVoidColor,
      "fill-color": x.value
    })), b = O(() => {
      let A = "";
      return l.showScore ? A = l.scoreTemplate.replace(
        /\{\s*value\s*\}/,
        g.value ? `${l.modelValue}` : `${d.value}`
      ) : l.showText && (A = l.texts[Math.ceil(d.value) - 1]), A;
    }), C = O(
      () => l.modelValue * 100 - Math.floor(l.modelValue) * 100
    ), w = O(
      () => We(l.colors) ? {
        [l.lowThreshold]: l.colors[0],
        [l.highThreshold]: { value: l.colors[1], excluded: !0 },
        [l.max]: l.colors[2]
      } : l.colors
    ), x = O(() => {
      const A = o(d.value, w.value);
      return Mt(A) ? "" : A;
    }), E = O(() => {
      let A = "";
      return g.value ? A = `${C.value}%` : l.allowHalf && (A = "50%"), {
        color: x.value,
        width: A
      };
    }), I = O(() => {
      let A = We(l.icons) ? [...l.icons] : Be({}, l.icons);
      return A = wa(A), We(A) ? {
        [l.lowThreshold]: A[0],
        [l.highThreshold]: {
          value: A[1],
          excluded: !0
        },
        [l.max]: A[2]
      } : A;
    }), T = O(
      () => o(l.modelValue, I.value)
    ), P = O(
      () => g.value ? rt(l.disabledVoidIcon) ? l.disabledVoidIcon : wa(l.disabledVoidIcon) : rt(l.voidIcon) ? l.voidIcon : wa(l.voidIcon)
    ), k = O(
      () => o(d.value, I.value)
    );
    function N(A) {
      const L = g.value && C.value > 0 && A - 1 < l.modelValue && A > l.modelValue, B = l.allowHalf && p.value && A - 0.5 <= d.value && A > d.value;
      return L || B;
    }
    function R(A) {
      l.clearable && A === l.modelValue && (A = 0), r(It, A), l.modelValue !== A && r(en, A);
    }
    function z(A) {
      g.value || (l.allowHalf && p.value ? R(d.value) : R(A));
    }
    function D(A) {
      if (g.value)
        return;
      const L = Nn(A), B = l.allowHalf ? 0.5 : 1;
      let V = d.value;
      switch (L) {
        case Ye.up:
        case Ye.right:
          V += B;
          break;
        case Ye.left:
        case Ye.down:
          V -= B;
          break;
      }
      if (V = T1(V, 0, l.max), V !== d.value)
        return A.stopPropagation(), A.preventDefault(), r(It, V), r(en, V), V;
    }
    function F(A, L) {
      g.value || (l.allowHalf && L ? (p.value = L.offsetX * 2 <= v.value[A - 1], d.value = p.value ? A - 0.5 : A) : d.value = A, f.value = A);
    }
    function M() {
      g.value || (l.allowHalf && (p.value = l.modelValue !== Math.floor(l.modelValue)), d.value = l.modelValue, f.value = -1);
    }
    return pe(
      () => l.modelValue,
      (A) => {
        d.value = A, p.value = l.modelValue !== Math.floor(l.modelValue);
      }
    ), l.modelValue || r(It, 0), t({
      setCurrentValue: F,
      resetCurrentValue: M
    }), (A, L) => {
      var B;
      return G(), ue("div", {
        id: S(c),
        class: X([h.value, S(s).is("disabled", S(g))]),
        role: "slider",
        "aria-label": S(u) ? void 0 : A.ariaLabel || "rating",
        "aria-labelledby": S(u) ? (B = S(a)) == null ? void 0 : B.labelId : void 0,
        "aria-valuenow": d.value,
        "aria-valuetext": b.value || void 0,
        "aria-valuemin": "0",
        "aria-valuemax": A.max,
        tabindex: "0",
        style: gt(y.value),
        onKeydown: D
      }, [
        (G(!0), ue(
          Ge,
          null,
          on(A.max, (V, j) => (G(), ue("span", {
            key: j,
            class: X(S(s).e("item")),
            onMousemove: (W) => F(V, W),
            onMouseleave: M,
            onClick: (W) => z(V)
          }, [
            $(S(ut), {
              ref_for: !0,
              ref_key: "iconRefs",
              ref: m,
              class: X([
                S(s).e("icon"),
                { hover: f.value === V },
                S(s).is("active", V <= d.value),
                S(s).is("focus-visible", V === Math.ceil(d.value || 1))
              ])
            }, {
              default: Ee(() => [
                _t((G(), Me(
                  Ht(k.value),
                  null,
                  null,
                  512
                )), [
                  [Jt, !N(V) && V <= d.value]
                ]),
                _t((G(), Me(
                  Ht(P.value),
                  null,
                  null,
                  512
                )), [
                  [Jt, !N(V) && V > d.value]
                ]),
                _t((G(), Me(Ht(P.value), {
                  class: X([S(s).em("decimal", "box")])
                }, null, 8, ["class"])), [
                  [Jt, N(V)]
                ]),
                _t($(S(ut), {
                  style: gt(E.value),
                  class: X([S(s).e("icon"), S(s).e("decimal")])
                }, {
                  default: Ee(() => [
                    (G(), Me(Ht(T.value)))
                  ]),
                  _: 1
                }, 8, ["style", "class"]), [
                  [Jt, N(V)]
                ])
              ]),
              _: 2
            }, 1032, ["class"])
          ], 42, qSe))),
          128
        )),
        A.showText || A.showScore ? (G(), ue(
          "span",
          {
            key: 0,
            class: X(S(s).e("text")),
            style: gt({ color: A.textColor })
          },
          qe(b.value),
          7
        )) : Ie("v-if", !0)
      ], 46, XSe);
    };
  }
});
var ZSe = /* @__PURE__ */ Je(JSe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/rate/src/rate.vue"]]);
const QSe = Dt(ZSe), nu = {
  primary: "icon-primary",
  success: "icon-success",
  warning: "icon-warning",
  error: "icon-error",
  info: "icon-info"
}, EN = {
  [nu.primary]: sm,
  [nu.success]: Gie,
  [nu.warning]: R1,
  [nu.error]: AO,
  [nu.info]: sm
}, eCe = Xe({
  title: {
    type: String,
    default: ""
  },
  subTitle: {
    type: String,
    default: ""
  },
  icon: {
    type: String,
    values: ["primary", "success", "warning", "info", "error"],
    default: "info"
  }
}), tCe = /* @__PURE__ */ le({
  name: "ElResult",
  __name: "result",
  props: eCe,
  setup(e) {
    const t = e, n = Ve("result"), o = O(() => {
      const l = t.icon, r = l && nu[l] ? nu[l] : "icon-info", a = EN[r] || EN["icon-info"];
      return {
        class: r,
        component: a
      };
    });
    return (l, r) => (G(), ue(
      "div",
      {
        class: X(S(n).b())
      },
      [
        ve(
          "div",
          {
            class: X(S(n).e("icon"))
          },
          [
            Oe(l.$slots, "icon", {}, () => [
              o.value.component ? (G(), Me(Ht(o.value.component), {
                key: 0,
                class: X(o.value.class)
              }, null, 8, ["class"])) : Ie("v-if", !0)
            ])
          ],
          2
        ),
        l.title || l.$slots.title ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(n).e("title"))
          },
          [
            Oe(l.$slots, "title", {}, () => [
              ve(
                "p",
                null,
                qe(l.title),
                1
              )
            ])
          ],
          2
        )) : Ie("v-if", !0),
        l.subTitle || l.$slots["sub-title"] ? (G(), ue(
          "div",
          {
            key: 1,
            class: X(S(n).e("subtitle"))
          },
          [
            Oe(l.$slots, "sub-title", {}, () => [
              ve(
                "p",
                null,
                qe(l.subTitle),
                1
              )
            ])
          ],
          2
        )) : Ie("v-if", !0),
        l.$slots.extra ? (G(), ue(
          "div",
          {
            key: 2,
            class: X(S(n).e("extra"))
          },
          [
            Oe(l.$slots, "extra")
          ],
          2
        )) : Ie("v-if", !0)
      ],
      2
    ));
  }
});
var nCe = /* @__PURE__ */ Je(tCe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/result/src/result.vue"]]);
const oCe = Dt(nCe), lCe = [
  "start",
  "center",
  "end",
  "space-around",
  "space-between",
  "space-evenly"
], rCe = ["top", "middle", "bottom"], aCe = Xe({
  tag: {
    type: String,
    default: "div"
  },
  gutter: {
    type: Number,
    default: 0
  },
  justify: {
    type: String,
    values: lCe,
    default: "start"
  },
  align: {
    type: String,
    values: rCe
  }
}), iCe = /* @__PURE__ */ le({
  name: "ElRow",
  __name: "row",
  props: aCe,
  setup(e) {
    const t = e, n = Ve("row"), o = O(() => t.gutter);
    at(jF, {
      gutter: o
    });
    const l = O(() => {
      const a = {};
      return t.gutter && (a.marginRight = a.marginLeft = `-${t.gutter / 2}px`), a;
    }), r = O(() => [
      n.b(),
      n.is(`justify-${t.justify}`, t.justify !== "start"),
      n.is(`align-${t.align}`, !!t.align)
    ]);
    return (a, i) => (G(), Me(Ht(a.tag), {
      class: X(r.value),
      style: gt(l.value)
    }, {
      default: Ee(() => [
        Oe(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "style"]));
  }
});
var sCe = /* @__PURE__ */ Je(iCe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/row/src/row.vue"]]);
const cCe = Dt(sCe), uCe = /* @__PURE__ */ le({
  props: {
    item: {
      type: Object,
      required: !0
    },
    style: {
      type: Object
    },
    height: Number
  },
  setup() {
    return {
      ns: Ve("select")
    };
  }
});
function dCe(e, t, n, o, l, r) {
  return G(), ue(
    "div",
    {
      class: X(e.ns.be("group", "title")),
      style: gt(vt(Be({}, e.style), { lineHeight: `${e.height}px` }))
    },
    qe(e.item.label),
    7
  );
}
var fCe = /* @__PURE__ */ Je(uCe, [["render", dCe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/group-item.vue"]]);
function pCe(e, { emit: t }) {
  return {
    hoverItem: () => {
      e.disabled || t("hover", e.index);
    },
    selectOptionClick: () => {
      e.disabled || t("select", e.item, e.index);
    }
  };
}
const vCe = Xe(Be(Be({
  allowCreate: Boolean,
  autocomplete: {
    type: ye(String),
    default: "none"
  },
  automaticDropdown: Boolean,
  clearable: Boolean,
  clearIcon: {
    type: Pn,
    default: Es
  },
  effect: {
    type: ye(String),
    default: "light"
  },
  collapseTags: Boolean,
  collapseTagsTooltip: Boolean,
  maxCollapseTags: {
    type: Number,
    default: 1
  },
  defaultFirstOption: Boolean,
  disabled: {
    type: Boolean,
    default: void 0
  },
  estimatedOptionHeight: {
    type: Number,
    default: void 0
  },
  filterable: Boolean,
  filterMethod: {
    type: ye(Function)
  },
  height: {
    type: Number,
    default: 274
  },
  itemHeight: {
    type: Number,
    default: 34
  },
  id: String,
  loading: Boolean,
  loadingText: String,
  modelValue: {
    type: ye([Array, String, Number, Boolean, Object]),
    default: void 0
  },
  multiple: Boolean,
  multipleLimit: {
    type: Number,
    default: 0
  },
  name: String,
  noDataText: String,
  noMatchText: String,
  remoteMethod: {
    type: ye(Function)
  },
  reserveKeyword: {
    type: Boolean,
    default: !0
  },
  options: {
    type: ye(Array),
    required: !0
  },
  placeholder: {
    type: String
  },
  teleported: In.teleported,
  persistent: {
    type: Boolean,
    default: !0
  },
  popperClass: In.popperClass,
  popperStyle: In.popperStyle,
  popperOptions: {
    type: ye(Object),
    default: () => ({})
  },
  remote: Boolean,
  debounce: {
    type: Number,
    default: 300
  },
  size: Bo,
  props: {
    type: ye(Object),
    default: () => A0
  },
  valueKey: {
    type: String,
    default: "value"
  },
  scrollbarAlwaysOn: Boolean,
  validateEvent: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 12
  },
  remoteShowSuffix: Boolean,
  showArrow: {
    type: Boolean,
    default: !0
  },
  placement: {
    type: ye(String),
    values: Mi,
    default: "bottom-start"
  },
  fallbackPlacements: {
    type: ye(Array),
    default: ["bottom-start", "top-start", "right", "left"]
  },
  tagType: vt(Be({}, gs.type), { default: "info" }),
  tagEffect: vt(Be({}, gs.effect), { default: "light" }),
  tabindex: {
    type: [String, Number],
    default: 0
  },
  appendTo: In.appendTo,
  fitInputWidth: {
    type: [Boolean, Number],
    default: !0,
    validator(e) {
      return Tn(e) || mt(e);
    }
  },
  suffixIcon: {
    type: Pn,
    default: Ni
  }
}, ad), zl(["ariaLabel"]))), mCe = Xe({
  data: Array,
  disabled: Boolean,
  hovering: Boolean,
  item: {
    type: ye(Object),
    required: !0
  },
  index: Number,
  style: Object,
  selected: Boolean,
  created: Boolean
}), hCe = {
  [It]: (e) => !0,
  [en]: (e) => !0,
  "remove-tag": (e) => !0,
  "visible-change": (e) => !0,
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent,
  clear: () => !0
}, gCe = {
  hover: (e) => mt(e),
  select: (e, t) => !0
}, w_ = Symbol(
  "ElSelectV2Injection"
), bCe = /* @__PURE__ */ le({
  props: mCe,
  emits: gCe,
  setup(e, { emit: t }) {
    const n = ze(w_), o = Ve("select"), { hoverItem: l, selectOptionClick: r } = pCe(e, { emit: t }), { getLabel: a } = mh(n.props), i = n.contentId;
    return {
      ns: o,
      contentId: i,
      hoverItem: l,
      selectOptionClick: r,
      getLabel: a
    };
  }
}), yCe = ["id", "aria-selected", "aria-disabled"];
function SCe(e, t, n, o, l, r) {
  return G(), ue("li", {
    id: `${e.contentId}-${e.index}`,
    role: "option",
    "aria-selected": e.selected,
    "aria-disabled": e.disabled || void 0,
    style: gt(e.style),
    class: X([
      e.ns.be("dropdown", "item"),
      e.ns.is("selected", e.selected),
      e.ns.is("disabled", e.disabled),
      e.ns.is("created", e.created),
      e.ns.is("hovering", e.hovering)
    ]),
    onMousemove: t[0] || (t[0] = (...a) => e.hoverItem && e.hoverItem(...a)),
    onClick: t[1] || (t[1] = Et((...a) => e.selectOptionClick && e.selectOptionClick(...a), ["stop"]))
  }, [
    Oe(e.$slots, "default", {
      item: e.item,
      index: e.index,
      disabled: e.disabled
    }, () => [
      ve(
        "span",
        null,
        qe(e.getLabel(e.item)),
        1
      )
    ])
  ], 46, yCe);
}
var CCe = /* @__PURE__ */ Je(bCe, [["render", SCe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/option-item.vue"]]), ON = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function wCe(e, t) {
  return !!(e === t || ON(e) && ON(t));
}
function $Ce(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!wCe(e[n], t[n]))
      return !1;
  return !0;
}
function xCe(e, t) {
  t === void 0 && (t = $Ce);
  var n = null;
  function o() {
    for (var l = [], r = 0; r < arguments.length; r++)
      l[r] = arguments[r];
    if (n && n.lastThis === this && t(l, n.lastArgs))
      return n.lastResult;
    var a = e.apply(this, l);
    return n = {
      lastResult: a,
      lastArgs: l,
      lastThis: this
    }, a;
  }
  return o.clear = function() {
    n = null;
  }, o;
}
const tV = () => {
  const t = xt().proxy.$props;
  return O(() => {
    const n = (o, l, r) => ({});
    return t.perfMode ? O1(n) : xCe(n);
  });
}, Ex = 50, j0 = "itemRendered", W0 = "scroll", Xd = "forward", K0 = "backward", Qr = "auto", Y1 = "smart", bm = "start", di = "center", ym = "end", Zf = "horizontal", nV = "vertical", ECe = "ltr", pf = "rtl", Sm = "negative", $_ = "positive-ascending", x_ = "positive-descending", OCe = {
  [Zf]: "left",
  [nV]: "top"
}, _Ce = 20, oV = ({ atEndEdge: e, atStartEdge: t, layout: n }, o) => {
  let l, r = 0;
  const a = (s) => s < 0 && t.value || s > 0 && e.value;
  return {
    hasReachedEdge: a,
    onWheel: (s) => {
      vs(l);
      let { deltaX: c, deltaY: u } = s;
      s.shiftKey && u !== 0 && (c = u, u = 0);
      const d = n.value === Zf ? c : u;
      a(d) || (r += d, !DO() && d !== 0 && s.preventDefault(), l = Ci(() => {
        o(r), r = 0;
      }));
    }
  };
}, Ox = Ua({
  type: ye([Number, Function]),
  required: !0
}), _x = Ua({
  type: Number
}), Ix = Ua({
  type: Number,
  default: 2
}), ICe = Ua({
  type: String,
  values: ["ltr", "rtl"],
  default: "ltr"
}), Tx = Ua({
  type: Number,
  default: 0
}), U0 = Ua({
  type: Number,
  required: !0
}), lV = Ua({
  type: String,
  values: ["horizontal", "vertical"],
  default: nV
}), rV = Xe({
  className: {
    type: String,
    default: ""
  },
  containerElement: {
    type: ye([String, Object]),
    default: "div"
  },
  data: {
    type: ye(Array),
    default: () => lo([])
  },
  direction: ICe,
  height: {
    type: [String, Number],
    required: !0
  },
  innerElement: {
    type: [String, Object],
    default: "div"
  },
  innerProps: {
    type: ye(Object),
    default: () => ({})
  },
  style: {
    type: ye([Object, String, Array])
  },
  useIsScrolling: Boolean,
  width: {
    type: [Number, String],
    required: !1
  },
  perfMode: {
    type: Boolean,
    default: !0
  },
  scrollbarAlwaysOn: Boolean
}), aV = Xe(Be({
  cache: Ix,
  estimatedItemSize: _x,
  layout: lV,
  initScrollOffset: Tx,
  total: U0,
  itemSize: Ox
}, rV)), Px = {
  type: Number,
  default: 6
}, iV = { type: Number, default: 0 }, sV = { type: Number, default: 2 }, Ou = Xe(Be({
  columnCache: Ix,
  columnWidth: Ox,
  estimatedColumnWidth: _x,
  estimatedRowHeight: _x,
  initScrollLeft: Tx,
  initScrollTop: Tx,
  itemKey: {
    type: ye(Function),
    default: ({
      columnIndex: e,
      rowIndex: t
    }) => `${t}:${e}`
  },
  rowCache: Ix,
  rowHeight: Ox,
  totalColumn: U0,
  totalRow: U0,
  hScrollbarSize: Px,
  vScrollbarSize: Px,
  scrollbarStartGap: iV,
  scrollbarEndGap: sV,
  role: String
}, rV)), cV = Xe({
  alwaysOn: Boolean,
  class: String,
  layout: lV,
  total: U0,
  ratio: {
    type: Number,
    required: !0
  },
  clientSize: {
    type: Number,
    required: !0
  },
  scrollFrom: {
    type: Number,
    required: !0
  },
  scrollbarSize: Px,
  startGap: iV,
  endGap: sV,
  visible: Boolean
}), pu = (e, t) => e < t ? Xd : K0, Cm = (e) => e === ECe || e === pf || e === Zf, _N = (e) => e === pf;
let Td = null;
function G0(e = !1) {
  if (Td === null || e) {
    const t = document.createElement("div"), n = t.style;
    n.width = "50px", n.height = "50px", n.overflow = "scroll", n.direction = "rtl";
    const o = document.createElement("div"), l = o.style;
    return l.width = "100px", l.height = "100px", t.appendChild(o), document.body.appendChild(t), t.scrollLeft > 0 ? Td = x_ : (t.scrollLeft = 1, t.scrollLeft === 0 ? Td = Sm : Td = $_), document.body.removeChild(t), Td;
  }
  return Td;
}
function TCe({ move: e, size: t, bar: n }, o) {
  const l = {}, r = `translate${n.axis}(${e}px)`;
  return l[n.size] = t, l.transform = r, o === "horizontal" ? l.height = "100%" : l.width = "100%", l;
}
const kx = /* @__PURE__ */ le({
  name: "ElVirtualScrollBar",
  props: cV,
  emits: ["scroll", "start-move", "stop-move"],
  setup(e, { emit: t }) {
    const n = O(() => e.startGap + e.endGap), o = Ve("virtual-scrollbar"), l = Ve("scrollbar"), r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H();
    let i = null, s = null;
    const c = /* @__PURE__ */ kt({
      isDragging: !1,
      traveled: 0
    }), u = O(() => A7[e.layout]), d = O(() => e.clientSize - S(n)), f = O(() => ({
      position: "absolute",
      width: `${Zf === e.layout ? d.value : e.scrollbarSize}px`,
      height: `${Zf === e.layout ? e.scrollbarSize : d.value}px`,
      [OCe[e.layout]]: "2px",
      right: "2px",
      bottom: "2px",
      borderRadius: "4px"
    })), p = O(() => {
      const x = e.ratio;
      if (x >= 100)
        return Number.POSITIVE_INFINITY;
      if (x >= 50)
        return x * d.value / 100;
      const E = d.value / 3;
      return Math.floor(
        Math.min(
          Math.max(x * d.value / 100, _Ce),
          E
        )
      );
    }), m = O(() => {
      if (!Number.isFinite(p.value))
        return {
          display: "none"
        };
      const x = `${p.value}px`;
      return TCe(
        {
          bar: u.value,
          size: x,
          move: c.traveled
        },
        e.layout
      );
    }), v = O(
      () => Math.ceil(e.clientSize - p.value - S(n))
    ), h = () => {
      window.addEventListener("mousemove", C), window.addEventListener("mouseup", b);
      const x = S(a);
      x && (s = document.onselectstart, document.onselectstart = () => !1, x.addEventListener("touchmove", C, { passive: !0 }), x.addEventListener("touchend", b));
    }, g = () => {
      window.removeEventListener("mousemove", C), window.removeEventListener("mouseup", b), document.onselectstart = s, s = null;
      const x = S(a);
      x && (x.removeEventListener("touchmove", C), x.removeEventListener("touchend", b));
    }, y = (x) => {
      x.stopImmediatePropagation(), !(x.ctrlKey || [1, 2].includes(x.button)) && (c.isDragging = !0, c[u.value.axis] = x.currentTarget[u.value.offset] - (x[u.value.client] - x.currentTarget.getBoundingClientRect()[u.value.direction]), t("start-move"), h());
    }, b = () => {
      c.isDragging = !1, c[u.value.axis] = 0, t("stop-move"), g();
    }, C = (x) => {
      const { isDragging: E } = c;
      if (!E || !a.value || !r.value)
        return;
      const I = c[u.value.axis];
      if (!I)
        return;
      vs(i);
      const T = (r.value.getBoundingClientRect()[u.value.direction] - x[u.value.client]) * -1, P = a.value[u.value.offset] - I, k = T - P;
      i = Ci(() => {
        c.traveled = Math.max(0, Math.min(k, v.value)), t("scroll", k, v.value);
      });
    }, w = (x) => {
      const E = Math.abs(
        x.target.getBoundingClientRect()[u.value.direction] - x[u.value.client]
      ), I = a.value[u.value.offset] / 2, T = E - I;
      c.traveled = Math.max(0, Math.min(T, v.value)), t("scroll", T, v.value);
    };
    return pe(
      () => e.scrollFrom,
      (x) => {
        c.isDragging || (c.traveled = Math.ceil(x * v.value));
      }
    ), yt(() => {
      g();
    }), () => ht(
      "div",
      {
        role: "presentation",
        ref: r,
        class: [
          o.b(),
          e.class,
          (e.alwaysOn || c.isDragging) && "always-on"
        ],
        style: f.value,
        onMousedown: Et(w, [
          "stop",
          "prevent"
        ]),
        onTouchstartPrevent: y
      },
      ht(
        "div",
        {
          ref: a,
          class: l.e("thumb"),
          style: m.value,
          onMousedown: y
        },
        []
      )
    );
  }
}), uV = ({
  name: e,
  getOffset: t,
  getItemSize: n,
  getItemOffset: o,
  getEstimatedTotalSize: l,
  getStartIndexForOffset: r,
  getStopIndexForStartIndex: a,
  initCache: i,
  clearCache: s,
  validateProps: c
}) => /* @__PURE__ */ le({
  name: e != null ? e : "ElVirtualList",
  props: aV,
  emits: [j0, W0],
  setup(u, { emit: d, expose: f }) {
    c(u);
    const p = xt(), m = Ve("vl"), v = /* @__PURE__ */ H(i(u, p)), h = tV(), g = /* @__PURE__ */ H(), y = /* @__PURE__ */ H(), b = /* @__PURE__ */ H(), C = /* @__PURE__ */ H({
      isScrolling: !1,
      scrollDir: "forward",
      scrollOffset: mt(u.initScrollOffset) ? u.initScrollOffset : 0,
      updateRequested: !1,
      isScrollbarDragging: !1,
      scrollbarAlwaysOn: u.scrollbarAlwaysOn
    }), w = O(() => {
      const { total: W, cache: Y } = u, { isScrolling: U, scrollDir: te, scrollOffset: J } = S(C);
      if (W === 0)
        return [0, 0, 0, 0];
      const re = r(
        u,
        J,
        S(v)
      ), oe = a(
        u,
        re,
        J,
        S(v)
      ), q = !U || te === K0 ? Math.max(1, Y) : 1, K = !U || te === Xd ? Math.max(1, Y) : 1;
      return [
        Math.max(0, re - q),
        Math.max(0, Math.min(W - 1, oe + K)),
        re,
        oe
      ];
    }), x = O(
      () => l(u, S(v))
    ), E = O(() => Cm(u.layout)), I = O(() => [
      {
        position: "relative",
        [`overflow-${E.value ? "x" : "y"}`]: "scroll",
        WebkitOverflowScrolling: "touch",
        willChange: "transform"
      },
      {
        direction: u.direction,
        height: mt(u.height) ? `${u.height}px` : u.height,
        width: mt(u.width) ? `${u.width}px` : u.width
      },
      u.style
    ]), T = O(() => {
      const W = S(x), Y = S(E);
      return {
        height: Y ? "100%" : `${W}px`,
        pointerEvents: S(C).isScrolling ? "none" : void 0,
        width: Y ? `${W}px` : "100%",
        margin: 0,
        boxSizing: "border-box"
      };
    }), P = O(
      () => E.value ? u.width : u.height
    ), { onWheel: k } = oV(
      {
        atStartEdge: O(() => C.value.scrollOffset <= 0),
        atEndEdge: O(
          () => C.value.scrollOffset >= x.value
        ),
        layout: O(() => u.layout)
      },
      (W) => {
        var Y, U;
        (U = (Y = b.value).onMouseUp) == null || U.call(Y), M(
          Math.min(
            C.value.scrollOffset + W,
            x.value - P.value
          )
        );
      }
    );
    wn(g, "wheel", k, {
      passive: !1
    });
    const N = () => {
      const { total: W } = u;
      if (W > 0) {
        const [J, re, oe, q] = S(w);
        d(j0, J, re, oe, q);
      }
      const { scrollDir: Y, scrollOffset: U, updateRequested: te } = S(C);
      d(W0, Y, U, te);
    }, R = (W) => {
      const { clientHeight: Y, scrollHeight: U, scrollTop: te } = W.currentTarget, J = S(C);
      if (J.scrollOffset === te)
        return;
      const re = Math.max(
        0,
        Math.min(te, U - Y)
      );
      C.value = vt(Be({}, J), {
        isScrolling: !0,
        scrollDir: pu(J.scrollOffset, re),
        scrollOffset: re,
        updateRequested: !1
      }), Ke(B);
    }, z = (W) => {
      const { clientWidth: Y, scrollLeft: U, scrollWidth: te } = W.currentTarget, J = S(C);
      if (J.scrollOffset === U)
        return;
      const { direction: re } = u;
      let oe = U;
      if (re === pf)
        switch (G0()) {
          case Sm: {
            oe = -U;
            break;
          }
          case x_: {
            oe = te - Y - U;
            break;
          }
        }
      oe = Math.max(
        0,
        Math.min(oe, te - Y)
      ), C.value = vt(Be({}, J), {
        isScrolling: !0,
        scrollDir: pu(J.scrollOffset, oe),
        scrollOffset: oe,
        updateRequested: !1
      }), Ke(B);
    }, D = (W) => {
      S(E) ? z(W) : R(W), N();
    }, F = (W, Y) => {
      const U = (x.value - P.value) / Y * W;
      M(
        Math.min(
          x.value - P.value,
          U
        )
      );
    }, M = (W) => {
      W = Math.max(W, 0), W !== S(C).scrollOffset && (C.value = vt(Be({}, S(C)), {
        scrollOffset: W,
        scrollDir: pu(S(C).scrollOffset, W),
        updateRequested: !0
      }), Ke(B));
    }, A = (W, Y = Qr) => {
      const { scrollOffset: U } = S(C);
      W = Math.max(0, Math.min(W, u.total - 1)), M(
        t(
          u,
          W,
          Y,
          U,
          S(v)
        )
      );
    }, L = (W) => {
      const { direction: Y, itemSize: U, layout: te } = u, J = h.value(
        s && U,
        s && te,
        s && Y
      );
      let re;
      if (hn(J, String(W)))
        re = J[W];
      else {
        const oe = o(u, W, S(v)), q = n(u, W, S(v)), K = S(E), se = Y === pf, Z = K ? oe : 0;
        J[W] = re = {
          position: "absolute",
          left: se ? void 0 : `${Z}px`,
          right: se ? `${Z}px` : void 0,
          top: K ? 0 : `${oe}px`,
          height: K ? "100%" : `${q}px`,
          width: K ? `${q}px` : "100%"
        };
      }
      return re;
    }, B = () => {
      C.value.isScrolling = !1, Ke(() => {
        h.value(-1, null, null);
      });
    }, V = () => {
      const W = g.value;
      W && (W.scrollTop = 0);
    };
    nt(() => {
      if (!Sn)
        return;
      const { initScrollOffset: W } = u, Y = S(g);
      mt(W) && Y && (S(E) ? Y.scrollLeft = W : Y.scrollTop = W), N();
    }), $o(() => {
      const { direction: W, layout: Y } = u, { scrollOffset: U, updateRequested: te } = S(C), J = S(g);
      if (te && J)
        if (Y === Zf)
          if (W === pf)
            switch (G0()) {
              case Sm: {
                J.scrollLeft = -U;
                break;
              }
              case $_: {
                J.scrollLeft = U;
                break;
              }
              default: {
                const { clientWidth: re, scrollWidth: oe } = J;
                J.scrollLeft = oe - re - U;
                break;
              }
            }
          else
            J.scrollLeft = U;
        else
          J.scrollTop = U;
    }), nd(() => {
      S(g).scrollTop = S(C).scrollOffset;
    });
    const j = {
      ns: m,
      clientSize: P,
      estimatedTotalSize: x,
      windowStyle: I,
      windowRef: g,
      innerRef: y,
      innerStyle: T,
      itemsToRender: w,
      scrollbarRef: b,
      states: C,
      getItemStyle: L,
      onScroll: D,
      onScrollbarScroll: F,
      onWheel: k,
      scrollTo: M,
      scrollToItem: A,
      resetScrollTop: V
    };
    return f({
      windowRef: g,
      innerRef: y,
      getItemStyleCache: h,
      scrollTo: M,
      scrollToItem: A,
      resetScrollTop: V,
      states: C
    }), j;
  },
  render(u) {
    var d;
    const {
      $slots: f,
      className: p,
      clientSize: m,
      containerElement: v,
      data: h,
      getItemStyle: g,
      innerElement: y,
      itemsToRender: b,
      innerStyle: C,
      layout: w,
      total: x,
      onScroll: E,
      onScrollbarScroll: I,
      states: T,
      useIsScrolling: P,
      windowStyle: k,
      ns: N
    } = u, [R, z] = b, D = Ht(v), F = Ht(y), M = [];
    if (x > 0)
      for (let V = R; V <= z; V++)
        M.push(
          ht(
            Ge,
            { key: V },
            (d = f.default) == null ? void 0 : d.call(f, {
              data: h,
              index: V,
              isScrolling: P ? T.isScrolling : void 0,
              style: g(V)
            })
          )
        );
    const A = [
      ht(
        F,
        Ut(u.innerProps, {
          style: C,
          ref: "innerRef"
        }),
        rt(F) ? M : {
          default: () => M
        }
      )
    ], L = ht(kx, {
      ref: "scrollbarRef",
      clientSize: m,
      layout: w,
      onScroll: I,
      ratio: m * 100 / this.estimatedTotalSize,
      scrollFrom: T.scrollOffset / (this.estimatedTotalSize - m),
      total: x,
      alwaysOn: T.scrollbarAlwaysOn
    }), B = ht(
      D,
      {
        class: [N.e("window"), p],
        style: k,
        onScroll: E,
        ref: "windowRef",
        key: 0
      },
      rt(D) ? [A] : { default: () => [A] }
    );
    return ht(
      "div",
      {
        key: 0,
        class: [N.e("wrapper"), T.scrollbarAlwaysOn ? "always-on" : ""]
      },
      [B, L]
    );
  }
}), dV = uV({
  name: "ElFixedSizeList",
  getItemOffset: ({ itemSize: e }, t) => t * e,
  getItemSize: ({ itemSize: e }) => e,
  getEstimatedTotalSize: ({ total: e, itemSize: t }) => t * e,
  getOffset: ({ height: e, total: t, itemSize: n, layout: o, width: l }, r, a, i) => {
    const s = Cm(o) ? l : e;
    process.env.NODE_ENV !== "production" && rt(s) && no(
      "[ElVirtualList]",
      `
        You should set
          width/height
        to number when your layout is
          horizontal/vertical
      `
    );
    const c = Math.max(0, t * n - s), u = Math.min(c, r * n), d = Math.max(0, (r + 1) * n - s);
    switch (a === Y1 && (i >= d - s && i <= u + s ? a = Qr : a = di), a) {
      case bm:
        return u;
      case ym:
        return d;
      case di: {
        const f = Math.round(d + (u - d) / 2);
        return f < Math.ceil(s / 2) ? 0 : f > c + Math.floor(s / 2) ? c : f;
      }
      case Qr:
      default:
        return i >= d && i <= u ? i : i < d ? d : u;
    }
  },
  getStartIndexForOffset: ({ total: e, itemSize: t }, n) => Math.max(0, Math.min(e - 1, Math.floor(n / t))),
  getStopIndexForStartIndex: ({ height: e, total: t, itemSize: n, layout: o, width: l }, r, a) => {
    const i = r * n, s = Cm(o) ? l : e, c = Math.ceil(
      (s + a - i) / n
    );
    return Math.max(
      0,
      Math.min(
        t - 1,
        r + c - 1
      )
    );
  },
  initCache() {
  },
  clearCache: !0,
  validateProps() {
  }
}), PCe = "ElDynamicSizeList", qd = (e, t, n) => {
  const { itemSize: o } = e, { items: l, lastVisitedIndex: r } = n;
  if (t > r) {
    let a = 0;
    if (r >= 0) {
      const i = l[r];
      a = i.offset + i.size;
    }
    for (let i = r + 1; i <= t; i++) {
      const s = o(i);
      l[i] = {
        offset: a,
        size: s
      }, a += s;
    }
    n.lastVisitedIndex = t;
  }
  return l[t];
}, kCe = (e, t, n) => {
  const { items: o, lastVisitedIndex: l } = t;
  return (l > 0 ? o[l].offset : 0) >= n ? fV(e, t, 0, l, n) : NCe(e, t, Math.max(0, l), n);
}, fV = (e, t, n, o, l) => {
  for (; n <= o; ) {
    const r = n + Math.floor((o - n) / 2), a = qd(e, r, t).offset;
    if (a === l)
      return r;
    a < l ? n = r + 1 : a > l && (o = r - 1);
  }
  return Math.max(0, n - 1);
}, NCe = (e, t, n, o) => {
  const { total: l } = e;
  let r = 1;
  for (; n < l && qd(e, n, t).offset < o; )
    n += r, r *= 2;
  return fV(
    e,
    t,
    Math.floor(n / 2),
    Math.min(n, l - 1),
    o
  );
}, IN = ({ total: e }, { items: t, estimatedItemSize: n, lastVisitedIndex: o }) => {
  let l = 0;
  if (o >= e && (o = e - 1), o >= 0) {
    const i = t[o];
    l = i.offset + i.size;
  }
  const a = (e - o - 1) * n;
  return l + a;
}, MCe = uV({
  name: "ElDynamicSizeList",
  getItemOffset: (e, t, n) => qd(e, t, n).offset,
  getItemSize: (e, t, { items: n }) => n[t].size,
  getEstimatedTotalSize: IN,
  getOffset: (e, t, n, o, l) => {
    const { height: r, layout: a, width: i } = e, s = Cm(a) ? i : r, c = qd(e, t, l), u = IN(e, l), d = Math.max(
      0,
      Math.min(u - s, c.offset)
    ), f = Math.max(0, c.offset - s + c.size);
    switch (n === Y1 && (o >= f - s && o <= d + s ? n = Qr : n = di), n) {
      case bm:
        return d;
      case ym:
        return f;
      case di:
        return Math.round(f + (d - f) / 2);
      case Qr:
      default:
        return o >= f && o <= d ? o : o < f ? f : d;
    }
  },
  getStartIndexForOffset: (e, t, n) => kCe(e, n, t),
  getStopIndexForStartIndex: (e, t, n, o) => {
    const { height: l, total: r, layout: a, width: i } = e, s = Cm(a) ? i : l, c = qd(e, t, o), u = n + s;
    let d = c.offset + c.size, f = t;
    for (; f < r - 1 && d < u; )
      f++, d += qd(e, f, o).size;
    return f;
  },
  initCache({ estimatedItemSize: e = Ex }, t) {
    const n = {
      items: {},
      estimatedItemSize: e,
      lastVisitedIndex: -1
    };
    return n.clearCacheAfterIndex = (o, l = !0) => {
      var r, a;
      n.lastVisitedIndex = Math.min(n.lastVisitedIndex, o - 1), (r = t.exposed) == null || r.getItemStyleCache(-1), l && ((a = t.proxy) == null || a.$forceUpdate());
    }, n;
  },
  clearCache: !1,
  validateProps: ({ itemSize: e }) => {
    process.env.NODE_ENV !== "production" && typeof e != "function" && no(
      PCe,
      `
          itemSize is required as function, but the given value was ${typeof e}
        `
    );
  }
}), ACe = {
  loading: Boolean,
  data: {
    type: Array,
    required: !0
  },
  hoveringIndex: Number,
  width: Number,
  id: String,
  ariaLabel: String
};
var RCe = /* @__PURE__ */ le({
  name: "ElSelectDropdown",
  props: ACe,
  setup(e, {
    slots: t,
    expose: n
  }) {
    const o = ze(w_), l = Ve("select"), {
      getLabel: r,
      getValue: a,
      getDisabled: i
    } = mh(o.props), s = /* @__PURE__ */ H([]), c = /* @__PURE__ */ H(), u = O(() => e.data.length);
    pe(() => u.value, () => {
      var k, N;
      (N = (k = o.tooltipRef.value) == null ? void 0 : k.updatePopper) == null || N.call(k);
    });
    const d = O(() => fn(o.props.estimatedOptionHeight)), f = O(() => d.value ? {
      itemSize: o.props.itemHeight
    } : {
      estimatedSize: o.props.estimatedOptionHeight,
      itemSize: (k) => s.value[k]
    }), p = (k = [], N) => {
      const {
        props: {
          valueKey: R
        }
      } = o;
      return Mt(N) ? k && k.some((z) => /* @__PURE__ */ Wt(Oo(z, R)) === Oo(N, R)) : k.includes(N);
    }, m = (k, N) => {
      if (Mt(N)) {
        const {
          valueKey: R
        } = o.props;
        return Oo(k, R) === Oo(N, R);
      } else
        return k === N;
    }, v = (k, N) => o.props.multiple ? p(k, a(N)) : m(k, a(N)), h = (k, N) => {
      const {
        disabled: R,
        multiple: z,
        multipleLimit: D
      } = o.props;
      return R || !N && (z ? D > 0 && k.length >= D : !1);
    }, g = (k) => e.hoveringIndex === k;
    n({
      listRef: c,
      isSized: d,
      isItemDisabled: h,
      isItemHovering: g,
      isItemSelected: v,
      scrollToItem: (k) => {
        const N = c.value;
        N && N.scrollToItem(k);
      },
      resetScrollTop: () => {
        const k = c.value;
        k && k.resetScrollTop();
      }
    });
    const w = (k) => {
      const {
        index: N,
        data: R,
        style: z
      } = k, D = S(d), {
        itemSize: F,
        estimatedSize: M
      } = S(f), {
        modelValue: A
      } = o.props, {
        onSelect: L,
        onHover: B
      } = o, V = R[N];
      if (V.type === "Group")
        return $(fCe, {
          item: V,
          style: z,
          height: D ? F : M
        }, null);
      const j = v(A, V), W = h(A, j), Y = g(N);
      return $(CCe, Ut(k, {
        selected: j,
        disabled: i(V) || W,
        created: !!V.created,
        hovering: Y,
        item: V,
        onSelect: L,
        onHover: B
      }), {
        default: (U) => {
          var te;
          return ((te = t.default) == null ? void 0 : te.call(t, U)) || $("span", null, [r(V)]);
        }
      });
    }, {
      onKeyboardNavigate: x,
      onKeyboardSelect: E
    } = o, I = () => {
      x("forward");
    }, T = () => {
      x("backward");
    }, P = (k) => {
      const N = Nn(k), {
        tab: R,
        esc: z,
        down: D,
        up: F,
        enter: M,
        numpadEnter: A
      } = Ye;
      switch ([z, D, F, M, A].includes(N) && (k.preventDefault(), k.stopPropagation()), N) {
        case R:
        case z:
          break;
        case D:
          I();
          break;
        case F:
          T();
          break;
        case M:
        case A:
          E();
          break;
      }
    };
    return () => {
      var k, N, R, z;
      const {
        data: D,
        width: F
      } = e, {
        height: M,
        multiple: A,
        scrollbarAlwaysOn: L
      } = o.props, B = O(() => k0 ? !0 : L), V = S(d) ? dV : MCe;
      return $("div", {
        class: [l.b("dropdown"), l.is("multiple", A)],
        style: {
          width: `${F}px`
        }
      }, [(k = t.header) == null ? void 0 : k.call(t), ((N = t.loading) == null ? void 0 : N.call(t)) || ((R = t.empty) == null ? void 0 : R.call(t)) || $(V, Ut({
        ref: c
      }, S(f), {
        className: l.be("dropdown", "list"),
        scrollbarAlwaysOn: B.value,
        data: D,
        height: M,
        width: F,
        total: D.length,
        innerElement: "ul",
        innerProps: {
          id: e.id,
          role: "listbox",
          "aria-label": e.ariaLabel,
          "aria-orientation": "vertical"
        },
        onKeydown: P
      }), {
        default: (j) => $(w, j, null)
      }), (z = t.footer) == null ? void 0 : z.call(t)]);
    };
  }
});
function DCe(e, t) {
  const { aliasProps: n, getLabel: o, getValue: l } = mh(e), r = /* @__PURE__ */ H(0), a = /* @__PURE__ */ H(), i = O(() => e.allowCreate && e.filterable);
  pe(
    () => e.options,
    (p) => {
      const m = new Set(p.map((v) => o(v)));
      t.createdOptions = t.createdOptions.filter(
        (v) => !m.has(o(v))
      );
    }
  );
  function s(p) {
    const m = (v) => o(v) === p;
    return e.options && e.options.some(m) || t.createdOptions.some(m);
  }
  function c(p) {
    i.value && (e.multiple && p.created ? r.value++ : a.value = p);
  }
  function u(p) {
    if (i.value)
      if (p && p.length > 0) {
        if (s(p)) {
          t.createdOptions = t.createdOptions.filter(
            (v) => o(v) !== t.previousQuery
          );
          return;
        }
        const m = {
          [n.value.value]: p,
          [n.value.label]: p,
          created: !0,
          [n.value.disabled]: !1
        };
        t.createdOptions.length >= r.value ? t.createdOptions[r.value] = m : t.createdOptions.push(m);
      } else if (e.multiple)
        t.createdOptions.length = r.value;
      else {
        const m = a.value;
        t.createdOptions.length = 0, m && m.created && t.createdOptions.push(m);
      }
  }
  function d(p) {
    if (!i.value || !p || !p.created || p.created && e.reserveKeyword && t.inputValue === o(p))
      return;
    const m = t.createdOptions.findIndex(
      (v) => l(v) === l(p)
    );
    ~m && (t.createdOptions.splice(m, 1), r.value--);
  }
  function f() {
    i.value && (t.createdOptions.length = 0, r.value = 0);
  }
  return {
    createNewOption: u,
    removeNewOption: d,
    selectNewOption: c,
    clearAllNewOption: f
  };
}
const LCe = (e, t) => {
  const { t: n } = an(), o = So(), l = Ve("select"), r = Ve("input"), { form: a, formItem: i } = cl(), { inputId: s } = zr(e, {
    formItemContext: i
  }), { aliasProps: c, getLabel: u, getValue: d, getDisabled: f, getOptions: p } = mh(e), { valueOnClear: m, isEmptyValue: v } = ih(e), h = /* @__PURE__ */ kt({
    inputValue: "",
    cachedOptions: [],
    createdOptions: [],
    hoveringIndex: -1,
    inputHovering: !1,
    selectionWidth: 0,
    collapseItemWidth: 0,
    previousQuery: null,
    previousValue: void 0,
    selectedLabel: "",
    menuVisibleOnFocus: !1,
    isBeforeHide: !1
  }), g = /* @__PURE__ */ H(-1), y = /* @__PURE__ */ H(!1), b = /* @__PURE__ */ H(), C = /* @__PURE__ */ H(), w = /* @__PURE__ */ H(), x = /* @__PURE__ */ H(), E = /* @__PURE__ */ H(), I = /* @__PURE__ */ H(), T = /* @__PURE__ */ H(), P = /* @__PURE__ */ H(), k = /* @__PURE__ */ H(), N = /* @__PURE__ */ H(), {
    isComposing: R,
    handleCompositionStart: z,
    handleCompositionEnd: D,
    handleCompositionUpdate: F
  } = fh({
    afterComposition: (et) => Mn(et)
  }), M = io(), { wrapperRef: A, isFocused: L, handleBlur: B } = Os(E, {
    disabled: M,
    afterFocus() {
      e.automaticDropdown && !Y.value && (Y.value = !0, h.menuVisibleOnFocus = !0);
    },
    beforeBlur(et) {
      var Pt, qt;
      return ((Pt = w.value) == null ? void 0 : Pt.isFocusInsideContent(et)) || ((qt = x.value) == null ? void 0 : qt.isFocusInsideContent(et));
    },
    afterBlur() {
      var et;
      Y.value = !1, h.menuVisibleOnFocus = !1, e.validateEvent && ((et = i == null ? void 0 : i.validate) == null || et.call(i, "blur").catch((Pt) => Gt(Pt)));
    }
  }), V = O(() => he("")), j = O(() => e.loading ? !1 : e.options.length > 0 || h.createdOptions.length > 0), W = /* @__PURE__ */ H([]), Y = /* @__PURE__ */ H(!1), U = O(() => {
    var et;
    return (et = a == null ? void 0 : a.statusIcon) != null ? et : !1;
  }), te = O(() => {
    const et = W.value.length * e.itemHeight;
    return et > e.height ? e.height : et;
  }), J = O(() => e.multiple ? We(e.modelValue) && e.modelValue.length > 0 : !v(e.modelValue)), re = O(() => e.clearable && !M.value && J.value && (L.value || h.inputHovering)), oe = O(
    () => e.remote && e.filterable && !e.remoteShowSuffix ? "" : e.suffixIcon
  ), q = O(
    () => oe.value && l.is("reverse", Y.value)
  ), K = O(() => (i == null ? void 0 : i.validateState) || ""), se = O(() => {
    if (K.value)
      return D1[K.value];
  }), Z = O(() => e.remote ? e.debounce : 0), ee = O(
    () => e.remote && !h.inputValue && !j.value
  ), fe = O(() => e.loading ? e.loadingText || n("el.select.loading") : e.filterable && h.inputValue && j.value && W.value.length === 0 ? e.noMatchText || n("el.select.noMatch") : j.value ? null : e.noDataText || n("el.select.noData")), me = O(
    () => e.filterable && it(e.filterMethod)
  ), ge = O(
    () => e.filterable && e.remote && it(e.remoteMethod)
  ), he = (et) => {
    const Pt = new RegExp(ZO(et), "i"), qt = (ln) => me.value || ge.value ? !0 : et ? Pt.test(u(ln) || "") : !0;
    return e.loading ? [] : [...h.createdOptions, ...e.options].reduce((ln, go) => {
      const Wl = p(go);
      if (We(Wl)) {
        const Bc = Wl.filter(qt);
        Bc.length > 0 && ln.push(
          {
            label: u(go),
            type: "Group"
          },
          ...Bc
        );
      } else (e.remote || qt(go)) && ln.push(go);
      return ln;
    }, []);
  }, $e = () => {
    W.value = he(h.inputValue);
  }, ne = O(() => {
    const et = /* @__PURE__ */ new Map();
    return V.value.forEach((Pt, qt) => {
      et.set(pt(d(Pt)), { option: Pt, index: qt });
    }), et;
  }), ae = O(() => {
    const et = /* @__PURE__ */ new Map();
    return W.value.forEach((Pt, qt) => {
      et.set(pt(d(Pt)), { option: Pt, index: qt });
    }), et;
  }), ce = O(
    () => W.value.every((et) => f(et))
  ), xe = Mo(), Te = O(
    () => xe.value === "small" ? "small" : "default"
  ), Se = () => {
    var et;
    if (mt(e.fitInputWidth)) {
      g.value = e.fitInputWidth;
      return;
    }
    const Pt = ((et = b.value) == null ? void 0 : et.offsetWidth) || 200;
    !e.fitInputWidth && j.value ? Ke(() => {
      g.value = Math.max(Pt, be());
    }) : g.value = Pt;
  }, be = () => {
    var et, Pt;
    const ln = document.createElement("canvas").getContext("2d"), go = l.be("dropdown", "item"), Bc = (((Pt = (et = P.value) == null ? void 0 : et.listRef) == null ? void 0 : Pt.innerRef) || document).querySelector(`.${go}`);
    if (Bc === null || ln === null)
      return 0;
    const yd = getComputedStyle(Bc), iC = Number.parseFloat(yd.paddingLeft) + Number.parseFloat(yd.paddingRight);
    return ln.font = `bold ${yd.font.replace(
      new RegExp(`\\b${yd.fontWeight}\\b`),
      ""
    )}`, W.value.reduce((Wh, Kh) => {
      const Kp = ln.measureText(u(Kh));
      return Math.max(Kp.width, Wh);
    }, 0) + iC;
  }, ie = () => {
    if (!C.value)
      return 0;
    const et = window.getComputedStyle(C.value);
    return Number.parseFloat(et.gap || "6px");
  }, we = O(() => {
    const et = ie(), Pt = e.filterable ? et + V1 : 0;
    return { maxWidth: `${N.value && e.maxCollapseTags === 1 ? h.selectionWidth - h.collapseItemWidth - et - Pt : h.selectionWidth - Pt}px` };
  }), Ne = O(() => ({ maxWidth: `${h.selectionWidth}px` })), tt = O(() => We(e.modelValue) ? e.modelValue.length === 0 && !h.inputValue : e.filterable ? !h.inputValue : !0), Pe = O(() => {
    var et;
    const Pt = (et = e.placeholder) != null ? et : n("el.select.placeholder");
    return e.multiple || !J.value ? Pt : h.selectedLabel;
  }), Re = O(() => {
    var et, Pt;
    return (Pt = (et = w.value) == null ? void 0 : et.popperRef) == null ? void 0 : Pt.contentRef;
  }), Le = O(() => {
    if (e.multiple) {
      const et = e.modelValue.length;
      if (et > 0 && ae.value.has(e.modelValue[et - 1])) {
        const { index: Pt } = ae.value.get(
          e.modelValue[et - 1]
        );
        return Pt;
      }
    } else if (!v(e.modelValue) && ae.value.has(e.modelValue)) {
      const { index: et } = ae.value.get(e.modelValue);
      return et;
    }
    return -1;
  }), Ue = O({
    get() {
      return Y.value && (e.loading || !ee.value || e.remote && !!o.empty) && (!y.value || !Ql(h.previousQuery));
    },
    set(et) {
      Y.value = et;
    }
  }), Ae = O(() => e.multiple ? e.collapseTags ? h.cachedOptions.slice(0, e.maxCollapseTags) : h.cachedOptions : []), De = O(() => e.multiple ? e.collapseTags ? h.cachedOptions.slice(e.maxCollapseTags) : [] : []), {
    createNewOption: _e,
    removeNewOption: Ze,
    selectNewOption: dt,
    clearAllNewOption: Tt
  } = DCe(e, h), jt = (et) => {
    var Pt;
    M.value || e.filterable && Y.value && et && !((Pt = T.value) != null && Pt.contains(et.target)) || (h.menuVisibleOnFocus ? h.menuVisibleOnFocus = !1 : Y.value = !Y.value);
  }, Qt = () => {
    h.inputValue.length > 0 && !Y.value && (Y.value = !0), _e(h.inputValue), Ke(() => {
      lt(h.inputValue);
    });
  }, je = lh(() => {
    Qt(), y.value = !1;
  }, Z), lt = (et) => {
    h.previousQuery === et || R.value || (h.previousQuery = et, e.filterable && it(e.filterMethod) ? e.filterMethod(et) : e.filterable && e.remote && it(e.remoteMethod) && e.remoteMethod(et), e.defaultFirstOption && (e.filterable || e.remote) && W.value.length ? Ke(Ct) : Ke(Xt));
  }, Ct = () => {
    const et = W.value.filter(
      (ln) => !ln.disabled && ln.type !== "Group"
    ), Pt = et.find((ln) => ln.created), qt = et[0];
    h.hoveringIndex = ct(
      W.value,
      Pt || qt
    );
  }, vn = (et) => {
    Jn(e.modelValue, et) || t(en, et);
  }, tn = (et) => {
    t(It, et), vn(et), h.previousValue = e.multiple ? String(et) : et, Ke(() => {
      if (e.multiple && We(e.modelValue)) {
        const Pt = h.cachedOptions.slice(), qt = e.modelValue.map(
          (ln) => Ao(ln, Pt)
        );
        Jn(h.cachedOptions, qt) || (h.cachedOptions = qt);
      } else
        Ts(!0);
    });
  }, ct = (et = [], Pt) => {
    if (!Mt(Pt))
      return et.indexOf(Pt);
    const qt = e.valueKey;
    let ln = -1;
    return et.some((go, Wl) => Oo(go, qt) === Oo(Pt, qt) ? (ln = Wl, !0) : !1), ln;
  }, pt = (et) => Mt(et) ? Oo(et, e.valueKey) : et, Lt = () => {
    Se();
  }, Gn = () => {
    h.selectionWidth = Number.parseFloat(
      window.getComputedStyle(C.value).width
    );
  }, To = () => {
    h.collapseItemWidth = N.value.getBoundingClientRect().width;
  }, st = () => {
    var et, Pt;
    (Pt = (et = w.value) == null ? void 0 : et.updatePopper) == null || Pt.call(et);
  }, Yt = () => {
    var et, Pt;
    (Pt = (et = x.value) == null ? void 0 : et.updatePopper) == null || Pt.call(et);
  }, Kt = (et) => {
    const Pt = d(et);
    if (e.multiple) {
      let qt = e.modelValue.slice();
      const ln = ct(qt, Pt);
      ln > -1 ? (qt = [
        ...qt.slice(0, ln),
        ...qt.slice(ln + 1)
      ], h.cachedOptions.splice(ln, 1), Ze(et)) : (e.multipleLimit <= 0 || qt.length < e.multipleLimit) && (qt = [...qt, Pt], h.cachedOptions.push(et), dt(et)), tn(qt), et.created && lt(""), e.filterable && !e.reserveKeyword && (h.inputValue = "");
    } else
      h.selectedLabel = u(et), !Jn(e.modelValue, Pt) && tn(Pt), Y.value = !1, dt(et), et.created || Tt();
    Zn();
  }, Ln = (et, Pt) => {
    let qt = e.modelValue.slice();
    const ln = ct(qt, d(Pt));
    ln > -1 && !M.value && (qt = [
      ...e.modelValue.slice(0, ln),
      ...e.modelValue.slice(ln + 1)
    ], h.cachedOptions.splice(ln, 1), tn(qt), t("remove-tag", d(Pt)), Ze(Pt)), et.stopPropagation(), Zn();
  }, Zn = () => {
    var et;
    (et = E.value) == null || et.focus();
  }, ho = () => {
    var et;
    if (Y.value) {
      Y.value = !1, Ke(() => {
        var Pt;
        return (Pt = E.value) == null ? void 0 : Pt.blur();
      });
      return;
    }
    (et = E.value) == null || et.blur();
  }, ul = () => {
    h.inputValue.length > 0 ? h.inputValue = "" : Y.value = !1;
  }, zo = (et) => ZB(
    et,
    (Pt) => !h.cachedOptions.some(
      (qt) => d(qt) === Pt && f(qt)
    )
  ), ir = (et) => {
    const Pt = Nn(et);
    if (e.multiple && Pt !== Ye.delete && h.inputValue.length === 0) {
      et.preventDefault();
      const qt = e.modelValue.slice(), ln = zo(qt);
      if (ln < 0)
        return;
      const go = qt[ln];
      qt.splice(ln, 1);
      const Wl = h.cachedOptions[ln];
      h.cachedOptions.splice(ln, 1), Ze(Wl), tn(qt), t("remove-tag", go);
    }
  }, hl = () => {
    let et;
    We(e.modelValue) ? et = [] : et = m.value, h.selectedLabel = "", Y.value = !1, tn(et), t("clear"), Tt(), Zn();
  }, Go = (et, Pt = void 0) => {
    const qt = W.value;
    if (!["forward", "backward"].includes(et) || M.value || qt.length <= 0 || ce.value || R.value)
      return;
    if (!Y.value)
      return jt();
    fn(Pt) && (Pt = h.hoveringIndex);
    let ln = -1;
    et === "forward" ? (ln = Pt + 1, ln >= qt.length && (ln = 0)) : et === "backward" && (ln = Pt - 1, (ln < 0 || ln >= qt.length) && (ln = qt.length - 1));
    const go = qt[ln];
    if (f(go) || go.type === "Group")
      return Go(et, ln);
    h.hoveringIndex = ln, xo(ln);
  }, He = () => {
    if (Y.value)
      ~h.hoveringIndex && W.value[h.hoveringIndex] && Kt(W.value[h.hoveringIndex]);
    else return jt();
  }, St = (et) => {
    h.hoveringIndex = et != null ? et : -1;
  }, Xt = () => {
    if (!e.multiple)
      h.hoveringIndex = W.value.findIndex((et) => pt(d(et)) === pt(e.modelValue));
    else {
      const et = e.modelValue.length;
      if (et > 0) {
        const Pt = e.modelValue[et - 1];
        h.hoveringIndex = W.value.findIndex(
          (qt) => pt(Pt) === pt(d(qt))
        );
      } else
        h.hoveringIndex = -1;
    }
  }, Mn = (et) => {
    if (h.inputValue = et.target.value, e.remote)
      y.value = !0, je();
    else
      return Qt();
  }, jn = (et) => {
    if (Y.value = !1, L.value) {
      const Pt = new FocusEvent("blur", et);
      B(Pt);
    }
  }, so = () => (h.isBeforeHide = !1, Ke(() => {
    ~Le.value && xo(Le.value);
  })), xo = (et) => {
    P.value.scrollToItem(et);
  }, Ao = (et, Pt) => {
    const qt = pt(et);
    if (ne.value.has(qt)) {
      const { option: ln } = ne.value.get(qt);
      return ln;
    }
    if (Pt && Pt.length) {
      const ln = Pt.find(
        (go) => pt(d(go)) === qt
      );
      if (ln)
        return ln;
    }
    return {
      [c.value.value]: et,
      [c.value.label]: et
    };
  }, wr = (et) => {
    var Pt, qt;
    return (qt = (Pt = ne.value.get(d(et))) == null ? void 0 : Pt.index) != null ? qt : -1;
  }, Ts = (et = !1) => {
    if (e.multiple)
      if (e.modelValue.length > 0) {
        const Pt = h.cachedOptions.slice();
        h.cachedOptions.length = 0, h.previousValue = e.modelValue.toString();
        for (const qt of e.modelValue) {
          const ln = Ao(qt, Pt);
          h.cachedOptions.push(ln);
        }
      } else
        h.cachedOptions = [], h.previousValue = void 0;
    else if (J.value) {
      h.previousValue = e.modelValue;
      const Pt = W.value, qt = Pt.findIndex(
        (ln) => pt(d(ln)) === pt(e.modelValue)
      );
      ~qt ? h.selectedLabel = u(Pt[qt]) : (!h.selectedLabel || et) && (h.selectedLabel = pt(e.modelValue));
    } else
      h.selectedLabel = "", h.previousValue = void 0;
    Tt(), Se();
  };
  pe(
    () => e.fitInputWidth,
    () => {
      Se();
    }
  ), pe(Y, (et) => {
    et ? (e.persistent || Se(), lt("")) : (h.inputValue = "", h.previousQuery = null, h.isBeforeHide = !0, _e(""));
  }), pe(
    () => e.modelValue,
    (et, Pt) => {
      var qt;
      (!et || We(et) && et.length === 0 || e.multiple && !Jn(et.toString(), h.previousValue) || !e.multiple && pt(et) !== pt(h.previousValue)) && Ts(!0), !Jn(et, Pt) && e.validateEvent && ((qt = i == null ? void 0 : i.validate) == null || qt.call(i, "change").catch((go) => Gt(go)));
    },
    {
      deep: !0
    }
  ), pe(
    () => e.options,
    () => {
      const et = E.value;
      (!et || et && document.activeElement !== et) && Ts();
    },
    {
      deep: !0,
      flush: "post"
    }
  ), pe(
    () => W.value,
    () => (Se(), P.value && Ke(P.value.resetScrollTop))
  ), Ot(() => {
    h.isBeforeHide || $e();
  }), Ot(() => {
    const { valueKey: et, options: Pt } = e, qt = /* @__PURE__ */ new Map();
    for (const ln of Pt) {
      const go = d(ln);
      let Wl = go;
      if (Mt(Wl) && (Wl = Oo(go, et)), qt.get(Wl)) {
        Gt(
          "ElSelectV2",
          "The option values you provided seem to be duplicated, which may cause some problems, please check."
        );
        break;
      } else
        qt.set(Wl, !0);
    }
  }), nt(() => {
    Ts();
  }), Xn(b, Lt), Xn(C, Gn), Xn(A, st), Xn(k, Yt), Xn(N, To);
  let bd;
  return pe(
    () => Ue.value,
    (et) => {
      et ? bd = Xn(P, st).stop : (bd == null || bd(), bd = void 0), t("visible-change", et);
    }
  ), {
    inputId: s,
    collapseTagSize: Te,
    currentPlaceholder: Pe,
    expanded: Y,
    emptyText: fe,
    popupHeight: te,
    debounce: Z,
    allOptions: V,
    allOptionsValueMap: ne,
    filteredOptions: W,
    iconComponent: oe,
    iconReverse: q,
    tagStyle: we,
    collapseTagStyle: Ne,
    popperSize: g,
    dropdownMenuVisible: Ue,
    hasModelValue: J,
    shouldShowPlaceholder: tt,
    selectDisabled: M,
    selectSize: xe,
    needStatusIcon: U,
    showClearBtn: re,
    states: h,
    isFocused: L,
    nsSelect: l,
    nsInput: r,
    inputRef: E,
    menuRef: P,
    tagMenuRef: k,
    tooltipRef: w,
    tagTooltipRef: x,
    selectRef: b,
    wrapperRef: A,
    selectionRef: C,
    prefixRef: I,
    suffixRef: T,
    collapseItemRef: N,
    popperRef: Re,
    validateState: K,
    validateIcon: se,
    showTagList: Ae,
    collapseTagList: De,
    debouncedOnInputChange: je,
    deleteTag: Ln,
    getLabel: u,
    getValue: d,
    getDisabled: f,
    getValueKey: pt,
    getIndex: wr,
    handleClear: hl,
    handleClickOutside: jn,
    handleDel: ir,
    handleEsc: ul,
    focus: Zn,
    blur: ho,
    handleMenuEnter: so,
    handleResize: Lt,
    resetSelectionWidth: Gn,
    updateTooltip: st,
    updateTagTooltip: Yt,
    updateOptions: $e,
    toggleMenu: jt,
    scrollTo: xo,
    onInput: Mn,
    onKeyboardNavigate: Go,
    onKeyboardSelect: He,
    onSelect: Kt,
    onHover: St,
    handleCompositionStart: z,
    handleCompositionEnd: D,
    handleCompositionUpdate: F
  };
}, BCe = /* @__PURE__ */ le({
  name: "ElSelectV2",
  components: {
    ElSelectMenu: RCe,
    ElTag: fs,
    ElTooltip: al,
    ElIcon: ut
  },
  directives: { ClickOutside: Cc },
  props: vCe,
  emits: hCe,
  setup(e, { emit: t }) {
    const n = O(() => {
      const { modelValue: s, multiple: c } = e, u = c ? [] : void 0;
      return We(s) ? c ? s : u : c ? u : s;
    }), o = LCe(
      /* @__PURE__ */ kt(vt(Be({}, /* @__PURE__ */ to(e)), {
        modelValue: n
      })),
      t
    ), { calculatorRef: l, inputStyle: r } = t_(), a = ml();
    at(w_, {
      props: /* @__PURE__ */ kt(vt(Be({}, /* @__PURE__ */ to(e)), {
        height: o.popupHeight,
        modelValue: n
      })),
      expanded: o.expanded,
      tooltipRef: o.tooltipRef,
      contentId: a,
      onSelect: o.onSelect,
      onHover: o.onHover,
      onKeyboardNavigate: o.onKeyboardNavigate,
      onKeyboardSelect: o.onKeyboardSelect
    });
    const i = O(() => e.multiple ? o.states.cachedOptions.map((s) => o.getLabel(s)) : o.states.selectedLabel);
    return vt(Be({}, o), {
      modelValue: n,
      selectedLabel: i,
      calculatorRef: l,
      inputStyle: r,
      contentId: a,
      BORDER_HORIZONTAL_WIDTH: $F
    });
  }
}), FCe = ["id", "autocomplete", "tabindex", "aria-expanded", "aria-label", "disabled", "aria-controls", "aria-activedescendant", "readonly", "name"], VCe = ["textContent"], zCe = { key: 1 };
function HCe(e, t, n, o, l, r) {
  const a = yn("el-tag"), i = yn("el-tooltip"), s = yn("el-icon"), c = yn("el-select-menu"), u = s1("click-outside");
  return _t((G(), ue(
    "div",
    {
      ref: "selectRef",
      class: X([e.nsSelect.b(), e.nsSelect.m(e.selectSize)]),
      onMouseenter: t[15] || (t[15] = (d) => e.states.inputHovering = !0),
      onMouseleave: t[16] || (t[16] = (d) => e.states.inputHovering = !1)
    },
    [
      $(i, {
        ref: "tooltipRef",
        visible: e.dropdownMenuVisible,
        teleported: e.teleported,
        "popper-class": [e.nsSelect.e("popper"), e.popperClass],
        "popper-style": e.popperStyle,
        "gpu-acceleration": !1,
        "stop-popper-mouse-event": !1,
        "popper-options": e.popperOptions,
        "fallback-placements": e.fallbackPlacements,
        effect: e.effect,
        placement: e.placement,
        pure: "",
        transition: `${e.nsSelect.namespace.value}-zoom-in-top`,
        trigger: "click",
        persistent: e.persistent,
        "append-to": e.appendTo,
        "show-arrow": e.showArrow,
        offset: e.offset,
        onBeforeShow: e.handleMenuEnter,
        onHide: t[14] || (t[14] = (d) => e.states.isBeforeHide = !1)
      }, {
        default: Ee(() => {
          var d, f;
          return [
            ve(
              "div",
              {
                ref: "wrapperRef",
                class: X([
                  e.nsSelect.e("wrapper"),
                  e.nsSelect.is("focused", e.isFocused),
                  e.nsSelect.is("hovering", e.states.inputHovering),
                  e.nsSelect.is("filterable", e.filterable),
                  e.nsSelect.is("disabled", e.selectDisabled)
                ]),
                onClick: t[11] || (t[11] = Et((...p) => e.toggleMenu && e.toggleMenu(...p), ["prevent"]))
              },
              [
                e.$slots.prefix ? (G(), ue(
                  "div",
                  {
                    key: 0,
                    ref: "prefixRef",
                    class: X(e.nsSelect.e("prefix"))
                  },
                  [
                    Oe(e.$slots, "prefix")
                  ],
                  2
                )) : Ie("v-if", !0),
                ve(
                  "div",
                  {
                    ref: "selectionRef",
                    class: X([
                      e.nsSelect.e("selection"),
                      e.nsSelect.is(
                        "near",
                        e.multiple && !e.$slots.prefix && !!e.modelValue.length
                      )
                    ])
                  },
                  [
                    e.multiple ? Oe(e.$slots, "tag", {
                      key: 0,
                      data: e.states.cachedOptions,
                      deleteTag: e.deleteTag,
                      selectDisabled: e.selectDisabled
                    }, () => [
                      (G(!0), ue(
                        Ge,
                        null,
                        on(e.showTagList, (p) => (G(), ue(
                          "div",
                          {
                            key: e.getValueKey(e.getValue(p)),
                            class: X(e.nsSelect.e("selected-item"))
                          },
                          [
                            $(a, {
                              closable: !e.selectDisabled && !e.getDisabled(p),
                              size: e.collapseTagSize,
                              type: e.tagType,
                              effect: e.tagEffect,
                              "disable-transitions": "",
                              style: gt(e.tagStyle),
                              onClose: (m) => e.deleteTag(m, p)
                            }, {
                              default: Ee(() => [
                                ve(
                                  "span",
                                  {
                                    class: X(e.nsSelect.e("tags-text"))
                                  },
                                  [
                                    Oe(e.$slots, "label", {
                                      index: e.getIndex(p),
                                      label: e.getLabel(p),
                                      value: e.getValue(p)
                                    }, () => [
                                      Ft(
                                        qe(e.getLabel(p)),
                                        1
                                      )
                                    ])
                                  ],
                                  2
                                )
                              ]),
                              _: 2
                            }, 1032, ["closable", "size", "type", "effect", "style", "onClose"])
                          ],
                          2
                        ))),
                        128
                      )),
                      e.collapseTags && e.modelValue.length > e.maxCollapseTags ? (G(), Me(i, {
                        key: 0,
                        ref: "tagTooltipRef",
                        disabled: e.dropdownMenuVisible || !e.collapseTagsTooltip,
                        "fallback-placements": ["bottom", "top", "right", "left"],
                        effect: e.effect,
                        placement: "bottom",
                        "popper-class": e.popperClass,
                        "popper-style": e.popperStyle,
                        teleported: e.teleported,
                        "popper-options": e.popperOptions
                      }, {
                        default: Ee(() => [
                          ve(
                            "div",
                            {
                              ref: "collapseItemRef",
                              class: X(e.nsSelect.e("selected-item"))
                            },
                            [
                              $(a, {
                                closable: !1,
                                size: e.collapseTagSize,
                                type: e.tagType,
                                effect: e.tagEffect,
                                style: gt(e.collapseTagStyle),
                                "disable-transitions": ""
                              }, {
                                default: Ee(() => [
                                  ve(
                                    "span",
                                    {
                                      class: X(e.nsSelect.e("tags-text"))
                                    },
                                    " + " + qe(e.modelValue.length - e.maxCollapseTags),
                                    3
                                  )
                                ]),
                                _: 1
                              }, 8, ["size", "type", "effect", "style"])
                            ],
                            2
                          )
                        ]),
                        content: Ee(() => [
                          ve(
                            "div",
                            {
                              ref: "tagMenuRef",
                              class: X(e.nsSelect.e("selection"))
                            },
                            [
                              (G(!0), ue(
                                Ge,
                                null,
                                on(e.collapseTagList, (p) => (G(), ue(
                                  "div",
                                  {
                                    key: e.getValueKey(e.getValue(p)),
                                    class: X(e.nsSelect.e("selected-item"))
                                  },
                                  [
                                    $(a, {
                                      class: "in-tooltip",
                                      closable: !e.selectDisabled && !e.getDisabled(p),
                                      size: e.collapseTagSize,
                                      type: e.tagType,
                                      effect: e.tagEffect,
                                      "disable-transitions": "",
                                      onClose: (m) => e.deleteTag(m, p)
                                    }, {
                                      default: Ee(() => [
                                        ve(
                                          "span",
                                          {
                                            class: X(e.nsSelect.e("tags-text"))
                                          },
                                          [
                                            Oe(e.$slots, "label", {
                                              index: e.getIndex(p),
                                              label: e.getLabel(p),
                                              value: e.getValue(p)
                                            }, () => [
                                              Ft(
                                                qe(e.getLabel(p)),
                                                1
                                              )
                                            ])
                                          ],
                                          2
                                        )
                                      ]),
                                      _: 2
                                    }, 1032, ["closable", "size", "type", "effect", "onClose"])
                                  ],
                                  2
                                ))),
                                128
                              ))
                            ],
                            2
                          )
                        ]),
                        _: 3
                      }, 8, ["disabled", "effect", "popper-class", "popper-style", "teleported", "popper-options"])) : Ie("v-if", !0)
                    ]) : Ie("v-if", !0),
                    ve(
                      "div",
                      {
                        class: X([
                          e.nsSelect.e("selected-item"),
                          e.nsSelect.e("input-wrapper"),
                          e.nsSelect.is("hidden", !e.filterable || e.selectDisabled)
                        ])
                      },
                      [
                        _t(ve("input", {
                          id: e.inputId,
                          ref: "inputRef",
                          "onUpdate:modelValue": t[0] || (t[0] = (p) => e.states.inputValue = p),
                          style: gt(e.inputStyle),
                          autocomplete: e.autocomplete,
                          tabindex: e.tabindex,
                          "aria-autocomplete": "none",
                          "aria-haspopup": "listbox",
                          autocapitalize: "off",
                          "aria-expanded": e.expanded,
                          "aria-label": e.ariaLabel,
                          class: X([e.nsSelect.e("input"), e.nsSelect.is(e.selectSize)]),
                          disabled: e.selectDisabled,
                          role: "combobox",
                          "aria-controls": e.contentId,
                          "aria-activedescendant": e.states.hoveringIndex >= 0 ? `${e.contentId}-${e.states.hoveringIndex}` : "",
                          readonly: !e.filterable,
                          spellcheck: "false",
                          type: "text",
                          name: e.name,
                          onInput: t[1] || (t[1] = (...p) => e.onInput && e.onInput(...p)),
                          onCompositionstart: t[2] || (t[2] = (...p) => e.handleCompositionStart && e.handleCompositionStart(...p)),
                          onCompositionupdate: t[3] || (t[3] = (...p) => e.handleCompositionUpdate && e.handleCompositionUpdate(...p)),
                          onCompositionend: t[4] || (t[4] = (...p) => e.handleCompositionEnd && e.handleCompositionEnd(...p)),
                          onKeydown: [
                            t[5] || (t[5] = uo(Et((p) => e.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"])),
                            t[6] || (t[6] = uo(Et((p) => e.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"])),
                            t[7] || (t[7] = uo(Et((...p) => e.onKeyboardSelect && e.onKeyboardSelect(...p), ["stop", "prevent"]), ["enter"])),
                            t[8] || (t[8] = uo(Et((...p) => e.handleEsc && e.handleEsc(...p), ["stop", "prevent"]), ["esc"])),
                            t[9] || (t[9] = uo(Et((...p) => e.handleDel && e.handleDel(...p), ["stop"]), ["delete"]))
                          ],
                          onClick: t[10] || (t[10] = Et((...p) => e.toggleMenu && e.toggleMenu(...p), ["stop"]))
                        }, null, 46, FCe), [
                          [d1, e.states.inputValue]
                        ]),
                        e.filterable ? (G(), ue("span", {
                          key: 0,
                          ref: "calculatorRef",
                          "aria-hidden": "true",
                          class: X(e.nsSelect.e("input-calculator")),
                          textContent: qe(e.states.inputValue)
                        }, null, 10, VCe)) : Ie("v-if", !0)
                      ],
                      2
                    ),
                    e.shouldShowPlaceholder ? (G(), ue(
                      "div",
                      {
                        key: 1,
                        class: X([
                          e.nsSelect.e("selected-item"),
                          e.nsSelect.e("placeholder"),
                          e.nsSelect.is(
                            "transparent",
                            !e.hasModelValue || e.expanded && !e.states.inputValue
                          )
                        ])
                      },
                      [
                        e.hasModelValue ? Oe(e.$slots, "label", {
                          key: 0,
                          index: (f = (d = e.allOptionsValueMap.get(e.modelValue)) == null ? void 0 : d.index) != null ? f : -1,
                          label: e.currentPlaceholder,
                          value: e.modelValue
                        }, () => [
                          ve(
                            "span",
                            null,
                            qe(e.currentPlaceholder),
                            1
                          )
                        ]) : (G(), ue(
                          "span",
                          zCe,
                          qe(e.currentPlaceholder),
                          1
                        ))
                      ],
                      2
                    )) : Ie("v-if", !0)
                  ],
                  2
                ),
                ve(
                  "div",
                  {
                    ref: "suffixRef",
                    class: X(e.nsSelect.e("suffix"))
                  },
                  [
                    e.iconComponent ? _t((G(), Me(s, {
                      key: 0,
                      class: X([e.nsSelect.e("caret"), e.nsInput.e("icon"), e.iconReverse])
                    }, {
                      default: Ee(() => [
                        (G(), Me(Ht(e.iconComponent)))
                      ]),
                      _: 1
                    }, 8, ["class"])), [
                      [Jt, !e.showClearBtn]
                    ]) : Ie("v-if", !0),
                    e.showClearBtn && e.clearIcon ? (G(), Me(s, {
                      key: 1,
                      class: X([
                        e.nsSelect.e("caret"),
                        e.nsInput.e("icon"),
                        e.nsSelect.e("clear")
                      ]),
                      onClick: Et(e.handleClear, ["prevent", "stop"])
                    }, {
                      default: Ee(() => [
                        (G(), Me(Ht(e.clearIcon)))
                      ]),
                      _: 1
                    }, 8, ["class", "onClick"])) : Ie("v-if", !0),
                    e.validateState && e.validateIcon && e.needStatusIcon ? (G(), Me(s, {
                      key: 2,
                      class: X([
                        e.nsInput.e("icon"),
                        e.nsInput.e("validateIcon"),
                        e.nsInput.is("loading", e.validateState === "validating")
                      ])
                    }, {
                      default: Ee(() => [
                        (G(), Me(Ht(e.validateIcon)))
                      ]),
                      _: 1
                    }, 8, ["class"])) : Ie("v-if", !0)
                  ],
                  2
                )
              ],
              2
            )
          ];
        }),
        content: Ee(() => [
          $(c, {
            id: e.contentId,
            ref: "menuRef",
            data: e.filteredOptions,
            width: e.popperSize - e.BORDER_HORIZONTAL_WIDTH,
            "hovering-index": e.states.hoveringIndex,
            "scrollbar-always-on": e.scrollbarAlwaysOn,
            "aria-label": e.ariaLabel
          }, or({
            default: Ee((d) => [
              Oe(e.$slots, "default", cs(us(d)))
            ]),
            _: 2
          }, [
            e.$slots.header ? {
              name: "header",
              fn: Ee(() => [
                ve(
                  "div",
                  {
                    class: X(e.nsSelect.be("dropdown", "header")),
                    onClick: t[12] || (t[12] = Et(() => {
                    }, ["stop"]))
                  },
                  [
                    Oe(e.$slots, "header")
                  ],
                  2
                )
              ]),
              key: "0"
            } : void 0,
            e.$slots.loading && e.loading ? {
              name: "loading",
              fn: Ee(() => [
                ve(
                  "div",
                  {
                    class: X(e.nsSelect.be("dropdown", "loading"))
                  },
                  [
                    Oe(e.$slots, "loading")
                  ],
                  2
                )
              ]),
              key: "1"
            } : e.loading || e.filteredOptions.length === 0 ? {
              name: "empty",
              fn: Ee(() => [
                ve(
                  "div",
                  {
                    class: X(e.nsSelect.be("dropdown", "empty"))
                  },
                  [
                    Oe(e.$slots, "empty", {}, () => [
                      ve(
                        "span",
                        null,
                        qe(e.emptyText),
                        1
                      )
                    ])
                  ],
                  2
                )
              ]),
              key: "2"
            } : void 0,
            e.$slots.footer ? {
              name: "footer",
              fn: Ee(() => [
                ve(
                  "div",
                  {
                    class: X(e.nsSelect.be("dropdown", "footer")),
                    onClick: t[13] || (t[13] = Et(() => {
                    }, ["stop"]))
                  },
                  [
                    Oe(e.$slots, "footer")
                  ],
                  2
                )
              ]),
              key: "3"
            } : void 0
          ]), 1032, ["id", "data", "width", "hovering-index", "scrollbar-always-on", "aria-label"])
        ]),
        _: 3
      }, 8, ["visible", "teleported", "popper-class", "popper-style", "popper-options", "fallback-placements", "effect", "placement", "transition", "persistent", "append-to", "show-arrow", "offset", "onBeforeShow"])
    ],
    34
  )), [
    [u, e.handleClickOutside, e.popperRef]
  ]);
}
var jCe = /* @__PURE__ */ Je(BCe, [["render", HCe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/select-v2/src/select.vue"]]);
const WCe = Dt(jCe), KCe = Xe({
  animated: Boolean,
  count: {
    type: Number,
    default: 1
  },
  rows: {
    type: Number,
    default: 3
  },
  loading: {
    type: Boolean,
    default: !0
  },
  throttle: {
    type: ye([Number, Object])
  }
}), UCe = Xe({
  variant: {
    type: String,
    values: [
      "circle",
      "rect",
      "h1",
      "h3",
      "text",
      "caption",
      "p",
      "image",
      "button"
    ],
    default: "text"
  }
}), GCe = /* @__PURE__ */ le({
  name: "ElSkeletonItem",
  __name: "skeleton-item",
  props: UCe,
  setup(e) {
    const t = Ve("skeleton");
    return (n, o) => (G(), ue(
      "div",
      {
        class: X([S(t).e("item"), S(t).e(n.variant)])
      },
      [
        n.variant === "image" ? (G(), Me(S(gse), { key: 0 })) : Ie("v-if", !0)
      ],
      2
    ));
  }
});
var Y0 = /* @__PURE__ */ Je(GCe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton-item.vue"]]);
const YCe = (e, t = 0) => {
  if (t === 0)
    return e;
  const n = Mt(t) && !!t.initVal, o = /* @__PURE__ */ H(n);
  let l = null;
  const r = (i) => {
    if (fn(i)) {
      o.value = e.value;
      return;
    }
    l && clearTimeout(l), l = setTimeout(() => {
      o.value = e.value;
    }, i);
  }, a = (i) => {
    i === "leading" ? mt(t) ? r(t) : r(t.leading) : Mt(t) ? r(t.trailing) : o.value = !1;
  };
  return nt(() => a("leading")), pe(
    () => e.value,
    (i) => {
      a(i ? "leading" : "trailing");
    }
  ), o;
}, XCe = /* @__PURE__ */ le({
  name: "ElSkeleton",
  __name: "skeleton",
  props: KCe,
  setup(e, { expose: t }) {
    const n = e, o = Ve("skeleton"), l = YCe(/* @__PURE__ */ ft(n, "loading"), n.throttle);
    return t({
      uiLoading: l
    }), (r, a) => S(l) ? (G(), ue(
      "div",
      Ut({
        key: 0,
        class: [S(o).b(), S(o).is("animated", r.animated)]
      }, r.$attrs),
      [
        (G(!0), ue(
          Ge,
          null,
          on(r.count, (i) => (G(), ue(
            Ge,
            { key: i },
            [
              S(l) ? Oe(r.$slots, "template", { key: i }, () => [
                $(Y0, {
                  class: X(S(o).is("first")),
                  variant: "p"
                }, null, 8, ["class"]),
                (G(!0), ue(
                  Ge,
                  null,
                  on(r.rows, (s) => (G(), Me(Y0, {
                    key: s,
                    class: X([
                      S(o).e("paragraph"),
                      S(o).is("last", s === r.rows && r.rows > 1)
                    ]),
                    variant: "p"
                  }, null, 8, ["class"]))),
                  128
                ))
              ]) : Ie("v-if", !0)
            ],
            64
          ))),
          128
        ))
      ],
      16
    )) : Oe(r.$slots, "default", cs(Ut({ key: 1 }, r.$attrs)));
  }
});
var qCe = /* @__PURE__ */ Je(XCe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/skeleton/src/skeleton.vue"]]);
const JCe = Dt(qCe, {
  SkeletonItem: Y0
}), ZCe = oo(Y0), pV = Symbol("sliderContextKey"), QCe = Xe(Be({
  modelValue: {
    type: ye([Number, Array]),
    default: 0
  },
  id: {
    type: String,
    default: void 0
  },
  min: {
    type: Number,
    default: 0
  },
  max: {
    type: Number,
    default: 100
  },
  step: {
    type: Number,
    default: 1
  },
  showInput: Boolean,
  showInputControls: {
    type: Boolean,
    default: !0
  },
  size: Bo,
  inputSize: Bo,
  showStops: Boolean,
  showTooltip: {
    type: Boolean,
    default: !0
  },
  formatTooltip: {
    type: ye(Function),
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  range: Boolean,
  vertical: Boolean,
  height: String,
  rangeStartLabel: {
    type: String,
    default: void 0
  },
  rangeEndLabel: {
    type: String,
    default: void 0
  },
  formatValueText: {
    type: ye(Function),
    default: void 0
  },
  tooltipClass: {
    type: String,
    default: void 0
  },
  placement: {
    type: String,
    values: Mi,
    default: "top"
  },
  marks: {
    type: ye(Object)
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  persistent: {
    type: Boolean,
    default: !0
  }
}, zl(["ariaLabel"]))), tw = (e) => mt(e) || We(e) && e.every(mt), ewe = {
  [It]: tw,
  [Po]: tw,
  [en]: tw
}, twe = Xe({
  modelValue: {
    type: Number,
    default: 0
  },
  vertical: Boolean,
  tooltipClass: String,
  placement: {
    type: String,
    values: Mi,
    default: "top"
  }
}), nwe = {
  [It]: (e) => mt(e)
}, owe = (e, t, n) => {
  const o = /* @__PURE__ */ H(), l = /* @__PURE__ */ H(!1), r = O(() => t.value instanceof Function), a = O(() => r.value && t.value(e.modelValue) || e.modelValue), i = Dr(() => {
    n.value && (l.value = !0);
  }, 50), s = Dr(() => {
    n.value && (l.value = !1);
  }, 50);
  return {
    tooltip: o,
    tooltipVisible: l,
    formatValue: a,
    displayTooltip: i,
    hideTooltip: s
  };
}, lwe = (e, t, n) => {
  const {
    disabled: o,
    min: l,
    max: r,
    step: a,
    showTooltip: i,
    persistent: s,
    precision: c,
    sliderSize: u,
    formatTooltip: d,
    emitChange: f,
    resetSize: p,
    updateDragging: m
  } = ze(pV), { tooltip: v, tooltipVisible: h, formatValue: g, displayTooltip: y, hideTooltip: b } = owe(e, d, i), C = /* @__PURE__ */ H(), w = O(() => `${(e.modelValue - l.value) / (r.value - l.value) * 100}%`), x = O(() => e.vertical ? { bottom: w.value } : { left: w.value }), E = () => {
    t.hovering = !0, y();
  }, I = () => {
    t.hovering = !1, t.dragging || b();
  }, T = (W) => {
    o.value || (W.preventDefault(), L(W), window.addEventListener("mousemove", B), window.addEventListener("touchmove", B), window.addEventListener("mouseup", V), window.addEventListener("touchend", V), window.addEventListener("contextmenu", V), C.value.focus());
  }, P = (W) => {
    o.value || (t.newPosition = Number.parseFloat(w.value) + W / (r.value - l.value) * 100, j(t.newPosition), f());
  }, k = () => {
    P(-a.value);
  }, N = () => {
    P(a.value);
  }, R = () => {
    P(-a.value * 4);
  }, z = () => {
    P(a.value * 4);
  }, D = () => {
    o.value || (j(0), f());
  }, F = () => {
    o.value || (j(100), f());
  }, M = (W) => {
    const Y = Nn(W);
    let U = !0;
    switch (Y) {
      case Ye.left:
      case Ye.down:
        k();
        break;
      case Ye.right:
      case Ye.up:
        N();
        break;
      case Ye.home:
        D();
        break;
      case Ye.end:
        F();
        break;
      case Ye.pageDown:
        R();
        break;
      case Ye.pageUp:
        z();
        break;
      default:
        U = !1;
        break;
    }
    U && W.preventDefault();
  }, A = (W) => {
    let Y, U;
    return W.type.startsWith("touch") ? (U = W.touches[0].clientY, Y = W.touches[0].clientX) : (U = W.clientY, Y = W.clientX), {
      clientX: Y,
      clientY: U
    };
  }, L = (W) => {
    t.dragging = !0, t.isClick = !0;
    const { clientX: Y, clientY: U } = A(W);
    e.vertical ? t.startY = U : t.startX = Y, t.startPosition = Number.parseFloat(w.value), t.newPosition = t.startPosition;
  }, B = (W) => {
    if (t.dragging) {
      t.isClick = !1, y(), p();
      let Y;
      const { clientX: U, clientY: te } = A(W);
      e.vertical ? (t.currentY = te, Y = (t.startY - t.currentY) / u.value * 100) : (t.currentX = U, Y = (t.currentX - t.startX) / u.value * 100), t.newPosition = t.startPosition + Y, j(t.newPosition);
    }
  }, V = () => {
    t.dragging && (setTimeout(() => {
      t.dragging = !1, t.hovering || b(), t.isClick || j(t.newPosition), f();
    }, 0), window.removeEventListener("mousemove", B), window.removeEventListener("touchmove", B), window.removeEventListener("mouseup", V), window.removeEventListener("touchend", V), window.removeEventListener("contextmenu", V));
  }, j = (W) => Rt(void 0, null, function* () {
    if (W === null || Number.isNaN(+W))
      return;
    W = T1(W, 0, 100);
    const Y = Math.floor((r.value - l.value) / a.value), U = Y * a.value / (r.value - l.value) * 100, te = U + (100 - U) / 2;
    let J;
    if (W < U) {
      const re = U / Y, oe = Math.round(W / re);
      J = l.value + oe * a.value;
    } else W < te ? J = l.value + Y * a.value : J = r.value;
    J = Number.parseFloat(J.toFixed(c.value)), J !== e.modelValue && n(It, J), !t.dragging && e.modelValue !== t.oldValue && (t.oldValue = e.modelValue), yield Ke(), t.dragging && y(), v.value.updatePopper();
  });
  return pe(
    () => t.dragging,
    (W) => {
      m(W);
    }
  ), wn(C, "touchstart", T, { passive: !1 }), {
    disabled: o,
    button: C,
    tooltip: v,
    tooltipVisible: h,
    showTooltip: i,
    persistent: s,
    wrapperStyle: x,
    formatValue: g,
    handleMouseEnter: E,
    handleMouseLeave: I,
    onButtonDown: T,
    onKeyDown: M,
    setPosition: j
  };
}, rwe = ["tabindex"], awe = /* @__PURE__ */ le({
  name: "ElSliderButton",
  __name: "button",
  props: twe,
  emits: nwe,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = Ve("slider"), a = /* @__PURE__ */ kt({
      hovering: !1,
      dragging: !1,
      isClick: !1,
      startX: 0,
      currentX: 0,
      startY: 0,
      currentY: 0,
      startPosition: 0,
      newPosition: 0,
      oldValue: o.modelValue
    }), i = O(
      () => d.value ? f.value : !1
    ), {
      disabled: s,
      button: c,
      tooltip: u,
      showTooltip: d,
      persistent: f,
      tooltipVisible: p,
      wrapperStyle: m,
      formatValue: v,
      handleMouseEnter: h,
      handleMouseLeave: g,
      onButtonDown: y,
      onKeyDown: b,
      setPosition: C
    } = lwe(o, a, l), { hovering: w, dragging: x } = /* @__PURE__ */ to(a);
    return t({
      onButtonDown: y,
      onKeyDown: b,
      setPosition: C,
      hovering: w,
      dragging: x
    }), (E, I) => (G(), ue("div", {
      ref_key: "button",
      ref: c,
      class: X([S(r).e("button-wrapper"), { hover: S(w), dragging: S(x) }]),
      style: gt(S(m)),
      tabindex: S(s) ? void 0 : 0,
      onMouseenter: I[0] || (I[0] = (...T) => S(h) && S(h)(...T)),
      onMouseleave: I[1] || (I[1] = (...T) => S(g) && S(g)(...T)),
      onMousedown: I[2] || (I[2] = (...T) => S(y) && S(y)(...T)),
      onFocus: I[3] || (I[3] = (...T) => S(h) && S(h)(...T)),
      onBlur: I[4] || (I[4] = (...T) => S(g) && S(g)(...T)),
      onKeydown: I[5] || (I[5] = (...T) => S(b) && S(b)(...T))
    }, [
      $(S(al), {
        ref_key: "tooltip",
        ref: u,
        visible: S(p),
        placement: E.placement,
        "fallback-placements": ["top", "bottom", "right", "left"],
        "stop-popper-mouse-event": !1,
        "popper-class": E.tooltipClass,
        disabled: !S(d),
        persistent: i.value
      }, {
        content: Ee(() => [
          ve(
            "span",
            null,
            qe(S(v)),
            1
          )
        ]),
        default: Ee(() => [
          ve(
            "div",
            {
              class: X([S(r).e("button"), { hover: S(w), dragging: S(x) }])
            },
            null,
            2
          )
        ]),
        _: 1
      }, 8, ["visible", "placement", "popper-class", "disabled", "persistent"])
    ], 46, rwe));
  }
});
var TN = /* @__PURE__ */ Je(awe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/button.vue"]]);
const iwe = Xe({
  mark: {
    type: ye([String, Object]),
    default: void 0
  }
});
var swe = /* @__PURE__ */ le({
  name: "ElSliderMarker",
  props: iwe,
  setup(e) {
    const t = Ve("slider"), n = O(() => rt(e.mark) ? e.mark : e.mark.label), o = O(
      () => rt(e.mark) ? void 0 : e.mark.style
    );
    return () => ht(
      "div",
      {
        class: t.e("marks-text"),
        style: o.value
      },
      n.value
    );
  }
});
const cwe = (e, t, n) => {
  const { formItem: o } = cl(), l = /* @__PURE__ */ Ce(), r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H(), i = {
    firstButton: r,
    secondButton: a
  }, s = io(), c = O(() => Math.min(t.firstValue, t.secondValue)), u = O(() => Math.max(t.firstValue, t.secondValue)), d = O(() => e.range ? `${100 * (u.value - c.value) / (e.max - e.min)}%` : `${100 * (t.firstValue - e.min) / (e.max - e.min)}%`), f = O(() => e.range ? `${100 * (c.value - e.min) / (e.max - e.min)}%` : "0%"), p = O(() => e.vertical ? { height: e.height } : {}), m = O(() => e.vertical ? {
    height: d.value,
    bottom: f.value
  } : {
    width: d.value,
    left: f.value
  }), v = () => {
    if (l.value) {
      const k = l.value.getBoundingClientRect();
      t.sliderSize = k[e.vertical ? "height" : "width"];
    }
  }, h = (k) => {
    const N = e.min + k * (e.max - e.min) / 100;
    if (!e.range)
      return r;
    let R;
    return Math.abs(c.value - N) < Math.abs(u.value - N) ? R = t.firstValue < t.secondValue ? "firstButton" : "secondButton" : R = t.firstValue > t.secondValue ? "firstButton" : "secondButton", i[R];
  }, g = (k) => {
    const N = h(k);
    return N.value.setPosition(k), N;
  }, y = (k) => {
    t.firstValue = k != null ? k : e.min, C(
      e.range ? [c.value, u.value] : k != null ? k : e.min
    );
  }, b = (k) => {
    t.secondValue = k, e.range && C([c.value, u.value]);
  }, C = (k) => {
    n(It, k), n(Po, k);
  }, w = () => Rt(void 0, null, function* () {
    yield Ke(), n(
      en,
      e.range ? [c.value, u.value] : e.modelValue
    );
  }), x = (k) => {
    var N, R, z, D, F, M;
    if (s.value || t.dragging)
      return;
    v();
    let A = 0;
    if (e.vertical) {
      const L = (z = (R = (N = k.touches) == null ? void 0 : N.item(0)) == null ? void 0 : R.clientY) != null ? z : k.clientY;
      A = (l.value.getBoundingClientRect().bottom - L) / t.sliderSize * 100;
    } else {
      const L = (M = (F = (D = k.touches) == null ? void 0 : D.item(0)) == null ? void 0 : F.clientX) != null ? M : k.clientX, B = l.value.getBoundingClientRect().left;
      A = (L - B) / t.sliderSize * 100;
    }
    if (!(A < 0 || A > 100))
      return g(A);
  };
  return {
    elFormItem: o,
    slider: l,
    firstButton: r,
    secondButton: a,
    sliderDisabled: s,
    minValue: c,
    maxValue: u,
    runwayStyle: p,
    barStyle: m,
    resetSize: v,
    setPosition: g,
    emitChange: w,
    onSliderWrapperPrevent: (k) => {
      var N, R;
      ((N = i.firstButton.value) != null && N.dragging || (R = i.secondButton.value) != null && R.dragging) && k.preventDefault();
    },
    onSliderClick: (k) => {
      x(k) && w();
    },
    onSliderDown: (k) => Rt(void 0, null, function* () {
      const N = x(k);
      N && (yield Ke(), N.value.onButtonDown(k));
    }),
    onSliderMarkerDown: (k) => {
      if (s.value || t.dragging)
        return;
      g(k) && w();
    },
    setFirstValue: y,
    setSecondValue: b
  };
}, uwe = (e, t, n, o) => ({
  stops: O(() => {
    if (!e.showStops || e.min > e.max)
      return [];
    if (e.step === 0)
      return Gt("ElSlider", "step should not be 0."), [];
    const a = Math.ceil((e.max - e.min) / e.step), i = 100 * e.step / (e.max - e.min), s = Array.from({ length: a - 1 }).map(
      (c, u) => (u + 1) * i
    );
    return e.range ? s.filter((c) => c < 100 * (n.value - e.min) / (e.max - e.min) || c > 100 * (o.value - e.min) / (e.max - e.min)) : s.filter(
      (c) => c > 100 * (t.firstValue - e.min) / (e.max - e.min)
    );
  }),
  getStopStyle: (a) => e.vertical ? { bottom: `${a}%` } : { left: `${a}%` }
}), dwe = (e) => O(() => e.marks ? Object.keys(e.marks).map(Number.parseFloat).sort((n, o) => n - o).filter((n) => n <= e.max && n >= e.min).map(
  (n) => ({
    point: n,
    position: (n - e.min) * 100 / (e.max - e.min),
    mark: e.marks[n]
  })
) : []), fwe = (e, t, n, o, l, r) => {
  const a = (c) => {
    l(It, c), l(Po, c);
  }, i = () => e.range ? ![n.value, o.value].every(
    (c, u) => c === t.oldValue[u]
  ) : e.modelValue !== t.oldValue, s = () => {
    var c, u;
    e.min > e.max && no("Slider", "min should not be greater than max.");
    const d = e.modelValue;
    e.range && We(d) ? d[1] < e.min ? a([e.min, e.min]) : d[0] > e.max ? a([e.max, e.max]) : d[0] < e.min ? a([e.min, d[1]]) : d[1] > e.max ? a([d[0], e.max]) : (t.firstValue = d[0], t.secondValue = d[1], i() && (e.validateEvent && ((c = r == null ? void 0 : r.validate) == null || c.call(r, "change").catch((f) => Gt(f))), t.oldValue = d.slice())) : !e.range && mt(d) && !Number.isNaN(d) && (d < e.min ? a(e.min) : d > e.max ? a(e.max) : (t.firstValue = d, i() && (e.validateEvent && ((u = r == null ? void 0 : r.validate) == null || u.call(r, "change").catch((f) => Gt(f))), t.oldValue = d)));
  };
  s(), pe(
    () => t.dragging,
    (c) => {
      c || s();
    }
  ), pe(
    () => e.modelValue,
    (c, u) => {
      t.dragging || We(c) && We(u) && c.every((d, f) => d === u[f]) && t.firstValue === c[0] && t.secondValue === c[1] || s();
    },
    {
      deep: !0
    }
  ), pe(
    () => [e.min, e.max],
    () => {
      s();
    }
  );
}, pwe = (e, t, n) => {
  const o = /* @__PURE__ */ H();
  return nt(() => Rt(void 0, null, function* () {
    e.range ? (We(e.modelValue) ? (t.firstValue = Math.max(e.min, e.modelValue[0]), t.secondValue = Math.min(e.max, e.modelValue[1])) : (t.firstValue = e.min, t.secondValue = e.max), t.oldValue = [t.firstValue, t.secondValue]) : (!mt(e.modelValue) || Number.isNaN(e.modelValue) ? t.firstValue = e.min : t.firstValue = Math.min(
      e.max,
      Math.max(e.min, e.modelValue)
    ), t.oldValue = t.firstValue), wn(window, "resize", n), yield Ke(), n();
  })), {
    sliderWrapper: o
  };
}, vwe = ["id", "role", "aria-label", "aria-labelledby"], mwe = { key: 1 }, hwe = /* @__PURE__ */ le({
  name: "ElSlider",
  __name: "slider",
  props: QCe,
  emits: ewe,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = Ve("slider"), { t: a } = an(), i = /* @__PURE__ */ kt({
      firstValue: 0,
      secondValue: 0,
      oldValue: 0,
      dragging: !1,
      sliderSize: 1
    }), {
      elFormItem: s,
      slider: c,
      firstButton: u,
      secondButton: d,
      sliderDisabled: f,
      minValue: p,
      maxValue: m,
      runwayStyle: v,
      barStyle: h,
      resetSize: g,
      emitChange: y,
      onSliderWrapperPrevent: b,
      onSliderClick: C,
      onSliderDown: w,
      onSliderMarkerDown: x,
      setFirstValue: E,
      setSecondValue: I
    } = cwe(o, i, l), { stops: T, getStopStyle: P } = uwe(o, i, p, m), { inputId: k, isLabeledByFormItem: N } = zr(o, {
      formItemContext: s
    }), R = Mo(), z = O(
      () => o.inputSize || R.value
    ), D = O(() => o.ariaLabel || a("el.slider.defaultLabel", {
      min: o.min,
      max: o.max
    })), F = O(() => o.range ? o.rangeStartLabel || a("el.slider.defaultRangeStartLabel") : D.value), M = O(() => o.formatValueText ? o.formatValueText(Y.value) : `${Y.value}`), A = O(() => o.rangeEndLabel || a("el.slider.defaultRangeEndLabel")), L = O(() => o.formatValueText ? o.formatValueText(U.value) : `${U.value}`), B = O(() => [
      r.b(),
      r.m(R.value),
      r.is("vertical", o.vertical),
      { [r.m("with-input")]: o.showInput }
    ]), V = dwe(o);
    fwe(o, i, p, m, l, s);
    const j = O(() => {
      const re = [o.min, o.max, o.step].map((oe) => {
        const q = `${oe}`.split(".")[1];
        return q ? q.length : 0;
      });
      return Math.max.apply(null, re);
    }), { sliderWrapper: W } = pwe(o, i, g), { firstValue: Y, secondValue: U, sliderSize: te } = /* @__PURE__ */ to(i), J = (re) => {
      i.dragging = re;
    };
    return wn(W, "touchstart", b, {
      passive: !1
    }), wn(W, "touchmove", b, {
      passive: !1
    }), at(pV, vt(Be({}, /* @__PURE__ */ to(o)), {
      sliderSize: te,
      disabled: f,
      precision: j,
      emitChange: y,
      resetSize: g,
      updateDragging: J
    })), t({
      onSliderClick: C
    }), (re, oe) => {
      var q, K;
      return G(), ue("div", {
        id: re.range ? S(k) : void 0,
        ref_key: "sliderWrapper",
        ref: W,
        class: X(B.value),
        role: re.range ? "group" : void 0,
        "aria-label": re.range && !S(N) ? D.value : void 0,
        "aria-labelledby": re.range && S(N) ? (q = S(s)) == null ? void 0 : q.labelId : void 0
      }, [
        ve(
          "div",
          {
            ref_key: "slider",
            ref: c,
            class: X([
              S(r).e("runway"),
              { "show-input": re.showInput && !re.range },
              S(r).is("disabled", S(f))
            ]),
            style: gt(S(v)),
            onMousedown: oe[0] || (oe[0] = (...se) => S(w) && S(w)(...se)),
            onTouchstartPassive: oe[1] || (oe[1] = (...se) => S(w) && S(w)(...se))
          },
          [
            ve(
              "div",
              {
                class: X(S(r).e("bar")),
                style: gt(S(h))
              },
              null,
              6
            ),
            $(TN, {
              id: re.range ? void 0 : S(k),
              ref_key: "firstButton",
              ref: u,
              "model-value": S(Y),
              vertical: re.vertical,
              "tooltip-class": re.tooltipClass,
              placement: re.placement,
              role: "slider",
              "aria-label": re.range || !S(N) ? F.value : void 0,
              "aria-labelledby": !re.range && S(N) ? (K = S(s)) == null ? void 0 : K.labelId : void 0,
              "aria-valuemin": re.min,
              "aria-valuemax": re.range ? S(U) : re.max,
              "aria-valuenow": S(Y),
              "aria-valuetext": M.value,
              "aria-orientation": re.vertical ? "vertical" : "horizontal",
              "aria-disabled": S(f),
              "onUpdate:modelValue": S(E)
            }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
            re.range ? (G(), Me(TN, {
              key: 0,
              ref_key: "secondButton",
              ref: d,
              "model-value": S(U),
              vertical: re.vertical,
              "tooltip-class": re.tooltipClass,
              placement: re.placement,
              role: "slider",
              "aria-label": A.value,
              "aria-valuemin": S(Y),
              "aria-valuemax": re.max,
              "aria-valuenow": S(U),
              "aria-valuetext": L.value,
              "aria-orientation": re.vertical ? "vertical" : "horizontal",
              "aria-disabled": S(f),
              "onUpdate:modelValue": S(I)
            }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : Ie("v-if", !0),
            re.showStops ? (G(), ue("div", mwe, [
              (G(!0), ue(
                Ge,
                null,
                on(S(T), (se, Z) => (G(), ue(
                  "div",
                  {
                    key: Z,
                    class: X(S(r).e("stop")),
                    style: gt(S(P)(se))
                  },
                  null,
                  6
                ))),
                128
              ))
            ])) : Ie("v-if", !0),
            S(V).length > 0 ? (G(), ue(
              Ge,
              { key: 2 },
              [
                ve("div", null, [
                  (G(!0), ue(
                    Ge,
                    null,
                    on(S(V), (se, Z) => (G(), ue(
                      "div",
                      {
                        key: Z,
                        style: gt(S(P)(se.position)),
                        class: X([S(r).e("stop"), S(r).e("marks-stop")])
                      },
                      null,
                      6
                    ))),
                    128
                  ))
                ]),
                ve(
                  "div",
                  {
                    class: X(S(r).e("marks"))
                  },
                  [
                    (G(!0), ue(
                      Ge,
                      null,
                      on(S(V), (se, Z) => (G(), Me(S(swe), {
                        key: Z,
                        mark: se.mark,
                        style: gt(S(P)(se.position)),
                        onMousedown: Et((ee) => S(x)(se.position), ["stop"])
                      }, null, 8, ["mark", "style", "onMousedown"]))),
                      128
                    ))
                  ],
                  2
                )
              ],
              64
            )) : Ie("v-if", !0)
          ],
          38
        ),
        re.showInput && !re.range ? (G(), Me(S(G9), {
          key: 0,
          ref: "input",
          "model-value": S(Y),
          class: X(S(r).e("input")),
          step: re.step,
          disabled: S(f),
          controls: re.showInputControls,
          min: re.min,
          max: re.max,
          precision: j.value,
          size: z.value,
          "onUpdate:modelValue": S(E),
          onChange: S(y)
        }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "precision", "size", "onUpdate:modelValue", "onChange"])) : Ie("v-if", !0)
      ], 10, vwe);
    };
  }
});
var gwe = /* @__PURE__ */ Je(hwe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/slider/src/slider.vue"]]);
const bwe = Dt(gwe), ywe = Xe({
  prefixCls: {
    type: String
  }
}), PN = /* @__PURE__ */ le({
  name: "ElSpaceItem",
  props: ywe,
  setup(e, { slots: t }) {
    const n = Ve("space"), o = O(() => `${e.prefixCls || n.b()}__item`);
    return () => ht("div", { class: o.value }, Oe(t, "default"));
  }
}), kN = {
  small: 8,
  default: 12,
  large: 16
};
function Swe(e) {
  const t = Ve("space"), n = O(() => [t.b(), t.m(e.direction), e.class]), o = /* @__PURE__ */ H(0), l = /* @__PURE__ */ H(0), r = O(() => {
    const i = e.wrap || e.fill ? { flexWrap: "wrap" } : {}, s = {
      alignItems: e.alignment
    }, c = {
      rowGap: `${l.value}px`,
      columnGap: `${o.value}px`
    };
    return [i, s, c, e.style];
  }), a = O(() => e.fill ? { flexGrow: 1, minWidth: `${e.fillRatio}%` } : {});
  return Ot(() => {
    const { size: i = "small", wrap: s, direction: c, fill: u } = e;
    if (We(i)) {
      const [d = 0, f = 0] = i;
      o.value = d, l.value = f;
    } else {
      let d;
      mt(i) ? d = i : d = kN[i || "small"] || kN.small, (s || u) && c === "horizontal" ? o.value = l.value = d : c === "horizontal" ? (o.value = d, l.value = 0) : (l.value = d, o.value = 0);
    }
  }), {
    classes: n,
    containerStyle: r,
    itemStyle: a
  };
}
const Cwe = Xe({
  direction: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "horizontal"
  },
  class: {
    type: ye([
      String,
      Object,
      Array
    ]),
    default: ""
  },
  style: {
    type: ye([String, Array, Object]),
    default: ""
  },
  alignment: {
    type: ye(String),
    default: "center"
  },
  prefixCls: {
    type: String
  },
  spacer: {
    type: ye([Object, String, Number, Array]),
    default: null,
    validator: (e) => dn(e) || mt(e) || rt(e)
  },
  wrap: Boolean,
  fill: Boolean,
  fillRatio: {
    type: Number,
    default: 100
  },
  size: {
    type: [String, Array, Number],
    values: ki,
    validator: (e) => mt(e) || We(e) && e.length === 2 && e.every(mt)
  }
}), wwe = /* @__PURE__ */ le({
  name: "ElSpace",
  props: Cwe,
  setup(e, { slots: t }) {
    const { classes: n, containerStyle: o, itemStyle: l } = Swe(e);
    function r(a, i = "", s = []) {
      const { prefixCls: c } = e;
      return a.forEach((u, d) => {
        nx(u) ? We(u.children) && u.children.forEach((f, p) => {
          nx(f) && We(f.children) ? r(
            f.children,
            `${i + p}-`,
            s
          ) : dn(f) && (f == null ? void 0 : f.type) === qn ? s.push(f) : s.push(
            $(
              PN,
              {
                style: l.value,
                prefixCls: c,
                key: `nested-${i + p}`
              },
              {
                default: () => [f]
              },
              Yr.PROPS | Yr.STYLE,
              ["style", "prefixCls"]
            )
          );
        }) : Gse(u) && s.push(
          $(
            PN,
            {
              style: l.value,
              prefixCls: c,
              key: `LoopKey${i + d}`
            },
            {
              default: () => [u]
            },
            Yr.PROPS | Yr.STYLE,
            ["style", "prefixCls"]
          )
        );
      }), s;
    }
    return () => {
      var a;
      const { spacer: i, direction: s } = e, c = Oe(t, "default", { key: 0 }, () => []);
      if (((a = c.children) != null ? a : []).length === 0)
        return null;
      if (We(c.children)) {
        let u = r(c.children);
        if (i) {
          const d = u.length - 1;
          u = u.reduce(
            (f, p, m) => {
              const v = [...f, p];
              return m !== d && v.push(
                $(
                  "span",
                  {
                    style: [
                      l.value,
                      s === "vertical" ? "width: 100%" : null
                    ],
                    key: m
                  },
                  [
                    dn(i) ? i : Ft(i, Yr.TEXT)
                  ],
                  Yr.STYLE
                )
              ), v;
            },
            []
          );
        }
        return $(
          "div",
          {
            class: n.value,
            style: o.value
          },
          u,
          Yr.STYLE | Yr.CLASS
        );
      }
      return c.children;
    };
  }
}), $we = Dt(wwe), xwe = Xe({
  decimalSeparator: {
    type: String,
    default: "."
  },
  groupSeparator: {
    type: String,
    default: ","
  },
  precision: {
    type: Number,
    default: 0
  },
  formatter: Function,
  value: {
    type: ye([Number, Object]),
    default: 0
  },
  prefix: String,
  suffix: String,
  title: String,
  valueStyle: {
    type: ye([String, Object, Array])
  }
}), Ewe = /* @__PURE__ */ le({
  name: "ElStatistic",
  __name: "statistic",
  props: xwe,
  setup(e, { expose: t }) {
    const n = e, o = Ve("statistic"), l = O(() => {
      const { value: r, formatter: a, precision: i, decimalSeparator: s, groupSeparator: c } = n;
      if (it(a))
        return a(r);
      if (!mt(r) || Number.isNaN(r))
        return r;
      let [u, d = ""] = String(r).split(".");
      return d = d.padEnd(i, "0").slice(0, i > 0 ? i : 0), u = u.replace(/\B(?=(\d{3})+(?!\d))/g, c), [u, d].join(d ? s : "");
    });
    return t({
      displayValue: l
    }), (r, a) => (G(), ue(
      "div",
      {
        class: X(S(o).b())
      },
      [
        r.$slots.title || r.title ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(o).e("head"))
          },
          [
            Oe(r.$slots, "title", {}, () => [
              Ft(
                qe(r.title),
                1
              )
            ])
          ],
          2
        )) : Ie("v-if", !0),
        ve(
          "div",
          {
            class: X(S(o).e("content"))
          },
          [
            r.$slots.prefix || r.prefix ? (G(), ue(
              "div",
              {
                key: 0,
                class: X(S(o).e("prefix"))
              },
              [
                Oe(r.$slots, "prefix", {}, () => [
                  ve(
                    "span",
                    null,
                    qe(r.prefix),
                    1
                  )
                ])
              ],
              2
            )) : Ie("v-if", !0),
            ve(
              "span",
              {
                class: X(S(o).e("number")),
                style: gt(r.valueStyle)
              },
              qe(l.value),
              7
            ),
            r.$slots.suffix || r.suffix ? (G(), ue(
              "div",
              {
                key: 1,
                class: X(S(o).e("suffix"))
              },
              [
                Oe(r.$slots, "suffix", {}, () => [
                  ve(
                    "span",
                    null,
                    qe(r.suffix),
                    1
                  )
                ])
              ],
              2
            )) : Ie("v-if", !0)
          ],
          2
        )
      ],
      2
    ));
  }
});
var Owe = /* @__PURE__ */ Je(Ewe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/statistic/src/statistic.vue"]]);
const vV = Dt(Owe), _we = Xe({
  format: {
    type: String,
    default: "HH:mm:ss"
  },
  prefix: String,
  suffix: String,
  title: String,
  value: {
    type: ye([Number, Object]),
    default: 0
  },
  valueStyle: {
    type: ye([String, Object, Array])
  }
}), Iwe = {
  finish: () => !0,
  [en]: (e) => mt(e)
}, Twe = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  ["M", 1e3 * 60 * 60 * 24 * 30],
  ["D", 1e3 * 60 * 60 * 24],
  ["H", 1e3 * 60 * 60],
  ["m", 1e3 * 60],
  ["s", 1e3],
  ["S", 1]
], NN = (e) => mt(e) ? new Date(e).getTime() : e.valueOf(), MN = (e, t) => {
  let n = e;
  const o = /\[([^\]]*)]/g;
  return Twe.reduce((r, [a, i]) => {
    const s = new RegExp(`${a}+(?![^\\[\\]]*\\])`, "g");
    if (s.test(r)) {
      const c = Math.floor(n / i);
      return n -= c * i, r.replace(
        s,
        (u) => String(c).padStart(u.length, "0")
      );
    }
    return r;
  }, t).replace(o, "$1");
}, Pwe = /* @__PURE__ */ le({
  name: "ElCountdown",
  __name: "countdown",
  props: _we,
  emits: Iwe,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n;
    let r;
    const a = /* @__PURE__ */ H(0), i = O(() => MN(a.value, o.format)), s = (d) => MN(d, o.format), c = () => {
      r && (vs(r), r = void 0);
    }, u = () => {
      const d = NN(o.value), f = () => {
        let p = d - Date.now();
        l(en, p), p <= 0 ? (p = 0, c(), l("finish")) : r = Ci(f), a.value = p;
      };
      r = Ci(f);
    };
    return nt(() => {
      a.value = NN(o.value) - Date.now(), pe(
        () => [o.value, o.format],
        () => {
          c(), u();
        },
        {
          immediate: !0
        }
      );
    }), yt(() => {
      c();
    }), t({
      displayValue: i
    }), (d, f) => (G(), Me(S(vV), {
      value: a.value,
      title: d.title,
      prefix: d.prefix,
      suffix: d.suffix,
      "value-style": d.valueStyle,
      formatter: s
    }, or({
      _: 2
    }, [
      on(d.$slots, (p, m) => ({
        name: m,
        fn: Ee(() => [
          Oe(d.$slots, m)
        ])
      }))
    ]), 1032, ["value", "title", "prefix", "suffix", "value-style"]));
  }
});
var kwe = /* @__PURE__ */ Je(Pwe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/countdown/src/countdown.vue"]]);
const Nwe = Dt(kwe), Mwe = Xe({
  space: {
    type: [Number, String],
    default: ""
  },
  active: {
    type: Number,
    default: 0
  },
  direction: {
    type: String,
    default: "horizontal",
    values: ["horizontal", "vertical"]
  },
  alignCenter: {
    type: Boolean
  },
  simple: {
    type: Boolean
  },
  finishStatus: {
    type: String,
    values: ["wait", "process", "finish", "error", "success"],
    default: "finish"
  },
  processStatus: {
    type: String,
    values: ["wait", "process", "finish", "error", "success"],
    default: "process"
  }
}), Awe = {
  [en]: (e, t) => [e, t].every(mt)
}, mV = "ElSteps", Rwe = /* @__PURE__ */ le({
  name: "ElSteps",
  __name: "steps",
  props: Mwe,
  emits: Awe,
  setup(e, { emit: t }) {
    const n = e, o = t, l = Ve("steps"), {
      children: r,
      addChild: a,
      removeChild: i,
      ChildrenSorter: s
    } = z1(xt(), "ElStep");
    return pe(r, () => {
      r.value.forEach((c, u) => {
        c.setIndex(u);
      });
    }), at(mV, { props: n, steps: r, addStep: a, removeStep: i }), pe(
      () => n.active,
      (c, u) => {
        o(en, c, u);
      }
    ), (c, u) => (G(), ue(
      "div",
      {
        class: X([S(l).b(), S(l).m(c.simple ? "simple" : c.direction)])
      },
      [
        Oe(c.$slots, "default"),
        $(S(s))
      ],
      2
    ));
  }
});
var Dwe = /* @__PURE__ */ Je(Rwe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/steps.vue"]]);
const Lwe = Xe({
  title: {
    type: String,
    default: ""
  },
  icon: {
    type: Pn
  },
  description: {
    type: String,
    default: ""
  },
  status: {
    type: String,
    values: ["", "wait", "process", "finish", "error", "success"],
    default: ""
  }
}), Bwe = /* @__PURE__ */ le({
  name: "ElStep",
  __name: "item",
  props: Lwe,
  setup(e) {
    const t = e, n = Ve("step"), o = /* @__PURE__ */ H(-1), l = /* @__PURE__ */ H({}), r = /* @__PURE__ */ H(""), a = ze(mV), i = xt();
    let s = 0, c = 0;
    nt(() => {
      pe(
        [
          () => a.props.active,
          () => a.props.processStatus,
          () => a.props.finishStatus
        ],
        ([I], [T]) => {
          c = T || 0, s = I - c, x(I);
        },
        { immediate: !0 }
      );
    });
    const u = O(() => t.status || r.value), d = O(() => {
      const I = a.steps.value[o.value - 1];
      return I ? I.internalStatus.value : "wait";
    }), f = O(() => a.props.alignCenter), p = O(() => a.props.direction === "vertical"), m = O(() => a.props.simple), v = O(() => a.steps.value.length), h = O(() => {
      var I;
      return ((I = a.steps.value[v.value - 1]) == null ? void 0 : I.uid) === i.uid;
    }), g = O(() => m.value ? "" : a.props.space), y = O(() => [
      n.b(),
      n.is(m.value ? "simple" : a.props.direction),
      n.is("flex", h.value && !g.value && !f.value),
      n.is("center", f.value && !p.value && !m.value)
    ]), b = O(() => {
      const I = {
        flexBasis: mt(g.value) ? `${g.value}px` : g.value ? g.value : `${100 / (v.value - (f.value ? 0 : 1))}%`
      };
      return p.value || h.value && (I.maxWidth = `${100 / v.value}%`), I;
    }), C = (I) => {
      o.value = I;
    }, w = (I) => {
      const T = I === "wait", k = {
        transitionDelay: `${Math.abs(s) === 1 ? 0 : s > 0 ? (o.value + 1 - c) * 150 : -(o.value + 1 - a.props.active) * 150}ms`
      }, N = I === a.props.processStatus || T ? 0 : 100;
      k.borderWidth = N && !m.value ? "1px" : 0, k[a.props.direction === "vertical" ? "height" : "width"] = `${N}%`, l.value = k;
    }, x = (I) => {
      I > o.value ? r.value = a.props.finishStatus : I === o.value && d.value !== "error" ? r.value = a.props.processStatus : r.value = "wait";
      const T = a.steps.value[o.value - 1];
      T && T.calcProgress(r.value);
    }, E = {
      uid: i.uid,
      getVnode: () => i.vnode,
      currentStatus: u,
      internalStatus: r,
      setIndex: C,
      calcProgress: w
    };
    return a.addStep(E), yt(() => {
      a.removeStep(E);
    }), (I, T) => (G(), ue(
      "div",
      {
        style: gt(b.value),
        class: X(y.value)
      },
      [
        Ie(" icon & line "),
        ve(
          "div",
          {
            class: X([S(n).e("head"), S(n).is(u.value)])
          },
          [
            m.value ? Ie("v-if", !0) : (G(), ue(
              "div",
              {
                key: 0,
                class: X(S(n).e("line"))
              },
              [
                ve(
                  "i",
                  {
                    class: X(S(n).e("line-inner")),
                    style: gt(l.value)
                  },
                  null,
                  6
                )
              ],
              2
            )),
            ve(
              "div",
              {
                class: X([S(n).e("icon"), S(n).is(I.icon || I.$slots.icon ? "icon" : "text")])
              },
              [
                Oe(I.$slots, "icon", {}, () => [
                  I.icon ? (G(), Me(S(ut), {
                    key: 0,
                    class: X(S(n).e("icon-inner"))
                  }, {
                    default: Ee(() => [
                      (G(), Me(Ht(I.icon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : u.value === "success" ? (G(), Me(S(ut), {
                    key: 1,
                    class: X([S(n).e("icon-inner"), S(n).is("status")])
                  }, {
                    default: Ee(() => [
                      $(S(ch))
                    ]),
                    _: 1
                  }, 8, ["class"])) : u.value === "error" ? (G(), Me(S(ut), {
                    key: 2,
                    class: X([S(n).e("icon-inner"), S(n).is("status")])
                  }, {
                    default: Ee(() => [
                      $(S(aa))
                    ]),
                    _: 1
                  }, 8, ["class"])) : m.value ? Ie("v-if", !0) : (G(), ue(
                    "div",
                    {
                      key: 3,
                      class: X(S(n).e("icon-inner"))
                    },
                    qe(o.value + 1),
                    3
                  ))
                ])
              ],
              2
            )
          ],
          2
        ),
        Ie(" title & description "),
        ve(
          "div",
          {
            class: X(S(n).e("main"))
          },
          [
            ve(
              "div",
              {
                class: X([S(n).e("title"), S(n).is(u.value)])
              },
              [
                Oe(I.$slots, "title", {}, () => [
                  Ft(
                    qe(I.title),
                    1
                  )
                ])
              ],
              2
            ),
            m.value ? (G(), ue(
              "div",
              {
                key: 0,
                class: X(S(n).e("arrow"))
              },
              null,
              2
            )) : (G(), ue(
              "div",
              {
                key: 1,
                class: X([S(n).e("description"), S(n).is(u.value)])
              },
              [
                Oe(I.$slots, "description", {}, () => [
                  Ft(
                    qe(I.description),
                    1
                  )
                ])
              ],
              2
            ))
          ],
          2
        )
      ],
      6
    ));
  }
});
var hV = /* @__PURE__ */ Je(Bwe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/steps/src/item.vue"]]);
const Fwe = Dt(Dwe, {
  Step: hV
}), Vwe = oo(hV), gV = (e) => ["", ...ki].includes(e), zwe = Xe(Be({
  modelValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  loading: Boolean,
  size: {
    type: String,
    validator: gV
  },
  width: {
    type: [String, Number],
    default: ""
  },
  inlinePrompt: Boolean,
  inactiveActionIcon: {
    type: Pn
  },
  activeActionIcon: {
    type: Pn
  },
  activeIcon: {
    type: Pn
  },
  inactiveIcon: {
    type: Pn
  },
  activeText: {
    type: String,
    default: ""
  },
  inactiveText: {
    type: String,
    default: ""
  },
  activeValue: {
    type: [Boolean, String, Number],
    default: !0
  },
  inactiveValue: {
    type: [Boolean, String, Number],
    default: !1
  },
  name: {
    type: String,
    default: ""
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  beforeChange: {
    type: ye(Function)
  },
  id: String,
  tabindex: {
    type: [String, Number]
  }
}, zl(["ariaLabel"]))), Hwe = {
  [It]: (e) => Tn(e) || rt(e) || mt(e),
  [en]: (e) => Tn(e) || rt(e) || mt(e),
  [Po]: (e) => Tn(e) || rt(e) || mt(e)
}, jwe = ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex"], Wwe = ["aria-hidden"], Kwe = { key: 1 }, Uwe = { key: 1 }, Gwe = ["aria-hidden"], nw = "ElSwitch", Ywe = /* @__PURE__ */ le({
  name: nw,
  __name: "switch",
  props: zwe,
  emits: Hwe,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, { formItem: r } = cl(), a = Mo(), i = Ve("switch"), { inputId: s } = zr(o, {
      formItemContext: r
    }), c = io(
      O(() => {
        if (o.loading)
          return !0;
      })
    ), u = /* @__PURE__ */ H(o.modelValue !== !1), d = /* @__PURE__ */ Ce(), f = O(() => [
      i.b(),
      i.m(a.value),
      i.is("disabled", c.value),
      i.is("checked", g.value)
    ]), p = O(() => [
      i.e("label"),
      i.em("label", "left"),
      i.is("active", !g.value)
    ]), m = O(() => [
      i.e("label"),
      i.em("label", "right"),
      i.is("active", g.value)
    ]), v = O(() => ({
      width: ao(o.width)
    }));
    pe(
      () => o.modelValue,
      () => {
        u.value = !0;
      }
    );
    const h = O(() => u.value ? o.modelValue : !1), g = O(() => h.value === o.activeValue);
    [o.activeValue, o.inactiveValue].includes(h.value) || (l(It, o.inactiveValue), l(en, o.inactiveValue), l(Po, o.inactiveValue)), pe(g, (w) => {
      var x;
      d.value.checked = w, o.validateEvent && ((x = r == null ? void 0 : r.validate) == null || x.call(r, "change").catch((E) => Gt(E)));
    });
    const y = () => {
      const w = g.value ? o.inactiveValue : o.activeValue;
      l(It, w), l(en, w), l(Po, w), Ke(() => {
        d.value.checked = g.value;
      });
    }, b = () => {
      if (c.value)
        return;
      const { beforeChange: w } = o;
      if (!w) {
        y();
        return;
      }
      const x = w();
      [
        mc(x),
        Tn(x)
      ].includes(!0) || no(
        nw,
        "beforeChange must return type `Promise<boolean>` or `boolean`"
      ), mc(x) ? x.then((I) => {
        I && y();
      }).catch((I) => {
        Gt(nw, `some error occurred: ${I}`);
      }) : x && y();
    }, C = () => {
      var w, x;
      (x = (w = d.value) == null ? void 0 : w.focus) == null || x.call(w);
    };
    return nt(() => {
      d.value.checked = g.value;
    }), t({
      focus: C,
      checked: g
    }), (w, x) => (G(), ue(
      "div",
      {
        class: X(f.value),
        onClick: Et(b, ["prevent"])
      },
      [
        ve("input", {
          id: S(s),
          ref_key: "input",
          ref: d,
          class: X(S(i).e("input")),
          type: "checkbox",
          role: "switch",
          "aria-checked": g.value,
          "aria-disabled": S(c),
          "aria-label": w.ariaLabel,
          name: w.name,
          "true-value": w.activeValue,
          "false-value": w.inactiveValue,
          disabled: S(c),
          tabindex: w.tabindex,
          onChange: y,
          onKeydown: uo(b, ["enter"])
        }, null, 42, jwe),
        !w.inlinePrompt && (w.inactiveIcon || w.inactiveText || w.$slots.inactive) ? (G(), ue(
          "span",
          {
            key: 0,
            class: X(p.value)
          },
          [
            Oe(w.$slots, "inactive", {}, () => [
              w.inactiveIcon ? (G(), Me(S(ut), { key: 0 }, {
                default: Ee(() => [
                  (G(), Me(Ht(w.inactiveIcon)))
                ]),
                _: 1
              })) : Ie("v-if", !0),
              !w.inactiveIcon && w.inactiveText ? (G(), ue("span", {
                key: 1,
                "aria-hidden": g.value
              }, qe(w.inactiveText), 9, Wwe)) : Ie("v-if", !0)
            ])
          ],
          2
        )) : Ie("v-if", !0),
        ve(
          "span",
          {
            class: X(S(i).e("core")),
            style: gt(v.value)
          },
          [
            w.inlinePrompt ? (G(), ue(
              "div",
              {
                key: 0,
                class: X(S(i).e("inner"))
              },
              [
                g.value ? (G(), ue(
                  "div",
                  {
                    key: 1,
                    class: X(S(i).e("inner-wrapper"))
                  },
                  [
                    Oe(w.$slots, "active", {}, () => [
                      w.activeIcon ? (G(), Me(S(ut), { key: 0 }, {
                        default: Ee(() => [
                          (G(), Me(Ht(w.activeIcon)))
                        ]),
                        _: 1
                      })) : Ie("v-if", !0),
                      !w.activeIcon && w.activeText ? (G(), ue(
                        "span",
                        Uwe,
                        qe(w.activeText),
                        1
                      )) : Ie("v-if", !0)
                    ])
                  ],
                  2
                )) : (G(), ue(
                  "div",
                  {
                    key: 0,
                    class: X(S(i).e("inner-wrapper"))
                  },
                  [
                    Oe(w.$slots, "inactive", {}, () => [
                      w.inactiveIcon ? (G(), Me(S(ut), { key: 0 }, {
                        default: Ee(() => [
                          (G(), Me(Ht(w.inactiveIcon)))
                        ]),
                        _: 1
                      })) : Ie("v-if", !0),
                      !w.inactiveIcon && w.inactiveText ? (G(), ue(
                        "span",
                        Kwe,
                        qe(w.inactiveText),
                        1
                      )) : Ie("v-if", !0)
                    ])
                  ],
                  2
                ))
              ],
              2
            )) : Ie("v-if", !0),
            ve(
              "div",
              {
                class: X(S(i).e("action"))
              },
              [
                w.loading ? (G(), Me(S(ut), {
                  key: 0,
                  class: X(S(i).is("loading"))
                }, {
                  default: Ee(() => [
                    $(S(wi))
                  ]),
                  _: 1
                }, 8, ["class"])) : g.value ? Oe(w.$slots, "active-action", { key: 1 }, () => [
                  w.activeActionIcon ? (G(), Me(S(ut), { key: 0 }, {
                    default: Ee(() => [
                      (G(), Me(Ht(w.activeActionIcon)))
                    ]),
                    _: 1
                  })) : Ie("v-if", !0)
                ]) : g.value ? Ie("v-if", !0) : Oe(w.$slots, "inactive-action", { key: 2 }, () => [
                  w.inactiveActionIcon ? (G(), Me(S(ut), { key: 0 }, {
                    default: Ee(() => [
                      (G(), Me(Ht(w.inactiveActionIcon)))
                    ]),
                    _: 1
                  })) : Ie("v-if", !0)
                ])
              ],
              2
            )
          ],
          6
        ),
        !w.inlinePrompt && (w.activeIcon || w.activeText || w.$slots.active) ? (G(), ue(
          "span",
          {
            key: 1,
            class: X(m.value)
          },
          [
            Oe(w.$slots, "active", {}, () => [
              w.activeIcon ? (G(), Me(S(ut), { key: 0 }, {
                default: Ee(() => [
                  (G(), Me(Ht(w.activeIcon)))
                ]),
                _: 1
              })) : Ie("v-if", !0),
              !w.activeIcon && w.activeText ? (G(), ue("span", {
                key: 1,
                "aria-hidden": !g.value
              }, qe(w.activeText), 9, Gwe)) : Ie("v-if", !0)
            ])
          ],
          2
        )) : Ie("v-if", !0)
      ],
      2
    ));
  }
});
var Xwe = /* @__PURE__ */ Je(Ywe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/switch/src/switch.vue"]]);
const qwe = Dt(Xwe), ow = function(e) {
  var t;
  return (t = e.target) == null ? void 0 : t.closest("td");
}, Jwe = function(e, t, n, o, l) {
  if (!t && !o && (!l || We(l) && !l.length))
    return e;
  rt(n) ? n = n === "descending" ? -1 : 1 : n = n && n < 0 ? -1 : 1;
  const r = o ? null : function(i, s) {
    return l ? QB(ll(l), (c) => rt(c) ? Oo(i, c) : c(i, s, e)) : (t !== "$key" && Mt(i) && "$value" in i && (i = i.$value), [
      Mt(i) ? t ? Oo(i, t) : null : i
    ]);
  }, a = function(i, s) {
    var c, u, d, f, p, m;
    if (o)
      return o(i.value, s.value);
    for (let v = 0, h = (u = (c = i.key) == null ? void 0 : c.length) != null ? u : 0; v < h; v++) {
      if (((d = i.key) == null ? void 0 : d[v]) < ((f = s.key) == null ? void 0 : f[v]))
        return -1;
      if (((p = i.key) == null ? void 0 : p[v]) > ((m = s.key) == null ? void 0 : m[v]))
        return 1;
    }
    return 0;
  };
  return e.map((i, s) => ({
    value: i,
    index: s,
    key: r ? r(i, s) : null
  })).sort((i, s) => {
    let c = a(i, s);
    return c || (c = i.index - s.index), c * +n;
  }).map((i) => i.value);
}, bV = function(e, t) {
  let n = null;
  return e.columns.forEach((o) => {
    o.id === t && (n = o);
  }), n;
}, Zwe = function(e, t) {
  let n = null;
  for (let o = 0; o < e.columns.length; o++) {
    const l = e.columns[o];
    if (l.columnKey === t) {
      n = l;
      break;
    }
  }
  return n || no("ElTable", `No column matching with column-key: ${t}`), n;
}, AN = function(e, t, n) {
  const o = (t.className || "").match(
    new RegExp(`${n}-table_[^\\s]+`, "gm")
  );
  return o ? bV(e, o[0]) : null;
}, bl = (e, t) => {
  if (!e)
    throw new Error("Row is required when get row identity");
  if (rt(t)) {
    if (!t.includes("."))
      return `${e[t]}`;
    const n = t.split(".");
    let o = e;
    for (const l of n)
      o = o[l];
    return `${o}`;
  } else if (it(t))
    return t.call(null, e);
  return "";
}, vf = function(e, t, n = !1, o = "children") {
  const l = e || [], r = {};
  return l.forEach((a, i) => {
    if (r[bl(a, t)] = { row: a, index: i }, n) {
      const s = a[o];
      We(s) && Object.assign(r, vf(s, t, !0, o));
    }
  }), r;
};
function Qwe(e, t) {
  const n = {};
  let o;
  for (o in e)
    n[o] = e[o];
  for (o in t)
    if (hn(t, o)) {
      const l = t[o];
      fn(l) || (n[o] = l);
    }
  return n;
}
function E_(e) {
  return e === "" || fn(e) || (e = Number.parseInt(e, 10), Number.isNaN(e) && (e = "")), e;
}
function yV(e) {
  return e === "" || fn(e) || (e = E_(e), Number.isNaN(e) && (e = 80)), e;
}
function e$e(e) {
  return mt(e) ? e : rt(e) ? /^\d+(?:px)?$/.test(e) ? Number.parseInt(e, 10) : e : null;
}
function t$e(...e) {
  return e.length === 0 ? (t) => t : e.length === 1 ? e[0] : e.reduce(
    (t, n) => (...o) => t(n(...o))
  );
}
function X0(e, t, n, o, l, r, a) {
  let i = r != null ? r : 0, s = !1;
  const u = (() => {
    if (!a)
      return e.indexOf(t);
    const v = bl(t, a);
    return e.findIndex((h) => bl(h, a) === v);
  })(), d = u !== -1, f = l == null ? void 0 : l.call(null, t, i), p = (v) => {
    v === "add" ? e.push(t) : e.splice(u, 1), s = !0;
  }, m = (v) => {
    let h = 0;
    const g = (o == null ? void 0 : o.children) && v[o.children];
    return g && We(g) && (h += g.length, g.forEach((y) => {
      h += m(y);
    })), h;
  };
  return (!l || f) && (Tn(n) ? n && !d ? p("add") : !n && d && p("remove") : p(d ? "remove" : "add")), !(o != null && o.checkStrictly) && (o != null && o.children) && We(t[o.children]) && t[o.children].forEach((v) => {
    const h = X0(
      e,
      v,
      n != null ? n : !d,
      o,
      l,
      i + 1,
      a
    );
    i += m(v) + 1, h && (s = h);
  }), s;
}
function n$e(e, t, n = "children", o = "hasChildren", l = !1) {
  const r = (i) => !(We(i) && i.length);
  function a(i, s, c) {
    t(i, s, c), s.forEach((u) => {
      if (u[o] && l) {
        t(u, null, c + 1);
        return;
      }
      const d = u[n];
      r(d) || a(u, d, c + 1);
    });
  }
  e.forEach((i) => {
    if (i[o] && l) {
      t(i, null, 0);
      return;
    }
    const s = i[n];
    r(s) || a(i, s, 0);
  });
}
const o$e = (e, t, n, o) => {
  const l = Be({
    strategy: "fixed"
  }, e.popperOptions), r = it(o == null ? void 0 : o.tooltipFormatter) ? o.tooltipFormatter({
    row: n,
    column: o,
    cellValue: ff(n, o.property).value
  }) : void 0;
  return dn(r) ? vt(Be({
    slotContent: r,
    content: null
  }, e), {
    popperOptions: l
  }) : vt(Be({
    slotContent: null,
    content: r != null ? r : t
  }, e), {
    popperOptions: l
  });
};
let El = null;
function l$e(e, t, n, o, l, r) {
  var a;
  const i = o$e(
    e,
    t,
    n,
    o
  ), s = vt(Be({}, i), {
    slotContent: void 0
  });
  if ((El == null ? void 0 : El.trigger) === l) {
    const m = (a = El.vm) == null ? void 0 : a.component;
    t7(m == null ? void 0 : m.props, s), m && i.slotContent && (m.slots.content = () => [i.slotContent]);
    return;
  }
  El == null || El();
  const c = r == null ? void 0 : r.refs.tableWrapper, u = c == null ? void 0 : c.dataset.prefix, d = $(
    al,
    Be({
      virtualTriggering: !0,
      virtualRef: l,
      appendTo: c,
      placement: "top",
      transition: "none",
      offset: 0,
      hideAfter: 0
    }, s),
    i.slotContent ? {
      content: () => i.slotContent
    } : void 0
  );
  d.appContext = Be(Be({}, r.appContext), r);
  const f = document.createElement("div");
  Bl(d, f), d.component.exposed.onOpen();
  const p = c == null ? void 0 : c.querySelector(`.${u}-scrollbar__wrap`);
  El = () => {
    var m, v;
    (v = (m = d.component) == null ? void 0 : m.exposed) != null && v.onClose && d.component.exposed.onClose(), Bl(null, f);
    const h = El;
    p == null || p.removeEventListener("scroll", h), h.trigger = void 0, h.vm = void 0, El = null;
  }, El.trigger = l != null ? l : void 0, El.vm = d, p == null || p.addEventListener("scroll", El);
}
function SV(e) {
  return e.children ? QB(e.children, SV) : [e];
}
function RN(e, t) {
  return e + t.colSpan;
}
const CV = (e, t, n, o) => {
  let l = 0, r = e;
  const a = n.states.columns.value;
  if (o) {
    const s = SV(o[e]);
    l = a.slice(0, a.indexOf(s[0])).reduce(RN, 0), r = l + s.reduce(RN, 0) - 1;
  } else
    l = e;
  let i;
  switch (t) {
    case "left":
      r < n.states.fixedLeafColumnsLength.value && (i = "left");
      break;
    case "right":
      l >= a.length - n.states.rightFixedLeafColumnsLength.value && (i = "right");
      break;
    default:
      r < n.states.fixedLeafColumnsLength.value ? i = "left" : l >= a.length - n.states.rightFixedLeafColumnsLength.value && (i = "right");
  }
  return i ? {
    direction: i,
    start: l,
    after: r
  } : {};
}, O_ = (e, t, n, o, l, r = 0) => {
  const a = [], { direction: i, start: s, after: c } = CV(
    t,
    n,
    o,
    l
  );
  if (i) {
    const u = i === "left";
    a.push(`${e}-fixed-column--${i}`), u && c + r === o.states.fixedLeafColumnsLength.value - 1 ? a.push("is-last-column") : !u && s - r === o.states.columns.value.length - o.states.rightFixedLeafColumnsLength.value && a.push("is-first-column");
  }
  return a;
};
function DN(e, t) {
  return e + (k1(t.realWidth) || Number.isNaN(t.realWidth) ? Number(t.width) : t.realWidth);
}
const __ = (e, t, n, o) => {
  const {
    direction: l,
    start: r = 0,
    after: a = 0
  } = CV(e, t, n, o);
  if (!l)
    return;
  const i = {}, s = l === "left", c = n.states.columns.value;
  return s ? i.left = c.slice(0, r).reduce(DN, 0) : i.right = c.slice(a + 1).reverse().reduce(DN, 0), i;
}, Qf = (e, t) => {
  e && (Number.isNaN(e[t]) || (e[t] = `${e[t]}px`));
};
function wV(e) {
  return e.some((t) => dn(t) ? !(t.type === qn || t.type === Ge && !wV(t.children)) : !0) ? e : null;
}
function r$e(e) {
  const t = xt(), n = /* @__PURE__ */ H(!1), o = /* @__PURE__ */ H([]);
  return {
    updateExpandRows: () => {
      const s = e.data.value || [], c = e.rowKey.value;
      if (n.value)
        o.value = s.slice();
      else if (c) {
        const u = vf(o.value, c);
        o.value = s.reduce((d, f) => {
          const p = bl(f, c);
          return u[p] && d.push(f), d;
        }, []);
      } else
        o.value = [];
    },
    toggleRowExpansion: (s, c) => {
      X0(
        o.value,
        s,
        c,
        void 0,
        void 0,
        void 0,
        e.rowKey.value
      ) && t.emit("expand-change", s, o.value.slice());
    },
    setExpandRowKeys: (s) => {
      t.store.assertRowKey();
      const c = e.data.value || [], u = e.rowKey.value, d = vf(c, u);
      o.value = s.reduce((f, p) => {
        const m = d[p];
        return m && f.push(m.row), f;
      }, []);
    },
    isRowExpanded: (s) => {
      const c = e.rowKey.value;
      return c ? !!vf(o.value, c)[bl(s, c)] : o.value.includes(s);
    },
    states: {
      expandRows: o,
      defaultExpandAll: n
    }
  };
}
function a$e(e) {
  const t = xt(), n = /* @__PURE__ */ H(null), o = /* @__PURE__ */ H(null), l = (c) => {
    t.store.assertRowKey(), n.value = c, a(c);
  }, r = () => {
    n.value = null;
  }, a = (c) => {
    var u;
    const { data: d, rowKey: f } = e, p = o.value;
    let m = null;
    f.value && (m = (u = (S(d) || []).find(
      (v) => bl(v, f.value) === c
    )) != null ? u : null), o.value = m != null ? m : null, t.emit("current-change", o.value, p);
  };
  return {
    setCurrentRowKey: l,
    restoreCurrentRowKey: r,
    setCurrentRowByKey: a,
    updateCurrentRow: (c) => {
      const u = o.value;
      if (c && c !== u) {
        o.value = c, t.emit("current-change", o.value, u);
        return;
      }
      !c && u && (o.value = null, t.emit("current-change", null, u));
    },
    updateCurrentRowData: () => {
      const c = e.rowKey.value, u = e.data.value || [], d = o.value;
      if (d && !u.includes(d))
        if (c) {
          const f = bl(d, c);
          a(f);
        } else
          o.value = null, t.emit("current-change", null, d);
      else n.value && (a(n.value), r());
    },
    states: {
      _currentRowKey: n,
      currentRow: o
    }
  };
}
function i$e(e) {
  const t = /* @__PURE__ */ H([]), n = /* @__PURE__ */ H({}), o = /* @__PURE__ */ H(16), l = /* @__PURE__ */ H(!1), r = /* @__PURE__ */ H({}), a = /* @__PURE__ */ H("hasChildren"), i = /* @__PURE__ */ H("children"), s = /* @__PURE__ */ H(!1), c = xt(), u = O(() => {
    if (!e.rowKey.value)
      return {};
    const C = e.data.value || [];
    return f(C);
  }), d = O(() => {
    const C = e.rowKey.value, w = Object.keys(r.value), x = {};
    return w.length && w.forEach((E) => {
      if (r.value[E].length) {
        const I = { children: [] };
        r.value[E].forEach((T) => {
          const P = bl(T, C);
          I.children.push(P), T[a.value] && !x[P] && (x[P] = { children: [] });
        }), x[E] = I;
      }
    }), x;
  }), f = (C) => {
    const w = e.rowKey.value, x = {};
    return n$e(
      C,
      (E, I, T) => {
        const P = bl(E, w);
        We(I) ? x[P] = {
          children: I.map((k) => bl(k, w)),
          level: T
        } : l.value && (x[P] = {
          children: [],
          lazy: !0,
          level: T
        });
      },
      i.value,
      a.value,
      l.value
    ), x;
  }, p = (C = !1, w) => {
    var x, E;
    w || (w = (x = c.store) == null ? void 0 : x.states.defaultExpandAll.value);
    const I = u.value, T = d.value, P = Object.keys(I), k = {};
    if (P.length) {
      const N = S(n), R = [], z = (F, M) => {
        if (C)
          return t.value ? w || t.value.includes(M) : !!(w || F != null && F.expanded);
        {
          const A = w || t.value && t.value.includes(M);
          return !!(F != null && F.expanded || A);
        }
      };
      P.forEach((F) => {
        const M = N[F], A = Be({}, I[F]);
        if (A.expanded = z(M, F), A.lazy) {
          const { loaded: L = !1, loading: B = !1 } = M || {};
          A.loaded = !!L, A.loading = !!B, R.push(F);
        }
        k[F] = A;
      });
      const D = Object.keys(T);
      l.value && D.length && R.length && D.forEach((F) => {
        var M;
        const A = N[F], L = T[F].children;
        if (R.includes(F)) {
          if (((M = k[F].children) == null ? void 0 : M.length) !== 0)
            throw new Error("[ElTable]children must be an empty array.");
          k[F].children = L;
        } else {
          const { loaded: B = !1, loading: V = !1 } = A || {};
          k[F] = {
            lazy: !0,
            loaded: !!B,
            loading: !!V,
            expanded: z(A, F),
            children: L,
            level: void 0
          };
        }
      });
    }
    n.value = k, (E = c.store) == null || E.updateTableScrollY();
  };
  pe(
    () => t.value,
    () => {
      p(!0);
    }
  ), pe(
    () => u.value,
    () => {
      p();
    }
  ), pe(
    () => d.value,
    () => {
      p();
    }
  );
  const m = (C) => {
    t.value = C, p();
  }, v = (C) => l.value && C && "loaded" in C && !C.loaded, h = (C, w) => {
    c.store.assertRowKey();
    const x = e.rowKey.value, E = bl(C, x), I = E && n.value[E];
    if (E && I && "expanded" in I) {
      const T = I.expanded;
      w = fn(w) ? !I.expanded : w, n.value[E].expanded = w, T !== w && c.emit("expand-change", C, w), w && v(I) && y(C, E, I), c.store.updateTableScrollY();
    }
  }, g = (C) => {
    c.store.assertRowKey();
    const w = e.rowKey.value, x = bl(C, w), E = n.value[x];
    v(E) ? y(C, x, E) : h(C, void 0);
  }, y = (C, w, x) => {
    const { load: E } = c.props;
    E && !n.value[w].loaded && (n.value[w].loading = !0, E(C, x, (I) => {
      if (!We(I))
        throw new TypeError("[ElTable] data must be an array");
      n.value[w].loading = !1, n.value[w].loaded = !0, n.value[w].expanded = !0, I.length && (r.value[w] = I), c.emit("expand-change", C, !0);
    }));
  };
  return {
    loadData: y,
    loadOrToggle: g,
    toggleTreeExpansion: h,
    updateTreeExpandKeys: m,
    updateTreeData: p,
    updateKeyChildren: (C, w) => {
      const { lazy: x, rowKey: E } = c.props;
      if (x) {
        if (!E)
          throw new Error("[Table] rowKey is required in updateKeyChild");
        r.value[C] && (r.value[C] = w);
      }
    },
    normalize: f,
    states: {
      expandRowKeys: t,
      treeData: n,
      indent: o,
      lazy: l,
      lazyTreeNodeMap: r,
      lazyColumnIdentifier: a,
      childrenColumnName: i,
      checkStrictly: s
    }
  };
}
const s$e = (e, t) => {
  const n = t.sortingColumn;
  return !n || rt(n.sortable) ? e : Jwe(
    e,
    t.sortProp,
    t.sortOrder,
    n.sortMethod,
    n.sortBy
  );
}, mb = (e) => {
  const t = [];
  return e.forEach((n) => {
    n.children && n.children.length > 0 ? t.push.apply(t, mb(n.children)) : t.push(n);
  }), t;
};
function c$e() {
  var e;
  const t = xt(), { size: n } = /* @__PURE__ */ to((e = t.proxy) == null ? void 0 : e.$props), o = /* @__PURE__ */ H(null), l = /* @__PURE__ */ H([]), r = /* @__PURE__ */ H([]), a = /* @__PURE__ */ H(!1), i = /* @__PURE__ */ H([]), s = /* @__PURE__ */ H([]), c = /* @__PURE__ */ H([]), u = /* @__PURE__ */ H([]), d = /* @__PURE__ */ H([]), f = /* @__PURE__ */ H([]), p = /* @__PURE__ */ H([]), m = /* @__PURE__ */ H([]), v = [], h = /* @__PURE__ */ H(0), g = /* @__PURE__ */ H(0), y = /* @__PURE__ */ H(0), b = /* @__PURE__ */ H(!1), C = /* @__PURE__ */ H([]), w = /* @__PURE__ */ H(!1), x = /* @__PURE__ */ H(!1), E = /* @__PURE__ */ H(null), I = /* @__PURE__ */ H({}), T = /* @__PURE__ */ H(null), P = /* @__PURE__ */ H(null), k = /* @__PURE__ */ H(null), N = /* @__PURE__ */ H(null), R = /* @__PURE__ */ H(null), z = O(() => o.value ? vf(C.value, o.value) : void 0);
  pe(
    l,
    () => {
      var Pe;
      t.state && (A(!1), t.props.tableLayout === "auto" && ((Pe = t.refs.tableHeaderRef) == null || Pe.updateFixedColumnStyle()));
    },
    {
      deep: !0
    }
  );
  const D = () => {
    if (!o.value)
      throw new Error("[ElTable] prop row-key is required");
  }, F = (Pe) => {
    var Re;
    (Re = Pe.children) == null || Re.forEach((Le) => {
      Le.fixed = Pe.fixed, F(Le);
    });
  }, M = () => {
    i.value.forEach((_e) => {
      F(_e);
    }), u.value = i.value.filter(
      (_e) => [!0, "left"].includes(_e.fixed)
    );
    const Pe = i.value.find(
      (_e) => _e.type === "selection"
    );
    let Re;
    Pe && Pe.fixed !== "right" && !u.value.includes(Pe) && i.value.indexOf(Pe) === 0 && u.value.length && (u.value.unshift(Pe), Re = !0), d.value = i.value.filter(
      (_e) => _e.fixed === "right"
    );
    const Le = i.value.filter(
      (_e) => (Re ? _e.type !== "selection" : !0) && !_e.fixed
    );
    s.value = Array.from(u.value).concat(Le).concat(d.value);
    const Ue = mb(Le), Ae = mb(u.value), De = mb(d.value);
    h.value = Ue.length, g.value = Ae.length, y.value = De.length, c.value = Array.from(Ae).concat(Ue).concat(De), a.value = u.value.length > 0 || d.value.length > 0;
  }, A = (Pe, Re = !1) => {
    Pe && M(), Re ? t.state.doLayout() : t.state.debouncedUpdateLayout();
  }, L = (Pe) => z.value ? !!z.value[bl(Pe, o.value)] : C.value.includes(Pe), B = () => {
    b.value = !1;
    const Pe = C.value;
    C.value = [], Pe.length && t.emit("selection-change", []);
  }, V = () => {
    var Pe, Re;
    let Le;
    if (o.value) {
      Le = [];
      const Ue = (Re = (Pe = t == null ? void 0 : t.store) == null ? void 0 : Pe.states) == null ? void 0 : Re.childrenColumnName.value, Ae = vf(l.value, o.value, !0, Ue);
      for (const De in z.value)
        hn(z.value, De) && !Ae[De] && Le.push(z.value[De].row);
    } else
      Le = C.value.filter((Ue) => !l.value.includes(Ue));
    if (Le.length) {
      const Ue = C.value.filter(
        (Ae) => !Le.includes(Ae)
      );
      C.value = Ue, t.emit("selection-change", Ue.slice());
    }
  }, j = () => (C.value || []).slice(), W = (Pe, Re, Le = !0, Ue = !1) => {
    var Ae, De, _e, Ze;
    const dt = {
      children: (De = (Ae = t == null ? void 0 : t.store) == null ? void 0 : Ae.states) == null ? void 0 : De.childrenColumnName.value,
      checkStrictly: (Ze = (_e = t == null ? void 0 : t.store) == null ? void 0 : _e.states) == null ? void 0 : Ze.checkStrictly.value
    };
    if (X0(
      C.value,
      Pe,
      Re,
      dt,
      Ue ? void 0 : E.value,
      l.value.indexOf(Pe),
      o.value
    )) {
      const jt = (C.value || []).slice();
      Le && t.emit("select", jt, Pe), t.emit("selection-change", jt);
    }
  }, Y = () => {
    var Pe, Re;
    const Le = x.value ? !b.value : !(b.value || C.value.length);
    b.value = Le;
    let Ue = !1, Ae = 0;
    const De = (Re = (Pe = t == null ? void 0 : t.store) == null ? void 0 : Pe.states) == null ? void 0 : Re.rowKey.value, { childrenColumnName: _e } = t.store.states, Ze = {
      children: _e.value,
      checkStrictly: !1
    };
    l.value.forEach((dt, Tt) => {
      const jt = Tt + Ae;
      X0(
        C.value,
        dt,
        Le,
        Ze,
        E.value,
        jt,
        De
      ) && (Ue = !0), Ae += te(bl(dt, De));
    }), Ue && t.emit(
      "selection-change",
      C.value ? C.value.slice() : []
    ), t.emit("select-all", (C.value || []).slice());
  }, U = () => {
    var Pe;
    if (((Pe = l.value) == null ? void 0 : Pe.length) === 0) {
      b.value = !1;
      return;
    }
    const { childrenColumnName: Re } = t.store.states;
    let Le = 0, Ue = 0;
    const Ae = (_e) => {
      var Ze;
      for (const dt of _e) {
        const Tt = E.value && E.value.call(null, dt, Le);
        if (L(dt))
          Ue++;
        else if (!E.value || Tt)
          return !1;
        if (Le++, (Ze = dt[Re.value]) != null && Ze.length && !Ae(dt[Re.value]))
          return !1;
      }
      return !0;
    }, De = Ae(l.value || []);
    b.value = Ue === 0 ? !1 : De;
  }, te = (Pe) => {
    var Re;
    if (!t || !t.store)
      return 0;
    const { treeData: Le } = t.store.states;
    let Ue = 0;
    const Ae = (Re = Le.value[Pe]) == null ? void 0 : Re.children;
    return Ae && (Ue += Ae.length, Ae.forEach((De) => {
      Ue += te(De);
    })), Ue;
  }, J = (Pe, Re) => {
    const Le = {};
    return ll(Pe).forEach((Ue) => {
      I.value[Ue.id] = Re, Le[Ue.columnKey || Ue.id] = Re;
    }), Le;
  }, re = (Pe, Re, Le) => {
    P.value && P.value !== Pe && (P.value.order = null), P.value = Pe, k.value = Re, N.value = Le;
  }, oe = () => {
    let Pe = S(r);
    Object.keys(I.value).forEach((Re) => {
      const Le = I.value[Re];
      if (!Le || Le.length === 0)
        return;
      const Ue = bV(
        {
          columns: c.value
        },
        Re
      );
      Ue && Ue.filterMethod && (Pe = Pe.filter((Ae) => Le.some(
        (De) => Ue.filterMethod.call(null, De, Ae, Ue)
      )));
    }), T.value = Pe;
  }, q = () => {
    var Pe;
    l.value = s$e((Pe = T.value) != null ? Pe : [], {
      sortingColumn: P.value,
      sortProp: k.value,
      sortOrder: N.value
    });
  }, K = (Pe = void 0) => {
    Pe != null && Pe.filter || oe(), q();
  }, se = (Pe) => {
    const { tableHeaderRef: Re } = t.refs;
    if (!Re)
      return;
    const Le = Object.assign({}, Re.filterPanels), Ue = Object.keys(Le);
    if (Ue.length)
      if (rt(Pe) && (Pe = [Pe]), We(Pe)) {
        const Ae = Pe.map(
          (De) => Zwe(
            {
              columns: c.value
            },
            De
          )
        );
        Ue.forEach((De) => {
          const _e = Ae.find((Ze) => Ze.id === De);
          _e && (_e.filteredValue = []);
        }), t.store.commit("filterChange", {
          column: Ae,
          values: [],
          silent: !0,
          multi: !0
        });
      } else
        Ue.forEach((Ae) => {
          const De = c.value.find((_e) => _e.id === Ae);
          De && (De.filteredValue = []);
        }), I.value = {}, t.store.commit("filterChange", {
          column: {},
          values: [],
          silent: !0
        });
  }, Z = () => {
    P.value && (re(null, null, null), t.store.commit("changeSortCondition", {
      silent: !0
    }));
  }, {
    setExpandRowKeys: ee,
    toggleRowExpansion: fe,
    updateExpandRows: me,
    states: ge,
    isRowExpanded: he
  } = r$e({
    data: l,
    rowKey: o
  }), {
    updateTreeExpandKeys: $e,
    toggleTreeExpansion: ne,
    updateTreeData: ae,
    updateKeyChildren: ce,
    loadOrToggle: xe,
    states: Te
  } = i$e({
    data: l,
    rowKey: o
  }), {
    updateCurrentRowData: Se,
    updateCurrentRow: be,
    setCurrentRowKey: ie,
    states: we
  } = a$e({
    data: l,
    rowKey: o
  });
  return {
    assertRowKey: D,
    updateColumns: M,
    scheduleLayout: A,
    isSelected: L,
    clearSelection: B,
    cleanSelection: V,
    getSelectionRows: j,
    toggleRowSelection: W,
    _toggleAllSelection: Y,
    toggleAllSelection: null,
    updateAllSelected: U,
    updateFilters: J,
    updateCurrentRow: be,
    updateSort: re,
    execFilter: oe,
    execSort: q,
    execQuery: K,
    clearFilter: se,
    clearSort: Z,
    toggleRowExpansion: fe,
    setExpandRowKeysAdapter: (Pe) => {
      ee(Pe), $e(Pe);
    },
    setCurrentRowKey: ie,
    toggleRowExpansionAdapter: (Pe, Re) => {
      c.value.some(({ type: Ue }) => Ue === "expand") ? fe(Pe, Re) : ne(Pe, Re);
    },
    isRowExpanded: he,
    updateExpandRows: me,
    updateCurrentRowData: Se,
    loadOrToggle: xe,
    updateTreeData: ae,
    updateKeyChildren: ce,
    states: Be(Be(Be({
      tableSize: n,
      rowKey: o,
      data: l,
      _data: r,
      isComplex: a,
      _columns: i,
      originColumns: s,
      columns: c,
      fixedColumns: u,
      rightFixedColumns: d,
      leafColumns: f,
      fixedLeafColumns: p,
      rightFixedLeafColumns: m,
      updateOrderFns: v,
      leafColumnsLength: h,
      fixedLeafColumnsLength: g,
      rightFixedLeafColumnsLength: y,
      isAllSelected: b,
      selection: C,
      reserveSelection: w,
      selectOnIndeterminate: x,
      selectable: E,
      filters: I,
      filteredData: T,
      sortingColumn: P,
      sortProp: k,
      sortOrder: N,
      hoverRow: R
    }, ge), Te), we)
  };
}
function Nx(e, t) {
  return e.map((n) => {
    var o;
    return n.id === t.id ? t : ((o = n.children) != null && o.length && (n.children = Nx(n.children, t)), n);
  });
}
function Mx(e) {
  e.forEach((t) => {
    var n, o;
    t.no = (n = t.getColumnIndex) == null ? void 0 : n.call(t), (o = t.children) != null && o.length && Mx(t.children);
  }), e.sort((t, n) => t.no - n.no);
}
function u$e() {
  const e = xt(), t = c$e(), n = Ve("table"), { t: o } = an(), l = {
    setData(i, s) {
      const c = S(i._data) !== s;
      i.data.value = s, i._data.value = s, e.store.execQuery(), e.store.updateCurrentRowData(), e.store.updateExpandRows(), e.store.updateTreeData(
        e.store.states.defaultExpandAll.value
      ), S(i.reserveSelection) ? e.store.assertRowKey() : c ? e.store.clearSelection() : e.store.cleanSelection(), e.store.updateAllSelected(), e.$ready && e.store.scheduleLayout();
    },
    insertColumn(i, s, c, u) {
      var d;
      const f = S(i._columns);
      let p = [];
      c ? (c && !c.children && (c.children = []), (d = c.children) == null || d.push(s), p = Nx(f, c)) : (f.push(s), p = f), Mx(p), i._columns.value = p, i.updateOrderFns.push(u), s.type === "selection" && (i.selectable.value = s.selectable, i.reserveSelection.value = s.reserveSelection), e.$ready && (e.store.updateColumns(), e.store.scheduleLayout());
    },
    updateColumnOrder(i, s) {
      var c;
      ((c = s.getColumnIndex) == null ? void 0 : c.call(s)) !== s.no && (Mx(i._columns.value), e.$ready && e.store.updateColumns());
    },
    removeColumn(i, s, c, u) {
      var d;
      const f = S(i._columns) || [];
      if (c)
        (d = c.children) == null || d.splice(
          c.children.findIndex((m) => m.id === s.id),
          1
        ), Ke(() => {
          var m;
          ((m = c.children) == null ? void 0 : m.length) === 0 && delete c.children;
        }), i._columns.value = Nx(f, c);
      else {
        const m = f.indexOf(s);
        m > -1 && (f.splice(m, 1), i._columns.value = f);
      }
      const p = i.updateOrderFns.indexOf(u);
      p > -1 && i.updateOrderFns.splice(p, 1), e.$ready && (e.store.updateColumns(), e.store.scheduleLayout());
    },
    sort(i, s) {
      const { prop: c, order: u, init: d } = s;
      if (c) {
        const f = S(i.columns).find(
          (p) => p.property === c
        );
        f && (f.order = u, e.store.updateSort(f, c, u), e.store.commit("changeSortCondition", { init: d }));
      }
    },
    changeSortCondition(i, s) {
      const { sortingColumn: c, sortProp: u, sortOrder: d } = i, f = S(c), p = S(u), m = S(d);
      k1(m) && (i.sortingColumn.value = null, i.sortProp.value = null);
      const v = { filter: !0 };
      e.store.execQuery(v), (!s || !(s.silent || s.init)) && e.emit("sort-change", {
        column: f,
        prop: p,
        order: m
      }), e.store.updateTableScrollY();
    },
    filterChange(i, s) {
      const { column: c, values: u, silent: d } = s, f = e.store.updateFilters(c, u);
      e.store.execQuery(), d || e.emit("filter-change", f), e.store.updateTableScrollY();
    },
    toggleAllSelection() {
      var i, s;
      (s = (i = e.store).toggleAllSelection) == null || s.call(i);
    },
    rowSelectedChanged(i, s) {
      e.store.toggleRowSelection(s), e.store.updateAllSelected();
    },
    setHoverRow(i, s) {
      i.hoverRow.value = s;
    },
    setCurrentRow(i, s) {
      e.store.updateCurrentRow(s);
    }
  }, r = function(i, ...s) {
    const c = e.store.mutations;
    if (c[i])
      c[i].apply(e, [
        e.store.states,
        ...s
      ]);
    else
      throw new Error(`Action not found: ${i}`);
  }, a = function() {
    Ke(() => e.layout.updateScrollY.apply(e.layout));
  };
  return vt(Be({
    ns: n,
    t: o
  }, t), {
    mutations: l,
    commit: r,
    updateTableScrollY: a
  });
}
const I_ = {
  rowKey: "rowKey",
  defaultExpandAll: "defaultExpandAll",
  selectOnIndeterminate: "selectOnIndeterminate",
  indent: "indent",
  lazy: "lazy",
  "treeProps.hasChildren": {
    key: "lazyColumnIdentifier",
    default: "hasChildren"
  },
  "treeProps.children": {
    key: "childrenColumnName",
    default: "children"
  },
  "treeProps.checkStrictly": {
    key: "checkStrictly",
    default: !1
  }
};
function d$e(e, t) {
  if (!e)
    throw new Error("Table is required.");
  const n = u$e();
  return n.toggleAllSelection = Dr(n._toggleAllSelection, 10), Object.keys(I_).forEach((o) => {
    $V(xV(t, o), o, n);
  }), f$e(n, t), n;
}
function f$e(e, t) {
  Object.keys(I_).forEach((n) => {
    pe(
      () => xV(t, n),
      (o) => {
        $V(o, n, e);
      }
    );
  });
}
function $V(e, t, n) {
  let o = e, l = I_[t];
  Mt(l) && (o = o || l.default, l = l.key), n.states[l].value = o;
}
function xV(e, t) {
  if (t.includes(".")) {
    const n = t.split(".");
    let o = e;
    return n.forEach((l) => {
      o = o[l];
    }), o;
  } else
    return e[t];
}
class p$e {
  constructor(t) {
    this.observers = [], this.table = null, this.store = null, this.columns = [], this.fit = !0, this.showHeader = !0, this.height = /* @__PURE__ */ H(null), this.scrollX = /* @__PURE__ */ H(!1), this.scrollY = /* @__PURE__ */ H(!1), this.bodyWidth = /* @__PURE__ */ H(null), this.fixedWidth = /* @__PURE__ */ H(null), this.rightFixedWidth = /* @__PURE__ */ H(null), this.gutterWidth = 0;
    for (const n in t)
      hn(t, n) && (/* @__PURE__ */ kn(this[n]) ? this[n].value = t[n] : this[n] = t[n]);
    if (!this.table)
      throw new Error("Table is required for Table Layout");
    if (!this.store)
      throw new Error("Store is required for Table Layout");
  }
  updateScrollY() {
    const t = this.height.value;
    if (k1(t))
      return !1;
    const n = this.table.refs.scrollBarRef;
    if (this.table.vnode.el && (n != null && n.wrapRef)) {
      let o = !0;
      const l = this.scrollY.value;
      return o = n.wrapRef.scrollHeight > n.wrapRef.clientHeight, this.scrollY.value = o, l !== o;
    }
    return !1;
  }
  setHeight(t, n = "height") {
    if (!Sn)
      return;
    const o = this.table.vnode.el;
    if (t = e$e(t), this.height.value = Number(t), !o && (t || t === 0)) {
      Ke(() => this.setHeight(t, n));
      return;
    }
    o && mt(t) ? (o.style[n] = `${t}px`, this.updateElsHeight()) : o && rt(t) && (o.style[n] = t, this.updateElsHeight());
  }
  setMaxHeight(t) {
    this.setHeight(t, "max-height");
  }
  getFlattenColumns() {
    const t = [];
    return this.table.store.states.columns.value.forEach((o) => {
      o.isColumnGroup ? t.push.apply(t, o.columns) : t.push(o);
    }), t;
  }
  updateElsHeight() {
    this.updateScrollY(), this.notifyObservers("scrollable");
  }
  headerDisplayNone(t) {
    if (!t)
      return !0;
    let n = t;
    for (; n.tagName !== "DIV"; ) {
      if (getComputedStyle(n).display === "none")
        return !0;
      n = n.parentElement;
    }
    return !1;
  }
  updateColumnsWidth() {
    var t;
    if (!Sn)
      return;
    const n = this.fit, o = (t = this.table.vnode.el) == null ? void 0 : t.clientWidth;
    let l = 0;
    const r = this.getFlattenColumns(), a = r.filter(
      (c) => !mt(c.width)
    );
    if (r.forEach((c) => {
      mt(c.width) && c.realWidth && (c.realWidth = null);
    }), a.length > 0 && n) {
      if (r.forEach((c) => {
        l += Number(c.width || c.minWidth || 80);
      }), l <= o) {
        this.scrollX.value = !1;
        const c = o - l;
        if (a.length === 1)
          a[0].realWidth = Number(a[0].minWidth || 80) + c;
        else {
          const u = a.reduce(
            (p, m) => p + Number(m.minWidth || 80),
            0
          ), d = c / u;
          let f = 0;
          a.forEach((p, m) => {
            if (m === 0)
              return;
            const v = Math.floor(
              Number(p.minWidth || 80) * d
            );
            f += v, p.realWidth = Number(p.minWidth || 80) + v;
          }), a[0].realWidth = Number(a[0].minWidth || 80) + c - f;
        }
      } else
        this.scrollX.value = !0, a.forEach((c) => {
          c.realWidth = Number(c.minWidth);
        });
      this.bodyWidth.value = Math.max(l, o), this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else
      r.forEach((c) => {
        !c.width && !c.minWidth ? c.realWidth = 80 : c.realWidth = Number(c.width || c.minWidth), l += c.realWidth;
      }), this.scrollX.value = l > o, this.bodyWidth.value = l;
    const i = this.store.states.fixedColumns.value;
    if (i.length > 0) {
      let c = 0;
      i.forEach((u) => {
        c += Number(u.realWidth || u.width);
      }), this.fixedWidth.value = c;
    }
    const s = this.store.states.rightFixedColumns.value;
    if (s.length > 0) {
      let c = 0;
      s.forEach((u) => {
        c += Number(u.realWidth || u.width);
      }), this.rightFixedWidth.value = c;
    }
    this.notifyObservers("columns");
  }
  addObserver(t) {
    this.observers.push(t);
  }
  removeObserver(t) {
    const n = this.observers.indexOf(t);
    n !== -1 && this.observers.splice(n, 1);
  }
  notifyObservers(t) {
    this.observers.forEach((o) => {
      var l, r;
      switch (t) {
        case "columns":
          (l = o.state) == null || l.onColumnsChange(this);
          break;
        case "scrollable":
          (r = o.state) == null || r.onScrollableChange(this);
          break;
        default:
          throw new Error(`Table Layout don't have event ${t}.`);
      }
    });
  }
}
const v$e = /* @__PURE__ */ le({
  name: "ElTableFilterPanel",
  components: {
    ElCheckbox: Fa,
    ElCheckboxGroup: o_,
    ElScrollbar: Ba,
    ElTooltip: al,
    ElIcon: ut,
    ArrowDown: Ni,
    ArrowUp: A1
  },
  props: {
    placement: {
      type: String,
      default: "bottom-start"
    },
    store: {
      type: Object
    },
    column: {
      type: Object
    },
    upDataColumn: {
      type: Function
    },
    appendTo: In.appendTo
  },
  setup(e) {
    const t = xt(), { t: n } = an(), o = Ve("table-filter"), l = t == null ? void 0 : t.parent;
    e.column && !l.filterPanels.value[e.column.id] && (l.filterPanels.value[e.column.id] = t);
    const r = /* @__PURE__ */ H(null), a = /* @__PURE__ */ H(null), i = /* @__PURE__ */ H(0), s = O(() => e.column && e.column.filters), c = O(() => e.column && e.column.filterClassName ? `${o.b()} ${e.column.filterClassName}` : o.b()), u = O({
      get: () => {
        var E;
        return (((E = e.column) == null ? void 0 : E.filteredValue) || [])[0];
      },
      set: (E) => {
        d.value && (hr(E) ? d.value.splice(0, 1) : d.value.splice(0, 1, E));
      }
    }), d = O({
      get() {
        return e.column ? e.column.filteredValue || [] : [];
      },
      set(E) {
        var I;
        e.column && ((I = e.upDataColumn) == null || I.call(e, "filteredValue", E));
      }
    }), f = O(() => e.column ? e.column.filterMultiple : !0), p = (E) => E.value === u.value, m = () => {
      var E;
      (E = r.value) == null || E.onClose();
    }, v = () => {
      y(d.value), m();
    }, h = () => {
      d.value = [], y(d.value), m();
    }, g = (E, I) => {
      u.value = E, i.value = I, hr(E) ? y([]) : y(d.value), m();
    }, y = (E) => {
      var I, T;
      (I = e.store) == null || I.commit("filterChange", {
        column: e.column,
        values: E
      }), (T = e.store) == null || T.updateAllSelected();
    }, b = () => {
      var E, I;
      (E = a.value) == null || E.focus(), !f.value && w(), e.column && ((I = e.upDataColumn) == null || I.call(e, "filterOpened", !0));
    }, C = () => {
      var E;
      e.column && ((E = e.upDataColumn) == null || E.call(e, "filterOpened", !1));
    }, w = () => {
      if (hr(u)) {
        i.value = 0;
        return;
      }
      const E = (s.value || []).findIndex((I) => I.value === u.value);
      i.value = E >= 0 ? E + 1 : 0;
    };
    return {
      multiple: f,
      filterClassName: c,
      filteredValue: d,
      filterValue: u,
      filters: s,
      handleConfirm: v,
      handleReset: h,
      handleSelect: g,
      isPropAbsent: hr,
      isActive: p,
      t: n,
      ns: o,
      tooltipRef: r,
      rootRef: a,
      checkedIndex: i,
      handleShowTooltip: b,
      handleHideTooltip: C,
      handleKeydown: (E) => {
        var I, T;
        const P = Nn(E), k = (s.value ? s.value.length : 0) + 1;
        let N = i.value, R = !0;
        switch (P) {
          case Ye.down:
          case Ye.right:
            N = (N + 1) % k;
            break;
          case Ye.up:
          case Ye.left:
            N = (N - 1 + k) % k;
            break;
          case Ye.tab:
            m(), R = !1;
            break;
          case Ye.enter:
          case Ye.space:
            if (N === 0)
              g(null, 0);
            else {
              const z = (s.value || [])[N - 1];
              z.value && g(z.value, N);
            }
            break;
          default:
            R = !1;
            break;
        }
        R && E.preventDefault(), i.value = N, (T = (I = a.value) == null ? void 0 : I.querySelector(
          `.${o.e("list-item")}:nth-child(${N + 1})`
        )) == null || T.focus();
      }
    };
  }
}), m$e = ["disabled"], h$e = ["tabindex", "aria-checked"], g$e = ["tabindex", "aria-checked", "onClick"], b$e = ["aria-label"];
function y$e(e, t, n, o, l, r) {
  const a = yn("el-checkbox"), i = yn("el-checkbox-group"), s = yn("el-scrollbar"), c = yn("arrow-up"), u = yn("arrow-down"), d = yn("el-icon"), f = yn("el-tooltip");
  return G(), Me(f, {
    ref: "tooltipRef",
    offset: 0,
    placement: e.placement,
    "show-arrow": !1,
    trigger: "click",
    role: "dialog",
    teleported: "",
    effect: "light",
    pure: "",
    loop: "",
    "popper-class": e.filterClassName,
    persistent: "",
    "append-to": e.appendTo,
    onShow: e.handleShowTooltip,
    onHide: e.handleHideTooltip
  }, {
    content: Ee(() => [
      e.multiple ? (G(), ue(
        "div",
        {
          key: 0,
          ref: "rootRef",
          tabindex: "-1",
          class: X(e.ns.e("multiple"))
        },
        [
          ve(
            "div",
            {
              class: X(e.ns.e("content"))
            },
            [
              $(s, {
                "wrap-class": e.ns.e("wrap")
              }, {
                default: Ee(() => [
                  $(i, {
                    modelValue: e.filteredValue,
                    "onUpdate:modelValue": t[0] || (t[0] = (p) => e.filteredValue = p),
                    class: X(e.ns.e("checkbox-group"))
                  }, {
                    default: Ee(() => [
                      (G(!0), ue(
                        Ge,
                        null,
                        on(e.filters, (p) => (G(), Me(a, {
                          key: p.value,
                          value: p.value
                        }, {
                          default: Ee(() => [
                            Ft(
                              qe(p.text),
                              1
                            )
                          ]),
                          _: 2
                        }, 1032, ["value"]))),
                        128
                      ))
                    ]),
                    _: 1
                  }, 8, ["modelValue", "class"])
                ]),
                _: 1
              }, 8, ["wrap-class"])
            ],
            2
          ),
          ve(
            "div",
            {
              class: X(e.ns.e("bottom"))
            },
            [
              ve("button", {
                class: X(e.ns.is("disabled", e.filteredValue.length === 0)),
                disabled: e.filteredValue.length === 0,
                type: "button",
                onClick: t[1] || (t[1] = (...p) => e.handleConfirm && e.handleConfirm(...p))
              }, qe(e.t("el.table.confirmFilter")), 11, m$e),
              ve(
                "button",
                {
                  type: "button",
                  onClick: t[2] || (t[2] = (...p) => e.handleReset && e.handleReset(...p))
                },
                qe(e.t("el.table.resetFilter")),
                1
              )
            ],
            2
          )
        ],
        2
      )) : (G(), ue(
        "ul",
        {
          key: 1,
          ref: "rootRef",
          tabindex: "-1",
          role: "radiogroup",
          class: X(e.ns.e("list")),
          onKeydown: t[4] || (t[4] = (...p) => e.handleKeydown && e.handleKeydown(...p))
        },
        [
          ve("li", {
            role: "radio",
            class: X([
              e.ns.e("list-item"),
              e.ns.is("active", e.isPropAbsent(e.filterValue))
            ]),
            tabindex: e.checkedIndex === 0 ? 0 : -1,
            "aria-checked": e.isPropAbsent(e.filterValue),
            onClick: t[3] || (t[3] = (p) => e.handleSelect(null, 0))
          }, qe(e.t("el.table.clearFilter")), 11, h$e),
          (G(!0), ue(
            Ge,
            null,
            on(e.filters, (p, m) => (G(), ue("li", {
              key: p.value,
              role: "radio",
              class: X([e.ns.e("list-item"), e.ns.is("active", e.isActive(p))]),
              tabindex: e.checkedIndex === m + 1 ? 0 : -1,
              "aria-checked": e.isActive(p),
              onClick: (v) => e.handleSelect(p.value, m + 1)
            }, qe(p.text), 11, g$e))),
            128
          ))
        ],
        34
      ))
    ]),
    default: Ee(() => {
      var p;
      return [
        ve("button", {
          type: "button",
          class: X(`${e.ns.namespace.value}-table__column-filter-trigger`),
          "aria-label": e.t("el.table.filterLabel", { column: ((p = e.column) == null ? void 0 : p.label) || "" })
        }, [
          $(d, null, {
            default: Ee(() => [
              Oe(e.$slots, "filter-icon", {}, () => {
                var m;
                return [
                  (m = e.column) != null && m.filterOpened ? (G(), Me(c, { key: 0 })) : (G(), Me(u, { key: 1 }))
                ];
              })
            ]),
            _: 3
          })
        ], 10, b$e)
      ];
    }),
    _: 3
  }, 8, ["placement", "popper-class", "append-to", "onShow", "onHide"]);
}
var S$e = /* @__PURE__ */ Je(v$e, [["render", y$e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/filter-panel.vue"]]);
function T_(e) {
  const t = xt();
  _c(() => {
    n.value.addObserver(t);
  }), nt(() => {
    o(n.value), l(n.value);
  }), $o(() => {
    o(n.value), l(n.value);
  }), Uo(() => {
    n.value.removeObserver(t);
  });
  const n = O(() => {
    const r = e.layout;
    if (!r)
      throw new Error("Can not find table layout.");
    return r;
  }), o = (r) => {
    var a;
    const i = ((a = e.vnode.el) == null ? void 0 : a.querySelectorAll("colgroup > col")) || [];
    if (!i.length)
      return;
    const s = r.getFlattenColumns(), c = {};
    s.forEach((u) => {
      c[u.id] = u;
    });
    for (let u = 0, d = i.length; u < d; u++) {
      const f = i[u], p = f.getAttribute("name"), m = c[p];
      m && f.setAttribute("width", m.realWidth || m.width);
    }
  }, l = (r) => {
    var a, i;
    const s = ((a = e.vnode.el) == null ? void 0 : a.querySelectorAll("colgroup > col[name=gutter]")) || [];
    for (let u = 0, d = s.length; u < d; u++)
      s[u].setAttribute("width", r.scrollY.value ? r.gutterWidth : "0");
    const c = ((i = e.vnode.el) == null ? void 0 : i.querySelectorAll("th.gutter")) || [];
    for (let u = 0, d = c.length; u < d; u++) {
      const f = c[u];
      f.style.width = r.scrollY.value ? `${r.gutterWidth}px` : "0", f.style.display = r.scrollY.value ? "" : "none";
    }
  };
  return {
    tableLayout: n.value,
    onColumnsChange: o,
    onScrollableChange: l
  };
}
const qa = Symbol("ElTable");
function C$e(e, t) {
  const n = xt(), o = ze(qa), l = (v) => {
    v.stopPropagation();
  }, r = (v, h) => {
    !h.filters && h.sortable ? m(v, h, !1) : h.filterable && !h.sortable && l(v), o == null || o.emit("header-click", h, v);
  }, a = (v, h) => {
    o == null || o.emit("header-contextmenu", h, v);
  }, i = /* @__PURE__ */ H(null), s = /* @__PURE__ */ H(!1), c = /* @__PURE__ */ H(), u = (v, h) => {
    var g, y;
    if (Sn && !(h.children && h.children.length > 0) && i.value && e.border && i.value.id === h.id) {
      s.value = !0;
      const b = o;
      t("set-drag-visible", !0);
      const C = b == null ? void 0 : b.vnode.el, w = C == null ? void 0 : C.getBoundingClientRect().left, x = (y = (g = n == null ? void 0 : n.vnode) == null ? void 0 : g.el) == null ? void 0 : y.querySelector(`th.${h.id}`), E = x.getBoundingClientRect(), I = E.left - w + 30;
      Zr(x, "noclick"), c.value = {
        startMouseLeft: v.clientX,
        startLeft: E.right - w,
        startColumnLeft: E.left - w,
        tableLeft: w
      };
      const T = b == null ? void 0 : b.refs.resizeProxy;
      T.style.left = `${c.value.startLeft}px`, document.onselectstart = function() {
        return !1;
      }, document.ondragstart = function() {
        return !1;
      };
      const P = (N) => {
        const R = N.clientX - c.value.startMouseLeft, z = c.value.startLeft + R;
        T.style.left = `${Math.max(I, z)}px`;
      }, k = () => {
        if (s.value) {
          const { startColumnLeft: N, startLeft: R } = c.value, D = Number.parseInt(T.style.left, 10) - N;
          h.width = h.realWidth = D, b == null || b.emit(
            "header-dragend",
            h.width,
            R - N,
            h,
            v
          ), requestAnimationFrame(() => {
            e.store.scheduleLayout(!1, !0);
          }), document.body.style.cursor = "", s.value = !1, i.value = null, c.value = void 0, t("set-drag-visible", !1);
        }
        document.removeEventListener("mousemove", P), document.removeEventListener("mouseup", k), document.onselectstart = null, document.ondragstart = null, setTimeout(() => {
          Al(x, "noclick");
        }, 0);
      };
      document.addEventListener("mousemove", P), document.addEventListener("mouseup", k);
    }
  }, d = (v, h) => {
    var g;
    if (!e.border || h.children && h.children.length > 0)
      return;
    const y = v.target, b = tr(y) ? y.closest("th") : null;
    if (!b)
      return;
    const C = pi(b, "is-sortable");
    if (C) {
      const P = s.value ? "col-resize" : "";
      b.style.cursor = P;
      const k = b.querySelector(".caret-wrapper");
      k && (k.style.cursor = P);
    }
    if (!h.resizable || s.value) {
      i.value = null;
      return;
    }
    const w = b.getBoundingClientRect(), x = ((g = b.parentNode) == null ? void 0 : g.lastElementChild) === b, E = e.allowDragLastColumn || !x, I = w.width > 12 && w.right - v.clientX < 8 && E, T = I ? "col-resize" : "";
    document.body.style.cursor = T, i.value = I ? h : null, C && (b.style.cursor = T);
  }, f = () => {
    !Sn || s.value || (document.body.style.cursor = "");
  }, p = ({ order: v, sortOrders: h }) => {
    if (v === "")
      return h[0];
    const g = h.indexOf(v || null);
    return h[g > h.length - 2 ? 0 : g + 1];
  }, m = (v, h, g) => {
    var y;
    v.stopPropagation();
    const b = h.order === g ? null : g || p(h), C = (y = v.target) == null ? void 0 : y.closest("th");
    if (C && pi(C, "noclick")) {
      Al(C, "noclick");
      return;
    }
    if (!h.sortable)
      return;
    const w = v.currentTarget;
    if (["ascending", "descending"].some(
      (P) => pi(w, P) && !h.sortOrders.includes(P)
    ))
      return;
    const x = e.store.states;
    let E = x.sortProp.value, I;
    const T = x.sortingColumn.value;
    (T !== h || T === h && k1(T.order)) && (T && (T.order = null), x.sortingColumn.value = h, E = h.property), b ? I = h.order = b : I = h.order = null, x.sortProp.value = E, x.sortOrder.value = I, o == null || o.store.commit("changeSortCondition");
  };
  return {
    handleHeaderClick: r,
    handleHeaderContextMenu: a,
    handleMouseDown: u,
    handleMouseMove: d,
    handleMouseOut: f,
    handleSortClick: m,
    handleFilterClick: l
  };
}
function w$e(e) {
  const t = ze(qa), n = Ve("table");
  return {
    getHeaderRowStyle: (i) => {
      const s = t == null ? void 0 : t.props.headerRowStyle;
      return it(s) ? s.call(null, { rowIndex: i }) : s;
    },
    getHeaderRowClass: (i) => {
      const s = [], c = t == null ? void 0 : t.props.headerRowClassName;
      return rt(c) ? s.push(c) : it(c) && s.push(c.call(null, { rowIndex: i })), s.join(" ");
    },
    getHeaderCellStyle: (i, s, c, u) => {
      var d;
      let f = (d = t == null ? void 0 : t.props.headerCellStyle) != null ? d : {};
      it(f) && (f = f.call(null, {
        rowIndex: i,
        columnIndex: s,
        row: c,
        column: u
      }));
      const p = __(
        s,
        u.fixed,
        e.store,
        c
      );
      return Qf(p, "left"), Qf(p, "right"), Object.assign({}, f, p);
    },
    getHeaderCellClass: (i, s, c, u) => {
      const d = O_(
        n.b(),
        s,
        u.fixed,
        e.store,
        c
      ), f = [
        u.id,
        u.order,
        u.headerAlign,
        u.className,
        u.labelClassName,
        ...d
      ];
      u.children || f.push("is-leaf"), u.sortable && f.push("is-sortable");
      const p = t == null ? void 0 : t.props.headerCellClassName;
      return rt(p) ? f.push(p) : it(p) && f.push(
        p.call(null, {
          rowIndex: i,
          columnIndex: s,
          row: c,
          column: u
        })
      ), f.push(n.e("cell")), f.filter((m) => !!m).join(" ");
    }
  };
}
const EV = (e) => {
  const t = [];
  return e.forEach((n) => {
    n.children ? (t.push(n), t.push.apply(t, EV(n.children))) : t.push(n);
  }), t;
}, OV = (e) => {
  let t = 1;
  const n = (r, a) => {
    if (a && (r.level = a.level + 1, t < r.level && (t = r.level)), r.children) {
      let i = 0;
      r.children.forEach((s) => {
        n(s, r), i += s.colSpan;
      }), r.colSpan = i;
    } else
      r.colSpan = 1;
  };
  e.forEach((r) => {
    r.level = 1, n(r, void 0);
  });
  const o = [];
  for (let r = 0; r < t; r++)
    o.push([]);
  return EV(e).forEach((r) => {
    r.children ? (r.rowSpan = 1, r.children.forEach((a) => a.isSubColumn = !0)) : r.rowSpan = t - r.level + 1, o[r.level - 1].push(r);
  }), o;
};
function $$e(e) {
  const t = ze(qa), n = O(() => OV(e.store.states.originColumns.value));
  return {
    isGroup: O(() => {
      const r = n.value.length > 1;
      return r && t && (t.state.isGroup.value = !0), r;
    }),
    toggleAllSelection: (r) => {
      r.stopPropagation(), t == null || t.store.commit("toggleAllSelection");
    },
    columnRows: n
  };
}
var x$e = /* @__PURE__ */ le({
  name: "ElTableHeader",
  components: {
    ElCheckbox: Fa
  },
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    },
    appendFilterPanelTo: {
      type: String
    },
    allowDragLastColumn: {
      type: Boolean
    }
  },
  setup(e, { emit: t }) {
    const n = xt(), o = ze(qa), l = Ve("table"), r = /* @__PURE__ */ H({}), { onColumnsChange: a, onScrollableChange: i } = T_(o), s = (o == null ? void 0 : o.props.tableLayout) === "auto", c = /* @__PURE__ */ kt(/* @__PURE__ */ new Map()), u = /* @__PURE__ */ H();
    let d;
    const f = () => {
      d = setTimeout(() => {
        c.size > 0 && (c.forEach((N, R) => {
          const z = u.value.querySelector(
            `.${R.replace(/\s/g, ".")}`
          );
          if (z) {
            const D = z.getBoundingClientRect().width;
            N.width = D || N.width;
          }
        }), c.clear());
      });
    };
    pe(c, f), yt(() => {
      d && (clearTimeout(d), d = void 0);
    }), nt(() => Rt(this, null, function* () {
      yield Ke(), yield Ke();
      const { prop: N, order: R } = e.defaultSort;
      o == null || o.store.commit("sort", { prop: N, order: R, init: !0 }), f();
    }));
    const {
      handleHeaderClick: p,
      handleHeaderContextMenu: m,
      handleMouseDown: v,
      handleMouseMove: h,
      handleMouseOut: g,
      handleSortClick: y,
      handleFilterClick: b
    } = C$e(e, t), {
      getHeaderRowStyle: C,
      getHeaderRowClass: w,
      getHeaderCellStyle: x,
      getHeaderCellClass: E
    } = w$e(e), { isGroup: I, toggleAllSelection: T, columnRows: P } = $$e(
      e
    ), { t: k } = an();
    return n.state = {
      onColumnsChange: a,
      onScrollableChange: i
    }, n.filterPanels = r, {
      ns: l,
      t: k,
      filterPanels: r,
      onColumnsChange: a,
      onScrollableChange: i,
      columnRows: P,
      getHeaderRowClass: w,
      getHeaderRowStyle: C,
      getHeaderCellClass: E,
      getHeaderCellStyle: x,
      handleHeaderClick: p,
      handleHeaderContextMenu: m,
      handleMouseDown: v,
      handleMouseMove: h,
      handleMouseOut: g,
      handleSortClick: y,
      handleFilterClick: b,
      isGroup: I,
      toggleAllSelection: T,
      saveIndexSelection: c,
      isTableLayoutAuto: s,
      theadRef: u,
      updateFixedColumnStyle: f
    };
  },
  render() {
    const {
      ns: e,
      t,
      isGroup: n,
      columnRows: o,
      getHeaderCellStyle: l,
      getHeaderCellClass: r,
      getHeaderRowClass: a,
      getHeaderRowStyle: i,
      handleHeaderClick: s,
      handleHeaderContextMenu: c,
      handleMouseDown: u,
      handleMouseMove: d,
      handleSortClick: f,
      handleMouseOut: p,
      store: m,
      $parent: v,
      saveIndexSelection: h,
      isTableLayoutAuto: g
    } = this;
    let y = 1;
    return ht(
      "thead",
      {
        ref: "theadRef",
        class: e.is("group", n)
      },
      o.map(
        (b, C) => ht(
          "tr",
          {
            class: a(C),
            key: C,
            style: i(C)
          },
          b.map((w, x) => {
            w.rowSpan > y && (y = w.rowSpan);
            const E = r(
              C,
              x,
              b,
              w
            );
            return g && w.fixed && h.set(E, w), ht(
              "th",
              {
                class: E,
                colspan: w.colSpan,
                key: `${w.id}-thead`,
                rowspan: w.rowSpan,
                scope: w.colSpan > 1 ? "colgroup" : "col",
                ariaSort: w.sortable ? w.order : void 0,
                style: l(
                  C,
                  x,
                  b,
                  w
                ),
                onClick: (I) => {
                  var T;
                  (T = I.currentTarget) != null && T.classList.contains(
                    "noclick"
                  ) || s(I, w);
                },
                onContextmenu: (I) => c(I, w),
                onMousedown: (I) => u(I, w),
                onMousemove: (I) => d(I, w),
                onMouseout: p
              },
              [
                ht(
                  "div",
                  {
                    class: [
                      "cell",
                      w.filteredValue && w.filteredValue.length > 0 ? "highlight" : ""
                    ]
                  },
                  [
                    w.renderHeader ? w.renderHeader({
                      column: w,
                      $index: x,
                      store: m,
                      _self: v
                    }) : w.label,
                    w.sortable && ht(
                      "button",
                      {
                        type: "button",
                        class: "caret-wrapper",
                        "aria-label": t("el.table.sortLabel", {
                          column: w.label || ""
                        }),
                        onClick: (I) => f(I, w)
                      },
                      [
                        ht("i", {
                          onClick: (I) => f(I, w, "ascending"),
                          class: "sort-caret ascending"
                        }),
                        ht("i", {
                          onClick: (I) => f(I, w, "descending"),
                          class: "sort-caret descending"
                        })
                      ]
                    ),
                    w.filterable && ht(
                      S$e,
                      {
                        store: m,
                        placement: w.filterPlacement || "bottom-start",
                        appendTo: v == null ? void 0 : v.appendFilterPanelTo,
                        column: w,
                        upDataColumn: (I, T) => {
                          w[I] = T;
                        }
                      },
                      {
                        "filter-icon": () => w.renderFilterIcon ? w.renderFilterIcon({
                          filterOpened: w.filterOpened
                        }) : null
                      }
                    )
                  ]
                )
              ]
            );
          })
        )
      )
    );
  }
});
function lw(e, t, n = 0.03) {
  return e - t > n;
}
function E$e(e) {
  const t = ze(qa), n = /* @__PURE__ */ H(""), o = /* @__PURE__ */ H(ht("div")), l = (m, v, h) => {
    var g, y, b;
    const C = t, w = ow(m);
    let x = null;
    const E = (g = C == null ? void 0 : C.vnode.el) == null ? void 0 : g.dataset.prefix;
    w && (x = AN(
      {
        columns: (b = (y = e.store) == null ? void 0 : y.states.columns.value) != null ? b : []
      },
      w,
      E
    ), x && (C == null || C.emit(`cell-${h}`, v, x, w, m))), C == null || C.emit(`row-${h}`, v, x, m);
  }, r = (m, v) => {
    l(m, v, "dblclick");
  }, a = (m, v) => {
    var h;
    (h = e.store) == null || h.commit("setCurrentRow", v), l(m, v, "click");
  }, i = (m, v) => {
    l(m, v, "contextmenu");
  }, s = Dr((m) => {
    var v;
    (v = e.store) == null || v.commit("setHoverRow", m);
  }, 30), c = Dr(() => {
    var m;
    (m = e.store) == null || m.commit("setHoverRow", null);
  }, 30), u = (m) => {
    const v = window.getComputedStyle(m, null), h = Number.parseInt(v.paddingLeft, 10) || 0, g = Number.parseInt(v.paddingRight, 10) || 0, y = Number.parseInt(v.paddingTop, 10) || 0, b = Number.parseInt(v.paddingBottom, 10) || 0;
    return {
      left: h,
      right: g,
      top: y,
      bottom: b
    };
  }, d = (m, v, h) => {
    var g;
    let y = (g = v == null ? void 0 : v.target) == null ? void 0 : g.parentNode;
    for (; m > 1 && (y = y == null ? void 0 : y.nextSibling, !(!y || y.nodeName !== "TR")); )
      h(y, "hover-row hover-fixed-row"), m--;
  };
  return {
    handleDoubleClick: r,
    handleClick: a,
    handleContextMenu: i,
    handleMouseEnter: s,
    handleMouseLeave: c,
    handleCellMouseEnter: (m, v, h) => {
      var g, y, b, C, w, x, E, I, T;
      if (!t)
        return;
      const P = t, k = ow(m), N = (g = P == null ? void 0 : P.vnode.el) == null ? void 0 : g.dataset.prefix;
      let R = null;
      if (k) {
        if (R = AN(
          {
            columns: (b = (y = e.store) == null ? void 0 : y.states.columns.value) != null ? b : []
          },
          k,
          N
        ), !R)
          return;
        k.rowSpan > 1 && d(k.rowSpan, m, Zr);
        const te = P.hoverState = {
          cell: k,
          column: R,
          row: v
        };
        P == null || P.emit(
          "cell-mouse-enter",
          te.row,
          te.column,
          te.cell,
          m
        );
      }
      if (!h) {
        ((C = El) == null ? void 0 : C.trigger) === k && ((w = El) == null || w());
        return;
      }
      const z = m.target.querySelector(
        ".cell"
      );
      if (!(pi(z, `${N}-tooltip`) && z.childNodes.length && ((x = z.textContent) != null && x.trim())))
        return;
      const D = document.createRange();
      D.setStart(z, 0), D.setEnd(z, z.childNodes.length);
      const { width: F, height: M } = D.getBoundingClientRect(), { width: A, height: L } = z.getBoundingClientRect(), { top: B, left: V, right: j, bottom: W } = u(z), Y = V + j, U = B + W;
      lw(F + Y, A) || lw(M + U, L) || lw(z.scrollWidth, A) ? l$e(
        h,
        (E = (k == null ? void 0 : k.innerText) || (k == null ? void 0 : k.textContent)) != null ? E : "",
        v,
        R,
        k,
        P
      ) : ((I = El) == null ? void 0 : I.trigger) === k && ((T = El) == null || T());
    },
    handleCellMouseLeave: (m) => {
      const v = ow(m);
      if (!v)
        return;
      v.rowSpan > 1 && d(v.rowSpan, m, Al);
      const h = t == null ? void 0 : t.hoverState;
      t == null || t.emit(
        "cell-mouse-leave",
        h == null ? void 0 : h.row,
        h == null ? void 0 : h.column,
        h == null ? void 0 : h.cell,
        m
      );
    },
    tooltipContent: n,
    tooltipTrigger: o
  };
}
function O$e(e) {
  const t = ze(qa), n = Ve("table");
  return {
    getRowStyle: (c, u) => {
      const d = t == null ? void 0 : t.props.rowStyle;
      return it(d) ? d.call(null, {
        row: c,
        rowIndex: u
      }) : d || null;
    },
    getRowClass: (c, u, d) => {
      var f;
      const p = [n.e("row")];
      t != null && t.props.highlightCurrentRow && c === ((f = e.store) == null ? void 0 : f.states.currentRow.value) && p.push("current-row"), e.stripe && d % 2 === 1 && p.push(n.em("row", "striped"));
      const m = t == null ? void 0 : t.props.rowClassName;
      return rt(m) ? p.push(m) : it(m) && p.push(
        m.call(null, {
          row: c,
          rowIndex: u
        })
      ), p;
    },
    getCellStyle: (c, u, d, f) => {
      const p = t == null ? void 0 : t.props.cellStyle;
      let m = p != null ? p : {};
      it(p) && (m = p.call(null, {
        rowIndex: c,
        columnIndex: u,
        row: d,
        column: f
      }));
      const v = __(
        u,
        e == null ? void 0 : e.fixed,
        e.store
      );
      return Qf(v, "left"), Qf(v, "right"), Object.assign({}, m, v);
    },
    getCellClass: (c, u, d, f, p) => {
      const m = O_(
        n.b(),
        u,
        e == null ? void 0 : e.fixed,
        e.store,
        void 0,
        p
      ), v = [f.id, f.align, f.className, ...m], h = t == null ? void 0 : t.props.cellClassName;
      return rt(h) ? v.push(h) : it(h) && v.push(
        h.call(null, {
          rowIndex: c,
          columnIndex: u,
          row: d,
          column: f
        })
      ), v.push(n.e("cell")), v.filter((g) => !!g).join(" ");
    },
    getSpan: (c, u, d, f) => {
      let p = 1, m = 1;
      const v = t == null ? void 0 : t.props.spanMethod;
      if (it(v)) {
        const h = v({
          row: c,
          column: u,
          rowIndex: d,
          columnIndex: f
        });
        We(h) ? (p = h[0], m = h[1]) : Mt(h) && (p = h.rowspan, m = h.colspan);
      }
      return { rowspan: p, colspan: m };
    },
    getColspanRealWidth: (c, u, d) => {
      if (u < 1)
        return c[d].realWidth;
      const f = c.map(({ realWidth: p, width: m }) => p || m).slice(d, d + u);
      return Number(
        f.reduce((p, m) => Number(p) + Number(m), -1)
      );
    }
  };
}
const _$e = ["colspan", "rowspan"], I$e = /* @__PURE__ */ le({
  name: "TableTdWrapper",
  __name: "td-wrapper",
  props: {
    colspan: {
      type: Number,
      default: 1
    },
    rowspan: {
      type: Number,
      default: 1
    }
  },
  setup(e) {
    return (t, n) => (G(), ue("td", {
      colspan: e.colspan,
      rowspan: e.rowspan
    }, [
      Oe(t.$slots, "default")
    ], 8, _$e));
  }
});
var T$e = /* @__PURE__ */ Je(I$e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table-body/td-wrapper.vue"]]);
function P$e(e) {
  const t = ze(qa), n = Ve("table"), {
    handleDoubleClick: o,
    handleClick: l,
    handleContextMenu: r,
    handleMouseEnter: a,
    handleMouseLeave: i,
    handleCellMouseEnter: s,
    handleCellMouseLeave: c,
    tooltipContent: u,
    tooltipTrigger: d
  } = E$e(e), {
    getRowStyle: f,
    getRowClass: p,
    getCellStyle: m,
    getCellClass: v,
    getSpan: h,
    getColspanRealWidth: g
  } = O$e(e);
  let y = -1;
  const b = O(() => {
    var I;
    return (I = e.store) == null ? void 0 : I.states.columns.value.findIndex(
      ({ type: T }) => T === "default"
    );
  }), C = (I, T) => {
    var P;
    const k = (P = t == null ? void 0 : t.props) == null ? void 0 : P.rowKey;
    return k ? bl(I, k) : T;
  }, w = (I, T, P, k = !1) => {
    const { tooltipEffect: N, tooltipOptions: R, store: z } = e, { indent: D, columns: F } = z.states, M = [];
    let A = !0;
    return P && (M.push(n.em("row", `level-${P.level}`)), A = !!P.display), T === 0 && (y = -1), e.stripe && A && y++, M.push(...p(I, T, y)), ht(
      "tr",
      {
        style: [A ? null : { display: "none" }, f(I, T)],
        class: M,
        key: C(I, T),
        onDblclick: (B) => o(B, I),
        onClick: (B) => l(B, I),
        onContextmenu: (B) => r(B, I),
        onMouseenter: () => a(T),
        onMouseleave: i
      },
      F.value.map((B, V) => {
        const { rowspan: j, colspan: W } = h(I, B, T, V);
        if (!j || !W)
          return null;
        const Y = Object.assign({}, B);
        Y.realWidth = g(
          F.value,
          W,
          V
        );
        const U = {
          store: z,
          _self: e.context || t,
          column: Y,
          row: I,
          $index: T,
          cellIndex: V,
          expanded: k
        };
        V === b.value && P && (U.treeNode = {
          indent: P.level && P.level * D.value,
          level: P.level
        }, Tn(P.expanded) && (U.treeNode.expanded = P.expanded, "loading" in P && (U.treeNode.loading = P.loading), "noLazyChildren" in P && (U.treeNode.noLazyChildren = P.noLazyChildren)));
        const te = `${C(I, T)},${V}`, J = Y.columnKey || Y.rawColumnKey || "", re = B.showOverflowTooltip && t7(
          {
            effect: N
          },
          R,
          B.showOverflowTooltip
        );
        return ht(
          T$e,
          {
            style: m(T, V, I, B),
            class: v(T, V, I, B, W - 1),
            key: `${J}${te}`,
            rowspan: j,
            colspan: W,
            onMouseenter: (oe) => s(
              oe,
              I,
              re
            ),
            onMouseleave: c
          },
          {
            default: () => x(V, B, U)
          }
        );
      })
    );
  }, x = (I, T, P) => T.renderCell(P);
  return {
    wrappedRowRender: (I, T) => {
      const P = e.store, { isRowExpanded: k, assertRowKey: N } = P, { treeData: R, lazyTreeNodeMap: z, childrenColumnName: D, rowKey: F } = P.states, M = P.states.columns.value;
      if (M.some(({ type: L }) => L === "expand")) {
        const L = k(I), B = w(I, T, void 0, L), V = t == null ? void 0 : t.renderExpanded;
        if (!V)
          return console.error("[Element Error]renderExpanded is required."), B;
        const j = [[B]];
        return (t.props.preserveExpandedContent || L) && j[0].push(
          ht(
            "tr",
            {
              key: `expanded-row__${B.key}`,
              style: { display: L ? "" : "none" }
            },
            [
              ht(
                "td",
                {
                  colspan: M.length,
                  class: `${n.e("cell")} ${n.e("expanded-cell")}`
                },
                [V({ row: I, $index: T, store: P, expanded: L })]
              )
            ]
          )
        ), j;
      } else if (Object.keys(R.value).length) {
        N();
        const L = bl(I, F.value);
        let B = R.value[L], V = null;
        B && (V = {
          expanded: B.expanded,
          level: B.level,
          display: !0,
          noLazyChildren: void 0,
          loading: void 0
        }, Tn(B.lazy) && (V && Tn(B.loaded) && B.loaded && (V.noLazyChildren = !(B.children && B.children.length)), V.loading = B.loading));
        const j = [w(I, T, V != null ? V : void 0)];
        if (B) {
          let W = 0;
          const Y = (te, J) => {
            te && te.length && J && te.forEach((re) => {
              const oe = {
                display: J.display && J.expanded,
                level: J.level + 1,
                expanded: !1,
                noLazyChildren: !1,
                loading: !1
              }, q = bl(re, F.value);
              if (hr(q))
                throw new Error("For nested data item, row-key is required.");
              if (B = Be({}, R.value[q]), B && (oe.expanded = B.expanded, B.level = B.level || oe.level, B.display = !!(B.expanded && oe.display), Tn(B.lazy) && (Tn(B.loaded) && B.loaded && (oe.noLazyChildren = !(B.children && B.children.length)), oe.loading = B.loading)), W++, j.push(w(re, T + W, oe)), B) {
                const K = z.value[q] || re[D.value];
                Y(K, B);
              }
            });
          };
          B.display = !0;
          const U = z.value[L] || I[D.value];
          Y(U, B);
        }
        return j;
      } else
        return w(I, T, void 0);
    },
    tooltipContent: u,
    tooltipTrigger: d
  };
}
const k$e = {
  store: {
    required: !0,
    type: Object
  },
  stripe: Boolean,
  tooltipEffect: String,
  tooltipOptions: {
    type: Object
  },
  context: {
    default: () => ({}),
    type: Object
  },
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  fixed: {
    type: String,
    default: ""
  },
  highlight: Boolean
};
var N$e = /* @__PURE__ */ le({
  name: "ElTableBody",
  props: k$e,
  setup(e) {
    var t;
    const n = xt(), o = ze(qa), l = Ve("table"), { wrappedRowRender: r, tooltipContent: a, tooltipTrigger: i } = P$e(e), { onColumnsChange: s, onScrollableChange: c } = T_(o), u = [];
    return pe((t = e.store) == null ? void 0 : t.states.hoverRow, (d, f) => {
      var p, m;
      const v = n == null ? void 0 : n.vnode.el, h = Array.from((v == null ? void 0 : v.children) || []).filter(
        (b) => b == null ? void 0 : b.classList.contains(`${l.e("row")}`)
      );
      let g = d;
      const y = (p = h[g]) == null ? void 0 : p.childNodes;
      if (y != null && y.length) {
        let b = 0;
        Array.from(y).reduce((w, x, E) => {
          var I, T;
          return ((I = y[E]) == null ? void 0 : I.colSpan) > 1 && (b = (T = y[E]) == null ? void 0 : T.colSpan), x.nodeName !== "TD" && b === 0 && w.push(E), b > 0 && b--, w;
        }, []).forEach((w) => {
          var x;
          for (g = d; g > 0; ) {
            const E = (x = h[g - 1]) == null ? void 0 : x.childNodes;
            if (E[w] && E[w].nodeName === "TD" && E[w].rowSpan > 1) {
              Zr(E[w], "hover-cell"), u.push(E[w]);
              break;
            }
            g--;
          }
        });
      } else
        u.forEach((b) => Al(b, "hover-cell")), u.length = 0;
      !((m = e.store) != null && m.states.isComplex.value) || !Sn || Ci(() => {
        const b = h[f], C = h[d];
        b && !b.classList.contains("hover-fixed-row") && Al(b, "hover-row"), C && Zr(C, "hover-row");
      });
    }), Uo(() => {
      var d;
      (d = El) == null || d();
    }), {
      ns: l,
      onColumnsChange: s,
      onScrollableChange: c,
      wrappedRowRender: r,
      tooltipContent: a,
      tooltipTrigger: i
    };
  },
  render() {
    const { wrappedRowRender: e, store: t } = this, n = (t == null ? void 0 : t.states.data.value) || [];
    return ht("tbody", { tabIndex: -1 }, [
      n.reduce((o, l) => o.concat(e(l, o.length)), [])
    ]);
  }
});
function M$e() {
  const e = ze(qa), t = e == null ? void 0 : e.store, n = O(() => {
    var i;
    return (i = t == null ? void 0 : t.states.fixedLeafColumnsLength.value) != null ? i : 0;
  }), o = O(() => {
    var i;
    return (i = t == null ? void 0 : t.states.rightFixedColumns.value.length) != null ? i : 0;
  }), l = O(() => {
    var i;
    return (i = t == null ? void 0 : t.states.columns.value.length) != null ? i : 0;
  }), r = O(() => {
    var i;
    return (i = t == null ? void 0 : t.states.fixedColumns.value.length) != null ? i : 0;
  }), a = O(() => {
    var i;
    return (i = t == null ? void 0 : t.states.rightFixedColumns.value.length) != null ? i : 0;
  });
  return {
    leftFixedLeafCount: n,
    rightFixedLeafCount: o,
    columnsCount: l,
    leftFixedCount: r,
    rightFixedCount: a,
    columns: O(() => {
      var i;
      return (i = t == null ? void 0 : t.states.columns.value) != null ? i : [];
    })
  };
}
function A$e(e) {
  const { columns: t } = M$e(), n = Ve("table");
  return {
    getCellClasses: (r, a) => {
      const i = r[a], s = [
        n.e("cell"),
        i.id,
        i.align,
        i.labelClassName,
        ...O_(n.b(), a, i.fixed, e.store)
      ];
      return i.className && s.push(i.className), i.children || s.push(n.is("leaf")), s;
    },
    getCellStyles: (r, a) => {
      const i = __(
        a,
        r.fixed,
        e.store
      );
      return Qf(i, "left"), Qf(i, "right"), i;
    },
    columns: t
  };
}
var R$e = /* @__PURE__ */ le({
  name: "ElTableFooter",
  props: {
    fixed: {
      type: String,
      default: ""
    },
    store: {
      required: !0,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,
      default: () => ({
        prop: "",
        order: ""
      })
    }
  },
  setup(e) {
    const t = ze(qa), n = Ve("table"), { getCellClasses: o, getCellStyles: l, columns: r } = A$e(
      e
    ), { onScrollableChange: a, onColumnsChange: i } = T_(t);
    return {
      ns: n,
      onScrollableChange: a,
      onColumnsChange: i,
      getCellClasses: o,
      getCellStyles: l,
      columns: r
    };
  },
  render() {
    const { columns: e, getCellStyles: t, getCellClasses: n, summaryMethod: o, sumText: l } = this, r = this.store.states.data.value;
    let a = [];
    return o ? a = o({
      columns: e,
      data: r
    }) : e.forEach((i, s) => {
      if (s === 0) {
        a[s] = l;
        return;
      }
      const c = r.map((p) => Number(p[i.property])), u = [];
      let d = !0;
      c.forEach((p) => {
        if (!Number.isNaN(+p)) {
          d = !1;
          const m = `${p}`.split(".")[1];
          u.push(m ? m.length : 0);
        }
      });
      const f = Math.max.apply(null, u);
      d ? a[s] = "" : a[s] = c.reduce((p, m) => {
        const v = Number(m);
        return Number.isNaN(+v) ? p : Number.parseFloat(
          (p + m).toFixed(Math.min(f, 20))
        );
      }, 0);
    }), ht(
      ht("tfoot", [
        ht("tr", {}, [
          ...e.map(
            (i, s) => ht(
              "td",
              {
                key: s,
                colspan: i.colSpan,
                rowspan: i.rowSpan,
                class: n(e, s),
                style: t(i, s)
              },
              [
                ht(
                  "div",
                  {
                    class: ["cell", i.labelClassName]
                  },
                  [a[s]]
                )
              ]
            )
          )
        ])
      ])
    );
  }
});
function D$e(e) {
  return {
    setCurrentRow: (d) => {
      e.commit("setCurrentRow", d);
    },
    getSelectionRows: () => e.getSelectionRows(),
    toggleRowSelection: (d, f, p = !0) => {
      e.toggleRowSelection(d, f, !1, p), e.updateAllSelected();
    },
    clearSelection: () => {
      e.clearSelection();
    },
    clearFilter: (d) => {
      e.clearFilter(d);
    },
    toggleAllSelection: () => {
      e.commit("toggleAllSelection");
    },
    toggleRowExpansion: (d, f) => {
      e.toggleRowExpansionAdapter(d, f);
    },
    clearSort: () => {
      e.clearSort();
    },
    sort: (d, f) => {
      e.commit("sort", { prop: d, order: f });
    },
    updateKeyChildren: (d, f) => {
      e.updateKeyChildren(d, f);
    }
  };
}
function L$e(e, t, n, o) {
  const l = /* @__PURE__ */ H(!1), r = /* @__PURE__ */ H(null), a = /* @__PURE__ */ H(!1), i = (M) => {
    a.value = M;
  }, s = /* @__PURE__ */ H({
    width: null,
    height: null,
    headerHeight: null
  }), c = /* @__PURE__ */ H(!1), u = {
    display: "inline-block",
    verticalAlign: "middle"
  }, d = /* @__PURE__ */ H(), f = /* @__PURE__ */ H(0), p = /* @__PURE__ */ H(0), m = /* @__PURE__ */ H(0), v = /* @__PURE__ */ H(0), h = /* @__PURE__ */ H(0);
  pe(
    () => e.height,
    (M) => {
      t.setHeight(M != null ? M : null);
    },
    { immediate: !0 }
  ), pe(
    () => e.maxHeight,
    (M) => {
      t.setMaxHeight(M != null ? M : null);
    },
    { immediate: !0 }
  ), pe(
    () => [e.currentRowKey, n.states.rowKey],
    ([M, A]) => {
      !S(A) || !S(M) || n.setCurrentRowKey(`${M}`);
    },
    {
      immediate: !0
    }
  ), pe(
    () => e.data,
    (M) => {
      o.store.commit("setData", M);
    },
    {
      immediate: !0,
      deep: !0
    }
  ), Ot(() => {
    e.expandRowKeys && n.setExpandRowKeysAdapter(e.expandRowKeys);
  });
  const g = () => {
    o.store.commit("setHoverRow", null), o.hoverState && (o.hoverState = null);
  }, y = (M, A) => {
    const { pixelX: L, pixelY: B } = A;
    Math.abs(L) >= Math.abs(B) && (o.refs.bodyWrapper.scrollLeft += A.pixelX / 5);
  }, b = O(() => e.height || e.maxHeight || n.states.fixedColumns.value.length > 0 || n.states.rightFixedColumns.value.length > 0), C = O(() => ({
    width: t.bodyWidth.value ? `${t.bodyWidth.value}px` : ""
  })), w = () => {
    b.value && t.updateElsHeight(), t.updateColumnsWidth(), typeof window != "undefined" && requestAnimationFrame(T);
  };
  nt(() => Rt(this, null, function* () {
    yield Ke(), n.updateColumns(), P(), requestAnimationFrame(w);
    const M = o.vnode.el, A = o.refs.headerWrapper;
    e.flexible && M && M.parentElement && (M.parentElement.style.minWidth = "0"), s.value = {
      width: d.value = M.offsetWidth,
      height: M.offsetHeight,
      headerHeight: e.showHeader && A ? A.offsetHeight : null
    }, n.states.columns.value.forEach((L) => {
      L.filteredValue && L.filteredValue.length && o.store.commit("filterChange", {
        column: L,
        values: L.filteredValue,
        silent: !0
      });
    }), o.$ready = !0;
  }));
  const x = (M, A) => {
    if (!M)
      return;
    const L = Array.from(M.classList).filter(
      (B) => !B.startsWith("is-scrolling-")
    );
    L.push(t.scrollX.value ? A : "is-scrolling-none"), M.className = L.join(" ");
  }, E = (M) => {
    const { tableWrapper: A } = o.refs;
    x(A, M);
  }, I = (M) => {
    const { tableWrapper: A } = o.refs;
    return !!(A && A.classList.contains(M));
  }, T = function() {
    if (!o.refs.scrollBarRef)
      return;
    if (!t.scrollX.value) {
      const Y = "is-scrolling-none";
      I(Y) || E(Y);
      return;
    }
    const M = o.refs.scrollBarRef.wrapRef;
    if (!M)
      return;
    const { scrollLeft: A, offsetWidth: L, scrollWidth: B } = M, { headerWrapper: V, footerWrapper: j } = o.refs;
    V && (V.scrollLeft = A), j && (j.scrollLeft = A);
    const W = B - L - 1;
    A >= W ? E("is-scrolling-right") : E(A === 0 ? "is-scrolling-left" : "is-scrolling-middle");
  }, P = () => {
    o.refs.scrollBarRef && (o.refs.scrollBarRef.wrapRef && wn(
      o.refs.scrollBarRef.wrapRef,
      "scroll",
      T,
      {
        passive: !0
      }
    ), e.fit ? Xn(o.vnode.el, k) : wn(window, "resize", k), Xn(o.refs.tableInnerWrapper, () => {
      var M, A;
      k(), (A = (M = o.refs) == null ? void 0 : M.scrollBarRef) == null || A.update();
    }));
  }, k = () => {
    var M, A, L, B;
    const V = o.vnode.el;
    if (!o.$ready || !V)
      return;
    let j = !1;
    const {
      width: W,
      height: Y,
      headerHeight: U
    } = s.value, te = d.value = V.offsetWidth;
    W !== te && (j = !0);
    const J = V.offsetHeight;
    (e.height || b.value) && Y !== J && (j = !0);
    const re = e.tableLayout === "fixed" ? o.refs.headerWrapper : (M = o.refs.tableHeaderRef) == null ? void 0 : M.$el;
    e.showHeader && (re == null ? void 0 : re.offsetHeight) !== U && (j = !0), f.value = ((A = o.refs.tableWrapper) == null ? void 0 : A.scrollHeight) || 0, m.value = (re == null ? void 0 : re.scrollHeight) || 0, v.value = ((L = o.refs.footerWrapper) == null ? void 0 : L.offsetHeight) || 0, h.value = ((B = o.refs.appendWrapper) == null ? void 0 : B.offsetHeight) || 0, p.value = f.value - m.value - v.value - h.value, j && (s.value = {
      width: te,
      height: J,
      headerHeight: e.showHeader && (re == null ? void 0 : re.offsetHeight) || 0
    }, w());
  }, N = Mo(), R = O(() => {
    const { bodyWidth: M, scrollY: A, gutterWidth: L } = t;
    return M.value ? `${M.value - (A.value ? L : 0)}px` : "";
  }), z = O(() => e.maxHeight ? "fixed" : e.tableLayout), D = O(() => {
    if (e.data && e.data.length)
      return;
    let M = "100%";
    e.height && p.value && (M = `${p.value}px`);
    const A = d.value;
    return {
      width: A ? `${A}px` : "",
      height: M
    };
  }), F = O(() => e.height ? {
    height: "100%"
  } : e.maxHeight ? Number.isNaN(Number(e.maxHeight)) ? {
    maxHeight: `calc(${e.maxHeight} - ${m.value + v.value}px)`
  } : {
    maxHeight: `${+e.maxHeight - m.value - v.value}px`
  } : {});
  return {
    isHidden: l,
    renderExpanded: r,
    setDragVisible: i,
    isGroup: c,
    handleMouseLeave: g,
    handleHeaderFooterMousewheel: y,
    tableSize: N,
    emptyBlockStyle: D,
    resizeProxyVisible: a,
    bodyWidth: R,
    resizeState: s,
    doLayout: w,
    tableBodyStyles: C,
    tableLayout: z,
    scrollbarViewStyle: u,
    scrollbarStyle: F
  };
}
function B$e(e) {
  let t;
  const n = () => {
    const l = e.vnode.el.querySelector(".hidden-columns"), r = { childList: !0, subtree: !0 }, a = e.store.states.updateOrderFns;
    t = new MutationObserver(() => {
      a.forEach((i) => i());
    }), t.observe(l, r);
  };
  nt(() => {
    n();
  }), Uo(() => {
    t == null || t.disconnect();
  });
}
var F$e = {
  data: {
    type: Array,
    default: () => []
  },
  size: Bo,
  width: [String, Number],
  height: [String, Number],
  maxHeight: [String, Number],
  fit: {
    type: Boolean,
    default: !0
  },
  stripe: Boolean,
  border: Boolean,
  rowKey: [String, Function],
  showHeader: {
    type: Boolean,
    default: !0
  },
  showSummary: Boolean,
  sumText: String,
  summaryMethod: Function,
  rowClassName: [String, Function],
  rowStyle: [Object, Function],
  cellClassName: [String, Function],
  cellStyle: [Object, Function],
  headerRowClassName: [String, Function],
  headerRowStyle: [Object, Function],
  headerCellClassName: [String, Function],
  headerCellStyle: [Object, Function],
  highlightCurrentRow: Boolean,
  currentRowKey: [String, Number],
  emptyText: String,
  expandRowKeys: Array,
  defaultExpandAll: Boolean,
  defaultSort: Object,
  tooltipEffect: String,
  tooltipOptions: Object,
  spanMethod: Function,
  selectOnIndeterminate: {
    type: Boolean,
    default: !0
  },
  indent: {
    type: Number,
    default: 16
  },
  treeProps: {
    type: Object,
    default: () => ({
      hasChildren: "hasChildren",
      children: "children",
      checkStrictly: !1
    })
  },
  lazy: Boolean,
  load: Function,
  style: {
    type: [String, Object, Array],
    default: () => ({})
  },
  className: {
    type: String,
    default: ""
  },
  tableLayout: {
    type: String,
    default: "fixed"
  },
  scrollbarAlwaysOn: Boolean,
  flexible: Boolean,
  showOverflowTooltip: [Boolean, Object],
  tooltipFormatter: Function,
  appendFilterPanelTo: String,
  scrollbarTabindex: {
    type: [Number, String],
    default: void 0
  },
  allowDragLastColumn: {
    type: Boolean,
    default: !0
  },
  preserveExpandedContent: Boolean,
  nativeScrollbar: Boolean
};
function _V(e) {
  const t = e.tableLayout === "auto";
  let n = e.columns || [];
  t && n.every(({ width: l }) => fn(l)) && (n = []);
  const o = (l) => {
    const r = {
      key: `${e.tableLayout}_${l.id}`,
      style: {},
      name: void 0
    };
    return t ? r.style = {
      width: `${l.width}px`
    } : r.name = l.id, r;
  };
  return ht(
    "colgroup",
    {},
    n.map((l) => ht("col", o(l)))
  );
}
_V.props = ["columns", "tableLayout"];
const V$e = () => {
  const e = /* @__PURE__ */ H(), t = (r, a) => {
    const i = e.value;
    i && i.scrollTo(r, a);
  }, n = (r, a) => {
    const i = e.value;
    i && mt(a) && ["Top", "Left"].includes(r) && i[`setScroll${r}`](a);
  };
  return {
    scrollBarRef: e,
    scrollTo: t,
    setScrollTop: (r) => n("Top", r),
    setScrollLeft: (r) => n("Left", r)
  };
};
var LN = !1, ou, Ax, Rx, hb, gb, IV, bb, Dx, Lx, Bx, TV, Fx, Vx, PV, kV;
function dr() {
  if (!LN) {
    LN = !0;
    var e = navigator.userAgent, t = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), n = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
    if (Fx = /\b(iPhone|iP[ao]d)/.exec(e), Vx = /\b(iP[ao]d)/.exec(e), Bx = /Android/i.exec(e), PV = /FBAN\/\w+;/i.exec(e), kV = /Mobile/i.exec(e), TV = !!/Win64/.exec(e), t) {
      ou = t[1] ? parseFloat(t[1]) : t[5] ? parseFloat(t[5]) : NaN, ou && document && document.documentMode && (ou = document.documentMode);
      var o = /(?:Trident\/(\d+.\d+))/.exec(e);
      IV = o ? parseFloat(o[1]) + 4 : ou, Ax = t[2] ? parseFloat(t[2]) : NaN, Rx = t[3] ? parseFloat(t[3]) : NaN, hb = t[4] ? parseFloat(t[4]) : NaN, hb ? (t = /(?:Chrome\/(\d+\.\d+))/.exec(e), gb = t && t[1] ? parseFloat(t[1]) : NaN) : gb = NaN;
    } else ou = Ax = Rx = gb = hb = NaN;
    if (n) {
      if (n[1]) {
        var l = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
        bb = l ? parseFloat(l[1].replace("_", ".")) : !0;
      } else bb = !1;
      Dx = !!n[2], Lx = !!n[3];
    } else bb = Dx = Lx = !1;
  }
}
var zx = { ie: function() {
  return dr() || ou;
}, ieCompatibilityMode: function() {
  return dr() || IV > ou;
}, ie64: function() {
  return zx.ie() && TV;
}, firefox: function() {
  return dr() || Ax;
}, opera: function() {
  return dr() || Rx;
}, webkit: function() {
  return dr() || hb;
}, safari: function() {
  return zx.webkit();
}, chrome: function() {
  return dr() || gb;
}, windows: function() {
  return dr() || Dx;
}, osx: function() {
  return dr() || bb;
}, linux: function() {
  return dr() || Lx;
}, iphone: function() {
  return dr() || Fx;
}, mobile: function() {
  return dr() || Fx || Vx || Bx || kV;
}, nativeApp: function() {
  return dr() || PV;
}, android: function() {
  return dr() || Bx;
}, ipad: function() {
  return dr() || Vx;
} }, z$e = zx, H$e = !!(typeof window < "u" && window.document && window.document.createElement), j$e = { canUseDOM: H$e }, NV = j$e, MV;
NV.canUseDOM && (MV = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
function W$e(e, t) {
  if (!NV.canUseDOM || t && !("addEventListener" in document)) return !1;
  var n = "on" + e, o = n in document;
  if (!o) {
    var l = document.createElement("div");
    l.setAttribute(n, "return;"), o = typeof l[n] == "function";
  }
  return !o && MV && e === "wheel" && (o = document.implementation.hasFeature("Events.wheel", "3.0")), o;
}
var K$e = W$e, BN = 10, FN = 40, VN = 800;
function AV(e) {
  var t = 0, n = 0, o = 0, l = 0;
  return "detail" in e && (n = e.detail), "wheelDelta" in e && (n = -e.wheelDelta / 120), "wheelDeltaY" in e && (n = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = n, n = 0), o = t * BN, l = n * BN, "deltaY" in e && (l = e.deltaY), "deltaX" in e && (o = e.deltaX), (o || l) && e.deltaMode && (e.deltaMode == 1 ? (o *= FN, l *= FN) : (o *= VN, l *= VN)), o && !t && (t = o < 1 ? -1 : 1), l && !n && (n = l < 1 ? -1 : 1), { spinX: t, spinY: n, pixelX: o, pixelY: l };
}
AV.getEventType = function() {
  return z$e.firefox() ? "DOMMouseScroll" : K$e("wheel") ? "wheel" : "mousewheel";
};
var U$e = AV;
/**
* Checks if an event is supported in the current execution environment.
*
* NOTE: This will not work correctly for non-generic events such as `change`,
* `reset`, `load`, `error`, and `select`.
*
* Borrows from Modernizr.
*
* @param {string} eventNameSuffix Event name, e.g. "click".
* @param {?boolean} capture Check if the capture phase is supported.
* @return {boolean} True if the event is supported.
* @internal
* @license Modernizr 3.0.0pre (Custom Build) | MIT
*/
const yb = "_Mousewheel", zN = function(e, t) {
  if (e && e.addEventListener) {
    RV(e);
    const n = function(o) {
      const l = U$e(o);
      t && Reflect.apply(t, this, [o, l]);
    };
    e[yb] = { wheelHandler: n }, e.addEventListener("wheel", n, { passive: !0 });
  }
}, RV = (e) => {
  var t;
  (t = e[yb]) != null && t.wheelHandler && (e.removeEventListener("wheel", e[yb].wheelHandler), e[yb] = null);
}, G$e = {
  beforeMount(e, t) {
    zN(e, t.value);
  },
  unmounted(e) {
    RV(e);
  },
  updated(e, t) {
    t.value !== t.oldValue && zN(e, t.value);
  }
};
let Y$e = 1;
const X$e = /* @__PURE__ */ le({
  name: "ElTable",
  directives: {
    Mousewheel: G$e
  },
  components: {
    TableHeader: x$e,
    TableBody: N$e,
    TableFooter: R$e,
    ElScrollbar: Ba,
    hColgroup: _V
  },
  props: F$e,
  emits: [
    "select",
    "select-all",
    "selection-change",
    "cell-mouse-enter",
    "cell-mouse-leave",
    "cell-contextmenu",
    "cell-click",
    "cell-dblclick",
    "row-click",
    "row-contextmenu",
    "row-dblclick",
    "header-click",
    "header-contextmenu",
    "sort-change",
    "filter-change",
    "current-change",
    "header-dragend",
    "expand-change",
    "scroll"
  ],
  setup(e) {
    const { t } = an(), n = Ve("table"), o = xt();
    at(qa, o);
    const l = d$e(o, e);
    o.store = l;
    const r = new p$e({
      store: o.store,
      table: o,
      fit: e.fit,
      showHeader: e.showHeader
    });
    o.layout = r;
    const a = O(() => (l.states.data.value || []).length === 0), {
      setCurrentRow: i,
      getSelectionRows: s,
      toggleRowSelection: c,
      clearSelection: u,
      clearFilter: d,
      toggleAllSelection: f,
      toggleRowExpansion: p,
      clearSort: m,
      sort: v,
      updateKeyChildren: h
    } = D$e(l), {
      isHidden: g,
      renderExpanded: y,
      setDragVisible: b,
      isGroup: C,
      handleMouseLeave: w,
      handleHeaderFooterMousewheel: x,
      tableSize: E,
      emptyBlockStyle: I,
      resizeProxyVisible: T,
      bodyWidth: P,
      resizeState: k,
      doLayout: N,
      tableBodyStyles: R,
      tableLayout: z,
      scrollbarViewStyle: D,
      scrollbarStyle: F
    } = L$e(e, r, l, o), { scrollBarRef: M, scrollTo: A, setScrollLeft: L, setScrollTop: B } = V$e(), V = Dr(N, 50), j = `${n.namespace.value}-table_${Y$e++}`;
    o.tableId = j, o.state = {
      isGroup: C,
      resizeState: k,
      doLayout: N,
      debouncedUpdateLayout: V
    };
    const W = O(
      () => {
        var te;
        return (te = e.sumText) != null ? te : t("el.table.sumText");
      }
    ), Y = O(() => {
      var te;
      return (te = e.emptyText) != null ? te : t("el.table.emptyText");
    }), U = O(() => OV(l.states.originColumns.value)[0]);
    return B$e(o), yt(() => {
      V.cancel();
    }), {
      ns: n,
      layout: r,
      store: l,
      columns: U,
      handleHeaderFooterMousewheel: x,
      handleMouseLeave: w,
      tableId: j,
      tableSize: E,
      isHidden: g,
      isEmpty: a,
      renderExpanded: y,
      resizeProxyVisible: T,
      resizeState: k,
      isGroup: C,
      bodyWidth: P,
      tableBodyStyles: R,
      emptyBlockStyle: I,
      debouncedUpdateLayout: V,
      setCurrentRow: i,
      getSelectionRows: s,
      toggleRowSelection: c,
      clearSelection: u,
      clearFilter: d,
      toggleAllSelection: f,
      toggleRowExpansion: p,
      clearSort: m,
      doLayout: N,
      sort: v,
      updateKeyChildren: h,
      t,
      setDragVisible: b,
      context: o,
      computedSumText: W,
      computedEmptyText: Y,
      tableLayout: z,
      scrollbarViewStyle: D,
      scrollbarStyle: F,
      scrollBarRef: M,
      scrollTo: A,
      setScrollLeft: L,
      setScrollTop: B,
      allowDragLastColumn: e.allowDragLastColumn
    };
  }
}), q$e = ["data-prefix"], J$e = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
function Z$e(e, t, n, o, l, r) {
  const a = yn("hColgroup"), i = yn("table-header"), s = yn("table-body"), c = yn("table-footer"), u = yn("el-scrollbar"), d = s1("mousewheel");
  return G(), ue("div", {
    ref: "tableWrapper",
    class: X([
      {
        [e.ns.m("fit")]: e.fit,
        [e.ns.m("striped")]: e.stripe,
        [e.ns.m("border")]: e.border || e.isGroup,
        [e.ns.m("hidden")]: e.isHidden,
        [e.ns.m("group")]: e.isGroup,
        [e.ns.m("fluid-height")]: e.maxHeight,
        [e.ns.m("scrollable-x")]: e.layout.scrollX.value,
        [e.ns.m("scrollable-y")]: e.layout.scrollY.value,
        [e.ns.m("enable-row-hover")]: !e.store.states.isComplex.value,
        [e.ns.m("enable-row-transition")]: (e.store.states.data.value || []).length !== 0 && (e.store.states.data.value || []).length < 100,
        "has-footer": e.showSummary
      },
      e.ns.m(e.tableSize),
      e.className,
      e.ns.b(),
      e.ns.m(`layout-${e.tableLayout}`)
    ]),
    style: gt(e.style),
    "data-prefix": e.ns.namespace.value,
    onMouseleave: t[1] || (t[1] = (...f) => e.handleMouseLeave && e.handleMouseLeave(...f))
  }, [
    ve(
      "div",
      {
        ref: "tableInnerWrapper",
        class: X(e.ns.e("inner-wrapper"))
      },
      [
        ve(
          "div",
          J$e,
          [
            Oe(e.$slots, "default")
          ],
          512
        ),
        e.showHeader && e.tableLayout === "fixed" ? _t((G(), ue(
          "div",
          {
            key: 0,
            ref: "headerWrapper",
            class: X(e.ns.e("header-wrapper"))
          },
          [
            ve(
              "table",
              {
                ref: "tableHeader",
                class: X(e.ns.e("header")),
                style: gt(e.tableBodyStyles),
                border: "0",
                cellpadding: "0",
                cellspacing: "0"
              },
              [
                $(a, {
                  columns: e.store.states.columns.value,
                  "table-layout": e.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                $(i, {
                  ref: "tableHeaderRef",
                  border: e.border,
                  "default-sort": e.defaultSort,
                  store: e.store,
                  "append-filter-panel-to": e.appendFilterPanelTo,
                  "allow-drag-last-column": e.allowDragLastColumn,
                  onSetDragVisible: e.setDragVisible
                }, null, 8, ["border", "default-sort", "store", "append-filter-panel-to", "allow-drag-last-column", "onSetDragVisible"])
              ],
              6
            )
          ],
          2
        )), [
          [d, e.handleHeaderFooterMousewheel]
        ]) : Ie("v-if", !0),
        ve(
          "div",
          {
            ref: "bodyWrapper",
            class: X(e.ns.e("body-wrapper"))
          },
          [
            $(u, {
              ref: "scrollBarRef",
              "view-style": e.scrollbarViewStyle,
              "wrap-style": e.scrollbarStyle,
              always: e.scrollbarAlwaysOn,
              tabindex: e.scrollbarTabindex,
              native: e.nativeScrollbar,
              onScroll: t[0] || (t[0] = (f) => e.$emit("scroll", f))
            }, {
              default: Ee(() => [
                ve(
                  "table",
                  {
                    ref: "tableBody",
                    class: X(e.ns.e("body")),
                    cellspacing: "0",
                    cellpadding: "0",
                    border: "0",
                    style: gt({
                      width: e.bodyWidth,
                      tableLayout: e.tableLayout
                    })
                  },
                  [
                    $(a, {
                      columns: e.store.states.columns.value,
                      "table-layout": e.tableLayout
                    }, null, 8, ["columns", "table-layout"]),
                    e.showHeader && e.tableLayout === "auto" ? (G(), Me(i, {
                      key: 0,
                      ref: "tableHeaderRef",
                      class: X(e.ns.e("body-header")),
                      border: e.border,
                      "default-sort": e.defaultSort,
                      store: e.store,
                      "append-filter-panel-to": e.appendFilterPanelTo,
                      onSetDragVisible: e.setDragVisible
                    }, null, 8, ["class", "border", "default-sort", "store", "append-filter-panel-to", "onSetDragVisible"])) : Ie("v-if", !0),
                    $(s, {
                      context: e.context,
                      highlight: e.highlightCurrentRow,
                      "row-class-name": e.rowClassName,
                      "tooltip-effect": e.tooltipEffect,
                      "tooltip-options": e.tooltipOptions,
                      "row-style": e.rowStyle,
                      store: e.store,
                      stripe: e.stripe
                    }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
                    e.showSummary && e.tableLayout === "auto" ? (G(), Me(c, {
                      key: 1,
                      class: X(e.ns.e("body-footer")),
                      border: e.border,
                      "default-sort": e.defaultSort,
                      store: e.store,
                      "sum-text": e.computedSumText,
                      "summary-method": e.summaryMethod
                    }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : Ie("v-if", !0)
                  ],
                  6
                ),
                e.isEmpty ? (G(), ue(
                  "div",
                  {
                    key: 0,
                    ref: "emptyBlock",
                    style: gt(e.emptyBlockStyle),
                    class: X(e.ns.e("empty-block"))
                  },
                  [
                    ve(
                      "span",
                      {
                        class: X(e.ns.e("empty-text"))
                      },
                      [
                        Oe(e.$slots, "empty", {}, () => [
                          Ft(
                            qe(e.computedEmptyText),
                            1
                          )
                        ])
                      ],
                      2
                    )
                  ],
                  6
                )) : Ie("v-if", !0),
                e.$slots.append ? (G(), ue(
                  "div",
                  {
                    key: 1,
                    ref: "appendWrapper",
                    class: X(e.ns.e("append-wrapper"))
                  },
                  [
                    Oe(e.$slots, "append")
                  ],
                  2
                )) : Ie("v-if", !0)
              ]),
              _: 3
            }, 8, ["view-style", "wrap-style", "always", "tabindex", "native"])
          ],
          2
        ),
        e.showSummary && e.tableLayout === "fixed" ? _t((G(), ue(
          "div",
          {
            key: 1,
            ref: "footerWrapper",
            class: X(e.ns.e("footer-wrapper"))
          },
          [
            ve(
              "table",
              {
                class: X(e.ns.e("footer")),
                cellspacing: "0",
                cellpadding: "0",
                border: "0",
                style: gt(e.tableBodyStyles)
              },
              [
                $(a, {
                  columns: e.store.states.columns.value,
                  "table-layout": e.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                $(c, {
                  border: e.border,
                  "default-sort": e.defaultSort,
                  store: e.store,
                  "sum-text": e.computedSumText,
                  "summary-method": e.summaryMethod
                }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
              ],
              6
            )
          ],
          2
        )), [
          [Jt, !e.isEmpty],
          [d, e.handleHeaderFooterMousewheel]
        ]) : Ie("v-if", !0),
        e.border || e.isGroup ? (G(), ue(
          "div",
          {
            key: 2,
            class: X(e.ns.e("border-left-patch"))
          },
          null,
          2
        )) : Ie("v-if", !0)
      ],
      2
    ),
    _t(ve(
      "div",
      {
        ref: "resizeProxy",
        class: X(e.ns.e("column-resize-proxy"))
      },
      null,
      2
    ), [
      [Jt, e.resizeProxyVisible]
    ])
  ], 46, q$e);
}
var Q$e = /* @__PURE__ */ Je(X$e, [["render", Z$e], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/table/src/table.vue"]]);
const exe = {
  selection: "table-column--selection",
  expand: "table__expand-column"
}, txe = {
  default: {
    order: ""
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ""
  }
}, nxe = (e) => exe[e] || "", oxe = {
  selection: {
    renderHeader({ store: e }) {
      var t;
      function n() {
        return e.states.data.value && e.states.data.value.length === 0;
      }
      return ht(Fa, {
        disabled: n(),
        size: e.states.tableSize.value,
        indeterminate: e.states.selection.value.length > 0 && !e.states.isAllSelected.value,
        "onUpdate:modelValue": (t = e.toggleAllSelection) != null ? t : void 0,
        modelValue: e.states.isAllSelected.value,
        ariaLabel: e.t("el.table.selectAllLabel")
      });
    },
    renderCell({
      row: e,
      column: t,
      store: n,
      $index: o
    }) {
      return ht(Fa, {
        disabled: t.selectable ? !t.selectable.call(null, e, o) : !1,
        size: n.states.tableSize.value,
        onChange: () => {
          n.commit("rowSelectedChanged", e);
        },
        onClick: (l) => l.stopPropagation(),
        modelValue: n.isSelected(e),
        ariaLabel: n.t("el.table.selectRowLabel")
      });
    },
    sortable: !1,
    resizable: !1
  },
  index: {
    renderHeader({
      column: e
    }) {
      return e.label || "#";
    },
    renderCell({
      column: e,
      $index: t
    }) {
      let n = t + 1;
      const o = e.index;
      return mt(o) ? n = t + o : it(o) && (n = o(t)), ht("div", {}, [n]);
    },
    sortable: !1
  },
  expand: {
    renderHeader({
      column: e
    }) {
      return e.label || "";
    },
    renderCell({
      column: e,
      row: t,
      store: n,
      expanded: o
    }) {
      const { ns: l } = n, r = [l.e("expand-icon")];
      !e.renderExpand && o && r.push(l.em("expand-icon", "expanded"));
      const a = function(i) {
        i.stopPropagation(), n.toggleRowExpansion(t);
      };
      return ht(
        "button",
        {
          type: "button",
          "aria-label": n.t(
            o ? "el.table.collapseRowLabel" : "el.table.expandRowLabel"
          ),
          "aria-expanded": o,
          class: r,
          onClick: a
        },
        {
          default: () => e.renderExpand ? [
            e.renderExpand({
              expanded: o
            })
          ] : [
            ht(ut, null, {
              default: () => [ht(Rl)]
            })
          ]
        }
      );
    },
    sortable: !1,
    resizable: !1
  }
};
function lxe({
  row: e,
  column: t,
  $index: n
}) {
  var o;
  const l = t.property, r = l && ff(e, l).value;
  return t && t.formatter ? t.formatter(e, t, r, n) : ((o = r == null ? void 0 : r.toString) == null ? void 0 : o.call(r)) || "";
}
function rxe({
  row: e,
  treeNode: t,
  store: n
}, o = !1) {
  const { ns: l } = n;
  if (!t)
    return o ? [
      ht("span", {
        class: l.e("placeholder")
      })
    ] : null;
  const r = [], a = function(i) {
    i.stopPropagation(), !t.loading && n.loadOrToggle(e);
  };
  if (t.indent && r.push(
    ht("span", {
      class: l.e("indent"),
      style: { "padding-left": `${t.indent}px` }
    })
  ), Tn(t.expanded) && !t.noLazyChildren) {
    const i = [
      l.e("expand-icon"),
      t.expanded ? l.em("expand-icon", "expanded") : ""
    ];
    let s = Rl;
    t.loading && (s = wi), r.push(
      ht(
        "button",
        {
          type: "button",
          "aria-label": n.t(
            t.expanded ? "el.table.collapseRowLabel" : "el.table.expandRowLabel"
          ),
          "aria-expanded": t.expanded,
          class: i,
          onClick: a
        },
        {
          default: () => [
            ht(
              ut,
              { class: l.is("loading", t.loading) },
              {
                default: () => [ht(s)]
              }
            )
          ]
        }
      )
    );
  } else
    r.push(
      ht("span", {
        class: l.e("placeholder")
      })
    );
  return r;
}
function HN(e, t) {
  return e.reduce((n, o) => (n[o] = o, n), t);
}
function axe(e, t) {
  const n = xt();
  return {
    registerComplexWatchers: () => {
      const r = ["fixed"], a = {
        realWidth: "width",
        realMinWidth: "minWidth"
      }, i = HN(r, a);
      Object.keys(i).forEach((s) => {
        const c = a[s];
        hn(t, c) && pe(
          () => t[c],
          (u) => {
            let d = u;
            c === "width" && s === "realWidth" && (d = E_(u)), c === "minWidth" && s === "realMinWidth" && (d = yV(u)), n.columnConfig.value[c] = d, n.columnConfig.value[s] = d;
            const f = c === "fixed";
            e.value.store.scheduleLayout(f);
          }
        );
      });
    },
    registerNormalWatchers: () => {
      const r = [
        "label",
        "filters",
        "filterMultiple",
        "filteredValue",
        "sortable",
        "index",
        "formatter",
        "className",
        "labelClassName",
        "filterClassName",
        "showOverflowTooltip",
        "tooltipFormatter",
        "resizable"
      ], a = ["showOverflowTooltip"], i = {
        property: "prop",
        align: "realAlign",
        headerAlign: "realHeaderAlign"
      }, s = HN(r, i);
      Object.keys(s).forEach((c) => {
        const u = i[c];
        hn(t, u) && pe(
          () => t[u],
          (d) => {
            n.columnConfig.value[c] = d, (c === "filters" || c === "filterMethod") && (n.columnConfig.value.filterable = !!(n.columnConfig.value.filters || n.columnConfig.value.filterMethod));
          }
        );
      }), a.forEach((c) => {
        hn(e.value.props, c) && pe(
          () => e.value.props[c],
          (u) => {
            n.columnConfig.value.type !== "selection" && fn(t[c]) && (n.columnConfig.value[c] = u);
          }
        );
      });
    }
  };
}
function ixe(e, t, n) {
  const o = xt(), l = /* @__PURE__ */ H(""), r = /* @__PURE__ */ H(!1), a = /* @__PURE__ */ H(), i = /* @__PURE__ */ H(), s = Ve("table");
  Ot(() => {
    a.value = e.align ? `is-${e.align}` : null, a.value;
  }), Ot(() => {
    i.value = e.headerAlign ? `is-${e.headerAlign}` : a.value, i.value;
  });
  const c = O(() => {
    let C = o.vnode.vParent || o.parent;
    for (; C && !C.tableId && !C.columnId; )
      C = C.vnode.vParent || C.parent;
    return C;
  }), u = O(() => {
    const { store: C } = o.parent;
    if (!C)
      return !1;
    const { treeData: w } = C.states, x = w.value;
    return x && Object.keys(x).length > 0;
  }), d = /* @__PURE__ */ H(E_(e.width)), f = /* @__PURE__ */ H(yV(e.minWidth)), p = (C) => (d.value && (C.width = d.value), f.value && (C.minWidth = f.value), !d.value && f.value && (C.width = void 0), C.minWidth || (C.minWidth = 80), C.realWidth = Number(
    fn(C.width) ? C.minWidth : C.width
  ), C), m = (C) => {
    const w = C.type, x = oxe[w] || {};
    Object.keys(x).forEach((I) => {
      const T = x[I];
      I !== "className" && !fn(T) && (C[I] = T);
    });
    const E = nxe(w);
    if (E) {
      const I = `${S(s.namespace)}-${E}`;
      C.className = C.className ? `${C.className} ${I}` : I;
    }
    return C;
  }, v = (C) => {
    We(C) ? C.forEach((x) => w(x)) : w(C);
    function w(x) {
      var E;
      ((E = x == null ? void 0 : x.type) == null ? void 0 : E.name) === "ElTableColumn" && (x.vParent = o);
    }
  };
  return {
    columnId: l,
    realAlign: a,
    isSubColumn: r,
    realHeaderAlign: i,
    columnOrTableParent: c,
    setColumnWidth: p,
    setColumnForcedProps: m,
    setColumnRenders: (C) => {
      e.renderHeader ? Gt(
        "TableColumn",
        "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header."
      ) : C.type !== "selection" && (C.renderHeader = (x) => {
        if (o.columnConfig.value.label, t.header) {
          const E = t.header(x);
          if (wV(E))
            return ht(Ge, E);
        }
        return Ft(C.label);
      }), t["filter-icon"] && (C.renderFilterIcon = (x) => Oe(t, "filter-icon", x)), t.expand && (C.renderExpand = (x) => Oe(t, "expand", x));
      let w = C.renderCell;
      return C.type === "expand" ? (C.renderCell = (x) => ht(
        "div",
        {
          class: "cell"
        },
        [w(x)]
      ), n.value.renderExpanded = (x) => t.default ? t.default(x) : t.default) : (w = w || lxe, C.renderCell = (x) => {
        let E = null;
        if (t.default) {
          const R = t.default(x);
          E = R.some((z) => z.type !== qn) ? R : w(x);
        } else
          E = w(x);
        const { columns: I } = n.value.store.states, T = I.value.findIndex(
          (R) => R.type === "default"
        ), P = u.value && x.cellIndex === T, k = rxe(x, P), N = {
          class: "cell",
          style: {}
        };
        return C.showOverflowTooltip && (N.class = `${N.class} ${S(s.namespace)}-tooltip`, N.style = {
          width: `${(x.column.realWidth || Number(x.column.width)) - 1}px`
        }), v(E), ht("div", N, [k, E]);
      }), C;
    },
    getPropsData: (...C) => C.reduce(
      (w, x) => (We(x) && x.forEach((E) => {
        w[E] = e[E];
      }), w),
      {}
    ),
    getColumnElIndex: (C, w) => Array.prototype.indexOf.call(C, w),
    updateColumnOrder: () => {
      n.value.store.commit("updateColumnOrder", o.columnConfig.value);
    }
  };
}
var sxe = {
  type: {
    type: String,
    default: "default"
  },
  label: String,
  className: String,
  labelClassName: String,
  property: String,
  prop: String,
  width: {
    type: [String, Number],
    default: ""
  },
  minWidth: {
    type: [String, Number],
    default: ""
  },
  renderHeader: Function,
  sortable: {
    type: [Boolean, String],
    default: !1
  },
  sortMethod: Function,
  sortBy: [String, Function, Array],
  resizable: {
    type: Boolean,
    default: !0
  },
  columnKey: String,
  align: String,
  headerAlign: String,
  showOverflowTooltip: {
    type: [Boolean, Object],
    default: void 0
  },
  tooltipFormatter: Function,
  fixed: [Boolean, String],
  formatter: Function,
  selectable: Function,
  reserveSelection: Boolean,
  filterMethod: Function,
  filteredValue: Array,
  filters: Array,
  filterPlacement: String,
  filterMultiple: {
    type: Boolean,
    default: !0
  },
  filterClassName: String,
  index: [Number, Function],
  sortOrders: {
    type: Array,
    default: () => ["ascending", "descending", null],
    validator: (e) => e.every(
      (t) => ["ascending", "descending", null].includes(t)
    )
  }
};
let cxe = 1;
var DV = /* @__PURE__ */ le({
  name: "ElTableColumn",
  components: {
    ElCheckbox: Fa
  },
  props: sxe,
  setup(e, { slots: t }) {
    const n = xt(), o = /* @__PURE__ */ H({}), l = O(() => {
      let b = n.parent;
      for (; b && !b.tableId; )
        b = b.parent;
      return b;
    }), { registerNormalWatchers: r, registerComplexWatchers: a } = axe(
      l,
      e
    ), {
      columnId: i,
      isSubColumn: s,
      realHeaderAlign: c,
      columnOrTableParent: u,
      setColumnWidth: d,
      setColumnForcedProps: f,
      setColumnRenders: p,
      getPropsData: m,
      getColumnElIndex: v,
      realAlign: h,
      updateColumnOrder: g
    } = ixe(e, t, l), y = u.value;
    i.value = `${"tableId" in y && y.tableId || "columnId" in y && y.columnId}_column_${cxe++}`, _c(() => {
      s.value = l.value !== y;
      const b = e.type || "default", C = e.sortable === "" ? !0 : e.sortable, w = b === "selection" ? !1 : fn(e.showOverflowTooltip) ? y.props.showOverflowTooltip : e.showOverflowTooltip, x = fn(e.tooltipFormatter) ? y.props.tooltipFormatter : e.tooltipFormatter, E = vt(Be({}, txe[b]), {
        id: i.value,
        type: b,
        property: e.prop || e.property,
        align: h,
        headerAlign: c,
        showOverflowTooltip: w,
        tooltipFormatter: x,
        filterable: e.filters || e.filterMethod,
        filteredValue: [],
        filterPlacement: "",
        filterClassName: "",
        isColumnGroup: !1,
        isSubColumn: !1,
        filterOpened: !1,
        sortable: C,
        index: e.index,
        rawColumnKey: n.vnode.key
      });
      let N = m([
        "columnKey",
        "label",
        "className",
        "labelClassName",
        "type",
        "renderHeader",
        "formatter",
        "fixed",
        "resizable"
      ], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], [
        "filterMethod",
        "filters",
        "filterMultiple",
        "filterOpened",
        "filteredValue",
        "filterPlacement",
        "filterClassName"
      ]);
      N = Qwe(E, N), N = t$e(
        p,
        d,
        f
      )(N), o.value = N, r(), a();
    }), nt(() => {
      var b, C;
      const w = u.value, x = s.value ? (b = w.vnode.el) == null ? void 0 : b.children : (C = w.refs.hiddenColumns) == null ? void 0 : C.children, E = () => v(x || [], n.vnode.el);
      o.value.getColumnIndex = E, E() > -1 && l.value.store.commit(
        "insertColumn",
        o.value,
        s.value ? "columnConfig" in w && w.columnConfig.value : null,
        g
      );
    }), yt(() => {
      const b = o.value.getColumnIndex;
      (b ? b() : -1) > -1 && l.value.store.commit(
        "removeColumn",
        o.value,
        s.value ? "columnConfig" in y && y.columnConfig.value : null,
        g
      );
    }), n.columnId = i.value, n.columnConfig = o;
  },
  render() {
    var e, t, n;
    try {
      const o = (t = (e = this.$slots).default) == null ? void 0 : t.call(e, {
        row: {},
        column: {},
        $index: -1
      }), l = [];
      if (We(o))
        for (const a of o)
          ((n = a.type) == null ? void 0 : n.name) === "ElTableColumn" || a.shapeFlag & 2 ? l.push(a) : a.type === Ge && We(a.children) && a.children.forEach((i) => {
            (i == null ? void 0 : i.patchFlag) !== 1024 && !rt(i == null ? void 0 : i.children) && l.push(i);
          });
      return ht("div", l);
    } catch (o) {
      return ht("div", []);
    }
  }
});
const uxe = Dt(Q$e, {
  TableColumn: DV
}), dxe = oo(DV);
var vu = /* @__PURE__ */ ((e) => (e.ASC = "asc", e.DESC = "desc", e))(vu || {}), wm = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.CENTER = "center", e.RIGHT = "right", e))(wm || {}), LV = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))(LV || {});
const Hx = {
  asc: "desc",
  desc: "asc"
  /* ASC */
}, $m = Symbol("placeholder"), fxe = (e, t, n) => {
  var o, l, r;
  const a = Be({
    flexGrow: 0,
    flexShrink: 0
  }, n ? {} : {
    flexGrow: (o = e.flexGrow) != null ? o : 0,
    flexShrink: (l = e.flexShrink) != null ? l : 1
  }), i = vt(Be(Be({}, (r = e.style) != null ? r : {}), a), {
    flexBasis: "auto",
    width: e.width
  });
  return t || (e.maxWidth && (i.maxWidth = e.maxWidth), e.minWidth && (i.minWidth = e.minWidth)), i;
};
function pxe(e, t, n) {
  const o = O(
    () => S(t).map((h, g) => {
      var y, b;
      return vt(Be({}, h), {
        key: (b = (y = h.key) != null ? y : h.dataKey) != null ? b : g
      });
    })
  ), l = O(() => S(o).filter((h) => !h.hidden)), r = O(
    () => S(l).filter(
      (h) => h.fixed === "left" || h.fixed === !0
    )
  ), a = O(
    () => S(l).filter((h) => h.fixed === "right")
  ), i = O(
    () => S(l).filter((h) => !h.fixed)
  ), s = O(() => {
    const h = [];
    return S(r).forEach((g) => {
      h.push(vt(Be({}, g), {
        placeholderSign: $m
      }));
    }), S(i).forEach((g) => {
      h.push(g);
    }), S(a).forEach((g) => {
      h.push(vt(Be({}, g), {
        placeholderSign: $m
      }));
    }), h;
  }), c = O(() => S(r).length || S(a).length), u = O(() => S(o).reduce(
    (h, g) => (h[g.key] = fxe(g, S(n), e.fixed), h),
    {}
  )), d = O(() => S(l).reduce(
    (h, g) => h + g.width,
    0
  )), f = (h) => S(o).find((g) => g.key === h), p = (h) => S(u)[h], m = (h, g) => {
    h.width = g;
  };
  function v(h) {
    var g;
    const { key: y } = h.currentTarget.dataset;
    if (!y)
      return;
    const { sortState: b, sortBy: C } = e;
    let w = vu.ASC;
    Mt(b) ? w = Hx[b[y]] : w = Hx[C.order], (g = e.onColumnSort) == null || g.call(e, { column: f(y), key: y, order: w });
  }
  return {
    columns: o,
    columnsStyles: u,
    columnsTotalWidth: d,
    fixedColumnsOnLeft: r,
    fixedColumnsOnRight: a,
    hasFixedColumns: c,
    mainColumns: s,
    normalColumns: i,
    visibleColumns: l,
    getColumn: f,
    getColumnStyle: p,
    updateColumnWidth: m,
    onColumnSorted: v
  };
}
const vxe = (e, {
  mainTableRef: t,
  leftTableRef: n,
  rightTableRef: o,
  onMaybeEndReached: l
}) => {
  const r = /* @__PURE__ */ H({ scrollLeft: 0, scrollTop: 0 });
  function a(p) {
    var m, v, h;
    const { scrollTop: g } = p;
    (m = t.value) == null || m.scrollTo(p), (v = n.value) == null || v.scrollToTop(g), (h = o.value) == null || h.scrollToTop(g);
  }
  function i(p) {
    r.value = p, a(p);
  }
  function s(p) {
    r.value.scrollTop = p, a(S(r));
  }
  function c(p) {
    var m, v;
    r.value.scrollLeft = p, (v = (m = t.value) == null ? void 0 : m.scrollTo) == null || v.call(m, S(r));
  }
  function u(p) {
    var m;
    i(p), (m = e.onScroll) == null || m.call(e, p);
  }
  function d({ scrollTop: p }) {
    const { scrollTop: m } = S(r);
    p !== m && s(p);
  }
  function f(p, m = "auto") {
    var v;
    (v = t.value) == null || v.scrollToRow(p, m);
  }
  return pe(
    () => S(r).scrollTop,
    (p, m) => {
      p > m && l();
    }
  ), {
    scrollPos: r,
    scrollTo: i,
    scrollToLeft: c,
    scrollToTop: s,
    scrollToRow: f,
    onScroll: u,
    onVerticalScroll: d
  };
}, mxe = (e, {
  mainTableRef: t,
  leftTableRef: n,
  rightTableRef: o,
  tableInstance: l,
  ns: r,
  isScrolling: a
}) => {
  const i = xt(), { emit: s } = i, c = /* @__PURE__ */ Ce(!1), u = /* @__PURE__ */ H(e.defaultExpandedRowKeys || []), d = /* @__PURE__ */ H(-1), f = /* @__PURE__ */ Ce(null), p = /* @__PURE__ */ H({}), m = /* @__PURE__ */ H({}), v = /* @__PURE__ */ Ce({}), h = /* @__PURE__ */ Ce({}), g = /* @__PURE__ */ Ce({}), y = O(() => mt(e.estimatedRowHeight));
  function b(P) {
    var k;
    (k = e.onRowsRendered) == null || k.call(e, P), P.rowCacheEnd > S(d) && (d.value = P.rowCacheEnd);
  }
  function C({ hovered: P, rowKey: k }) {
    if (a.value)
      return;
    l.vnode.el.querySelectorAll(`[rowkey="${String(k)}"]`).forEach((z) => {
      P ? z.classList.add(r.is("hovered")) : z.classList.remove(r.is("hovered"));
    });
  }
  function w({
    expanded: P,
    rowData: k,
    rowIndex: N,
    rowKey: R
  }) {
    var z, D;
    const F = [...S(u)], M = F.indexOf(R);
    P ? M === -1 && F.push(R) : M > -1 && F.splice(M, 1), u.value = F, s("update:expandedRowKeys", F), (z = e.onRowExpand) == null || z.call(e, {
      expanded: P,
      rowData: k,
      rowIndex: N,
      rowKey: R
    }), (D = e.onExpandedRowsChange) == null || D.call(e, F), l.vnode.el.querySelector(
      `.${r.is("hovered")}[rowkey="${String(R)}"]`
    ) && Ke(() => C({ hovered: !0, rowKey: R }));
  }
  const x = Dr(() => {
    var P, k, N, R;
    c.value = !0, p.value = Be(Be({}, S(p)), S(m)), E(S(f), !1), m.value = {}, f.value = null, (P = t.value) == null || P.forceUpdate(), (k = n.value) == null || k.forceUpdate(), (N = o.value) == null || N.forceUpdate(), (R = i.proxy) == null || R.$forceUpdate(), c.value = !1;
  }, 0);
  function E(P, k = !1) {
    S(y) && [t, n, o].forEach((N) => {
      const R = S(N);
      R && R.resetAfterRowIndex(P, k);
    });
  }
  function I(P, k, N) {
    const R = S(f);
    (R === null || R > N) && (f.value = N), m.value[P] = k;
  }
  function T({ rowKey: P, height: k, rowIndex: N }, R) {
    R ? R === LV.RIGHT ? g.value[P] = k : v.value[P] = k : h.value[P] = k;
    const z = Math.max(
      ...[v, g, h].map(
        (D) => D.value[P] || 0
      )
    );
    S(p)[P] !== z && (I(P, z, N), x());
  }
  return {
    expandedRowKeys: u,
    lastRenderedRowIndex: d,
    isDynamic: y,
    isResetting: c,
    rowHeights: p,
    resetAfterIndex: E,
    onRowExpanded: w,
    onRowHovered: C,
    onRowsRendered: b,
    onRowHeightChange: T
  };
}, hxe = (e, { expandedRowKeys: t, lastRenderedRowIndex: n, resetAfterIndex: o }) => {
  const l = /* @__PURE__ */ H({}), r = O(() => {
    const i = {}, { data: s, rowKey: c } = e, u = S(t);
    if (!u || !u.length)
      return s;
    const d = [], f = /* @__PURE__ */ new Set();
    u.forEach((m) => f.add(m));
    let p = s.slice();
    for (p.forEach((m) => i[m[c]] = 0); p.length > 0; ) {
      const m = p.shift();
      d.push(m), f.has(m[c]) && We(m.children) && m.children.length > 0 && (p = [...m.children, ...p], m.children.forEach(
        (v) => i[v[c]] = i[m[c]] + 1
      ));
    }
    return l.value = i, d;
  }), a = O(() => {
    const { data: i, expandColumnKey: s } = e;
    return s ? S(r) : i;
  });
  return pe(a, (i, s) => {
    i !== s && (n.value = -1, o(0, !0));
  }), {
    data: a,
    depthMap: l
  };
}, gxe = (e, t) => e + t, Sb = (e) => We(e) ? e.reduce(gxe, 0) : e, ju = (e, t, n = {}) => it(e) ? e(t) : e != null ? e : n, tc = (e) => (["width", "maxWidth", "minWidth", "height"].forEach((t) => {
  e[t] = ao(e[t]);
}), e), BV = (e) => dn(e) ? (t) => ht(e, t) : e, bxe = (e, {
  columnsTotalWidth: t,
  rowsHeight: n,
  fixedColumnsOnLeft: o,
  fixedColumnsOnRight: l
}) => {
  const r = O(() => {
    const { fixed: g, width: y, vScrollbarSize: b } = e, C = y - b;
    return g ? Math.max(Math.round(S(t)), C) : C;
  }), a = O(() => {
    const { height: g = 0, maxHeight: y = 0, footerHeight: b, hScrollbarSize: C } = e;
    if (y > 0) {
      const w = S(f), x = S(n), I = S(d) + w + x + C;
      return Math.min(I, y - b);
    }
    return g - b;
  }), i = O(() => {
    const { maxHeight: g } = e, y = S(a);
    if (mt(g) && g > 0)
      return y;
    const b = S(n) + S(d) + S(f);
    return Math.min(y, b);
  }), s = (g) => g.width, c = O(
    () => Sb(S(o).map(s))
  ), u = O(
    () => Sb(S(l).map(s))
  ), d = O(() => Sb(e.headerHeight)), f = O(() => {
    var g;
    return (((g = e.fixedData) == null ? void 0 : g.length) || 0) * e.rowHeight;
  }), p = O(() => S(a) - S(d) - S(f)), m = O(() => {
    const { style: g = {}, height: y, width: b } = e;
    return tc(vt(Be({}, g), {
      height: y,
      width: b
    }));
  }), v = O(
    () => tc({ height: e.footerHeight })
  ), h = O(() => ({
    top: ao(S(d)),
    bottom: ao(e.footerHeight),
    width: ao(e.width)
  }));
  return {
    bodyWidth: r,
    fixedTableHeight: i,
    mainTableHeight: a,
    leftTableWidth: c,
    rightTableWidth: u,
    windowHeight: p,
    footerHeight: v,
    emptyStyle: h,
    rootStyle: m,
    headerHeight: d
  };
};
function yxe(e) {
  const t = /* @__PURE__ */ H(), n = /* @__PURE__ */ H(), o = /* @__PURE__ */ H(), {
    columns: l,
    columnsStyles: r,
    columnsTotalWidth: a,
    fixedColumnsOnLeft: i,
    fixedColumnsOnRight: s,
    hasFixedColumns: c,
    mainColumns: u,
    onColumnSorted: d
  } = pxe(e, /* @__PURE__ */ ft(e, "columns"), /* @__PURE__ */ ft(e, "fixed")), {
    scrollTo: f,
    scrollToLeft: p,
    scrollToTop: m,
    scrollToRow: v,
    onScroll: h,
    onVerticalScroll: g,
    scrollPos: y
  } = vxe(e, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: o,
    onMaybeEndReached: Z
  }), b = Ve("table-v2"), C = xt(), w = /* @__PURE__ */ Ce(!1), {
    expandedRowKeys: x,
    lastRenderedRowIndex: E,
    isDynamic: I,
    isResetting: T,
    rowHeights: P,
    resetAfterIndex: k,
    onRowExpanded: N,
    onRowHeightChange: R,
    onRowHovered: z,
    onRowsRendered: D
  } = mxe(e, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: o,
    tableInstance: C,
    ns: b,
    isScrolling: w
  }), { data: F, depthMap: M } = hxe(e, {
    expandedRowKeys: x,
    lastRenderedRowIndex: E,
    resetAfterIndex: k
  }), A = O(() => {
    const { estimatedRowHeight: ee, rowHeight: fe } = e, me = S(F);
    return mt(ee) ? Object.values(S(P)).reduce(
      (ge, he) => ge + he,
      0
    ) : me.length * fe;
  }), {
    bodyWidth: L,
    fixedTableHeight: B,
    mainTableHeight: V,
    leftTableWidth: j,
    rightTableWidth: W,
    windowHeight: Y,
    footerHeight: U,
    emptyStyle: te,
    rootStyle: J,
    headerHeight: re
  } = bxe(e, {
    columnsTotalWidth: a,
    fixedColumnsOnLeft: i,
    fixedColumnsOnRight: s,
    rowsHeight: A
  }), oe = /* @__PURE__ */ H(), q = O(() => {
    const ee = S(F).length === 0;
    return We(e.fixedData) ? e.fixedData.length === 0 && ee : ee;
  });
  function K(ee) {
    const { estimatedRowHeight: fe, rowHeight: me, rowKey: ge } = e;
    return fe ? S(P)[S(F)[ee][ge]] || fe : me;
  }
  const se = /* @__PURE__ */ H(!1);
  function Z() {
    const { onEndReached: ee } = e;
    if (!ee)
      return;
    const { scrollTop: fe } = S(y), me = S(A), ge = S(Y), he = me - (fe + ge) + e.hScrollbarSize;
    !se.value && S(E) >= 0 && me <= fe + S(V) - S(re) ? (se.value = !0, ee(he)) : se.value = !1;
  }
  return pe(
    () => S(A),
    () => se.value = !1
  ), pe(
    () => e.expandedRowKeys,
    (ee) => x.value = ee,
    {
      deep: !0
    }
  ), {
    columns: l,
    containerRef: oe,
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: o,
    isDynamic: I,
    isResetting: T,
    isScrolling: w,
    hasFixedColumns: c,
    columnsStyles: r,
    columnsTotalWidth: a,
    data: F,
    expandedRowKeys: x,
    depthMap: M,
    fixedColumnsOnLeft: i,
    fixedColumnsOnRight: s,
    mainColumns: u,
    bodyWidth: L,
    emptyStyle: te,
    rootStyle: J,
    footerHeight: U,
    mainTableHeight: V,
    fixedTableHeight: B,
    leftTableWidth: j,
    rightTableWidth: W,
    showEmpty: q,
    getRowHeight: K,
    onColumnSorted: d,
    onRowHovered: z,
    onRowExpanded: N,
    onRowsRendered: D,
    onRowHeightChange: R,
    scrollTo: f,
    scrollToLeft: p,
    scrollToTop: m,
    scrollToRow: v,
    onScroll: h,
    onVerticalScroll: g
  };
}
const P_ = Symbol("tableV2"), FV = "tableV2GridScrollLeft", VV = String, bh = {
  type: ye(Array),
  required: !0
}, k_ = {
  type: ye(Array)
}, zV = vt(Be({}, k_), {
  required: !0
}), Sxe = String, jN = {
  type: ye(Array),
  default: () => lo([])
}, lu = {
  type: Number,
  required: !0
}, HV = {
  type: ye([String, Number, Symbol]),
  default: "id"
}, WN = {
  type: ye(Object)
}, mu = Xe({
  class: String,
  columns: bh,
  columnsStyles: {
    type: ye(Object),
    required: !0
  },
  depth: Number,
  expandColumnKey: Sxe,
  estimatedRowHeight: vt(Be({}, Ou.estimatedRowHeight), {
    default: void 0
  }),
  isScrolling: Boolean,
  onRowExpand: {
    type: ye(Function)
  },
  onRowHover: {
    type: ye(Function)
  },
  onRowHeightChange: {
    type: ye(Function)
  },
  rowData: {
    type: ye(Object),
    required: !0
  },
  rowEventHandlers: {
    type: ye(Object)
  },
  rowIndex: {
    type: Number,
    required: !0
  },
  rowKey: HV,
  style: {
    type: ye(Object)
  }
}), rw = {
  type: Number,
  required: !0
}, N_ = Xe({
  class: String,
  columns: bh,
  fixedHeaderData: {
    type: ye(Array)
  },
  headerData: {
    type: ye(Array),
    required: !0
  },
  headerHeight: {
    type: ye([Number, Array]),
    default: 50
  },
  rowWidth: rw,
  rowHeight: {
    type: Number,
    default: 50
  },
  height: rw,
  width: rw
}), Cb = Xe({
  columns: bh,
  data: zV,
  fixedData: k_,
  estimatedRowHeight: mu.estimatedRowHeight,
  width: lu,
  height: lu,
  headerWidth: lu,
  headerHeight: N_.headerHeight,
  bodyWidth: lu,
  rowHeight: lu,
  cache: aV.cache,
  useIsScrolling: Boolean,
  scrollbarAlwaysOn: Ou.scrollbarAlwaysOn,
  scrollbarStartGap: Ou.scrollbarStartGap,
  scrollbarEndGap: Ou.scrollbarEndGap,
  class: VV,
  style: WN,
  containerStyle: WN,
  getRowHeight: {
    type: ye(Function),
    required: !0
  },
  rowKey: mu.rowKey,
  onRowsRendered: {
    type: ye(Function)
  },
  onScroll: {
    type: ye(Function)
  }
}), Cxe = Xe({
  cache: Cb.cache,
  estimatedRowHeight: mu.estimatedRowHeight,
  rowKey: HV,
  headerClass: {
    type: ye([
      String,
      Function
    ])
  },
  headerProps: {
    type: ye([
      Object,
      Function
    ])
  },
  headerCellProps: {
    type: ye([
      Object,
      Function
    ])
  },
  headerHeight: N_.headerHeight,
  footerHeight: {
    type: Number,
    default: 0
  },
  rowClass: {
    type: ye([String, Function])
  },
  rowProps: {
    type: ye([Object, Function])
  },
  rowHeight: {
    type: Number,
    default: 50
  },
  cellProps: {
    type: ye([
      Object,
      Function
    ])
  },
  columns: bh,
  data: zV,
  dataGetter: {
    type: ye(Function)
  },
  fixedData: k_,
  expandColumnKey: mu.expandColumnKey,
  expandedRowKeys: jN,
  defaultExpandedRowKeys: jN,
  class: VV,
  fixed: Boolean,
  style: {
    type: ye(Object)
  },
  width: lu,
  height: lu,
  maxHeight: Number,
  useIsScrolling: Boolean,
  indentSize: {
    type: Number,
    default: 12
  },
  iconSize: {
    type: Number,
    default: 12
  },
  hScrollbarSize: Ou.hScrollbarSize,
  vScrollbarSize: Ou.vScrollbarSize,
  scrollbarAlwaysOn: cV.alwaysOn,
  sortBy: {
    type: ye(Object),
    default: () => ({})
  },
  sortState: {
    type: ye(Object),
    default: void 0
  },
  onColumnSort: {
    type: ye(Function)
  },
  onExpandedRowsChange: {
    type: ye(Function)
  },
  onEndReached: {
    type: ye(Function)
  },
  onRowExpand: mu.onRowExpand,
  onScroll: Cb.onScroll,
  onRowsRendered: Cb.onRowsRendered,
  rowEventHandlers: mu.rowEventHandlers
}), wxe = "ElTableV2Header", $xe = /* @__PURE__ */ le({
  name: wxe,
  props: N_,
  setup(e, {
    slots: t,
    expose: n
  }) {
    const o = Ve("table-v2"), l = ze(FV), r = /* @__PURE__ */ H(), a = O(() => tc({
      width: e.width,
      height: e.height
    })), i = O(() => tc({
      width: e.rowWidth,
      height: e.height
    })), s = O(() => ll(S(e.headerHeight))), c = (f) => {
      const p = S(r);
      Ke(() => {
        p != null && p.scroll && p.scroll({
          left: f
        });
      });
    }, u = () => {
      const f = o.e("fixed-header-row"), {
        columns: p,
        fixedHeaderData: m,
        rowHeight: v
      } = e;
      return m == null ? void 0 : m.map((h, g) => {
        var y;
        const b = tc({
          height: v,
          width: "100%"
        });
        return (y = t.fixed) == null ? void 0 : y.call(t, {
          class: f,
          columns: p,
          rowData: h,
          rowIndex: -(g + 1),
          style: b
        });
      });
    }, d = () => {
      const f = o.e("dynamic-header-row"), {
        columns: p
      } = e;
      return S(s).map((m, v) => {
        var h;
        const g = tc({
          width: "100%",
          height: m
        });
        return (h = t.dynamic) == null ? void 0 : h.call(t, {
          class: f,
          columns: p,
          headerIndex: v,
          style: g
        });
      });
    };
    return $o(() => {
      l != null && l.value && c(l.value);
    }), n({
      scrollToLeft: c
    }), () => {
      if (!(e.height <= 0))
        return $("div", {
          ref: r,
          class: e.class,
          style: S(a),
          role: "rowgroup"
        }, [$("div", {
          style: S(i),
          class: o.e("header")
        }, [d(), u()])]);
    };
  }
});
var xxe = $xe;
const Exe = ({ atXEndEdge: e, atXStartEdge: t, atYEndEdge: n, atYStartEdge: o }, l) => {
  let r = null, a = 0, i = 0;
  const s = (u, d) => {
    const f = u < 0 && t.value || u > 0 && e.value, p = d < 0 && o.value || d > 0 && n.value;
    return f || p;
  };
  return {
    hasReachedEdge: s,
    onWheel: (u) => {
      vs(r);
      let d = u.deltaX, f = u.deltaY;
      Math.abs(d) > Math.abs(f) ? f = 0 : d = 0, u.shiftKey && f !== 0 && (d = f, f = 0), !s(d, f) && (a += d, i += f, u.preventDefault(), r = Ci(() => {
        l(a, i), a = 0, i = 0;
      }));
    }
  };
}, Oxe = (e, t, n, o, l, r, a) => {
  const i = /* @__PURE__ */ H(0), s = /* @__PURE__ */ H(0);
  let c, u = 0, d = 0;
  const f = (m) => {
    vs(c), i.value = m.touches[0].clientX, s.value = m.touches[0].clientY, u = 0, d = 0;
  }, p = (m) => {
    m.preventDefault(), vs(c), u += i.value - m.touches[0].clientX, d += s.value - m.touches[0].clientY, i.value = m.touches[0].clientX, s.value = m.touches[0].clientY, c = Ci(() => {
      const v = o.value - S(r), h = l.value - S(a), g = Math.min(
        t.value.scrollLeft + u,
        v
      ), y = Math.min(
        t.value.scrollTop + d,
        h
      );
      n({
        scrollLeft: g,
        scrollTop: y
      }), u = 0, d = 0;
    });
  };
  return wn(e, "touchstart", f, {
    passive: !0
  }), wn(e, "touchmove", p, {
    passive: !1
  }), {
    touchStartX: i,
    touchStartY: s,
    handleTouchStart: f,
    handleTouchMove: p
  };
}, jV = ({
  name: e,
  clearCache: t,
  getColumnPosition: n,
  getColumnStartIndexForOffset: o,
  getColumnStopIndexForStartIndex: l,
  getEstimatedTotalHeight: r,
  getEstimatedTotalWidth: a,
  getColumnOffset: i,
  getRowOffset: s,
  getRowPosition: c,
  getRowStartIndexForOffset: u,
  getRowStopIndexForStartIndex: d,
  initCache: f,
  injectToInstance: p,
  validateProps: m
}) => /* @__PURE__ */ le({
  name: e != null ? e : "ElVirtualList",
  props: Ou,
  emits: [j0, W0],
  setup(v, { emit: h, expose: g, slots: y }) {
    const b = Ve("vl");
    m(v);
    const C = xt(), w = /* @__PURE__ */ H(f(v, C));
    p == null || p(C, w);
    const x = /* @__PURE__ */ H(), E = /* @__PURE__ */ H(), I = /* @__PURE__ */ H(), T = /* @__PURE__ */ H(), P = /* @__PURE__ */ H({
      isScrolling: !1,
      scrollLeft: mt(v.initScrollLeft) ? v.initScrollLeft : 0,
      scrollTop: mt(v.initScrollTop) ? v.initScrollTop : 0,
      updateRequested: !1,
      xAxisScrollDir: Xd,
      yAxisScrollDir: Xd
    }), k = tV(), N = O(
      () => Number.parseInt(`${v.height}`, 10)
    ), R = O(() => Number.parseInt(`${v.width}`, 10)), z = O(() => {
      const { totalColumn: ae, totalRow: ce, columnCache: xe } = v, { isScrolling: Te, xAxisScrollDir: Se, scrollLeft: be } = S(P);
      if (ae === 0 || ce === 0)
        return [0, 0, 0, 0];
      const ie = o(
        v,
        be,
        S(w)
      ), we = l(
        v,
        ie,
        be,
        S(w)
      ), Ne = !Te || Se === K0 ? Math.max(1, xe) : 1, tt = !Te || Se === Xd ? Math.max(1, xe) : 1;
      return [
        Math.max(0, ie - Ne),
        Math.max(0, Math.min(ae - 1, we + tt)),
        ie,
        we
      ];
    }), D = O(() => {
      const { totalColumn: ae, totalRow: ce, rowCache: xe } = v, { isScrolling: Te, yAxisScrollDir: Se, scrollTop: be } = S(P);
      if (ae === 0 || ce === 0)
        return [0, 0, 0, 0];
      const ie = u(
        v,
        be,
        S(w)
      ), we = d(
        v,
        ie,
        be,
        S(w)
      ), Ne = !Te || Se === K0 ? Math.max(1, xe) : 1, tt = !Te || Se === Xd ? Math.max(1, xe) : 1;
      return [
        Math.max(0, ie - Ne),
        Math.max(0, Math.min(ce - 1, we + tt)),
        ie,
        we
      ];
    }), F = O(
      () => r(v, S(w))
    ), M = O(
      () => a(v, S(w))
    ), A = O(() => {
      var ae;
      return [
        {
          position: "relative",
          overflow: "hidden",
          WebkitOverflowScrolling: "touch",
          willChange: "transform"
        },
        {
          direction: v.direction,
          height: mt(v.height) ? `${v.height}px` : v.height,
          width: mt(v.width) ? `${v.width}px` : v.width
        },
        (ae = v.style) != null ? ae : {}
      ];
    }), L = O(() => {
      const ae = `${S(M)}px`;
      return {
        height: `${S(F)}px`,
        pointerEvents: S(P).isScrolling ? "none" : void 0,
        width: ae,
        margin: 0,
        boxSizing: "border-box"
      };
    }), B = () => {
      const { totalColumn: ae, totalRow: ce } = v;
      if (ae > 0 && ce > 0) {
        const [
          we,
          Ne,
          tt,
          Pe
        ] = S(z), [Re, Le, Ue, Ae] = S(D);
        h(j0, {
          columnCacheStart: we,
          columnCacheEnd: Ne,
          rowCacheStart: Re,
          rowCacheEnd: Le,
          columnVisibleStart: tt,
          columnVisibleEnd: Pe,
          rowVisibleStart: Ue,
          rowVisibleEnd: Ae
        });
      }
      const {
        scrollLeft: xe,
        scrollTop: Te,
        updateRequested: Se,
        xAxisScrollDir: be,
        yAxisScrollDir: ie
      } = S(P);
      h(W0, {
        xAxisScrollDir: be,
        scrollLeft: xe,
        yAxisScrollDir: ie,
        scrollTop: Te,
        updateRequested: Se
      });
    }, V = (ae) => {
      const {
        clientHeight: ce,
        clientWidth: xe,
        scrollHeight: Te,
        scrollLeft: Se,
        scrollTop: be,
        scrollWidth: ie
      } = ae.currentTarget, we = S(P);
      if (we.scrollTop === be && we.scrollLeft === Se)
        return;
      let Ne = Se;
      if (_N(v.direction))
        switch (G0()) {
          case Sm:
            Ne = -Se;
            break;
          case x_:
            Ne = ie - xe - Se;
            break;
        }
      P.value = vt(Be({}, we), {
        isScrolling: !0,
        scrollLeft: Ne,
        scrollTop: Math.max(
          0,
          Math.min(be, Te - ce)
        ),
        updateRequested: !0,
        xAxisScrollDir: pu(we.scrollLeft, Ne),
        yAxisScrollDir: pu(we.scrollTop, be)
      }), Ke(() => se()), Z(), B();
    }, j = (ae, ce) => {
      const xe = S(N), Te = (F.value - xe) / ce * ae;
      U({
        scrollTop: Math.min(F.value - xe, Te)
      });
    }, W = (ae, ce) => {
      const xe = S(R), Te = (M.value - xe) / ce * ae;
      U({
        scrollLeft: Math.min(M.value - xe, Te)
      });
    }, { onWheel: Y } = Exe(
      {
        atXStartEdge: O(() => P.value.scrollLeft <= 0),
        atXEndEdge: O(
          () => P.value.scrollLeft >= M.value - S(R)
        ),
        atYStartEdge: O(() => P.value.scrollTop <= 0),
        atYEndEdge: O(
          () => P.value.scrollTop >= F.value - S(N)
        )
      },
      (ae, ce) => {
        var xe, Te, Se, be;
        (Te = (xe = E.value) == null ? void 0 : xe.onMouseUp) == null || Te.call(xe), (be = (Se = I.value) == null ? void 0 : Se.onMouseUp) == null || be.call(Se);
        const ie = S(R), we = S(N);
        U({
          scrollLeft: Math.min(
            P.value.scrollLeft + ae,
            M.value - ie
          ),
          scrollTop: Math.min(
            P.value.scrollTop + ce,
            F.value - we
          )
        });
      }
    );
    wn(x, "wheel", Y, {
      passive: !1
    });
    const U = ({
      scrollLeft: ae = P.value.scrollLeft,
      scrollTop: ce = P.value.scrollTop
    }) => {
      ae = Math.max(ae, 0), ce = Math.max(ce, 0);
      const xe = S(P);
      ce === xe.scrollTop && ae === xe.scrollLeft || (P.value = vt(Be({}, xe), {
        xAxisScrollDir: pu(xe.scrollLeft, ae),
        yAxisScrollDir: pu(xe.scrollTop, ce),
        scrollLeft: ae,
        scrollTop: ce,
        updateRequested: !0
      }), Ke(() => se()), Z(), B());
    }, { touchStartX: te, touchStartY: J, handleTouchStart: re, handleTouchMove: oe } = Oxe(
      x,
      P,
      U,
      M,
      F,
      R,
      N
    ), q = (ae = 0, ce = 0, xe = Qr) => {
      const Te = S(P);
      ce = Math.max(0, Math.min(ce, v.totalColumn - 1)), ae = Math.max(0, Math.min(ae, v.totalRow - 1));
      const Se = w7(b.namespace.value), be = S(w), ie = r(v, be), we = a(v, be);
      U({
        scrollLeft: i(
          v,
          ce,
          xe,
          Te.scrollLeft,
          be,
          we > v.width ? Se : 0
        ),
        scrollTop: s(
          v,
          ae,
          xe,
          Te.scrollTop,
          be,
          ie > v.height ? Se : 0
        )
      });
    }, K = (ae, ce) => {
      const { columnWidth: xe, direction: Te, rowHeight: Se } = v, be = k.value(
        t && xe,
        t && Se,
        t && Te
      ), ie = `${ae},${ce}`;
      if (hn(be, ie))
        return be[ie];
      {
        const [, we] = n(v, ce, S(w)), Ne = S(w), tt = _N(Te), [Pe, Re] = c(v, ae, Ne), [Le] = n(v, ce, Ne);
        return be[ie] = {
          position: "absolute",
          left: tt ? void 0 : `${we}px`,
          right: tt ? `${we}px` : void 0,
          top: `${Re}px`,
          height: `${Pe}px`,
          width: `${Le}px`
        }, be[ie];
      }
    }, se = () => {
      P.value.isScrolling = !1, Ke(() => {
        k.value(-1, null, null);
      });
    };
    nt(() => {
      if (!Sn)
        return;
      const { initScrollLeft: ae, initScrollTop: ce } = v, xe = S(x);
      xe && (mt(ae) && (xe.scrollLeft = ae), mt(ce) && (xe.scrollTop = ce)), B();
    });
    const Z = () => {
      const { direction: ae } = v, { scrollLeft: ce, scrollTop: xe, updateRequested: Te } = S(P), Se = S(x);
      if (Te && Se) {
        if (ae === pf)
          switch (G0()) {
            case Sm: {
              Se.scrollLeft = -ce;
              break;
            }
            case $_: {
              Se.scrollLeft = ce;
              break;
            }
            default: {
              const { clientWidth: be, scrollWidth: ie } = Se;
              Se.scrollLeft = ie - be - ce;
              break;
            }
          }
        else
          Se.scrollLeft = Math.max(0, ce);
        Se.scrollTop = Math.max(0, xe);
      }
    }, { resetAfterColumnIndex: ee, resetAfterRowIndex: fe, resetAfter: me } = C.proxy;
    g({
      windowRef: x,
      innerRef: T,
      getItemStyleCache: k,
      touchStartX: te,
      touchStartY: J,
      handleTouchStart: re,
      handleTouchMove: oe,
      scrollTo: U,
      scrollToItem: q,
      states: P,
      resetAfterColumnIndex: ee,
      resetAfterRowIndex: fe,
      resetAfter: me
    });
    const ge = () => {
      const {
        scrollbarAlwaysOn: ae,
        scrollbarStartGap: ce,
        scrollbarEndGap: xe,
        totalColumn: Te,
        totalRow: Se
      } = v, be = S(R), ie = S(N), we = S(M), Ne = S(F), { scrollLeft: tt, scrollTop: Pe } = S(P), Re = ht(kx, {
        ref: E,
        alwaysOn: ae,
        startGap: ce,
        endGap: xe,
        class: b.e("horizontal"),
        clientSize: be,
        layout: "horizontal",
        onScroll: W,
        ratio: be * 100 / we,
        scrollFrom: tt / (we - be),
        total: Se,
        visible: !0
      }), Le = ht(kx, {
        ref: I,
        alwaysOn: ae,
        startGap: ce,
        endGap: xe,
        class: b.e("vertical"),
        clientSize: ie,
        layout: "vertical",
        onScroll: j,
        ratio: ie * 100 / Ne,
        scrollFrom: Pe / (Ne - ie),
        total: Te,
        visible: !0
      });
      return {
        horizontalScrollbar: Re,
        verticalScrollbar: Le
      };
    }, he = () => {
      var ae;
      const [ce, xe] = S(z), [Te, Se] = S(D), { data: be, totalColumn: ie, totalRow: we, useIsScrolling: Ne, itemKey: tt } = v, Pe = [];
      if (we > 0 && ie > 0)
        for (let Re = Te; Re <= Se; Re++)
          for (let Le = ce; Le <= xe; Le++) {
            const Ue = tt({ columnIndex: Le, data: be, rowIndex: Re });
            Pe.push(
              ht(
                Ge,
                { key: Ue },
                (ae = y.default) == null ? void 0 : ae.call(y, {
                  columnIndex: Le,
                  data: be,
                  isScrolling: Ne ? S(P).isScrolling : void 0,
                  style: K(Re, Le),
                  rowIndex: Re
                })
              )
            );
          }
      return Pe;
    }, $e = () => {
      const ae = Ht(v.innerElement), ce = he();
      return [
        ht(
          ae,
          Ut(v.innerProps, {
            style: S(L),
            ref: T
          }),
          rt(ae) ? ce : {
            default: () => ce
          }
        )
      ];
    };
    return () => {
      const ae = Ht(
        v.containerElement
      ), { horizontalScrollbar: ce, verticalScrollbar: xe } = ge(), Te = $e();
      return ht(
        "div",
        {
          key: 0,
          class: b.e("wrapper"),
          role: v.role
        },
        [
          ht(
            ae,
            {
              class: v.className,
              style: S(A),
              onScroll: V,
              ref: x
            },
            rt(ae) ? Te : { default: () => Te }
          ),
          ce,
          xe
        ]
      );
    };
  }
}), { max: q0, min: WV, floor: KV } = Math, KN = "ElDynamicSizeGrid", _xe = {
  column: "columnWidth",
  row: "rowHeight"
}, jx = {
  column: "lastVisitedColumnIndex",
  row: "lastVisitedRowIndex"
}, Ji = (e, t, n, o) => {
  const [l, r, a] = [
    n[o],
    e[_xe[o]],
    n[jx[o]]
  ];
  if (t > a) {
    let i = 0;
    if (a >= 0) {
      const s = l[a];
      i = s.offset + s.size;
    }
    for (let s = a + 1; s <= t; s++) {
      const c = r(s);
      l[s] = {
        offset: i,
        size: c
      }, i += c;
    }
    n[jx[o]] = t;
  }
  return l[t];
}, UV = (e, t, n, o, l, r) => {
  for (; n <= o; ) {
    const a = n + KV((o - n) / 2), i = Ji(e, a, t, r).offset;
    if (i === l)
      return a;
    i < l ? n = a + 1 : o = a - 1;
  }
  return q0(0, n - 1);
}, Ixe = (e, t, n, o, l) => {
  const r = l === "column" ? e.totalColumn : e.totalRow;
  let a = 1;
  for (; n < r && Ji(e, n, t, l).offset < o; )
    n += a, a *= 2;
  return UV(e, t, KV(n / 2), WV(n, r - 1), o, l);
}, UN = (e, t, n, o) => {
  const [l, r] = [
    t[o],
    t[jx[o]]
  ];
  return (r > 0 ? l[r].offset : 0) >= n ? UV(e, t, 0, r, n, o) : Ixe(e, t, q0(0, r), n, o);
}, GV = ({ totalRow: e }, { estimatedRowHeight: t, lastVisitedRowIndex: n, row: o }) => {
  let l = 0;
  if (n >= e && (n = e - 1), n >= 0) {
    const i = o[n];
    l = i.offset + i.size;
  }
  const a = (e - n - 1) * t;
  return l + a;
}, YV = ({ totalColumn: e }, { column: t, estimatedColumnWidth: n, lastVisitedColumnIndex: o }) => {
  let l = 0;
  if (o > e && (o = e - 1), o >= 0) {
    const i = t[o];
    l = i.offset + i.size;
  }
  const a = (e - o - 1) * n;
  return l + a;
}, Txe = {
  column: YV,
  row: GV
}, GN = (e, t, n, o, l, r, a) => {
  const [i, s] = [
    r === "row" ? e.height : e.width,
    Txe[r]
  ], c = Ji(e, t, l, r), u = s(e, l), d = q0(0, WV(u - i, c.offset)), f = q0(0, c.offset - i + a + c.size);
  switch (n === Y1 && (o >= f - i && o <= d + i ? n = Qr : n = di), n) {
    case bm:
      return d;
    case ym:
      return f;
    case di:
      return Math.round(f + (d - f) / 2);
    case Qr:
    default:
      return o >= f && o <= d ? o : f > d || o < f ? f : d;
  }
}, Pxe = jV({
  name: "ElDynamicSizeGrid",
  getColumnPosition: (e, t, n) => {
    const o = Ji(e, t, n, "column");
    return [o.size, o.offset];
  },
  getRowPosition: (e, t, n) => {
    const o = Ji(e, t, n, "row");
    return [o.size, o.offset];
  },
  getColumnOffset: (e, t, n, o, l, r) => GN(
    e,
    t,
    n,
    o,
    l,
    "column",
    r
  ),
  getRowOffset: (e, t, n, o, l, r) => GN(
    e,
    t,
    n,
    o,
    l,
    "row",
    r
  ),
  getColumnStartIndexForOffset: (e, t, n) => UN(e, n, t, "column"),
  getColumnStopIndexForStartIndex: (e, t, n, o) => {
    const l = Ji(e, t, o, "column"), r = n + e.width;
    let a = l.offset + l.size, i = t;
    for (; i < e.totalColumn - 1 && a < r; )
      i++, a += Ji(e, t, o, "column").size;
    return i;
  },
  getEstimatedTotalHeight: GV,
  getEstimatedTotalWidth: YV,
  getRowStartIndexForOffset: (e, t, n) => UN(e, n, t, "row"),
  getRowStopIndexForStartIndex: (e, t, n, o) => {
    const { totalRow: l, height: r } = e, a = Ji(e, t, o, "row"), i = n + r;
    let s = a.size + a.offset, c = t;
    for (; c < l - 1 && s < i; )
      c++, s += Ji(e, c, o, "row").size;
    return c;
  },
  injectToInstance: (e, t) => {
    const n = ({ columnIndex: r, rowIndex: a }, i) => {
      var s, c;
      i = fn(i) ? !0 : i, mt(r) && (t.value.lastVisitedColumnIndex = Math.min(
        t.value.lastVisitedColumnIndex,
        r - 1
      )), mt(a) && (t.value.lastVisitedRowIndex = Math.min(
        t.value.lastVisitedRowIndex,
        a - 1
      )), (s = e.exposed) == null || s.getItemStyleCache.value(-1, null, null), i && ((c = e.proxy) == null || c.$forceUpdate());
    }, o = (r, a) => {
      n(
        {
          columnIndex: r
        },
        a
      );
    }, l = (r, a) => {
      n(
        {
          rowIndex: r
        },
        a
      );
    };
    Object.assign(e.proxy, {
      resetAfterColumnIndex: o,
      resetAfterRowIndex: l,
      resetAfter: n
    });
  },
  initCache: ({
    estimatedColumnWidth: e = Ex,
    estimatedRowHeight: t = Ex
  }) => ({
    column: {},
    estimatedColumnWidth: e,
    estimatedRowHeight: t,
    lastVisitedColumnIndex: -1,
    lastVisitedRowIndex: -1,
    row: {}
  }),
  clearCache: !1,
  validateProps: ({ columnWidth: e, rowHeight: t }) => {
    process.env.NODE_ENV !== "production" && (it(e) || no(
      KN,
      `
          "columnWidth" must be passed as function,
            instead ${typeof e} was given.
        `
    ), it(t) || no(
      KN,
      `
          "rowHeight" must be passed as function,
            instead ${typeof t} was given.
        `
    ));
  }
}), YN = "ElFixedSizeGrid", kxe = jV({
  name: "ElFixedSizeGrid",
  getColumnPosition: ({ columnWidth: e }, t) => [
    e,
    t * e
  ],
  getRowPosition: ({ rowHeight: e }, t) => [
    e,
    t * e
  ],
  getEstimatedTotalHeight: ({ totalRow: e, rowHeight: t }) => t * e,
  getEstimatedTotalWidth: ({ totalColumn: e, columnWidth: t }) => t * e,
  getColumnOffset: ({ totalColumn: e, columnWidth: t, width: n }, o, l, r, a, i) => {
    n = Number(n);
    const s = Math.max(
      0,
      e * t - n
    ), c = Math.min(
      s,
      o * t
    ), u = Math.max(
      0,
      o * t - n + i + t
    );
    switch (l === "smart" && (r >= u - n && r <= c + n ? l = Qr : l = di), l) {
      case bm:
        return c;
      case ym:
        return u;
      case di: {
        const d = Math.round(u + (c - u) / 2);
        return d < Math.ceil(n / 2) ? 0 : d > s + Math.floor(n / 2) ? s : d;
      }
      case Qr:
      default:
        return r >= u && r <= c ? r : u > c || r < u ? u : c;
    }
  },
  getRowOffset: ({ rowHeight: e, height: t, totalRow: n }, o, l, r, a, i) => {
    t = Number(t);
    const s = Math.max(0, n * e - t), c = Math.min(s, o * e), u = Math.max(
      0,
      o * e - t + i + e
    );
    switch (l === Y1 && (r >= u - t && r <= c + t ? l = Qr : l = di), l) {
      case bm:
        return c;
      case ym:
        return u;
      case di: {
        const d = Math.round(u + (c - u) / 2);
        return d < Math.ceil(t / 2) ? 0 : d > s + Math.floor(t / 2) ? s : d;
      }
      case Qr:
      default:
        return r >= u && r <= c ? r : u > c || r < u ? u : c;
    }
  },
  getColumnStartIndexForOffset: ({ columnWidth: e, totalColumn: t }, n) => Math.max(
    0,
    Math.min(
      t - 1,
      Math.floor(n / e)
    )
  ),
  getColumnStopIndexForStartIndex: ({ columnWidth: e, totalColumn: t, width: n }, o, l) => {
    const r = o * e, a = Math.ceil(
      (n + l - r) / e
    );
    return Math.max(
      0,
      Math.min(t - 1, o + a - 1)
    );
  },
  getRowStartIndexForOffset: ({ rowHeight: e, totalRow: t }, n) => Math.max(
    0,
    Math.min(t - 1, Math.floor(n / e))
  ),
  getRowStopIndexForStartIndex: ({ rowHeight: e, totalRow: t, height: n }, o, l) => {
    const r = o * e, a = Math.ceil(
      (n + l - r) / e
    );
    return Math.max(
      0,
      Math.min(
        t - 1,
        o + a - 1
      )
    );
  },
  initCache: () => {
  },
  clearCache: !0,
  validateProps: ({ columnWidth: e, rowHeight: t }) => {
    process.env.NODE_ENV !== "production" && (mt(e) || no(
      YN,
      `
          "columnWidth" must be passed as number,
            instead ${typeof e} was given.
        `
    ), mt(t) || no(
      YN,
      `
          "columnWidth" must be passed as number,
            instead ${typeof t} was given.
        `
    ));
  }
}), Nxe = "ElTableV2Grid", Mxe = (e) => {
  const t = /* @__PURE__ */ H(), n = /* @__PURE__ */ H(), o = /* @__PURE__ */ H(0), l = O(() => {
    const {
      data: h,
      rowHeight: g,
      estimatedRowHeight: y
    } = e;
    if (!y)
      return h.length * g;
  }), r = O(() => {
    const {
      fixedData: h,
      rowHeight: g
    } = e;
    return ((h == null ? void 0 : h.length) || 0) * g;
  }), a = O(() => Sb(e.headerHeight)), i = O(() => {
    const {
      height: h
    } = e;
    return Math.max(0, h - S(a) - S(r));
  }), s = O(() => S(a) + S(r) > 0), c = ({
    data: h,
    rowIndex: g
  }) => h[g][e.rowKey];
  function u({
    rowCacheStart: h,
    rowCacheEnd: g,
    rowVisibleStart: y,
    rowVisibleEnd: b
  }) {
    var C;
    (C = e.onRowsRendered) == null || C.call(e, {
      rowCacheStart: h,
      rowCacheEnd: g,
      rowVisibleStart: y,
      rowVisibleEnd: b
    });
  }
  function d(h, g) {
    var y;
    (y = n.value) == null || y.resetAfterRowIndex(h, g);
  }
  function f(h, g) {
    const y = S(t), b = S(n);
    Mt(h) ? (y == null || y.scrollToLeft(h.scrollLeft), o.value = h.scrollLeft, b == null || b.scrollTo(h)) : (y == null || y.scrollToLeft(h), o.value = h, b == null || b.scrollTo({
      scrollLeft: h,
      scrollTop: g
    }));
  }
  function p(h) {
    var g;
    (g = S(n)) == null || g.scrollTo({
      scrollTop: h
    });
  }
  function m(h, g) {
    const y = S(n);
    if (!y)
      return;
    const b = o.value;
    y.scrollToItem(h, 0, g), b && f({
      scrollLeft: b
    });
  }
  function v() {
    var h, g;
    (h = S(n)) == null || h.$forceUpdate(), (g = S(t)) == null || g.$forceUpdate();
  }
  return pe(() => e.bodyWidth, () => {
    var h;
    mt(e.estimatedRowHeight) && ((h = n.value) == null || h.resetAfter({
      columnIndex: 0
    }, !1));
  }), {
    bodyRef: n,
    forceUpdate: v,
    fixedRowHeight: r,
    gridHeight: i,
    hasHeader: s,
    headerHeight: a,
    headerRef: t,
    totalHeight: l,
    itemKey: c,
    onItemRendered: u,
    resetAfterRowIndex: d,
    scrollTo: f,
    scrollToTop: p,
    scrollToRow: m,
    scrollLeft: o
  };
}, Axe = /* @__PURE__ */ le({
  name: Nxe,
  props: Cb,
  setup(e, {
    slots: t,
    expose: n
  }) {
    const {
      ns: o
    } = ze(P_), {
      bodyRef: l,
      fixedRowHeight: r,
      gridHeight: a,
      hasHeader: i,
      headerRef: s,
      headerHeight: c,
      totalHeight: u,
      forceUpdate: d,
      itemKey: f,
      onItemRendered: p,
      resetAfterRowIndex: m,
      scrollTo: v,
      scrollToTop: h,
      scrollToRow: g,
      scrollLeft: y
    } = Mxe(e);
    at(FV, y), nd(() => Rt(this, null, function* () {
      var C;
      yield Ke();
      const w = (C = l.value) == null ? void 0 : C.states.scrollTop;
      w && h(Math.round(w) + 1);
    })), n({
      forceUpdate: d,
      totalHeight: u,
      scrollTo: v,
      scrollToTop: h,
      scrollToRow: g,
      resetAfterRowIndex: m
    });
    const b = () => e.bodyWidth;
    return () => {
      const {
        cache: C,
        columns: w,
        data: x,
        fixedData: E,
        useIsScrolling: I,
        scrollbarAlwaysOn: T,
        scrollbarEndGap: P,
        scrollbarStartGap: k,
        style: N,
        rowHeight: R,
        bodyWidth: z,
        estimatedRowHeight: D,
        headerWidth: F,
        height: M,
        width: A,
        getRowHeight: L,
        onScroll: B
      } = e, V = mt(D), j = V ? Pxe : kxe, W = S(c);
      return $("div", {
        role: "table",
        class: [o.e("table"), e.class],
        style: N
      }, [$(j, {
        ref: l,
        data: x,
        useIsScrolling: I,
        itemKey: f,
        columnCache: 0,
        columnWidth: V ? b : z,
        totalColumn: 1,
        totalRow: x.length,
        rowCache: C,
        rowHeight: V ? L : R,
        width: A,
        height: S(a),
        class: o.e("body"),
        role: "rowgroup",
        scrollbarStartGap: k,
        scrollbarEndGap: P,
        scrollbarAlwaysOn: T,
        onScroll: B,
        onItemRendered: p,
        perfMode: !1
      }, {
        default: (Y) => {
          var U;
          const te = x[Y.rowIndex];
          return (U = t.row) == null ? void 0 : U.call(t, vt(Be({}, Y), {
            columns: w,
            rowData: te
          }));
        }
      }), S(i) && $(xxe, {
        ref: s,
        class: o.e("header-wrapper"),
        columns: w,
        headerData: x,
        headerHeight: e.headerHeight,
        fixedHeaderData: E,
        rowWidth: F,
        rowHeight: R,
        width: A,
        height: Math.min(W + S(r), M)
      }, {
        dynamic: t.header,
        fixed: t.row
      })]);
    };
  }
});
var M_ = Axe;
function Rxe(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !dn(e);
}
const Dxe = (e, {
  slots: t
}) => {
  const l = e, {
    mainTableRef: n
  } = l, o = Hr(l, [
    "mainTableRef"
  ]);
  return $(M_, Ut({
    ref: n
  }, o), Rxe(t) ? t : {
    default: () => [t]
  });
};
var Lxe = Dxe;
function Bxe(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !dn(e);
}
const Fxe = (e, {
  slots: t
}) => {
  if (!e.columns.length)
    return;
  const l = e, {
    leftTableRef: n
  } = l, o = Hr(l, [
    "leftTableRef"
  ]);
  return $(M_, Ut({
    ref: n
  }, o), Bxe(t) ? t : {
    default: () => [t]
  });
};
var Vxe = Fxe;
function zxe(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !dn(e);
}
const Hxe = (e, {
  slots: t
}) => {
  if (!e.columns.length)
    return;
  const l = e, {
    rightTableRef: n
  } = l, o = Hr(l, [
    "rightTableRef"
  ]);
  return $(M_, Ut({
    ref: n
  }, o), zxe(t) ? t : {
    default: () => [t]
  });
};
var jxe = Hxe;
const Wxe = (e) => {
  const {
    isScrolling: t
  } = ze(P_), n = /* @__PURE__ */ H(!1), o = /* @__PURE__ */ H(), l = O(() => mt(e.estimatedRowHeight) && e.rowIndex >= 0), r = (s = !1) => {
    const c = S(o);
    if (!c)
      return;
    const {
      columns: u,
      onRowHeightChange: d,
      rowKey: f,
      rowIndex: p,
      style: m
    } = e, {
      height: v
    } = c.getBoundingClientRect();
    n.value = !0, Ke(() => {
      if (s || v !== Number.parseInt(m.height)) {
        const h = u[0], g = (h == null ? void 0 : h.placeholderSign) === $m;
        d == null || d({
          rowKey: f,
          height: v,
          rowIndex: p
        }, h && !g && h.fixed);
      }
    });
  }, a = O(() => {
    const {
      rowData: s,
      rowIndex: c,
      rowKey: u,
      onRowHover: d
    } = e, f = e.rowEventHandlers || {}, p = {};
    return Object.entries(f).forEach(([m, v]) => {
      it(v) && (p[m] = (h) => {
        v({
          event: h,
          rowData: s,
          rowIndex: c,
          rowKey: u
        });
      });
    }), d && [{
      name: "onMouseleave",
      hovered: !1
    }, {
      name: "onMouseenter",
      hovered: !0
    }].forEach(({
      name: m,
      hovered: v
    }) => {
      const h = p[m];
      p[m] = (g) => {
        d({
          event: g,
          hovered: v,
          rowData: s,
          rowIndex: c,
          rowKey: u
        }), h == null || h(g);
      };
    }), p;
  }), i = (s) => {
    const {
      onRowExpand: c,
      rowData: u,
      rowIndex: d,
      rowKey: f
    } = e;
    c == null || c({
      expanded: s,
      rowData: u,
      rowIndex: d,
      rowKey: f
    });
  };
  return nt(() => {
    S(l) && r(!0);
  }), {
    isScrolling: t,
    measurable: l,
    measured: n,
    rowRef: o,
    eventHandlers: a,
    onExpand: i
  };
}, Kxe = "ElTableV2TableRow", Uxe = /* @__PURE__ */ le({
  name: Kxe,
  props: mu,
  setup(e, {
    expose: t,
    slots: n,
    attrs: o
  }) {
    const {
      eventHandlers: l,
      isScrolling: r,
      measurable: a,
      measured: i,
      rowRef: s,
      onExpand: c
    } = Wxe(e);
    return t({
      onExpand: c
    }), () => {
      const {
        columns: u,
        columnsStyles: d,
        expandColumnKey: f,
        depth: p,
        rowData: m,
        rowIndex: v,
        style: h
      } = e;
      let g = u.map((b, C) => {
        const w = We(m.children) && m.children.length > 0 && b.key === f;
        return n.cell({
          column: b,
          columns: u,
          columnIndex: C,
          depth: p,
          style: d[b.key],
          rowData: m,
          rowIndex: v,
          isScrolling: S(r),
          expandIconProps: w ? {
            rowData: m,
            rowIndex: v,
            onExpand: c
          } : void 0
        });
      });
      if (n.row && (g = n.row({
        cells: g.map((b) => We(b) && b.length === 1 ? b[0] : b),
        style: h,
        columns: u,
        depth: p,
        rowData: m,
        rowIndex: v,
        isScrolling: S(r)
      })), S(a)) {
        const y = h || {}, {
          height: b
        } = y, C = Hr(y, [
          "height"
        ]), w = S(i);
        return $("div", Ut({
          ref: s,
          class: e.class,
          style: w ? h : C,
          role: "row"
        }, o, S(l)), [g]);
      }
      return $("div", Ut(o, {
        ref: s,
        class: e.class,
        style: h,
        role: "row"
      }, S(l)), [g]);
    };
  }
});
var Gxe = Uxe;
function Yxe(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !dn(e);
}
const Xxe = (e, {
  slots: t
}) => {
  const {
    columns: n,
    columnsStyles: o,
    depthMap: l,
    expandColumnKey: r,
    expandedRowKeys: a,
    estimatedRowHeight: i,
    hasFixedColumns: s,
    rowData: c,
    rowIndex: u,
    style: d,
    isScrolling: f,
    rowProps: p,
    rowClass: m,
    rowKey: v,
    rowEventHandlers: h,
    ns: g,
    onRowHovered: y,
    onRowExpanded: b
  } = e, C = ju(m, {
    columns: n,
    rowData: c,
    rowIndex: u
  }, ""), w = ju(p, {
    columns: n,
    rowData: c,
    rowIndex: u
  }), x = c[v], E = l[x] || 0, I = !!r, T = u < 0, P = [g.e("row"), C, g.is("expanded", I && a.includes(x)), g.is("fixed", !E && T), g.is("customized", !!t.row), {
    [g.e(`row-depth-${E}`)]: I && u >= 0
  }], k = s ? y : void 0, N = vt(Be({}, w), {
    columns: n,
    columnsStyles: o,
    class: P,
    depth: E,
    expandColumnKey: r,
    estimatedRowHeight: T ? void 0 : i,
    isScrolling: f,
    rowIndex: u,
    rowData: c,
    rowKey: x,
    rowEventHandlers: h,
    style: d
  });
  return $(Gxe, Ut(N, {
    onRowExpand: b,
    onMouseenter: (D) => {
      k == null || k({
        hovered: !0,
        rowKey: x,
        event: D,
        rowData: c,
        rowIndex: u
      });
    },
    onMouseleave: (D) => {
      k == null || k({
        hovered: !1,
        rowKey: x,
        event: D,
        rowData: c,
        rowIndex: u
      });
    },
    rowkey: x
  }), Yxe(t) ? t : {
    default: () => [t]
  });
};
var qxe = Xxe;
const A_ = (e, {
  slots: t
}) => {
  var n;
  const {
    cellData: o,
    style: l
  } = e, r = ((n = o == null ? void 0 : o.toString) == null ? void 0 : n.call(o)) || "", a = Oe(t, "default", e, () => [r]);
  return $("div", {
    class: e.class,
    title: r,
    style: l
  }, [a]);
};
A_.displayName = "ElTableV2Cell";
A_.inheritAttrs = !1;
var Jxe = A_;
const XV = (e) => {
  const {
    expanded: t,
    expandable: n,
    onExpand: o,
    style: l,
    size: r,
    ariaLabel: a
  } = e, i = {
    onClick: n ? () => o(!t) : void 0,
    ariaLabel: a,
    ariaExpanded: t,
    class: e.class
  };
  return $("button", Ut(i, {
    type: "button"
  }), [$(ut, {
    size: r,
    style: l
  }, {
    default: () => [$(Rl, null, null)]
  })]);
};
XV.inheritAttrs = !1;
var Zxe = XV;
const qV = ({
  columns: e,
  column: t,
  columnIndex: n,
  depth: o,
  expandIconProps: l,
  isScrolling: r,
  rowData: a,
  rowIndex: i,
  style: s,
  expandedRowKeys: c,
  ns: u,
  t: d,
  cellProps: f,
  expandColumnKey: p,
  indentSize: m,
  iconSize: v,
  rowKey: h
}, {
  slots: g
}) => {
  const y = tc(s);
  if (t.placeholderSign === $m)
    return $("div", {
      class: u.em("row-cell", "placeholder"),
      style: y
    }, null);
  const {
    cellRenderer: b,
    dataKey: C,
    dataGetter: w
  } = t, x = it(w) ? w({
    columns: e,
    column: t,
    columnIndex: n,
    rowData: a,
    rowIndex: i
  }) : Oo(a, C != null ? C : ""), E = ju(f, {
    cellData: x,
    columns: e,
    column: t,
    columnIndex: n,
    rowIndex: i,
    rowData: a
  }), I = {
    class: u.e("cell-text"),
    columns: e,
    column: t,
    columnIndex: n,
    cellData: x,
    isScrolling: r,
    rowData: a,
    rowIndex: i
  }, T = BV(b), P = T ? T(I) : Oe(g, "default", I, () => [$(Jxe, I, null)]), k = [u.e("row-cell"), t.class, t.align === wm.CENTER && u.is("align-center"), t.align === wm.RIGHT && u.is("align-right")], N = i >= 0 && p && t.key === p, R = i >= 0 && c.includes(a[h]);
  let z;
  const D = `margin-inline-start: ${o * m}px;`;
  return N && (Mt(l) ? z = $(Zxe, Ut(l, {
    class: [u.e("expand-icon"), u.is("expanded", R)],
    size: v,
    expanded: R,
    ariaLabel: d(R ? "el.table.collapseRowLabel" : "el.table.expandRowLabel"),
    style: D,
    expandable: !0
  }), null) : z = $("div", {
    style: [D, `width: ${v}px; height: ${v}px;`].join(" ")
  }, null)), $("div", Ut({
    class: k,
    style: y
  }, E, {
    role: "cell"
  }), [z, P]);
};
qV.inheritAttrs = !1;
var XN = qV;
const Qxe = Xe({
  class: String,
  columns: bh,
  columnsStyles: {
    type: ye(Object),
    required: !0
  },
  headerIndex: Number,
  style: { type: ye(Object) }
}), e2e = /* @__PURE__ */ le({
  name: "ElTableV2HeaderRow",
  props: Qxe,
  setup(e, {
    slots: t
  }) {
    return () => {
      const {
        columns: n,
        columnsStyles: o,
        headerIndex: l,
        style: r
      } = e;
      let a = n.map((i, s) => t.cell({
        columns: n,
        column: i,
        columnIndex: s,
        headerIndex: l,
        style: o[i.key]
      }));
      return t.header && (a = t.header({
        cells: a.map((i) => We(i) && i.length === 1 ? i[0] : i),
        columns: n,
        headerIndex: l
      })), $("div", {
        class: e.class,
        style: r,
        role: "row"
      }, [a]);
    };
  }
});
var t2e = e2e;
function n2e(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !dn(e);
}
const o2e = ({
  columns: e,
  columnsStyles: t,
  headerIndex: n,
  style: o,
  headerClass: l,
  headerProps: r,
  ns: a
}, {
  slots: i
}) => {
  const s = {
    columns: e,
    headerIndex: n
  }, c = [a.e("header-row"), ju(l, s, ""), a.is("customized", !!i.header)], u = vt(Be({}, ju(r, s)), {
    columnsStyles: t,
    class: c,
    columns: e,
    headerIndex: n,
    style: o
  });
  return $(t2e, u, n2e(i) ? i : {
    default: () => [i]
  });
};
var l2e = o2e;
const R_ = (e, {
  slots: t
}) => Oe(t, "default", e, () => {
  var n, o;
  return [$("div", {
    class: e.class,
    title: (n = e.column) == null ? void 0 : n.title
  }, [(o = e.column) == null ? void 0 : o.title])];
});
R_.displayName = "ElTableV2HeaderCell";
R_.inheritAttrs = !1;
var r2e = R_;
const a2e = (e) => {
  const {
    sortOrder: t
  } = e;
  return $("button", {
    type: "button",
    "aria-label": e.ariaLabel,
    class: e.class
  }, [$(ut, {
    size: 14
  }, {
    default: () => [t === vu.ASC ? $(Nse, null, null) : $(Pse, null, null)]
  })]);
};
var i2e = a2e;
const s2e = (e, {
  slots: t
}) => {
  const {
    column: n,
    ns: o,
    t: l,
    style: r,
    onColumnSorted: a
  } = e, i = tc(r);
  if (n.placeholderSign === $m)
    return $("div", {
      class: o.em("header-row-cell", "placeholder"),
      style: i
    }, null);
  const {
    headerCellRenderer: s,
    headerClass: c,
    sortable: u
  } = n, d = vt(Be({}, e), {
    class: o.e("header-cell-text")
  }), f = BV(s), p = f ? f(d) : Oe(t, "default", d, () => [$(r2e, d, null)]), {
    sortBy: m,
    sortState: v,
    headerCellProps: h
  } = e;
  let g, y, b;
  if (v) {
    const x = v[n.key];
    g = !!Hx[x], y = g ? x : vu.ASC;
  } else
    g = n.key === m.key, y = g ? m.order : vu.ASC;
  y === vu.ASC ? b = "ascending" : y === vu.DESC ? b = "descending" : b = void 0;
  const C = [o.e("header-cell"), ju(c, e, ""), n.align === wm.CENTER && o.is("align-center"), n.align === wm.RIGHT && o.is("align-right"), u && o.is("sortable")], w = vt(Be({}, ju(h, e)), {
    onClick: n.sortable ? a : void 0,
    ariaSort: u ? b : void 0,
    class: C,
    style: i,
    "data-key": n.key
  });
  return $("div", Ut(w, {
    role: "columnheader"
  }), [p, u && $(i2e, {
    class: [o.e("sort-icon"), g && o.is("sorting")],
    sortOrder: y,
    ariaLabel: l("el.table.sortLabel", {
      column: n.title || ""
    })
  }, null)]);
};
var qN = s2e;
const JV = (e, {
  slots: t
}) => {
  var n;
  return $("div", {
    class: e.class,
    style: e.style
  }, [(n = t.default) == null ? void 0 : n.call(t)]);
};
JV.displayName = "ElTableV2Footer";
var c2e = JV;
const ZV = (e, {
  slots: t
}) => {
  const n = Oe(t, "default", {}, () => [$(H9, null, null)]);
  return $("div", {
    class: e.class,
    style: e.style
  }, [n]);
};
ZV.displayName = "ElTableV2Empty";
var u2e = ZV;
const QV = (e, {
  slots: t
}) => {
  var n;
  return $("div", {
    class: e.class,
    style: e.style
  }, [(n = t.default) == null ? void 0 : n.call(t)]);
};
QV.displayName = "ElTableV2Overlay";
var d2e = QV;
function nv(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !dn(e);
}
const f2e = "ElTableV2", p2e = /* @__PURE__ */ le({
  name: f2e,
  props: Cxe,
  setup(e, {
    slots: t,
    expose: n
  }) {
    const o = Ve("table-v2"), {
      t: l
    } = an(), {
      columnsStyles: r,
      fixedColumnsOnLeft: a,
      fixedColumnsOnRight: i,
      mainColumns: s,
      mainTableHeight: c,
      fixedTableHeight: u,
      leftTableWidth: d,
      rightTableWidth: f,
      data: p,
      depthMap: m,
      expandedRowKeys: v,
      hasFixedColumns: h,
      mainTableRef: g,
      leftTableRef: y,
      rightTableRef: b,
      isDynamic: C,
      isResetting: w,
      isScrolling: x,
      bodyWidth: E,
      emptyStyle: I,
      rootStyle: T,
      footerHeight: P,
      showEmpty: k,
      scrollTo: N,
      scrollToLeft: R,
      scrollToTop: z,
      scrollToRow: D,
      getRowHeight: F,
      onColumnSorted: M,
      onRowHeightChange: A,
      onRowHovered: L,
      onRowExpanded: B,
      onRowsRendered: V,
      onScroll: j,
      onVerticalScroll: W
    } = yxe(e);
    return n({
      scrollTo: N,
      scrollToLeft: R,
      scrollToTop: z,
      scrollToRow: D
    }), at(P_, {
      ns: o,
      isResetting: w,
      isScrolling: x
    }), () => {
      const {
        cache: Y,
        cellProps: U,
        estimatedRowHeight: te,
        expandColumnKey: J,
        fixedData: re,
        headerHeight: oe,
        headerClass: q,
        headerProps: K,
        headerCellProps: se,
        sortBy: Z,
        sortState: ee,
        rowHeight: fe,
        rowClass: me,
        rowEventHandlers: ge,
        rowKey: he,
        rowProps: $e,
        scrollbarAlwaysOn: ne,
        indentSize: ae,
        iconSize: ce,
        useIsScrolling: xe,
        vScrollbarSize: Te,
        width: Se
      } = e, be = S(p), ie = {
        cache: Y,
        class: o.e("main"),
        columns: S(s),
        data: be,
        fixedData: re,
        estimatedRowHeight: te,
        bodyWidth: S(E),
        headerHeight: oe,
        headerWidth: S(E),
        height: S(c),
        mainTableRef: g,
        rowKey: he,
        rowHeight: fe,
        scrollbarAlwaysOn: ne,
        scrollbarStartGap: 2,
        scrollbarEndGap: Te,
        useIsScrolling: xe,
        width: Se,
        getRowHeight: F,
        onRowsRendered: V,
        onScroll: j
      }, we = S(d), Ne = S(u), tt = {
        cache: Y,
        class: o.e("left"),
        columns: S(a),
        data: be,
        fixedData: re,
        estimatedRowHeight: te,
        leftTableRef: y,
        rowHeight: fe,
        bodyWidth: we,
        headerWidth: we,
        headerHeight: oe,
        height: Ne,
        rowKey: he,
        scrollbarAlwaysOn: ne,
        scrollbarStartGap: 2,
        scrollbarEndGap: Te,
        useIsScrolling: xe,
        width: we,
        getRowHeight: F,
        onScroll: W
      }, Pe = S(f), Re = {
        cache: Y,
        class: o.e("right"),
        columns: S(i),
        data: be,
        fixedData: re,
        estimatedRowHeight: te,
        rightTableRef: b,
        rowHeight: fe,
        bodyWidth: Pe,
        headerWidth: Pe,
        headerHeight: oe,
        height: Ne,
        rowKey: he,
        scrollbarAlwaysOn: ne,
        scrollbarStartGap: 2,
        scrollbarEndGap: Te,
        width: Pe,
        style: `${o.cssVarName("table-scrollbar-size")}: ${Te}px`,
        useIsScrolling: xe,
        getRowHeight: F,
        onScroll: W
      }, Le = S(r), Ue = {
        ns: o,
        depthMap: S(m),
        columnsStyles: Le,
        expandColumnKey: J,
        expandedRowKeys: S(v),
        estimatedRowHeight: te,
        hasFixedColumns: S(h),
        rowProps: $e,
        rowClass: me,
        rowKey: he,
        rowEventHandlers: ge,
        onRowHovered: L,
        onRowExpanded: B,
        onRowHeightChange: A
      }, Ae = {
        cellProps: U,
        expandColumnKey: J,
        indentSize: ae,
        iconSize: ce,
        rowKey: he,
        expandedRowKeys: S(v),
        ns: o,
        t: l
      }, De = {
        ns: o,
        headerClass: q,
        headerProps: K,
        columnsStyles: Le
      }, _e = {
        ns: o,
        t: l,
        sortBy: Z,
        sortState: ee,
        headerCellProps: se,
        onColumnSorted: M
      }, Ze = {
        row: (jt) => $(qxe, Ut(jt, Ue), {
          row: t.row,
          cell: (Qt) => {
            let je;
            return t.cell ? $(XN, Ut(Qt, Ae, {
              style: Le[Qt.column.key]
            }), nv(je = t.cell(Qt)) ? je : {
              default: () => [je]
            }) : $(XN, Ut(Qt, Ae, {
              style: Le[Qt.column.key]
            }), null);
          }
        }),
        header: (jt) => $(l2e, Ut(jt, De), {
          header: t.header,
          cell: (Qt) => {
            let je;
            return t["header-cell"] ? $(qN, Ut(Qt, _e, {
              style: Le[Qt.column.key]
            }), nv(je = t["header-cell"](Qt)) ? je : {
              default: () => [je]
            }) : $(qN, Ut(Qt, _e, {
              style: Le[Qt.column.key]
            }), null);
          }
        })
      }, dt = [e.class, o.b(), o.e("root"), o.is("dynamic", S(C))], Tt = {
        class: o.e("footer"),
        style: S(P)
      };
      return $("div", {
        class: dt,
        style: S(T)
      }, [$(Lxe, ie, nv(Ze) ? Ze : {
        default: () => [Ze]
      }), $(Vxe, tt, nv(Ze) ? Ze : {
        default: () => [Ze]
      }), $(jxe, Re, nv(Ze) ? Ze : {
        default: () => [Ze]
      }), t.footer && $(c2e, Tt, {
        default: t.footer
      }), S(k) && $(u2e, {
        class: o.e("empty"),
        style: S(I)
      }, {
        default: t.empty
      }), t.overlay && $(d2e, {
        class: o.e("overlay")
      }, {
        default: t.overlay
      })]);
    };
  }
});
var v2e = p2e;
const m2e = Xe({
  disableWidth: Boolean,
  disableHeight: Boolean,
  onResize: {
    type: ye(Function)
  }
}), h2e = (e) => {
  const t = /* @__PURE__ */ H(), n = /* @__PURE__ */ H(0), o = /* @__PURE__ */ H(0);
  let l;
  return nt(() => {
    l = Xn(t, ([r]) => {
      const { width: a, height: i } = r.contentRect, { paddingLeft: s, paddingRight: c, paddingTop: u, paddingBottom: d } = getComputedStyle(r.target), f = Number.parseInt(s) || 0, p = Number.parseInt(c) || 0, m = Number.parseInt(u) || 0, v = Number.parseInt(d) || 0;
      n.value = a - f - p, o.value = i - m - v;
    }).stop;
  }), yt(() => {
    l == null || l();
  }), pe([n, o], ([r, a]) => {
    var i;
    (i = e.onResize) == null || i.call(e, {
      width: r,
      height: a
    });
  }), {
    sizer: t,
    width: n,
    height: o
  };
}, g2e = /* @__PURE__ */ le({
  name: "ElAutoResizer",
  props: m2e,
  setup(e, {
    slots: t
  }) {
    const n = Ve("auto-resizer"), {
      height: o,
      width: l,
      sizer: r
    } = h2e(e), a = {
      width: "100%",
      height: "100%"
    };
    return () => {
      var i;
      return $("div", {
        ref: r,
        class: n.b(),
        style: a
      }, [(i = t.default) == null ? void 0 : i.call(t, {
        height: o.value,
        width: l.value
      })]);
    };
  }
});
var b2e = g2e;
const y2e = Dt(v2e), S2e = Dt(b2e), X1 = Symbol("tabsRootContextKey"), C2e = Xe({
  tabs: {
    type: ye(Array),
    default: () => lo([])
  },
  tabRefs: {
    type: ye(Object),
    default: () => lo({})
  }
}), JN = "ElTabBar", w2e = /* @__PURE__ */ le({
  name: JN,
  __name: "tab-bar",
  props: C2e,
  setup(e, { expose: t }) {
    const n = e, o = ze(X1);
    o || no(JN, "<el-tabs><el-tab-bar /></el-tabs>");
    const l = Ve("tabs"), r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H(), i = O(
      () => {
        var p;
        return fn(o.props.defaultValue) || !!((p = a.value) != null && p.transform);
      }
    ), s = () => {
      let p = 0, m = 0;
      const v = ["top", "bottom"].includes(o.props.tabPosition) ? "width" : "height", h = v === "width" ? "x" : "y", g = h === "x" ? "left" : "top";
      return n.tabs.every((y) => {
        if (fn(y.paneName))
          return !1;
        const b = n.tabRefs[y.paneName];
        if (!b)
          return !1;
        if (!y.active)
          return !0;
        p = b[`offset${Gs(g)}`], m = b[`client${Gs(v)}`];
        const C = window.getComputedStyle(b);
        return v === "width" && (m -= Number.parseFloat(C.paddingLeft) + Number.parseFloat(C.paddingRight), p += Number.parseFloat(C.paddingLeft)), !1;
      }), {
        [v]: `${m}px`,
        transform: `translate${Gs(h)}(${p}px)`
      };
    }, c = () => a.value = s(), u = [], d = () => {
      u.forEach((p) => p.stop()), u.length = 0, Object.values(n.tabRefs).forEach((p) => {
        u.push(Xn(p, c));
      });
    };
    pe(
      () => n.tabs,
      () => Rt(this, null, function* () {
        yield Ke(), c(), d();
      }),
      { immediate: !0 }
    );
    const f = Xn(r, () => c());
    return yt(() => {
      u.forEach((p) => p.stop()), u.length = 0, f.stop();
    }), t({
      ref: r,
      update: c
    }), (p, m) => i.value ? (G(), ue(
      "div",
      {
        key: 0,
        ref_key: "barRef",
        ref: r,
        class: X([S(l).e("active-bar"), S(l).is(S(o).props.tabPosition)]),
        style: gt(a.value)
      },
      null,
      6
    )) : Ie("v-if", !0);
  }
});
var $2e = /* @__PURE__ */ Je(w2e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-bar.vue"]]);
const x2e = Xe({
  panes: {
    type: ye(Array),
    default: () => lo([])
  },
  currentName: {
    type: [String, Number],
    default: ""
  },
  editable: Boolean,
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  stretch: Boolean,
  tabindex: {
    type: [String, Number],
    default: void 0
  }
}), E2e = {
  tabClick: (e, t, n) => n instanceof Event,
  tabRemove: (e, t) => t instanceof Event
}, ZN = "ElTabNav", O2e = /* @__PURE__ */ le({
  name: ZN,
  props: x2e,
  emits: E2e,
  setup(e, {
    expose: t,
    emit: n
  }) {
    const o = ze(X1);
    o || no(ZN, "<el-tabs><tab-nav /></el-tabs>");
    const l = Ve("tabs"), r = aie(), a = sie(), i = /* @__PURE__ */ H(), s = /* @__PURE__ */ H(), c = /* @__PURE__ */ H(), u = /* @__PURE__ */ H({}), d = /* @__PURE__ */ H(), f = /* @__PURE__ */ H(!1), p = /* @__PURE__ */ H(0), m = /* @__PURE__ */ H(!1), v = /* @__PURE__ */ H(!0), h = /* @__PURE__ */ Ce(), g = O(() => ["top", "bottom"].includes(o.props.tabPosition)), y = O(() => g.value ? "width" : "height"), b = O(() => ({
      transform: `translate${y.value === "width" ? "X" : "Y"}(-${p.value}px)`
    })), {
      width: C,
      height: w
    } = tx(i), {
      width: x,
      height: E
    } = tx(s, {
      width: 0,
      height: 0
    }, {
      box: "border-box"
    }), I = O(() => g.value ? C.value : w.value), T = O(() => g.value ? x.value : E.value), {
      onWheel: P
    } = oV({
      atStartEdge: O(() => p.value <= 0),
      atEndEdge: O(() => T.value - p.value <= I.value),
      layout: O(() => g.value ? "horizontal" : "vertical")
    }, (B) => {
      p.value = T1(p.value + B, 0, T.value - I.value);
    }), k = () => {
      if (!i.value)
        return;
      const B = i.value[`offset${Gs(y.value)}`], V = p.value;
      if (!V)
        return;
      const j = V > B ? V - B : 0;
      p.value = j;
    }, N = () => {
      if (!i.value || !s.value)
        return;
      const B = s.value[`offset${Gs(y.value)}`], V = i.value[`offset${Gs(y.value)}`], j = p.value;
      if (B - j <= V)
        return;
      const W = B - j > V * 2 ? j + V : B - V;
      p.value = W;
    }, R = () => Rt(this, null, function* () {
      const B = s.value;
      if (!f.value || !c.value || !i.value || !B)
        return;
      yield Ke();
      const V = u.value[e.currentName];
      if (!V)
        return;
      const j = i.value, W = V.getBoundingClientRect(), Y = j.getBoundingClientRect(), U = g.value ? B.offsetWidth - Y.width : B.offsetHeight - Y.height, te = p.value;
      let J = te;
      g.value ? (W.left < Y.left && (J = te - (Y.left - W.left)), W.right > Y.right && (J = te + W.right - Y.right)) : (W.top < Y.top && (J = te - (Y.top - W.top)), W.bottom > Y.bottom && (J = te + (W.bottom - Y.bottom))), J = Math.max(J, 0), p.value = Math.min(J, U);
    }), z = () => {
      var B;
      if (!s.value || !i.value)
        return;
      e.stretch && ((B = d.value) == null || B.update());
      const V = s.value[`offset${Gs(y.value)}`], j = i.value[`offset${Gs(y.value)}`], W = p.value;
      j < V ? (f.value = f.value || {}, f.value.prev = W, f.value.next = W + j < V, V - W < j && (p.value = V - j)) : (f.value = !1, W > 0 && (p.value = 0));
    }, D = (B) => {
      const V = Nn(B);
      let j = 0;
      switch (V) {
        case Ye.left:
        case Ye.up:
          j = -1;
          break;
        case Ye.right:
        case Ye.down:
          j = 1;
          break;
        default:
          return;
      }
      const W = Array.from(B.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
      let U = W.indexOf(B.target) + j;
      U < 0 ? U = W.length - 1 : U >= W.length && (U = 0), W[U].focus({
        preventScroll: !0
      }), W[U].click(), F();
    }, F = () => {
      v.value && (m.value = !0);
    }, M = () => m.value = !1, A = (B, V) => {
      u.value[V] = B;
    }, L = () => Rt(this, null, function* () {
      yield Ke();
      const B = u.value[e.currentName];
      B == null || B.focus({
        preventScroll: !0
      });
    });
    return pe(r, (B) => {
      B === "hidden" ? v.value = !1 : B === "visible" && setTimeout(() => v.value = !0, 50);
    }), pe(a, (B) => {
      B ? setTimeout(() => v.value = !0, 50) : v.value = !1;
    }), Xn(c, () => {
      Ci(z);
    }), nt(() => setTimeout(() => R(), 0)), $o(() => z()), t({
      scrollToActiveTab: R,
      removeFocus: M,
      focusActiveTab: L,
      tabListRef: s,
      tabBarRef: d,
      scheduleRender: () => lf(h)
    }), () => {
      const B = f.value ? [$("span", {
        class: [l.e("nav-prev"), l.is("disabled", !f.value.prev)],
        onClick: k
      }, [$(ut, null, {
        default: () => [$(ms, null, null)]
      })]), $("span", {
        class: [l.e("nav-next"), l.is("disabled", !f.value.next)],
        onClick: N
      }, [$(ut, null, {
        default: () => [$(Rl, null, null)]
      })])] : null, V = e.panes.map((j, W) => {
        var Y, U, te, J, re;
        const oe = j.uid, q = j.props.disabled, K = (U = (Y = j.props.name) != null ? Y : j.index) != null ? U : `${W}`, se = !q && (j.isClosable || j.props.closable !== !1 && e.editable);
        j.index = `${W}`;
        const Z = se ? $(ut, {
          class: "is-icon-close",
          onClick: (me) => n("tabRemove", j, me)
        }, {
          default: () => [$(aa, null, null)]
        }) : null, ee = ((J = (te = j.slots).label) == null ? void 0 : J.call(te)) || j.props.label, fe = !q && j.active ? (re = e.tabindex) != null ? re : o.props.tabindex : -1;
        return $("div", {
          ref: (me) => A(me, K),
          class: [l.e("item"), l.is(o.props.tabPosition), l.is("active", j.active), l.is("disabled", q), l.is("closable", se), l.is("focus", m.value)],
          id: `tab-${K}`,
          key: `tab-${oe}`,
          "aria-controls": `pane-${K}`,
          role: "tab",
          "aria-selected": j.active,
          tabindex: fe,
          onFocus: () => F(),
          onBlur: () => M(),
          onClick: (me) => {
            M(), n("tabClick", j, K, me);
          },
          onKeydown: (me) => {
            const ge = Nn(me);
            se && (ge === Ye.delete || ge === Ye.backspace) && n("tabRemove", j, me);
          }
        }, [ee, Z]);
      });
      return h.value, $("div", {
        ref: c,
        class: [l.e("nav-wrap"), l.is("scrollable", !!f.value), l.is(o.props.tabPosition)]
      }, [B, $("div", {
        class: l.e("nav-scroll"),
        ref: i
      }, [e.panes.length > 0 ? $("div", {
        class: [l.e("nav"), l.is(o.props.tabPosition), l.is("stretch", e.stretch && ["top", "bottom"].includes(o.props.tabPosition))],
        ref: s,
        style: b.value,
        role: "tablist",
        onKeydown: D,
        onWheel: P
      }, [e.type ? null : $($2e, {
        ref: d,
        tabs: [...e.panes],
        tabRefs: u.value
      }, null), V]) : null])]);
    };
  }
}), _2e = Xe({
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  closable: Boolean,
  addable: Boolean,
  modelValue: {
    type: [String, Number]
  },
  defaultValue: {
    type: [String, Number]
  },
  editable: Boolean,
  tabPosition: {
    type: String,
    values: ["top", "right", "bottom", "left"],
    default: "top"
  },
  beforeLeave: {
    type: ye(Function),
    default: () => !0
  },
  stretch: Boolean,
  tabindex: {
    type: [String, Number],
    default: 0
  }
}), aw = (e) => rt(e) || mt(e), I2e = {
  [It]: (e) => aw(e),
  tabClick: (e, t) => t instanceof Event,
  tabChange: (e) => aw(e),
  edit: (e, t) => ["remove", "add"].includes(t),
  tabRemove: (e) => aw(e),
  tabAdd: () => !0
}, T2e = /* @__PURE__ */ le({
  name: "ElTabs",
  props: _2e,
  emits: I2e,
  setup(e, {
    emit: t,
    slots: n,
    expose: o
  }) {
    var l;
    const r = Ve("tabs"), a = O(() => ["left", "right"].includes(e.tabPosition)), {
      children: i,
      addChild: s,
      removeChild: c,
      ChildrenSorter: u
    } = z1(xt(), "ElTabPane"), d = /* @__PURE__ */ H(), f = /* @__PURE__ */ H((l = fn(e.modelValue) ? e.defaultValue : e.modelValue) != null ? l : "0"), p = (b, C = !1) => Rt(this, null, function* () {
      var w, x, E, I;
      if (!(f.value === b || fn(b)))
        try {
          let T;
          if (e.beforeLeave) {
            const P = e.beforeLeave(b, f.value);
            T = P instanceof Promise ? yield P : P;
          } else
            T = !0;
          if (T !== !1) {
            const P = (w = i.value.find((k) => k.paneName === f.value)) == null ? void 0 : w.isFocusInsidePane();
            f.value = b, C && (t(It, b), t("tabChange", b)), (E = (x = d.value) == null ? void 0 : x.removeFocus) == null || E.call(x), P && ((I = d.value) == null || I.focusActiveTab());
          }
        } catch (T) {
        }
    }), m = (b, C, w) => {
      b.props.disabled || (t("tabClick", b, w), p(C, !0));
    }, v = (b, C) => {
      b.props.disabled || fn(b.props.name) || (C.stopPropagation(), t("edit", b.props.name, "remove"), t("tabRemove", b.props.name));
    }, h = () => {
      t("edit", void 0, "add"), t("tabAdd");
    }, g = (b) => {
      const C = Nn(b);
      [Ye.enter, Ye.numpadEnter].includes(C) && h();
    }, y = (b) => {
      const C = b.el.firstChild, w = ["bottom", "right"].includes(e.tabPosition) ? b.children[0].el : b.children[1].el;
      C !== w && C.before(w);
    };
    return pe(() => e.modelValue, (b) => p(b)), pe(f, () => Rt(this, null, function* () {
      var b;
      yield Ke(), (b = d.value) == null || b.scrollToActiveTab();
    })), at(X1, {
      props: e,
      currentName: f,
      registerPane: s,
      unregisterPane: c,
      nav$: d
    }), o({
      currentName: f,
      get tabNavRef() {
        return Cp(d.value, ["scheduleRender"]);
      }
    }), () => {
      const b = n["add-icon"], C = e.editable || e.addable ? $("div", {
        class: [r.e("new-tab"), a.value && r.e("new-tab-vertical")],
        tabindex: e.tabindex,
        onClick: h,
        onKeydown: g
      }, [b ? Oe(n, "add-icon") : $(ut, {
        class: r.is("icon-plus")
      }, {
        default: () => [$(E7, null, null)]
      })]) : null, w = () => $(O2e, {
        ref: d,
        currentName: f.value,
        editable: e.editable,
        type: e.type,
        panes: i.value,
        stretch: e.stretch,
        onTabClick: m,
        onTabRemove: v
      }, null), x = $("div", {
        class: [r.e("header"), a.value && r.e("header-vertical"), r.is(e.tabPosition)]
      }, [$(u, null, {
        default: w,
        $stable: !0
      }), C]), E = $("div", {
        class: r.e("content")
      }, [Oe(n, "default")]);
      return $("div", {
        class: [r.b(), r.m(e.tabPosition), {
          [r.m("card")]: e.type === "card",
          [r.m("border-card")]: e.type === "border-card"
        }],
        onVnodeMounted: y,
        onVnodeUpdated: y
      }, [E, x]);
    };
  }
}), P2e = Xe({
  label: {
    type: String,
    default: ""
  },
  name: {
    type: [String, Number]
  },
  closable: {
    type: Boolean,
    default: void 0
  },
  disabled: Boolean,
  lazy: Boolean
}), k2e = ["id", "aria-hidden", "aria-labelledby"], QN = "ElTabPane", N2e = /* @__PURE__ */ le({
  name: QN,
  __name: "tab-pane",
  props: P2e,
  setup(e) {
    const t = e, n = xt(), o = So(), l = ze(X1);
    l || no(QN, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
    const r = Ve("tab-pane"), a = /* @__PURE__ */ H(), i = /* @__PURE__ */ H(), s = O(() => {
      var v;
      return (v = t.closable) != null ? v : l.props.closable;
    }), c = O(
      () => {
        var v;
        return l.currentName.value === ((v = t.name) != null ? v : i.value);
      }
    ), u = /* @__PURE__ */ H(c.value), d = O(() => {
      var v;
      return (v = t.name) != null ? v : i.value;
    }), f = O(
      () => !t.lazy || u.value || c.value
    ), p = () => {
      var v;
      return (v = a.value) == null ? void 0 : v.contains(document.activeElement);
    };
    pe(c, (v) => {
      v && (u.value = !0);
    });
    const m = /* @__PURE__ */ kt({
      uid: n.uid,
      getVnode: () => n.vnode,
      slots: o,
      props: t,
      paneName: d,
      active: c,
      index: i,
      isClosable: s,
      isFocusInsidePane: p
    });
    return l.registerPane(m), yt(() => {
      l.unregisterPane(m);
    }), vp(() => {
      var v;
      o.label && ((v = l.nav$.value) == null || v.scheduleRender());
    }), (v, h) => f.value ? _t((G(), ue("div", {
      key: 0,
      id: `pane-${d.value}`,
      ref_key: "paneRef",
      ref: a,
      class: X(S(r).b()),
      role: "tabpanel",
      "aria-hidden": !c.value,
      "aria-labelledby": `tab-${d.value}`
    }, [
      Oe(v.$slots, "default")
    ], 10, k2e)), [
      [Jt, c.value]
    ]) : Ie("v-if", !0);
  }
});
var ez = /* @__PURE__ */ Je(N2e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-pane.vue"]]);
const M2e = Dt(T2e, {
  TabPane: ez
}), A2e = oo(ez), R2e = Xe({
  type: {
    type: String,
    values: ["primary", "success", "info", "warning", "danger", ""],
    default: ""
  },
  size: {
    type: String,
    values: ki,
    default: ""
  },
  truncated: Boolean,
  lineClamp: {
    type: [String, Number]
  },
  tag: {
    type: String,
    default: "span"
  }
}), D2e = /* @__PURE__ */ le({
  name: "ElText",
  __name: "text",
  props: R2e,
  setup(e) {
    const t = e, n = /* @__PURE__ */ H(), o = Mo(), l = Ve("text"), r = O(() => [
      l.b(),
      l.m(t.type),
      l.m(o.value),
      l.is("truncated", t.truncated),
      l.is("line-clamp", !fn(t.lineClamp))
    ]), a = () => {
      var i, s, c, u, d, f, p;
      if (Ti().title)
        return;
      let v = !1;
      const h = ((i = n.value) == null ? void 0 : i.textContent) || "";
      if (t.truncated) {
        const g = (s = n.value) == null ? void 0 : s.offsetWidth, y = (c = n.value) == null ? void 0 : c.scrollWidth;
        g && y && y > g && (v = !0);
      } else if (!fn(t.lineClamp)) {
        const g = (u = n.value) == null ? void 0 : u.offsetHeight, y = (d = n.value) == null ? void 0 : d.scrollHeight;
        g && y && y > g && (v = !0);
      }
      v ? (f = n.value) == null || f.setAttribute("title", h) : (p = n.value) == null || p.removeAttribute("title");
    };
    return nt(a), $o(a), (i, s) => (G(), Me(Ht(i.tag), {
      ref_key: "textRef",
      ref: n,
      class: X(r.value),
      style: gt({ "-webkit-line-clamp": i.lineClamp })
    }, {
      default: Ee(() => [
        Oe(i.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "style"]));
  }
});
var L2e = /* @__PURE__ */ Je(D2e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/text/src/text.vue"]]);
const D_ = Dt(L2e), B2e = Xe(Be({
  format: {
    type: String,
    default: "HH:mm"
  },
  modelValue: {
    type: ye(String)
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  editable: {
    type: Boolean,
    default: !0
  },
  effect: {
    type: ye(String),
    default: "light"
  },
  clearable: {
    type: Boolean,
    default: !0
  },
  size: Bo,
  placeholder: String,
  start: {
    type: String,
    default: "09:00"
  },
  end: {
    type: String,
    default: "18:00"
  },
  step: {
    type: String,
    default: "00:30"
  },
  minTime: {
    type: ye(String)
  },
  maxTime: {
    type: ye(String)
  },
  includeEndTime: Boolean,
  name: String,
  prefixIcon: {
    type: ye([String, Object]),
    default: () => x7
  },
  clearIcon: {
    type: ye([String, Object]),
    default: () => Es
  },
  popperClass: {
    type: String,
    default: ""
  },
  popperStyle: {
    type: ye([String, Object])
  }
}, ad)), ns = (e) => {
  const t = (e || "").split(":");
  if (t.length >= 2) {
    let n = Number.parseInt(t[0], 10);
    const o = Number.parseInt(t[1], 10), l = e.toUpperCase();
    return l.includes("AM") && n === 12 ? n = 0 : l.includes("PM") && n !== 12 && (n += 12), {
      hours: n,
      minutes: o
    };
  }
  return null;
}, iw = (e, t) => {
  const n = ns(e);
  if (!n)
    return -1;
  const o = ns(t);
  if (!o)
    return -1;
  const l = n.minutes + n.hours * 60, r = o.minutes + o.hours * 60;
  return l === r ? 0 : l > r ? 1 : -1;
}, eM = (e) => `${e}`.padStart(2, "0"), Hd = (e) => `${eM(e.hours)}:${eM(e.minutes)}`, F2e = (e, t) => {
  const n = ns(e);
  if (!n)
    return "";
  const o = ns(t);
  if (!o)
    return "";
  const l = {
    hours: n.hours,
    minutes: n.minutes
  };
  return l.minutes += o.minutes, l.hours += o.hours, l.hours += Math.floor(l.minutes / 60), l.minutes = l.minutes % 60, Hd(l);
}, V2e = /* @__PURE__ */ le({
  name: "ElTimeSelect",
  __name: "time-select",
  props: B2e,
  emits: [en, "blur", "focus", "clear", It],
  setup(e, { expose: t }) {
    wt.extend(W1);
    const { Option: n } = wc, o = e, l = Ve("input"), r = /* @__PURE__ */ H(), a = io(), { lang: i } = an(), s = O(() => o.modelValue), c = O(() => {
      const g = ns(o.start);
      return g ? Hd(g) : null;
    }), u = O(() => {
      const g = ns(o.end);
      return g ? Hd(g) : null;
    }), d = O(() => {
      const g = ns(o.step);
      return g ? Hd(g) : null;
    }), f = O(() => {
      const g = ns(o.minTime || "");
      return g ? Hd(g) : null;
    }), p = O(() => {
      const g = ns(o.maxTime || "");
      return g ? Hd(g) : null;
    }), m = O(() => {
      var g;
      const y = [], b = (C, w) => {
        y.push({
          value: C,
          disabled: iw(w, f.value || "-1:-1") <= 0 || iw(w, p.value || "100:100") >= 0
        });
      };
      if (o.start && o.end && o.step) {
        let C = c.value, w;
        for (; C && u.value && iw(C, u.value) <= 0; )
          w = wt(C, "HH:mm").locale(i.value).format(o.format), b(w, C), C = F2e(C, d.value);
        if (o.includeEndTime && u.value && ((g = y[y.length - 1]) == null ? void 0 : g.value) !== u.value) {
          const x = wt(u.value, "HH:mm").locale(i.value).format(o.format);
          b(x, u.value);
        }
      }
      return y;
    });
    return t({
      blur: () => {
        var g, y;
        (y = (g = r.value) == null ? void 0 : g.blur) == null || y.call(g);
      },
      focus: () => {
        var g, y;
        (y = (g = r.value) == null ? void 0 : g.focus) == null || y.call(g);
      }
    }), (g, y) => (G(), Me(S(wc), {
      ref_key: "select",
      ref: r,
      "model-value": s.value,
      disabled: S(a),
      clearable: g.clearable,
      "clear-icon": g.clearIcon,
      size: g.size,
      effect: g.effect,
      placeholder: g.placeholder,
      "default-first-option": "",
      filterable: g.editable,
      "empty-values": g.emptyValues,
      "value-on-clear": g.valueOnClear,
      "popper-class": g.popperClass,
      "popper-style": g.popperStyle,
      "onUpdate:modelValue": y[0] || (y[0] = (b) => g.$emit(S(It), b)),
      onChange: y[1] || (y[1] = (b) => g.$emit(S(en), b)),
      onBlur: y[2] || (y[2] = (b) => g.$emit("blur", b)),
      onFocus: y[3] || (y[3] = (b) => g.$emit("focus", b)),
      onClear: y[4] || (y[4] = () => g.$emit("clear"))
    }, {
      prefix: Ee(() => [
        g.prefixIcon ? (G(), Me(S(ut), {
          key: 0,
          class: X(S(l).e("prefix-icon"))
        }, {
          default: Ee(() => [
            (G(), Me(Ht(g.prefixIcon)))
          ]),
          _: 1
        }, 8, ["class"])) : Ie("v-if", !0)
      ]),
      default: Ee(() => [
        (G(!0), ue(
          Ge,
          null,
          on(m.value, (b) => (G(), Me(S(n), {
            key: b.value,
            label: b.value,
            value: b.value,
            disabled: b.disabled
          }, null, 8, ["label", "value", "disabled"]))),
          128
        ))
      ]),
      _: 1
    }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable", "empty-values", "value-on-clear", "popper-class", "popper-style"]));
  }
});
var z2e = /* @__PURE__ */ Je(V2e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-select/src/time-select.vue"]]);
const H2e = Dt(z2e), tz = "timeline", j2e = Xe({
  mode: {
    type: String,
    values: ["start", "alternate", "alternate-reverse", "end"],
    default: "start"
  },
  reverse: Boolean
}), W2e = /* @__PURE__ */ le({
  name: "ElTimeline",
  props: j2e,
  setup(e, { slots: t }) {
    const n = Ve("timeline");
    at(tz, { props: e, slots: t });
    const o = O(() => [n.b(), n.is(e.mode)]);
    return () => {
      var l, r;
      const a = Nr(
        (r = (l = t.default) == null ? void 0 : l.call(t)) != null ? r : []
      );
      return ht(
        "ul",
        { class: o.value },
        e.reverse ? a.reverse() : a
      );
    };
  }
}), K2e = Xe({
  timestamp: {
    type: String,
    default: ""
  },
  hideTimestamp: Boolean,
  center: Boolean,
  placement: {
    type: String,
    values: ["top", "bottom"],
    default: "bottom"
  },
  type: {
    type: String,
    values: ["primary", "success", "warning", "danger", "info"],
    default: ""
  },
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: ["normal", "large"],
    default: "normal"
  },
  icon: {
    type: Pn
  },
  hollow: Boolean
}), U2e = /* @__PURE__ */ le({
  name: "ElTimelineItem",
  __name: "timeline-item",
  props: K2e,
  setup(e) {
    const t = e, { props: n } = ze(
      tz
    ), o = Ve("timeline-item"), l = O(() => [
      o.e("node"),
      o.em("node", t.size || ""),
      o.em("node", t.type || ""),
      o.is("hollow", t.hollow)
    ]), r = O(() => [
      o.b(),
      { [o.e("center")]: t.center },
      o.is(n.mode)
    ]);
    return (a, i) => (G(), ue(
      "li",
      {
        class: X(r.value)
      },
      [
        ve(
          "div",
          {
            class: X(S(o).e("tail"))
          },
          null,
          2
        ),
        a.$slots.dot ? Ie("v-if", !0) : (G(), ue(
          "div",
          {
            key: 0,
            class: X(l.value),
            style: gt({
              backgroundColor: a.color
            })
          },
          [
            a.icon ? (G(), Me(S(ut), {
              key: 0,
              class: X(S(o).e("icon"))
            }, {
              default: Ee(() => [
                (G(), Me(Ht(a.icon)))
              ]),
              _: 1
            }, 8, ["class"])) : Ie("v-if", !0)
          ],
          6
        )),
        a.$slots.dot ? (G(), ue(
          "div",
          {
            key: 1,
            class: X(S(o).e("dot"))
          },
          [
            Oe(a.$slots, "dot")
          ],
          2
        )) : Ie("v-if", !0),
        ve(
          "div",
          {
            class: X(S(o).e("wrapper"))
          },
          [
            !a.hideTimestamp && a.placement === "top" ? (G(), ue(
              "div",
              {
                key: 0,
                class: X([S(o).e("timestamp"), S(o).is("top")])
              },
              qe(a.timestamp),
              3
            )) : Ie("v-if", !0),
            ve(
              "div",
              {
                class: X(S(o).e("content"))
              },
              [
                Oe(a.$slots, "default")
              ],
              2
            ),
            !a.hideTimestamp && a.placement === "bottom" ? (G(), ue(
              "div",
              {
                key: 1,
                class: X([S(o).e("timestamp"), S(o).is("bottom")])
              },
              qe(a.timestamp),
              3
            )) : Ie("v-if", !0)
          ],
          2
        )
      ],
      2
    ));
  }
});
var nz = /* @__PURE__ */ Je(U2e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/timeline/src/timeline-item.vue"]]);
const G2e = Dt(W2e, {
  TimelineItem: nz
}), Y2e = oo(nz), oz = "left-check-change", lz = "right-check-change", jd = Xe({
  data: {
    type: ye(Array),
    default: () => []
  },
  titles: {
    type: ye(Array),
    default: () => []
  },
  buttonTexts: {
    type: ye(Array),
    default: () => []
  },
  filterPlaceholder: String,
  filterMethod: {
    type: ye(
      Function
    )
  },
  leftDefaultChecked: {
    type: ye(Array),
    default: () => []
  },
  rightDefaultChecked: {
    type: ye(Array),
    default: () => []
  },
  renderContent: {
    type: ye(Function)
  },
  modelValue: {
    type: ye(Array),
    default: () => []
  },
  format: {
    type: ye(Object),
    default: () => ({})
  },
  filterable: Boolean,
  props: {
    type: ye(Object),
    default: () => lo({
      label: "label",
      key: "key",
      disabled: "disabled"
    })
  },
  targetOrder: {
    type: String,
    values: ["original", "push", "unshift"],
    default: "original"
  },
  validateEvent: {
    type: Boolean,
    default: !0
  }
}), Wx = (e, t) => [e, t].every(We) || We(e) && wo(t), X2e = {
  [en]: (e, t, n) => [e, n].every(We) && ["left", "right"].includes(t),
  [It]: (e) => We(e),
  [oz]: Wx,
  [lz]: Wx
}, Kx = "checked-change", q2e = Xe({
  data: jd.data,
  optionRender: {
    type: ye(
      Function
    )
  },
  placeholder: String,
  title: String,
  filterable: Boolean,
  format: jd.format,
  filterMethod: jd.filterMethod,
  defaultChecked: jd.leftDefaultChecked,
  props: jd.props
}), J2e = {
  [Kx]: Wx
}, yh = (e) => {
  const t = {
    label: "label",
    key: "key",
    disabled: "disabled"
  };
  return O(() => Be(Be({}, t), e.props));
}, Z2e = (e, t, n) => {
  const o = yh(e), l = O(() => e.data.filter((u) => it(e.filterMethod) ? e.filterMethod(t.query, u) : String(
    u[o.value.label] || u[o.value.key]
  ).toLowerCase().includes(t.query.toLowerCase()))), r = O(
    () => l.value.filter((u) => !u[o.value.disabled])
  ), a = O(() => {
    const u = t.checked.length, d = e.data.length, { noChecked: f, hasChecked: p } = e.format;
    return f && p ? u > 0 ? p.replace(/\${checked}/g, u.toString()).replace(/\${total}/g, d.toString()) : f.replace(/\${total}/g, d.toString()) : `${u}/${d}`;
  }), i = O(() => {
    const u = t.checked.length;
    return u > 0 && u < r.value.length;
  }), s = () => {
    const u = r.value.map(
      (d) => d[o.value.key]
    );
    t.allChecked = u.length > 0 && u.every((d) => t.checked.includes(d));
  }, c = (u) => {
    t.checked = u ? r.value.map((d) => d[o.value.key]) : [];
  };
  return pe(
    () => t.checked,
    (u, d) => {
      if (s(), t.checkChangeByUser) {
        const f = u.concat(d).filter((p) => !u.includes(p) || !d.includes(p));
        n(Kx, u, f);
      } else
        n(Kx, u), t.checkChangeByUser = !0;
    }
  ), pe(r, () => {
    s();
  }), pe(
    () => e.data,
    () => {
      const u = [], d = l.value.map(
        (f) => f[o.value.key]
      );
      t.checked.forEach((f) => {
        d.includes(f) && u.push(f);
      }), t.checkChangeByUser = !1, t.checked = u;
    }
  ), pe(
    () => e.defaultChecked,
    (u, d) => {
      if (d && u.length === d.length && u.every((m) => d.includes(m)))
        return;
      const f = [], p = r.value.map(
        (m) => m[o.value.key]
      );
      u.forEach((m) => {
        p.includes(m) && f.push(m);
      }), t.checkChangeByUser = !1, t.checked = f;
    },
    {
      immediate: !0
    }
  ), {
    filteredData: l,
    checkableData: r,
    checkedSummary: a,
    isIndeterminate: i,
    updateAllChecked: s,
    handleAllCheckedChange: c
  };
}, Q2e = /* @__PURE__ */ le({
  name: "ElTransferPanel",
  __name: "transfer-panel",
  props: q2e,
  emits: J2e,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = So(), a = ({ option: C }) => C, { t: i } = an(), s = Ve("transfer"), c = /* @__PURE__ */ kt({
      checked: [],
      allChecked: !1,
      query: "",
      checkChangeByUser: !0
    }), u = yh(o), {
      filteredData: d,
      checkedSummary: f,
      isIndeterminate: p,
      handleAllCheckedChange: m
    } = Z2e(o, c, l), v = O(
      () => !Ql(c.query) && Ql(d.value)
    ), h = O(() => !Ql(r.default()[0].children)), { checked: g, allChecked: y, query: b } = /* @__PURE__ */ to(c);
    return t({
      query: b
    }), (C, w) => (G(), ue(
      "div",
      {
        class: X(S(s).b("panel"))
      },
      [
        ve(
          "p",
          {
            class: X(S(s).be("panel", "header"))
          },
          [
            $(S(Fa), {
              modelValue: S(y),
              "onUpdate:modelValue": w[0] || (w[0] = (x) => /* @__PURE__ */ kn(y) ? y.value = x : null),
              indeterminate: S(p),
              "validate-event": !1,
              onChange: S(m)
            }, {
              default: Ee(() => [
                Ft(
                  qe(C.title) + " ",
                  1
                ),
                ve(
                  "span",
                  null,
                  qe(S(f)),
                  1
                )
              ]),
              _: 1
            }, 8, ["modelValue", "indeterminate", "onChange"])
          ],
          2
        ),
        ve(
          "div",
          {
            class: X([S(s).be("panel", "body"), S(s).is("with-footer", h.value)])
          },
          [
            C.filterable ? (G(), Me(S(Nl), {
              key: 0,
              modelValue: S(b),
              "onUpdate:modelValue": w[1] || (w[1] = (x) => /* @__PURE__ */ kn(b) ? b.value = x : null),
              class: X(S(s).be("panel", "filter")),
              size: "default",
              placeholder: C.placeholder,
              "prefix-icon": S(Ise),
              clearable: "",
              "validate-event": !1
            }, null, 8, ["modelValue", "class", "placeholder", "prefix-icon"])) : Ie("v-if", !0),
            _t($(S(o_), {
              modelValue: S(g),
              "onUpdate:modelValue": w[2] || (w[2] = (x) => /* @__PURE__ */ kn(g) ? g.value = x : null),
              "validate-event": !1,
              class: X([S(s).is("filterable", C.filterable), S(s).be("panel", "list")])
            }, {
              default: Ee(() => [
                (G(!0), ue(
                  Ge,
                  null,
                  on(S(d), (x) => (G(), Me(S(Fa), {
                    key: x[S(u).key],
                    class: X(S(s).be("panel", "item")),
                    value: x[S(u).key],
                    disabled: x[S(u).disabled],
                    "validate-event": !1
                  }, {
                    default: Ee(() => {
                      var E;
                      return [
                        $(a, {
                          option: (E = C.optionRender) == null ? void 0 : E.call(C, x)
                        }, null, 8, ["option"])
                      ];
                    }),
                    _: 2
                  }, 1032, ["class", "value", "disabled"]))),
                  128
                ))
              ]),
              _: 1
            }, 8, ["modelValue", "class"]), [
              [Jt, !v.value && !S(Ql)(C.data)]
            ]),
            _t(ve(
              "div",
              {
                class: X(S(s).be("panel", "empty"))
              },
              [
                Oe(C.$slots, "empty", {}, () => [
                  Ft(
                    qe(v.value ? S(i)("el.transfer.noMatch") : S(i)("el.transfer.noData")),
                    1
                  )
                ])
              ],
              2
            ), [
              [Jt, v.value || S(Ql)(C.data)]
            ])
          ],
          2
        ),
        h.value ? (G(), ue(
          "p",
          {
            key: 0,
            class: X(S(s).be("panel", "footer"))
          },
          [
            Oe(C.$slots, "default")
          ],
          2
        )) : Ie("v-if", !0)
      ],
      2
    ));
  }
});
var tM = /* @__PURE__ */ Je(Q2e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer-panel.vue"]]);
const eEe = (e) => {
  const t = yh(e), n = O(
    () => e.data.reduce((r, a) => (r[a[t.value.key]] = a) && r, {})
  ), o = O(
    () => e.data.filter(
      (r) => !e.modelValue.includes(r[t.value.key])
    )
  ), l = O(() => e.targetOrder === "original" ? e.data.filter(
    (r) => e.modelValue.includes(r[t.value.key])
  ) : e.modelValue.reduce(
    (r, a) => {
      const i = n.value[a];
      return i && r.push(i), r;
    },
    []
  ));
  return {
    sourceData: o,
    targetData: l
  };
}, tEe = (e, t, n) => {
  const o = yh(e), l = (i, s, c) => {
    n(It, i), n(en, i, s, c);
  };
  return {
    addToLeft: () => {
      const i = e.modelValue.slice();
      t.rightChecked.forEach((s) => {
        const c = i.indexOf(s);
        c > -1 && i.splice(c, 1);
      }), l(i, "left", t.rightChecked);
    },
    addToRight: () => {
      let i = e.modelValue.slice();
      const s = e.data.filter((c) => {
        const u = c[o.value.key];
        return t.leftChecked.includes(u) && !e.modelValue.includes(u);
      }).map((c) => c[o.value.key]);
      i = e.targetOrder === "unshift" ? s.concat(i) : i.concat(s), e.targetOrder === "original" && (i = e.data.filter((c) => i.includes(c[o.value.key])).map((c) => c[o.value.key])), l(i, "right", t.leftChecked);
    }
  };
}, nEe = (e, t) => ({
  onSourceCheckedChange: (l, r) => {
    e.leftChecked = l, r && t(oz, l, r);
  },
  onTargetCheckedChange: (l, r) => {
    e.rightChecked = l, r && t(lz, l, r);
  }
}), oEe = { key: 0 }, lEe = { key: 0 }, rEe = /* @__PURE__ */ le({
  name: "ElTransfer",
  __name: "transfer",
  props: jd,
  emits: X2e,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = So(), { t: a } = an(), i = Ve("transfer"), { formItem: s } = cl(), c = /* @__PURE__ */ kt({
      leftChecked: [],
      rightChecked: []
    }), u = yh(o), { sourceData: d, targetData: f } = eEe(o), { onSourceCheckedChange: p, onTargetCheckedChange: m } = nEe(
      c,
      l
    ), { addToLeft: v, addToRight: h } = tEe(o, c, l), g = /* @__PURE__ */ H(), y = /* @__PURE__ */ H(), b = (T) => {
      switch (T) {
        case "left":
          g.value.query = "";
          break;
        case "right":
          y.value.query = "";
          break;
      }
    }, C = O(() => o.buttonTexts.length === 2), w = O(
      () => o.titles[0] || a("el.transfer.titles.0")
    ), x = O(
      () => o.titles[1] || a("el.transfer.titles.1")
    ), E = O(
      () => o.filterPlaceholder || a("el.transfer.filterPlaceholder")
    );
    pe(
      () => o.modelValue,
      () => {
        var T;
        o.validateEvent && ((T = s == null ? void 0 : s.validate) == null || T.call(s, "change").catch((P) => Gt(P)));
      }
    );
    const I = O(() => (T) => {
      var P;
      if (o.renderContent)
        return o.renderContent(ht, T);
      const k = (((P = r.default) == null ? void 0 : P.call(r, { option: T })) || []).filter(
        (N) => N.type !== qn
      );
      return k.length ? k : ht(
        "span",
        T[u.value.label] || T[u.value.key]
      );
    });
    return t({
      clearQuery: b,
      leftPanel: g,
      rightPanel: y
    }), (T, P) => (G(), ue(
      "div",
      {
        class: X(S(i).b())
      },
      [
        $(tM, {
          ref_key: "leftPanel",
          ref: g,
          data: S(d),
          "option-render": I.value,
          placeholder: E.value,
          title: w.value,
          filterable: T.filterable,
          format: T.format,
          "filter-method": T.filterMethod,
          "default-checked": T.leftDefaultChecked,
          props: o.props,
          onCheckedChange: S(p)
        }, {
          empty: Ee(() => [
            Oe(T.$slots, "left-empty")
          ]),
          default: Ee(() => [
            Oe(T.$slots, "left-footer")
          ]),
          _: 3
        }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
        ve(
          "div",
          {
            class: X(S(i).e("buttons"))
          },
          [
            $(S(Qo), {
              type: "primary",
              class: X([S(i).e("button"), S(i).is("with-texts", C.value)]),
              disabled: S(Ql)(c.rightChecked),
              onClick: S(v)
            }, {
              default: Ee(() => [
                $(S(ut), null, {
                  default: Ee(() => [
                    $(S(ms))
                  ]),
                  _: 1
                }),
                S(fn)(T.buttonTexts[0]) ? Ie("v-if", !0) : (G(), ue(
                  "span",
                  oEe,
                  qe(T.buttonTexts[0]),
                  1
                ))
              ]),
              _: 1
            }, 8, ["class", "disabled", "onClick"]),
            $(S(Qo), {
              type: "primary",
              class: X([S(i).e("button"), S(i).is("with-texts", C.value)]),
              disabled: S(Ql)(c.leftChecked),
              onClick: S(h)
            }, {
              default: Ee(() => [
                S(fn)(T.buttonTexts[1]) ? Ie("v-if", !0) : (G(), ue(
                  "span",
                  lEe,
                  qe(T.buttonTexts[1]),
                  1
                )),
                $(S(ut), null, {
                  default: Ee(() => [
                    $(S(Rl))
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["class", "disabled", "onClick"])
          ],
          2
        ),
        $(tM, {
          ref_key: "rightPanel",
          ref: y,
          data: S(f),
          "option-render": I.value,
          placeholder: E.value,
          filterable: T.filterable,
          format: T.format,
          "filter-method": T.filterMethod,
          title: x.value,
          "default-checked": T.rightDefaultChecked,
          props: o.props,
          onCheckedChange: S(m)
        }, {
          empty: Ee(() => [
            Oe(T.$slots, "right-empty")
          ]),
          default: Ee(() => [
            Oe(T.$slots, "right-footer")
          ]),
          _: 3
        }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
      ],
      2
    ));
  }
});
var aEe = /* @__PURE__ */ Je(rEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/transfer/src/transfer.vue"]]);
const iEe = Dt(aEe), mf = "$treeNodeId", nM = function(e, t) {
  !t || t[mf] || Object.defineProperty(t, mf, {
    value: e.id,
    enumerable: !1,
    configurable: !1,
    writable: !1
  });
}, L_ = (e, t) => t == null ? void 0 : t[e || mf], Ux = (e, t, n) => {
  const o = e.value.currentNode;
  n();
  const l = e.value.currentNode;
  o !== l && t("current-change", l ? l.data : null, l);
}, rz = (e) => {
  let t = !0, n = !0, o = !0, l = !0;
  for (let r = 0, a = e.length; r < a; r++) {
    const i = e[r];
    (i.checked !== !0 || i.indeterminate) && (t = !1, i.disabled || (o = !1)), (i.checked !== !1 || i.indeterminate) && (n = !1), i.isEffectivelyChecked || (l = !1);
  }
  return {
    all: t,
    none: n,
    allWithoutDisable: o,
    half: !t && !n,
    isEffectivelyChecked: l
  };
}, vv = function(e) {
  if (e.childNodes.length === 0 || e.loading) {
    e.isEffectivelyChecked = e.disabled || e.checked;
    return;
  }
  const { all: t, none: n, half: o, isEffectivelyChecked: l } = rz(
    e.childNodes
  );
  e.isEffectivelyChecked = l, t ? (e.checked = !0, e.indeterminate = !1) : o ? (e.checked = !1, e.indeterminate = !0) : n && (e.checked = !1, e.indeterminate = !1);
  const r = e.parent;
  !r || r.level === 0 || e.store.checkStrictly || vv(r);
}, hg = function(e, t) {
  const n = e.store.props, o = e.data || {}, l = n[t];
  if (it(l))
    return l(o, e);
  if (rt(l))
    return o[l];
  if (fn(l)) {
    const r = o[t];
    return fn(r) ? "" : r;
  }
}, Gx = function(e, t) {
  e.forEach((n) => {
    n.canFocus = t, Gx(n.childNodes, t);
  });
};
let sEe = 0, Yx = class wb {
  constructor(t) {
    this.isLeafByUser = void 0, this.isLeaf = void 0, this.isEffectivelyChecked = !1, this.id = sEe++, this.text = null, this.checked = !1, this.indeterminate = !1, this.data = null, this.expanded = !1, this.parent = null, this.visible = !0, this.isCurrent = !1, this.canFocus = !1;
    for (const n in t)
      hn(t, n) && (this[n] = t[n]);
    this.level = 0, this.loaded = !1, this.childNodes = [], this.loading = !1, this.parent && (this.level = this.parent.level + 1);
  }
  initialize() {
    var t;
    const n = this.store;
    if (!n)
      throw new Error("[Node]store is required!");
    n.registerNode(this);
    const o = n.props;
    if (o && typeof o.isLeaf != "undefined") {
      const a = hg(this, "isLeaf");
      Tn(a) && (this.isLeafByUser = a);
    }
    if (n.lazy !== !0 && this.data ? (this.setData(this.data), n.defaultExpandAll && (this.expanded = !0, this.canFocus = !0)) : this.level > 0 && n.lazy && n.defaultExpandAll && !this.isLeafByUser && this.expand(), We(this.data) || nM(this, this.data), !this.data)
      return;
    const l = n.defaultExpandedKeys, r = n.key;
    r && !wo(this.key) && l && l.includes(this.key) && this.expand(null, n.autoExpandParent), r && n.currentNodeKey !== void 0 && this.key === n.currentNodeKey && (n.currentNode && (n.currentNode.isCurrent = !1), n.currentNode = this, n.currentNode.isCurrent = !0), n.lazy && n._initDefaultCheckedNode(this), this.updateLeafState(), (this.level === 1 || ((t = this.parent) == null ? void 0 : t.expanded) === !0) && (this.canFocus = !0);
  }
  setData(t) {
    We(t) || nM(this, t), this.data = t, this.childNodes = [];
    let n;
    this.level === 0 && We(this.data) ? n = this.data : n = hg(this, "children") || [];
    for (let o = 0, l = n.length; o < l; o++)
      this.insertChild({ data: n[o] });
  }
  get label() {
    return hg(this, "label");
  }
  get key() {
    const t = this.store.key;
    return this.data ? this.data[t] : null;
  }
  get disabled() {
    return hg(this, "disabled");
  }
  get nextSibling() {
    const t = this.parent;
    if (t) {
      const n = t.childNodes.indexOf(this);
      if (n > -1)
        return t.childNodes[n + 1];
    }
    return null;
  }
  get previousSibling() {
    const t = this.parent;
    if (t) {
      const n = t.childNodes.indexOf(this);
      if (n > -1)
        return n > 0 ? t.childNodes[n - 1] : null;
    }
    return null;
  }
  contains(t, n = !0) {
    return (this.childNodes || []).some(
      (o) => o === t || n && o.contains(t)
    );
  }
  remove() {
    const t = this.parent;
    t && t.removeChild(this);
  }
  insertChild(t, n, o) {
    if (!t)
      throw new Error("InsertChild error: child is required.");
    if (!(t instanceof wb)) {
      if (!o) {
        const l = this.getChildren(!0);
        l != null && l.includes(t.data) || (fn(n) || n < 0 ? l == null || l.push(t.data) : l == null || l.splice(n, 0, t.data));
      }
      Object.assign(t, {
        parent: this,
        store: this.store
      }), t = /* @__PURE__ */ kt(new wb(t)), t instanceof wb && t.initialize();
    }
    t.level = this.level + 1, fn(n) || n < 0 ? this.childNodes.push(t) : this.childNodes.splice(n, 0, t), this.updateLeafState();
  }
  insertBefore(t, n) {
    let o;
    n && (o = this.childNodes.indexOf(n)), this.insertChild(t, o);
  }
  insertAfter(t, n) {
    let o;
    n && (o = this.childNodes.indexOf(n), o !== -1 && (o += 1)), this.insertChild(t, o);
  }
  removeChild(t) {
    const n = this.getChildren() || [], o = n.indexOf(t.data);
    o > -1 && n.splice(o, 1);
    const l = this.childNodes.indexOf(t);
    l > -1 && (this.store && this.store.deregisterNode(t), t.parent = null, this.childNodes.splice(l, 1)), this.updateLeafState();
  }
  removeChildByData(t) {
    const n = this.childNodes.find((o) => o.data === t);
    n && this.removeChild(n);
  }
  expand(t, n) {
    const o = () => {
      if (n) {
        let l = this.parent;
        for (; l && l.level > 0; )
          l.expanded = !0, l = l.parent;
      }
      this.expanded = !0, t && t(), Gx(this.childNodes, !0);
    };
    this.shouldLoadData() ? this.loadData((l) => {
      We(l) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || vv(this), o());
    }) : o();
  }
  doCreateChildren(t, n = {}) {
    t.forEach((o) => {
      this.insertChild(
        Object.assign({ data: o }, n),
        void 0,
        !0
      );
    });
  }
  collapse() {
    this.expanded = !1, Gx(this.childNodes, !1);
  }
  shouldLoadData() {
    return !!(this.store.lazy === !0 && this.store.load && !this.loaded);
  }
  updateLeafState() {
    if (this.store.lazy === !0 && this.loaded !== !0 && typeof this.isLeafByUser != "undefined") {
      this.isLeaf = this.isLeafByUser, this.isEffectivelyChecked = this.isLeaf && this.disabled;
      return;
    }
    const t = this.childNodes;
    if (!this.store.lazy || this.store.lazy === !0 && this.loaded === !0) {
      this.isLeaf = !t || t.length === 0, this.isEffectivelyChecked = this.isLeaf && this.disabled;
      return;
    }
    this.isLeaf = !1;
  }
  setChecked(t, n, o, l) {
    if (this.indeterminate = t === "half", this.checked = t === !0, this.isEffectivelyChecked = !this.childNodes.length && (this.disabled || this.checked), this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const a = () => {
        if (n) {
          const i = this.childNodes;
          for (let d = 0, f = i.length; d < f; d++) {
            const p = i[d];
            l = l || t !== !1;
            const m = p.disabled && p.isLeaf ? p.checked : l;
            p.setChecked(m, n, !0, l);
          }
          const { half: s, all: c, isEffectivelyChecked: u } = rz(i);
          c || (this.checked = c, this.indeterminate = s), this.isEffectivelyChecked = this.childNodes.length ? u : this.disabled || this.checked;
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(
          () => {
            a(), vv(this);
          },
          {
            checked: t !== !1
          }
        );
        return;
      } else
        a();
    }
    const r = this.parent;
    !r || r.level === 0 || o || vv(r);
  }
  getChildren(t = !1) {
    if (this.level === 0)
      return this.data;
    const n = this.data;
    if (!n)
      return null;
    const o = this.store.props;
    let l = "children";
    return o && (l = o.children || "children"), fn(n[l]) && (n[l] = null), t && !n[l] && (n[l] = []), n[l];
  }
  updateChildren() {
    const t = this.getChildren() || [], n = this.childNodes.map((r) => r.data), o = {}, l = [];
    t.forEach((r, a) => {
      const i = r[mf];
      !!i && n.some((c) => (c == null ? void 0 : c[mf]) === i) ? o[i] = { index: a, data: r } : l.push({ index: a, data: r });
    }), this.store.lazy || n.forEach((r) => {
      o[r == null ? void 0 : r[mf]] || this.removeChildByData(r);
    }), l.forEach(({ index: r, data: a }) => {
      this.insertChild({ data: a }, r);
    }), this.updateLeafState();
  }
  loadData(t, n = {}) {
    if (this.store.lazy === !0 && this.store.load && !this.loaded && (!this.loading || Object.keys(n).length)) {
      this.loading = !0;
      const o = (r) => {
        this.childNodes = [], this.doCreateChildren(r, n), this.loaded = !0, this.loading = !1, this.updateLeafState(), t && t.call(this, r);
      }, l = () => {
        this.loading = !1;
      };
      this.store.load(this, o, l);
    } else
      t && t.call(this);
  }
  eachNode(t) {
    const n = [this];
    for (; n.length; ) {
      const o = n.shift();
      n.unshift(...o.childNodes), t(o);
    }
  }
  reInitChecked() {
    this.store.checkStrictly || vv(this);
  }
};
class cEe {
  constructor(t) {
    this.lazy = !1, this.checkStrictly = !1, this.autoExpandParent = !1, this.defaultExpandAll = !1, this.checkDescendants = !1, this.currentNode = null, this.currentNodeKey = null;
    for (const n in t)
      hn(t, n) && (this[n] = t[n]);
    this.nodesMap = {};
  }
  initialize() {
    if (this.root = new Yx({
      data: this.data,
      store: this
    }), this.root.initialize(), this.lazy && this.load) {
      const t = this.load;
      t(
        this.root,
        (n) => {
          this.root.doCreateChildren(n), this._initDefaultCheckedNodes();
        },
        gn
      );
    } else
      this._initDefaultCheckedNodes();
  }
  filter(t) {
    const n = this.filterNodeMethod, o = this.lazy, l = function(r) {
      return Rt(this, null, function* () {
        const a = r.root ? r.root.childNodes : r.childNodes;
        for (const [i, s] of a.entries())
          s.visible = !!(n != null && n.call(
            s,
            t,
            s.data,
            s
          )), i % 80 === 0 && i > 0 && (yield Ke()), yield l(s);
        if (!r.visible && a.length) {
          let i = !0;
          i = !a.some((s) => s.visible), r.root ? r.root.visible = i === !1 : r.visible = i === !1;
        }
        t && r.visible && !r.isLeaf && (!o || r.loaded) && r.expand();
      });
    };
    l(this);
  }
  setData(t) {
    t !== this.root.data ? (this.nodesMap = {}, this.root.setData(t), this._initDefaultCheckedNodes(), this.setCurrentNodeKey(this.currentNodeKey)) : this.root.updateChildren();
  }
  getNode(t) {
    if (t instanceof Yx)
      return t;
    const n = Mt(t) ? L_(this.key, t) : t;
    return this.nodesMap[n] || null;
  }
  insertBefore(t, n) {
    var o;
    const l = this.getNode(n);
    (o = l.parent) == null || o.insertBefore({ data: t }, l);
  }
  insertAfter(t, n) {
    var o;
    const l = this.getNode(n);
    (o = l.parent) == null || o.insertAfter({ data: t }, l);
  }
  remove(t) {
    const n = this.getNode(t);
    n && n.parent && (n === this.currentNode && (this.currentNode = null), n.parent.removeChild(n));
  }
  append(t, n) {
    const o = hr(n) ? this.root : this.getNode(n);
    o && o.insertChild({ data: t });
  }
  _initDefaultCheckedNodes() {
    const t = this.defaultCheckedKeys || [], n = this.nodesMap;
    t.forEach((o) => {
      const l = n[o];
      l && l.setChecked(!0, !this.checkStrictly);
    });
  }
  _initDefaultCheckedNode(t) {
    const n = this.defaultCheckedKeys || [];
    !wo(t.key) && n.includes(t.key) && t.setChecked(!0, !this.checkStrictly);
  }
  setDefaultCheckedKey(t) {
    t !== this.defaultCheckedKeys && (this.defaultCheckedKeys = t, this._initDefaultCheckedNodes());
  }
  registerNode(t) {
    const n = this.key;
    if (!(!t || !t.data))
      if (!n)
        this.nodesMap[t.id] = t;
      else {
        const o = t.key;
        wo(o) || (this.nodesMap[o] = t);
      }
  }
  deregisterNode(t) {
    !this.key || !t || !t.data || (t.childNodes.forEach((o) => {
      this.deregisterNode(o);
    }), delete this.nodesMap[t.key]);
  }
  getCheckedNodes(t = !1, n = !1) {
    const o = [], l = function(r) {
      (r.root ? r.root.childNodes : r.childNodes).forEach((i) => {
        (i.checked || n && i.indeterminate) && (!t || t && i.isLeaf) && o.push(i.data), l(i);
      });
    };
    return l(this), o;
  }
  getCheckedKeys(t = !1) {
    return this.getCheckedNodes(t).map((n) => (n || {})[this.key]);
  }
  getHalfCheckedNodes() {
    const t = [], n = function(o) {
      (o.root ? o.root.childNodes : o.childNodes).forEach((r) => {
        r.indeterminate && t.push(r.data), n(r);
      });
    };
    return n(this), t;
  }
  getHalfCheckedKeys() {
    return this.getHalfCheckedNodes().map((t) => (t || {})[this.key]);
  }
  _getAllNodes() {
    const t = [], n = this.nodesMap;
    for (const o in n)
      hn(n, o) && t.push(n[o]);
    return t;
  }
  updateChildren(t, n) {
    const o = this.nodesMap[t];
    if (!o)
      return;
    const l = o.childNodes;
    for (let r = l.length - 1; r >= 0; r--) {
      const a = l[r];
      this.remove(a.data);
    }
    for (let r = 0, a = n.length; r < a; r++) {
      const i = n[r];
      this.append(i, o.data);
    }
  }
  _setCheckedKeys(t, n = !1, o) {
    const l = this._getAllNodes().sort((s, c) => s.level - c.level), r = /* @__PURE__ */ Object.create(null), a = Object.keys(o);
    l.forEach((s) => s.setChecked(!1, !1));
    const i = (s) => {
      s.childNodes.forEach((c) => {
        var u;
        r[c.data[t]] = !0, (u = c.childNodes) != null && u.length && i(c);
      });
    };
    for (let s = 0, c = l.length; s < c; s++) {
      const u = l[s], d = u.data[t].toString();
      if (!a.includes(d)) {
        u.checked && !r[d] && u.setChecked(!1, !1);
        continue;
      }
      if (u.childNodes.length && i(u), u.isLeaf || this.checkStrictly) {
        u.setChecked(!0, !1);
        continue;
      }
      if (u.setChecked(!0, !0), n) {
        u.setChecked(!1, !1);
        const p = function(m) {
          m.childNodes.forEach((h) => {
            h.isLeaf || h.setChecked(!1, !1), p(h);
          });
        };
        p(u);
      }
    }
  }
  setCheckedNodes(t, n = !1) {
    const o = this.key, l = {};
    t.forEach((r) => {
      l[(r || {})[o]] = !0;
    }), this._setCheckedKeys(o, n, l);
  }
  setCheckedKeys(t, n = !1) {
    this.defaultCheckedKeys = t;
    const o = this.key, l = {};
    t.forEach((r) => {
      l[r] = !0;
    }), this._setCheckedKeys(o, n, l);
  }
  setDefaultExpandedKeys(t) {
    t = t || [], this.defaultExpandedKeys = t, t.forEach((n) => {
      const o = this.getNode(n);
      o && o.expand(null, this.autoExpandParent);
    });
  }
  setChecked(t, n, o) {
    const l = this.getNode(t);
    l && l.setChecked(!!n, o);
  }
  getCurrentNode() {
    return this.currentNode;
  }
  setCurrentNode(t) {
    const n = this.currentNode;
    n && (n.isCurrent = !1), this.currentNode = t, this.currentNode.isCurrent = !0;
  }
  setUserCurrentNode(t, n = !0) {
    var o;
    const l = t[this.key], r = this.nodesMap[l];
    this.setCurrentNode(r), n && this.currentNode && this.currentNode.level > 1 && ((o = this.currentNode.parent) == null || o.expand(null, !0));
  }
  setCurrentNodeKey(t, n = !0) {
    var o;
    if (this.currentNodeKey = t, hr(t)) {
      this.currentNode && (this.currentNode.isCurrent = !1), this.currentNode = null;
      return;
    }
    const l = this.getNode(t);
    l && (this.setCurrentNode(l), n && this.currentNode && this.currentNode.level > 1 && ((o = this.currentNode.parent) == null || o.expand(null, !0)));
  }
}
const B_ = "RootTree", az = "NodeInstance", oM = "TreeNodeMap", uEe = /* @__PURE__ */ le({
  name: "ElTreeNodeContent",
  props: {
    node: {
      type: Object,
      required: !0
    },
    renderContent: Function
  },
  setup(e) {
    const t = Ve("tree"), n = ze(
      az
    ), o = ze(B_);
    return () => {
      const l = e.node, { data: r, store: a } = l;
      return e.renderContent ? e.renderContent(ht, { _self: n, node: l, data: r, store: a }) : Oe(o.ctx.slots, "default", { node: l, data: r }, () => [
        ht(
          D_,
          { tag: "span", truncated: !0, class: t.be("node", "label") },
          () => [l.label]
        )
      ]);
    };
  }
});
var dEe = /* @__PURE__ */ Je(uEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node-content.vue"]]);
function iz(e) {
  const t = ze(
    oM,
    null
  );
  let n = {
    treeNodeExpand: (o) => {
      var l;
      e.node !== o && ((l = e.node) == null || l.collapse());
    },
    children: /* @__PURE__ */ new Set()
  };
  return t && t.children.add(n), yt(() => {
    t && t.children.delete(n), n = null;
  }), at(oM, n), {
    broadcastExpanded: (o) => {
      if (e.accordion)
        for (const l of n.children)
          l.treeNodeExpand(o);
    }
  };
}
const sz = Symbol("dragEvents");
function fEe({
  props: e,
  ctx: t,
  el$: n,
  dropIndicator$: o,
  store: l
}) {
  const r = Ve("tree"), a = /* @__PURE__ */ H({
    showDropIndicator: !1,
    draggingNode: null,
    dropNode: null,
    allowDrop: !0,
    dropType: null
  });
  return at(sz, {
    treeNodeDragStart: ({ event: u, treeNode: d }) => {
      if (u.dataTransfer) {
        if (it(e.allowDrag) && !e.allowDrag(d.node))
          return u.preventDefault(), !1;
        u.dataTransfer.effectAllowed = "move";
        try {
          u.dataTransfer.setData("text/plain", "");
        } catch (f) {
        }
        a.value.draggingNode = d, t.emit("node-drag-start", d.node, u);
      }
    },
    treeNodeDragOver: ({ event: u, treeNode: d }) => {
      if (!u.dataTransfer)
        return;
      const f = d, p = a.value.dropNode;
      p && p.node.id !== f.node.id && Al(p.$el, r.is("drop-inner"));
      const m = a.value.draggingNode;
      if (!m || !f)
        return;
      let v = !0, h = !0, g = !0, y = !0;
      it(e.allowDrop) && (v = e.allowDrop(m.node, f.node, "prev"), y = h = e.allowDrop(
        m.node,
        f.node,
        "inner"
      ), g = e.allowDrop(m.node, f.node, "next")), u.dataTransfer.dropEffect = h || v || g ? "move" : "none", (v || h || g) && (p == null ? void 0 : p.node.id) !== f.node.id && (p && t.emit("node-drag-leave", m.node, p.node, u), t.emit("node-drag-enter", m.node, f.node, u)), v || h || g ? a.value.dropNode = f : a.value.dropNode = null, f.node.nextSibling === m.node && (g = !1), f.node.previousSibling === m.node && (v = !1), f.node.contains(m.node, !1) && (h = !1), (m.node === f.node || m.node.contains(f.node)) && (v = !1, h = !1, g = !1);
      const b = f.$el, C = b.querySelector(`.${r.be("node", "content")}`).getBoundingClientRect(), w = n.value.getBoundingClientRect(), x = n.value.scrollTop;
      let E;
      const I = v ? h ? 0.25 : g ? 0.45 : 1 : Number.NEGATIVE_INFINITY, T = g ? h ? 0.75 : v ? 0.55 : 0 : Number.POSITIVE_INFINITY;
      let P = -9999;
      const k = u.clientY - C.top;
      k < C.height * I ? E = "before" : k > C.height * T ? E = "after" : h ? E = "inner" : E = "none";
      const N = b.querySelector(`.${r.be("node", "expand-icon")}`).getBoundingClientRect(), R = o.value;
      E === "before" ? P = N.top - w.top + x : E === "after" && (P = N.bottom - w.top + x), R.style.top = `${P}px`, R.style.left = `${N.right - w.left}px`, E === "inner" ? Zr(b, r.is("drop-inner")) : Al(b, r.is("drop-inner")), a.value.showDropIndicator = E === "before" || E === "after", a.value.allowDrop = a.value.showDropIndicator || y, a.value.dropType = E, t.emit("node-drag-over", m.node, f.node, u);
    },
    treeNodeDragEnd: (u) => {
      var d, f;
      const { draggingNode: p, dropType: m, dropNode: v } = a.value;
      if (u.preventDefault(), u.dataTransfer && (u.dataTransfer.dropEffect = "move"), p != null && p.node.data && v) {
        const h = { data: p.node.data };
        m !== "none" && p.node.remove(), m === "before" ? (d = v.node.parent) == null || d.insertBefore(h, v.node) : m === "after" ? (f = v.node.parent) == null || f.insertAfter(h, v.node) : m === "inner" && v.node.insertChild(h), m !== "none" && (l.value.registerNode(h), l.value.key && p.node.eachNode((g) => {
          var y;
          (y = l.value.nodesMap[g.data[l.value.key]]) == null || y.setChecked(
            g.checked,
            !l.value.checkStrictly
          );
        })), Al(v.$el, r.is("drop-inner")), t.emit(
          "node-drag-end",
          p.node,
          v.node,
          m,
          u
        ), m !== "none" && t.emit(
          "node-drop",
          p.node,
          v.node,
          m,
          u
        );
      }
      p && !v && t.emit("node-drag-end", p.node, null, m, u), a.value.showDropIndicator = !1, a.value.draggingNode = null, a.value.dropNode = null, a.value.allowDrop = !0;
    }
  }), {
    dragState: a
  };
}
const pEe = /* @__PURE__ */ le({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: j1,
    ElCheckbox: Fa,
    NodeContent: dEe,
    ElIcon: ut,
    Loading: wi
  },
  props: {
    node: {
      type: Yx,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: Boolean
  },
  emits: ["node-expand"],
  setup(e, t) {
    const n = Ve("tree"), { broadcastExpanded: o } = iz(e), l = ze(B_), r = /* @__PURE__ */ H(!1), a = /* @__PURE__ */ H(!1), i = /* @__PURE__ */ H(), s = /* @__PURE__ */ H(), c = /* @__PURE__ */ H(), u = ze(sz), d = xt();
    at(az, d), l || Gt("Tree", "Can not find node's tree."), e.node.expanded && (r.value = !0, a.value = !0);
    const f = l.props.props.children || "children";
    pe(
      () => {
        var T;
        const P = (T = e.node.data) == null ? void 0 : T[f];
        return P && [...P];
      },
      () => {
        e.node.updateChildren();
      }
    ), pe(
      () => e.node.indeterminate,
      (T) => {
        v(e.node.checked, T);
      }
    ), pe(
      () => e.node.checked,
      (T) => {
        v(T, e.node.indeterminate);
      }
    ), pe(
      () => e.node.childNodes.length,
      () => e.node.reInitChecked()
    ), pe(
      () => e.node.expanded,
      (T) => {
        Ke(() => r.value = T), T && (a.value = !0);
      }
    );
    const p = (T) => L_(l.props.nodeKey, T.data), m = (T) => {
      const P = e.props.class;
      if (!P)
        return {};
      let k;
      if (it(P)) {
        const { data: N } = T;
        k = P(N, T);
      } else
        k = P;
      return rt(k) ? { [k]: !0 } : k;
    }, v = (T, P) => {
      (i.value !== T || s.value !== P) && l.ctx.emit("check-change", e.node.data, T, P), i.value = T, s.value = P;
    }, h = (T) => {
      Ux(l.store, l.ctx.emit, () => {
        var P;
        if ((P = l == null ? void 0 : l.props) == null ? void 0 : P.nodeKey) {
          const N = p(e.node);
          l.store.value.setCurrentNodeKey(N);
        } else
          l.store.value.setCurrentNode(e.node);
      }), l.currentNode.value = e.node, l.props.expandOnClickNode && y(), (l.props.checkOnClickNode || e.node.isLeaf && l.props.checkOnClickLeaf && e.showCheckbox) && !e.node.disabled && b(!e.node.checked), l.ctx.emit("node-click", e.node.data, e.node, d, T);
    }, g = (T) => {
      var P;
      (P = l.instance.vnode.props) != null && P.onNodeContextmenu && (T.stopPropagation(), T.preventDefault()), l.ctx.emit(
        "node-contextmenu",
        T,
        e.node.data,
        e.node,
        d
      );
    }, y = () => {
      e.node.isLeaf || (r.value ? (l.ctx.emit("node-collapse", e.node.data, e.node, d), e.node.collapse()) : e.node.expand(() => {
        t.emit("node-expand", e.node.data, e.node, d);
      }));
    }, b = (T) => {
      const P = l == null ? void 0 : l.props.checkStrictly, k = e.node.childNodes;
      !P && k.length && (T = k.some((N) => !N.isEffectivelyChecked)), e.node.setChecked(T, !P), Ke(() => {
        const N = l.store.value;
        l.ctx.emit("check", e.node.data, {
          checkedNodes: N.getCheckedNodes(),
          checkedKeys: N.getCheckedKeys(),
          halfCheckedNodes: N.getHalfCheckedNodes(),
          halfCheckedKeys: N.getHalfCheckedKeys()
        });
      });
    };
    return {
      ns: n,
      node$: c,
      tree: l,
      expanded: r,
      childNodeRendered: a,
      oldChecked: i,
      oldIndeterminate: s,
      getNodeKey: p,
      getNodeClass: m,
      handleSelectChange: v,
      handleClick: h,
      handleContextMenu: g,
      handleExpandIconClick: y,
      handleCheckChange: b,
      handleChildNodeExpand: (T, P, k) => {
        o(P), l.ctx.emit("node-expand", T, P, k);
      },
      handleDragStart: (T) => {
        l.props.draggable && u.treeNodeDragStart({ event: T, treeNode: e });
      },
      handleDragOver: (T) => {
        T.preventDefault(), l.props.draggable && u.treeNodeDragOver({
          event: T,
          treeNode: { $el: c.value, node: e.node }
        });
      },
      handleDrop: (T) => {
        T.preventDefault();
      },
      handleDragEnd: (T) => {
        l.props.draggable && u.treeNodeDragEnd(T);
      },
      CaretRight: $7
    };
  }
}), vEe = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"], mEe = ["aria-expanded"];
function hEe(e, t, n, o, l, r) {
  const a = yn("el-icon"), i = yn("el-checkbox"), s = yn("loading"), c = yn("node-content"), u = yn("el-tree-node"), d = yn("el-collapse-transition");
  return _t((G(), ue("div", {
    ref: "node$",
    class: X([
      e.ns.b("node"),
      e.ns.is("expanded", e.expanded),
      e.ns.is("current", e.node.isCurrent),
      e.ns.is("hidden", !e.node.visible),
      e.ns.is("focusable", !e.node.disabled),
      e.ns.is("checked", !e.node.disabled && e.node.checked),
      e.getNodeClass(e.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": e.expanded,
    "aria-disabled": e.node.disabled,
    "aria-checked": e.node.checked,
    draggable: e.tree.props.draggable,
    "data-key": e.getNodeKey(e.node),
    onClick: t[2] || (t[2] = Et((...f) => e.handleClick && e.handleClick(...f), ["stop"])),
    onContextmenu: t[3] || (t[3] = (...f) => e.handleContextMenu && e.handleContextMenu(...f)),
    onDragstart: t[4] || (t[4] = Et((...f) => e.handleDragStart && e.handleDragStart(...f), ["stop"])),
    onDragover: t[5] || (t[5] = Et((...f) => e.handleDragOver && e.handleDragOver(...f), ["stop"])),
    onDragend: t[6] || (t[6] = Et((...f) => e.handleDragEnd && e.handleDragEnd(...f), ["stop"])),
    onDrop: t[7] || (t[7] = Et((...f) => e.handleDrop && e.handleDrop(...f), ["stop"]))
  }, [
    ve(
      "div",
      {
        class: X(e.ns.be("node", "content")),
        style: gt({ paddingLeft: (e.node.level - 1) * e.tree.props.indent + "px" })
      },
      [
        e.tree.props.icon || e.CaretRight ? (G(), Me(a, {
          key: 0,
          class: X([
            e.ns.be("node", "expand-icon"),
            e.ns.is("leaf", e.node.isLeaf),
            {
              expanded: !e.node.isLeaf && e.expanded
            }
          ]),
          onClick: Et(e.handleExpandIconClick, ["stop"])
        }, {
          default: Ee(() => [
            (G(), Me(Ht(e.tree.props.icon || e.CaretRight)))
          ]),
          _: 1
        }, 8, ["class", "onClick"])) : Ie("v-if", !0),
        e.showCheckbox ? (G(), Me(i, {
          key: 1,
          "model-value": e.node.checked,
          indeterminate: e.node.indeterminate,
          disabled: !!e.node.disabled,
          onClick: t[0] || (t[0] = Et(() => {
          }, ["stop"])),
          onChange: e.handleCheckChange
        }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : Ie("v-if", !0),
        e.node.loading ? (G(), Me(a, {
          key: 2,
          class: X([e.ns.be("node", "loading-icon"), e.ns.is("loading")])
        }, {
          default: Ee(() => [
            $(s)
          ]),
          _: 1
        }, 8, ["class"])) : Ie("v-if", !0),
        $(c, {
          node: e.node,
          "render-content": e.renderContent
        }, null, 8, ["node", "render-content"])
      ],
      6
    ),
    $(d, null, {
      default: Ee(() => [
        !e.renderAfterExpand || e.childNodeRendered ? _t((G(), ue("div", {
          key: 0,
          class: X(e.ns.be("node", "children")),
          role: "group",
          "aria-expanded": e.expanded,
          onClick: t[1] || (t[1] = Et(() => {
          }, ["stop"]))
        }, [
          (G(!0), ue(
            Ge,
            null,
            on(e.node.childNodes, (f) => (G(), Me(u, {
              key: e.getNodeKey(f),
              "render-content": e.renderContent,
              "render-after-expand": e.renderAfterExpand,
              "show-checkbox": e.showCheckbox,
              node: f,
              accordion: e.accordion,
              props: e.props,
              onNodeExpand: e.handleChildNodeExpand
            }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))),
            128
          ))
        ], 10, mEe)), [
          [Jt, e.expanded]
        ]) : Ie("v-if", !0)
      ]),
      _: 1
    })
  ], 42, vEe)), [
    [Jt, e.node.visible]
  ]);
}
var gEe = /* @__PURE__ */ Je(pEe, [["render", hEe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);
function bEe({ el$: e }, t) {
  const n = Ve("tree");
  nt(() => {
    r();
  }), $o(() => {
    var a;
    (a = e.value) == null || a.querySelectorAll("input[type=checkbox]").forEach((i) => {
      i.setAttribute("tabindex", "-1");
    });
  });
  function o(a, i) {
    var s, c;
    const u = t.value.getNode(a[i].dataset.key);
    return u.canFocus && u.visible && (((s = u.parent) == null ? void 0 : s.expanded) || ((c = u.parent) == null ? void 0 : c.level) === 0);
  }
  wn(e, "keydown", (a) => {
    const i = a.target;
    if (!i.className.includes(n.b("node")))
      return;
    const s = Nn(a), c = Array.from(
      e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)
    ), u = c.indexOf(i);
    let d;
    if ([Ye.up, Ye.down].includes(s)) {
      if (a.preventDefault(), s === Ye.up) {
        d = u === -1 ? 0 : u !== 0 ? u - 1 : c.length - 1;
        const p = d;
        for (; !o(c, d); ) {
          if (d--, d === p) {
            d = -1;
            break;
          }
          d < 0 && (d = c.length - 1);
        }
      } else {
        d = u === -1 ? 0 : u < c.length - 1 ? u + 1 : 0;
        const p = d;
        for (; !o(c, d); ) {
          if (d++, d === p) {
            d = -1;
            break;
          }
          d >= c.length && (d = 0);
        }
      }
      d !== -1 && c[d].focus();
    }
    [Ye.left, Ye.right].includes(s) && (a.preventDefault(), i.click());
    const f = i.querySelector(
      '[type="checkbox"]'
    );
    [Ye.enter, Ye.numpadEnter, Ye.space].includes(
      s
    ) && f && (a.preventDefault(), f.click());
  });
  const r = () => {
    var a;
    if (!e.value)
      return;
    const i = Array.from(
      e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)
    );
    Array.from(
      e.value.querySelectorAll("input[type=checkbox]")
    ).forEach((u) => {
      u.setAttribute("tabindex", "-1");
    });
    const c = e.value.querySelectorAll(
      `.${n.is("checked")}[role=treeitem]`
    );
    if (c.length) {
      c[0].setAttribute("tabindex", "0");
      return;
    }
    (a = i[0]) == null || a.setAttribute("tabindex", "0");
  };
}
const cz = Xe({
  data: {
    type: ye(Array),
    default: () => []
  },
  emptyText: {
    type: String
  },
  renderAfterExpand: {
    type: Boolean,
    default: !0
  },
  nodeKey: String,
  checkStrictly: Boolean,
  defaultExpandAll: Boolean,
  expandOnClickNode: {
    type: Boolean,
    default: !0
  },
  checkOnClickNode: Boolean,
  checkOnClickLeaf: {
    type: Boolean,
    default: !0
  },
  checkDescendants: Boolean,
  autoExpandParent: {
    type: Boolean,
    default: !0
  },
  defaultCheckedKeys: {
    type: Array
  },
  defaultExpandedKeys: {
    type: Array
  },
  currentNodeKey: {
    type: [String, Number]
  },
  renderContent: {
    type: ye(Function)
  },
  showCheckbox: Boolean,
  draggable: Boolean,
  allowDrag: {
    type: ye(Function)
  },
  allowDrop: {
    type: ye(Function)
  },
  props: {
    type: Object,
    default: () => ({
      children: "children",
      label: "label",
      disabled: "disabled"
    })
  },
  lazy: Boolean,
  highlightCurrent: Boolean,
  load: {
    type: Function
  },
  filterNodeMethod: {
    type: Function
  },
  accordion: Boolean,
  indent: {
    type: Number,
    default: 18
  },
  icon: {
    type: Pn
  }
}), yEe = {
  "check-change": (e, t, n) => e && Tn(t) && Tn(n),
  "current-change": (e, t) => !0,
  "node-click": (e, t, n, o) => e && t && o instanceof Event,
  "node-contextmenu": (e, t, n, o) => e instanceof Event && t && n,
  "node-collapse": (e, t, n) => e && t,
  "node-expand": (e, t, n) => e && t,
  check: (e, t) => e && t,
  "node-drag-start": (e, t) => e && t,
  "node-drag-end": (e, t, n, o) => e && o,
  "node-drop": (e, t, n, o) => e && t && o,
  "node-drag-leave": (e, t, n) => e && t && n,
  "node-drag-enter": (e, t, n) => e && t && n,
  "node-drag-over": (e, t, n) => e && t && n
}, SEe = /* @__PURE__ */ le({
  name: "ElTree",
  components: { ElTreeNode: gEe },
  props: cz,
  emits: yEe,
  setup(e, t) {
    const { t: n } = an(), o = Ve("tree"), l = /* @__PURE__ */ H(
      new cEe({
        key: e.nodeKey,
        data: e.data,
        lazy: e.lazy,
        props: e.props,
        load: e.load,
        currentNodeKey: e.currentNodeKey,
        checkStrictly: e.checkStrictly,
        checkDescendants: e.checkDescendants,
        defaultCheckedKeys: e.defaultCheckedKeys,
        defaultExpandedKeys: e.defaultExpandedKeys,
        autoExpandParent: e.autoExpandParent,
        defaultExpandAll: e.defaultExpandAll,
        filterNodeMethod: e.filterNodeMethod
      })
    );
    l.value.initialize();
    const r = /* @__PURE__ */ H(l.value.root), a = /* @__PURE__ */ H(null), i = /* @__PURE__ */ H(null), s = /* @__PURE__ */ H(null), { broadcastExpanded: c } = iz(e), { dragState: u } = fEe({
      props: e,
      ctx: t,
      el$: i,
      dropIndicator$: s,
      store: l
    });
    bEe({ el$: i }, l);
    const d = xt(), f = O(() => {
      let B = d == null ? void 0 : d.parent;
      for (; B; ) {
        if (B.type.name === "ElTreeSelect")
          return !0;
        B = B.parent;
      }
      return !1;
    }), p = O(() => {
      const { childNodes: B } = r.value;
      return (!B || B.length === 0 || B.every(({ visible: V }) => !V)) && !f.value;
    });
    pe(
      () => e.currentNodeKey,
      (B) => {
        l.value.setCurrentNodeKey(B != null ? B : null);
      }
    ), pe(
      () => e.defaultCheckedKeys,
      (B, V) => {
        Jn(B, V) || l.value.setDefaultCheckedKey(B != null ? B : []);
      }
    ), pe(
      () => e.defaultExpandedKeys,
      (B) => {
        l.value.setDefaultExpandedKeys(B != null ? B : []);
      }
    ), pe(
      () => e.data,
      (B) => {
        l.value.setData(B);
      },
      { deep: !0 }
    ), pe(
      () => e.checkStrictly,
      (B) => {
        l.value.checkStrictly = B;
      }
    );
    const m = (B) => {
      if (!e.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      l.value.filter(B);
    }, v = (B) => L_(e.nodeKey, B.data), h = (B) => {
      if (!e.nodeKey)
        throw new Error(`[Tree] nodeKey is required in ${B}`);
    }, g = (B) => {
      h("getNodePath");
      const V = l.value.getNode(B);
      if (!V)
        return [];
      const j = [V.data];
      let W = V.parent;
      for (; W && W !== r.value; )
        j.push(W.data), W = W.parent;
      return j.reverse();
    }, y = (B, V) => l.value.getCheckedNodes(B, V), b = (B) => l.value.getCheckedKeys(B), C = () => {
      const B = l.value.getCurrentNode();
      return B ? B.data : null;
    }, w = () => {
      h("getCurrentKey");
      const B = C();
      return B ? B[e.nodeKey] : null;
    }, x = (B, V) => {
      h("setCheckedNodes"), l.value.setCheckedNodes(B, V);
    }, E = (B, V) => {
      h("setCheckedKeys"), l.value.setCheckedKeys(B, V);
    }, I = (B, V, j) => {
      l.value.setChecked(B, V, j);
    }, T = () => l.value.getHalfCheckedNodes(), P = () => l.value.getHalfCheckedKeys(), k = (B, V = !0) => {
      h("setCurrentNode"), Ux(l, t.emit, () => {
        c(B), l.value.setUserCurrentNode(B, V);
      });
    }, N = (B = null, V = !0) => {
      h("setCurrentKey"), Ux(l, t.emit, () => {
        c(), l.value.setCurrentNodeKey(B, V);
      });
    }, R = (B) => l.value.getNode(B), z = (B) => {
      l.value.remove(B);
    }, D = (B, V) => {
      l.value.append(B, V);
    }, F = (B, V) => {
      l.value.insertBefore(B, V);
    }, M = (B, V) => {
      l.value.insertAfter(B, V);
    }, A = (B, V, j) => {
      c(V), t.emit("node-expand", B, V, j);
    }, L = (B, V) => {
      h("updateKeyChild"), l.value.updateChildren(B, V);
    };
    return at(B_, {
      ctx: t,
      props: e,
      store: l,
      root: r,
      currentNode: a,
      instance: d
    }), at($i, void 0), {
      ns: o,
      store: l,
      root: r,
      currentNode: a,
      dragState: u,
      el$: i,
      dropIndicator$: s,
      isEmpty: p,
      filter: m,
      getNodeKey: v,
      getNodePath: g,
      getCheckedNodes: y,
      getCheckedKeys: b,
      getCurrentNode: C,
      getCurrentKey: w,
      setCheckedNodes: x,
      setCheckedKeys: E,
      setChecked: I,
      getHalfCheckedNodes: T,
      getHalfCheckedKeys: P,
      setCurrentNode: k,
      setCurrentKey: N,
      t: n,
      getNode: R,
      remove: z,
      append: D,
      insertBefore: F,
      insertAfter: M,
      handleNodeExpand: A,
      updateKeyChildren: L
    };
  }
});
function CEe(e, t, n, o, l, r) {
  const a = yn("el-tree-node");
  return G(), ue(
    "div",
    {
      ref: "el$",
      class: X([
        e.ns.b(),
        e.ns.is("dragging", !!e.dragState.draggingNode),
        e.ns.is("drop-not-allow", !e.dragState.allowDrop),
        e.ns.is("drop-inner", e.dragState.dropType === "inner"),
        { [e.ns.m("highlight-current")]: e.highlightCurrent }
      ]),
      role: "tree"
    },
    [
      (G(!0), ue(
        Ge,
        null,
        on(e.root.childNodes, (i) => (G(), Me(a, {
          key: e.getNodeKey(i),
          node: i,
          props: e.props,
          accordion: e.accordion,
          "render-after-expand": e.renderAfterExpand,
          "show-checkbox": e.showCheckbox,
          "render-content": e.renderContent,
          onNodeExpand: e.handleNodeExpand
        }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))),
        128
      )),
      e.isEmpty ? (G(), ue(
        "div",
        {
          key: 0,
          class: X(e.ns.e("empty-block"))
        },
        [
          Oe(e.$slots, "empty", {}, () => {
            var i;
            return [
              ve(
                "span",
                {
                  class: X(e.ns.e("empty-text"))
                },
                qe((i = e.emptyText) != null ? i : e.t("el.tree.emptyText")),
                3
              )
            ];
          })
        ],
        2
      )) : Ie("v-if", !0),
      _t(ve(
        "div",
        {
          ref: "dropIndicator$",
          class: X(e.ns.e("drop-indicator"))
        },
        null,
        2
      ), [
        [Jt, e.dragState.showDropIndicator]
      ])
    ],
    2
  );
}
var wEe = /* @__PURE__ */ Je(SEe, [["render", CEe], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);
const F_ = Dt(wEe), $Ee = (e, { attrs: t, emit: n }, {
  select: o,
  tree: l,
  key: r
}) => {
  const a = Ve("tree-select");
  pe(
    () => e.data,
    () => {
      e.filterable && Ke(() => {
        var c, u;
        (u = l.value) == null || u.filter((c = o.value) == null ? void 0 : c.states.inputValue);
      });
    },
    { flush: "post" }
  );
  const i = (c) => {
    var u;
    const d = c.at(-1);
    if (d.expanded && d.childNodes.at(-1))
      i([d.childNodes.at(-1)]);
    else {
      const f = (u = l.value.el$) == null ? void 0 : u.querySelector(
        `[data-key="${c.at(-1).key}"]`
      );
      f == null || f.focus({ preventScroll: !0 });
      return;
    }
  };
  return nt(() => {
    wn(
      () => {
        var c;
        return (c = o.value) == null ? void 0 : c.$el;
      },
      "keydown",
      (c) => Rt(void 0, null, function* () {
        const u = Nn(c), { dropdownMenuVisible: d } = o.value;
        [Ye.down, Ye.up].includes(u) && d && (yield Ke(), setTimeout(() => {
          var f, p, m;
          if (Ye.up === u) {
            const v = l.value.store.root.childNodes;
            i(v);
            return;
          }
          (m = (p = (f = o.value.optionsArray[o.value.states.hoveringIndex].$el) == null ? void 0 : f.parentNode) == null ? void 0 : p.parentNode) == null || m.focus({ preventScroll: !0 });
        }));
      }),
      {
        capture: !0
      }
    );
  }), vt(Be(Be({}, La(/* @__PURE__ */ to(e), Object.keys(wc.props))), t), {
    class: O(() => t.class),
    style: O(() => t.style),
    "onUpdate:modelValue": (c) => n(It, c),
    valueKey: r,
    popperClass: O(() => {
      const c = [a.e("popper")];
      return e.popperClass && c.push(e.popperClass), c.join(" ");
    }),
    filterMethod: (c = "") => {
      var u;
      e.filterMethod ? e.filterMethod(c) : e.remoteMethod ? e.remoteMethod(c) : (u = l.value) == null || u.filter(c);
    }
  });
}, xEe = /* @__PURE__ */ le({
  extends: R0,
  setup(e, t) {
    const n = R0.setup(e, t);
    delete n.selectOptionClick;
    const o = xt().proxy;
    return Ke(() => {
      n.select.states.cachedOptions.get(o.value) || n.select.onOptionCreate(o);
    }), pe(
      () => t.attrs.visible,
      (l) => {
        Ke(() => {
          n.states.visible = l;
        });
      },
      {
        immediate: !0
      }
    ), n;
  },
  methods: {
    selectOptionClick() {
      this.$el.parentElement.click();
    }
  }
});
function Xx(e) {
  return e || e === 0;
}
function V_(e) {
  return We(e) && e.length;
}
function Pd(e) {
  return We(e) ? e : Xx(e) ? [e] : [];
}
function $b(e, t, n, o, l) {
  for (let r = 0; r < e.length; r++) {
    const a = e[r];
    if (t(a, r, e, l))
      return o ? o(a, r, e, l) : a;
    {
      const i = n(a);
      if (V_(i)) {
        const s = $b(
          i,
          t,
          n,
          o,
          a
        );
        if (s)
          return s;
      }
    }
  }
}
function xb(e, t, n, o) {
  for (let l = 0; l < e.length; l++) {
    const r = e[l];
    t(r, l, e, o);
    const a = n(r);
    V_(a) && xb(a, t, n, r);
  }
}
const EEe = (e, { attrs: t, slots: n, emit: o }, {
  select: l,
  tree: r,
  key: a
}) => {
  pe(
    [() => e.modelValue, r],
    () => {
      e.showCheckbox && Ke(() => {
        const f = r.value;
        f && !Jn(
          f.getCheckedKeys(),
          Pd(e.modelValue)
        ) && f.setCheckedKeys(Pd(e.modelValue));
      });
    },
    {
      immediate: !0,
      deep: !0
    }
  );
  const i = O(() => Be({
    value: a.value,
    label: "label",
    children: "children",
    disabled: "disabled",
    isLeaf: "isLeaf"
  }, e.props)), s = (f, p) => {
    var m;
    const v = i.value[f];
    return it(v) ? v(
      p,
      (m = r.value) == null ? void 0 : m.getNode(s("value", p))
    ) : p[v];
  }, c = Pd(e.modelValue).map((f) => $b(
    e.data || [],
    (p) => s("value", p) === f,
    (p) => s("children", p),
    (p, m, v, h) => h && s("value", h)
  )).filter((f) => Xx(f)), u = O(() => {
    if (!e.renderAfterExpand && !e.lazy)
      return [];
    const f = [];
    return xb(
      e.data.concat(e.cacheData),
      (p) => {
        const m = s("value", p);
        f.push({
          value: m,
          currentLabel: s("label", p),
          isDisabled: s("disabled", p)
        });
      },
      (p) => s("children", p)
    ), f;
  }), d = () => {
    var f;
    return (f = r.value) == null ? void 0 : f.getCheckedKeys().filter((p) => {
      var m;
      const v = (m = r.value) == null ? void 0 : m.getNode(p);
      return !wo(v) && Ql(v.childNodes);
    });
  };
  return vt(Be(Be({}, La(/* @__PURE__ */ to(e), Object.keys(F_.props))), t), {
    nodeKey: a,
    expandOnClickNode: O(() => !e.checkStrictly && e.expandOnClickNode),
    defaultExpandedKeys: O(() => e.defaultExpandedKeys ? e.defaultExpandedKeys.concat(c) : c),
    renderContent: (f, { node: p, data: m, store: v }) => f(
      xEe,
      {
        value: s("value", m),
        label: s("label", m),
        disabled: s("disabled", m),
        visible: p.visible
      },
      e.renderContent ? () => e.renderContent(f, { node: p, data: m, store: v }) : n.default ? () => n.default({ node: p, data: m, store: v }) : void 0
    ),
    filterNodeMethod: (f, p, m) => e.filterNodeMethod ? e.filterNodeMethod(f, p, m) : f ? new RegExp(ZO(f), "i").test(s("label", p) || "") : !0,
    onNodeClick: (f, p, m) => {
      var v, h, g;
      if ((v = t.onNodeClick) == null || v.call(t, f, p, m), !(e.showCheckbox && e.checkOnClickNode))
        if (!e.showCheckbox && (e.checkStrictly || p.isLeaf)) {
          if (!s("disabled", f)) {
            const y = (h = l.value) == null ? void 0 : h.states.options.get(
              s("value", f)
            );
            (g = l.value) == null || g.handleOptionSelect(y);
          }
        } else e.expandOnClickNode && m.proxy.handleExpandIconClick();
    },
    onCheck: (f, p) => {
      var m;
      if (!e.showCheckbox)
        return;
      const v = s("value", f), h = {};
      xb(
        [r.value.store.root],
        (C) => h[C.key] = C,
        (C) => C.childNodes
      );
      const g = p.checkedKeys, y = e.multiple ? Pd(e.modelValue).filter(
        (C) => !(C in h) && !g.includes(C)
      ) : [], b = y.concat(g);
      if (e.checkStrictly)
        o(
          It,
          e.multiple ? b : b.includes(v) ? v : void 0
        );
      else if (e.multiple) {
        const C = d();
        o(It, y.concat(C));
      } else {
        const C = $b(
          [f],
          (E) => !V_(s("children", E)) && !s("disabled", E),
          (E) => s("children", E)
        ), w = C ? s("value", C) : void 0, x = Xx(e.modelValue) && !!$b(
          [f],
          (E) => s("value", E) === e.modelValue,
          (E) => s("children", E)
        );
        o(
          It,
          w === e.modelValue || x ? void 0 : w
        );
      }
      Ke(() => {
        var C;
        const w = Pd(e.modelValue);
        r.value.setCheckedKeys(w), (C = t.onCheck) == null || C.call(t, f, {
          checkedKeys: r.value.getCheckedKeys(),
          checkedNodes: r.value.getCheckedNodes(),
          halfCheckedKeys: r.value.getHalfCheckedKeys(),
          halfCheckedNodes: r.value.getHalfCheckedNodes()
        });
      }), (m = l.value) == null || m.focus();
    },
    onNodeExpand: (f, p, m) => {
      var v;
      (v = t.onNodeExpand) == null || v.call(t, f, p, m), Ke(() => {
        if (!e.checkStrictly && e.lazy && e.multiple && p.checked) {
          const h = {}, g = r.value.getCheckedKeys();
          xb(
            [r.value.store.root],
            (C) => h[C.key] = C,
            (C) => C.childNodes
          );
          const y = Pd(e.modelValue).filter(
            (C) => !(C in h) && !g.includes(C)
          ), b = d();
          o(It, y.concat(b));
        }
      });
    },
    cacheOptions: u
  });
};
var OEe = /* @__PURE__ */ le({
  props: {
    data: {
      type: Array,
      default: () => []
    }
  },
  setup(e) {
    const t = ze(hh);
    return pe(
      () => e.data,
      () => {
        var n;
        e.data.forEach((l) => {
          t.states.cachedOptions.has(l.value) || t.states.cachedOptions.set(l.value, l);
        });
        const o = ((n = t.selectRef) == null ? void 0 : n.querySelectorAll("input")) || [];
        Sn && !Array.from(o).includes(
          document.activeElement
        ) && t.setSelected();
      },
      { flush: "post", immediate: !0 }
    ), () => {
    };
  }
});
const _Ee = /* @__PURE__ */ le({
  name: "ElTreeSelect",
  inheritAttrs: !1,
  props: vt(Be(Be({}, xF), cz), {
    cacheData: {
      type: Array,
      default: () => []
    }
  }),
  setup(e, t) {
    const { slots: n, expose: o } = t, l = /* @__PURE__ */ H(), r = /* @__PURE__ */ H(), a = O(() => e.nodeKey || e.valueKey || "value"), i = $Ee(e, t, { select: l, tree: r, key: a }), d = EEe(e, t, {
      select: l,
      tree: r,
      key: a
    }), { cacheOptions: s } = d, c = Hr(d, ["cacheOptions"]), u = /* @__PURE__ */ kt({});
    return o(u), nt(() => {
      Object.assign(u, vt(Be(Be({}, La(r.value, [
        "filter",
        "updateKeyChildren",
        "getCheckedNodes",
        "setCheckedNodes",
        "getCheckedKeys",
        "setCheckedKeys",
        "setChecked",
        "getHalfCheckedNodes",
        "getHalfCheckedKeys",
        "getCurrentKey",
        "getCurrentNode",
        "setCurrentKey",
        "setCurrentNode",
        "getNode",
        "remove",
        "append",
        "insertBefore",
        "insertAfter"
      ])), La(l.value, ["focus", "blur", "selectedLabel"])), {
        treeRef: r.value,
        selectRef: l.value
      }));
    }), () => ht(
      wc,
      /* @__PURE__ */ kt(vt(Be({}, i), {
        ref: (f) => l.value = f
      })),
      vt(Be({}, n), {
        default: () => [
          ht(OEe, { data: s.value }),
          ht(
            F_,
            /* @__PURE__ */ kt(vt(Be({}, c), {
              ref: (f) => r.value = f
            }))
          )
        ]
      })
    );
  }
});
var IEe = /* @__PURE__ */ Je(_Ee, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-select/src/tree-select.vue"]]);
const TEe = Dt(IEe), z_ = Symbol(), PEe = {
  key: -1,
  level: -1,
  data: {}
};
var mv = /* @__PURE__ */ ((e) => (e.KEY = "id", e.LABEL = "label", e.CHILDREN = "children", e.DISABLED = "disabled", e.CLASS = "", e))(mv || {}), qx = /* @__PURE__ */ ((e) => (e.ADD = "add", e.DELETE = "delete", e))(qx || {});
const uz = {
  type: Number,
  default: 26
}, kEe = Xe({
  data: {
    type: ye(Array),
    default: () => lo([])
  },
  emptyText: {
    type: String
  },
  height: {
    type: Number,
    default: 200
  },
  props: {
    type: ye(Object),
    default: () => lo({
      children: "children",
      label: "label",
      disabled: "disabled",
      value: "id",
      class: ""
      /* CLASS */
    })
  },
  highlightCurrent: Boolean,
  showCheckbox: Boolean,
  defaultCheckedKeys: {
    type: ye(Array),
    default: () => lo([])
  },
  checkStrictly: Boolean,
  defaultExpandedKeys: {
    type: ye(Array),
    default: () => lo([])
  },
  indent: {
    type: Number,
    default: 16
  },
  itemSize: uz,
  icon: {
    type: Pn
  },
  expandOnClickNode: {
    type: Boolean,
    default: !0
  },
  checkOnClickNode: Boolean,
  checkOnClickLeaf: {
    type: Boolean,
    default: !0
  },
  currentNodeKey: {
    type: ye([String, Number])
  },
  accordion: Boolean,
  filterMethod: {
    type: ye(Function)
  },
  perfMode: {
    type: Boolean,
    default: !0
  },
  scrollbarAlwaysOn: Boolean
}), NEe = Xe({
  node: {
    type: ye(Object),
    default: () => lo(PEe)
  },
  expanded: Boolean,
  checked: Boolean,
  indeterminate: Boolean,
  showCheckbox: Boolean,
  disabled: Boolean,
  current: Boolean,
  hiddenExpandIcon: Boolean,
  itemSize: uz
}), MEe = Xe({
  node: {
    type: ye(Object),
    required: !0
  }
}), dz = "node-click", fz = "node-drop", pz = "node-expand", vz = "node-collapse", mz = "current-change", hz = "check", gz = "check-change", bz = "node-contextmenu", AEe = {
  [dz]: (e, t, n) => e && t && n,
  [fz]: (e, t, n) => e && t && n,
  [pz]: (e, t) => e && t,
  [vz]: (e, t) => e && t,
  [mz]: (e, t) => e && t,
  [hz]: (e, t) => e && t,
  [gz]: (e, t) => e && Tn(t),
  [bz]: (e, t, n) => e && t && n
}, REe = {
  click: (e, t) => !!(e && t),
  drop: (e, t) => !!(e && t),
  toggle: (e) => !!e,
  check: (e, t) => e && Tn(t)
};
function DEe(e, t) {
  const n = /* @__PURE__ */ H(/* @__PURE__ */ new Set()), o = /* @__PURE__ */ H(/* @__PURE__ */ new Set()), { emit: l } = xt();
  pe(
    [() => t.value, () => e.defaultCheckedKeys],
    () => Ke(() => {
      y(e.defaultCheckedKeys);
    }),
    {
      immediate: !0
    }
  );
  const r = () => {
    if (!t.value || !e.showCheckbox || e.checkStrictly)
      return;
    const { levelTreeNodeMap: b, maxLevel: C } = t.value, w = n.value, x = /* @__PURE__ */ new Set();
    for (let E = C; E >= 1; --E) {
      const I = b.get(E);
      I && I.forEach((T) => {
        const P = T.children;
        let k = !T.isLeaf || T.disabled || w.has(T.key);
        if (P) {
          let N = !0, R = !1;
          for (const z of P) {
            const D = z.key;
            if (z.isEffectivelyChecked || (k = !1), w.has(D))
              R = !0;
            else if (x.has(D)) {
              N = !1, R = !0;
              break;
            } else
              N = !1;
          }
          N ? w.add(T.key) : R ? (x.add(T.key), w.delete(T.key)) : (w.delete(T.key), x.delete(T.key));
        }
        T.isEffectivelyChecked = k;
      });
    }
    o.value = x;
  }, a = (b) => n.value.has(b.key), i = (b) => o.value.has(b.key), s = (b, C, w = !0, x = !0) => {
    const E = n.value, I = b.children;
    !e.checkStrictly && w && (I != null && I.length) && (C = I.some((P) => !P.isEffectivelyChecked));
    const T = (P, k) => {
      E[k ? qx.ADD : qx.DELETE](
        P.key
      );
      const N = P.children;
      !e.checkStrictly && N && N.forEach((R) => {
        (!R.disabled || R.children) && T(R, k);
      });
    };
    T(b, C), x && r(), w && c(b, C);
  }, c = (b, C) => {
    const { checkedNodes: w, checkedKeys: x } = m(), { halfCheckedNodes: E, halfCheckedKeys: I } = v();
    l(hz, b.data, {
      checkedKeys: x,
      checkedNodes: w,
      halfCheckedKeys: I,
      halfCheckedNodes: E
    }), l(gz, b.data, C);
  };
  function u(b = !1) {
    return m(b).checkedKeys;
  }
  function d(b = !1) {
    return m(b).checkedNodes;
  }
  function f() {
    return v().halfCheckedKeys;
  }
  function p() {
    return v().halfCheckedNodes;
  }
  function m(b = !1) {
    const C = [], w = [];
    if (t != null && t.value && e.showCheckbox) {
      const { treeNodeMap: x } = t.value;
      n.value.forEach((E) => {
        const I = x.get(E);
        I && (!b || b && I.isLeaf) && (w.push(E), C.push(I.data));
      });
    }
    return {
      checkedKeys: w,
      checkedNodes: C
    };
  }
  function v() {
    const b = [], C = [];
    if (t != null && t.value && e.showCheckbox) {
      const { treeNodeMap: w } = t.value;
      o.value.forEach((x) => {
        const E = w.get(x);
        E && (C.push(x), b.push(E.data));
      });
    }
    return {
      halfCheckedNodes: b,
      halfCheckedKeys: C
    };
  }
  function h(b) {
    n.value.clear(), o.value.clear(), Ke(() => {
      y(b);
    });
  }
  function g(b, C) {
    if (t != null && t.value && e.showCheckbox) {
      const w = t.value.treeNodeMap.get(b);
      w && s(w, C, !1);
    }
  }
  function y(b) {
    if (t != null && t.value) {
      const { treeNodeMap: C } = t.value;
      if (e.showCheckbox && C && (b == null ? void 0 : b.length) > 0) {
        for (const w of b) {
          const x = C.get(w);
          x && !a(x) && s(x, !0, !1, !1);
        }
        r();
      }
    }
  }
  return {
    updateCheckedKeys: r,
    toggleCheckbox: s,
    isChecked: a,
    isIndeterminate: i,
    getCheckedKeys: u,
    getCheckedNodes: d,
    getHalfCheckedKeys: f,
    getHalfCheckedNodes: p,
    setChecked: g,
    setCheckedKeys: h
  };
}
function LEe(e, t) {
  const n = /* @__PURE__ */ H(/* @__PURE__ */ new Set([])), o = /* @__PURE__ */ H(/* @__PURE__ */ new Set([])), l = O(() => it(e.filterMethod));
  function r(i) {
    var s;
    if (!l.value)
      return;
    const c = /* @__PURE__ */ new Set(), u = o.value, d = n.value, f = [], p = ((s = t.value) == null ? void 0 : s.treeNodes) || [], m = e.filterMethod;
    d.clear();
    function v(h) {
      h.forEach((g) => {
        f.push(g), m != null && m(i, g.data, g) ? f.forEach((b) => {
          c.add(b.key), b.expanded = !0;
        }) : (g.expanded = !1, g.isLeaf && d.add(g.key));
        const y = g.children;
        if (y && v(y), !g.isLeaf) {
          if (!c.has(g.key))
            d.add(g.key);
          else if (y) {
            let b = !0;
            for (const C of y)
              if (!d.has(C.key)) {
                b = !1;
                break;
              }
            b ? u.add(g.key) : u.delete(g.key);
          }
        }
        f.pop();
      });
    }
    return v(p), c;
  }
  function a(i) {
    return o.value.has(i.key);
  }
  return {
    hiddenExpandIconKeySet: o,
    hiddenNodeKeySet: n,
    doFilter: r,
    isForceHiddenExpandIcon: a
  };
}
function BEe(e, t) {
  const n = /* @__PURE__ */ H(/* @__PURE__ */ new Set()), o = /* @__PURE__ */ H(), l = /* @__PURE__ */ Ce(), r = /* @__PURE__ */ H(), {
    isIndeterminate: a,
    isChecked: i,
    toggleCheckbox: s,
    getCheckedKeys: c,
    getCheckedNodes: u,
    getHalfCheckedKeys: d,
    getHalfCheckedNodes: f,
    setChecked: p,
    setCheckedKeys: m
  } = DEe(e, l), { doFilter: v, hiddenNodeKeySet: h, isForceHiddenExpandIcon: g } = LEe(
    e,
    l
  ), y = O(() => {
    var K;
    return ((K = e.props) == null ? void 0 : K.value) || mv.KEY;
  }), b = O(() => {
    var K;
    return ((K = e.props) == null ? void 0 : K.children) || mv.CHILDREN;
  }), C = O(() => {
    var K;
    return ((K = e.props) == null ? void 0 : K.disabled) || mv.DISABLED;
  }), w = O(() => {
    var K;
    return ((K = e.props) == null ? void 0 : K.label) || mv.LABEL;
  }), x = O(() => {
    var K;
    const se = n.value, Z = h.value, ee = [], fe = ((K = l.value) == null ? void 0 : K.treeNodes) || [], me = [];
    for (let ge = fe.length - 1; ge >= 0; --ge)
      me.push(fe[ge]);
    for (; me.length; ) {
      const ge = me.pop();
      if (!Z.has(ge.key) && (ee.push(ge), ge.children && se.has(ge.key)))
        for (let he = ge.children.length - 1; he >= 0; --he)
          me.push(ge.children[he]);
    }
    return ee;
  }), E = O(() => x.value.length > 0);
  function I(K) {
    const se = /* @__PURE__ */ new Map(), Z = /* @__PURE__ */ new Map();
    let ee = 1;
    function fe(ge, he = 1, $e = void 0) {
      var ne;
      const ae = [];
      for (const ce of ge) {
        const xe = k(ce), Te = {
          level: he,
          key: xe,
          data: ce
        };
        Te.label = R(ce), Te.parent = $e;
        const Se = P(ce);
        Te.disabled = N(ce), Te.isLeaf = !Se || Se.length === 0, Te.expanded = n.value.has(xe), Se && Se.length && (Te.children = fe(Se, he + 1, Te)), ae.push(Te), se.set(xe, Te), Z.has(he) || Z.set(he, []), (ne = Z.get(he)) == null || ne.push(Te);
      }
      return he > ee && (ee = he), ae;
    }
    const me = fe(K);
    return {
      treeNodeMap: se,
      levelTreeNodeMap: Z,
      maxLevel: ee,
      treeNodes: me
    };
  }
  function T(K) {
    const se = v(K);
    se && (n.value = se);
  }
  function P(K) {
    return K[b.value];
  }
  function k(K) {
    return K ? K[y.value] : "";
  }
  function N(K) {
    return K[C.value];
  }
  function R(K) {
    return K[w.value];
  }
  function z(K) {
    n.value.has(K.key) ? V(K) : B(K);
  }
  function D(K) {
    const se = /* @__PURE__ */ new Set(), Z = l.value.treeNodeMap;
    n.value.forEach((ee) => {
      const fe = Z.get(ee);
      n.value.delete(fe.key), fe.expanded = !1;
    }), K.forEach((ee) => {
      let fe = Z.get(ee);
      for (; fe && !se.has(fe.key); )
        se.add(fe.key), fe.expanded = !0, fe = fe.parent;
    }), n.value = se;
  }
  function F(K, se) {
    t(dz, K.data, K, se), A(K), e.expandOnClickNode && z(K), e.showCheckbox && (e.checkOnClickNode || K.isLeaf && e.checkOnClickLeaf) && !K.disabled && s(K, !i(K), !0);
  }
  function M(K, se) {
    t(fz, K.data, K, se);
  }
  function A(K) {
    W(K) || (o.value = K.key, t(mz, K.data, K));
  }
  function L(K, se) {
    s(K, se);
  }
  function B(K) {
    const se = n.value;
    if (l.value && e.accordion) {
      const { treeNodeMap: ee } = l.value;
      se.forEach((fe) => {
        const me = ee.get(fe);
        K && K.level === (me == null ? void 0 : me.level) && (se.delete(fe), me.expanded = !1);
      });
    }
    se.add(K.key);
    const Z = re(K.key);
    Z && (Z.expanded = !0, t(pz, Z.data, Z));
  }
  function V(K) {
    n.value.delete(K.key);
    const se = re(K.key);
    se && (se.expanded = !1, t(vz, se.data, se));
  }
  function j(K) {
    return !!K.disabled;
  }
  function W(K) {
    const se = o.value;
    return se !== void 0 && se === K.key;
  }
  function Y() {
    var K, se;
    if (o.value)
      return (se = (K = l.value) == null ? void 0 : K.treeNodeMap.get(o.value)) == null ? void 0 : se.data;
  }
  function U() {
    return o.value;
  }
  function te(K) {
    o.value = K;
  }
  function J(K) {
    l.value = I(K);
  }
  function re(K) {
    var se;
    const Z = Mt(K) ? k(K) : K;
    return (se = l.value) == null ? void 0 : se.treeNodeMap.get(Z);
  }
  function oe(K, se = "auto") {
    const Z = re(K);
    Z && r.value && r.value.scrollToItem(x.value.indexOf(Z), se);
  }
  function q(K) {
    var se;
    (se = r.value) == null || se.scrollTo(K);
  }
  return pe(
    () => e.currentNodeKey,
    (K) => {
      o.value = K;
    },
    {
      immediate: !0
    }
  ), pe(
    () => e.defaultExpandedKeys,
    (K) => {
      n.value = new Set(K);
    },
    {
      immediate: !0
    }
  ), pe(
    () => e.data,
    (K) => {
      J(K);
    },
    {
      immediate: !0
    }
  ), {
    tree: l,
    flattenTree: x,
    isNotEmpty: E,
    listRef: r,
    getKey: k,
    getChildren: P,
    toggleExpand: z,
    toggleCheckbox: s,
    isChecked: i,
    isIndeterminate: a,
    isDisabled: j,
    isCurrent: W,
    isForceHiddenExpandIcon: g,
    handleNodeClick: F,
    handleNodeDrop: M,
    handleNodeCheck: L,
    getCurrentNode: Y,
    getCurrentKey: U,
    setCurrentKey: te,
    getCheckedKeys: c,
    getCheckedNodes: u,
    getHalfCheckedKeys: d,
    getHalfCheckedNodes: f,
    setChecked: p,
    setCheckedKeys: m,
    filter: T,
    setData: J,
    getNode: re,
    expandNode: B,
    collapseNode: V,
    setExpandedKeys: D,
    scrollToNode: oe,
    scrollTo: q
  };
}
var FEe = /* @__PURE__ */ le({
  name: "ElTreeNodeContent",
  props: MEe,
  setup(e) {
    const t = ze(z_), n = Ve("tree");
    return () => {
      const o = e.node, { data: l } = o;
      return t != null && t.ctx.slots.default ? t.ctx.slots.default({ node: o, data: l }) : ht(
        D_,
        { tag: "span", truncated: !0, class: n.be("node", "label") },
        () => [o == null ? void 0 : o.label]
      );
    };
  }
});
const VEe = ["aria-expanded", "aria-disabled", "aria-checked", "data-key"], zEe = /* @__PURE__ */ le({
  name: "ElTreeNode",
  __name: "tree-node",
  props: NEe,
  emits: REe,
  setup(e, { emit: t }) {
    const n = e, o = t, l = ze(z_), r = Ve("tree"), a = O(() => {
      var m;
      return (m = l == null ? void 0 : l.props.indent) != null ? m : 16;
    }), i = O(() => {
      var m;
      return (m = l == null ? void 0 : l.props.icon) != null ? m : $7;
    }), s = (m) => {
      const v = l == null ? void 0 : l.props.props.class;
      if (!v)
        return {};
      let h;
      if (it(v)) {
        const { data: g } = m;
        h = v(g, m);
      } else
        h = v;
      return rt(h) ? { [h]: !0 } : h;
    }, c = (m) => {
      o("click", n.node, m);
    }, u = (m) => {
      o("drop", n.node, m);
    }, d = () => {
      o("toggle", n.node);
    }, f = (m) => {
      o("check", n.node, m);
    }, p = (m) => {
      var v, h, g, y;
      (g = (h = (v = l == null ? void 0 : l.instance) == null ? void 0 : v.vnode) == null ? void 0 : h.props) != null && g.onNodeContextmenu && (m.stopPropagation(), m.preventDefault()), l == null || l.ctx.emit(bz, m, (y = n.node) == null ? void 0 : y.data, n.node);
    };
    return (m, v) => {
      var h, g, y;
      return G(), ue("div", {
        ref: "node$",
        class: X([
          S(r).b("node"),
          S(r).is("expanded", m.expanded),
          S(r).is("current", m.current),
          S(r).is("focusable", !m.disabled),
          S(r).is("checked", !m.disabled && m.checked),
          s(m.node)
        ]),
        role: "treeitem",
        tabindex: "-1",
        "aria-expanded": m.expanded,
        "aria-disabled": m.disabled,
        "aria-checked": m.checked,
        "data-key": (h = m.node) == null ? void 0 : h.key,
        onClick: Et(c, ["stop"]),
        onContextmenu: p,
        onDragover: v[1] || (v[1] = Et(() => {
        }, ["prevent"])),
        onDragenter: v[2] || (v[2] = Et(() => {
        }, ["prevent"])),
        onDrop: Et(u, ["stop"])
      }, [
        ve(
          "div",
          {
            class: X(S(r).be("node", "content")),
            style: gt({
              paddingLeft: `${(m.node.level - 1) * a.value}px`,
              height: m.itemSize + "px"
            })
          },
          [
            i.value ? (G(), Me(S(ut), {
              key: 0,
              class: X([
                S(r).is("leaf", !!((g = m.node) != null && g.isLeaf)),
                S(r).is("hidden", m.hiddenExpandIcon),
                {
                  expanded: !((y = m.node) != null && y.isLeaf) && m.expanded
                },
                S(r).be("node", "expand-icon")
              ]),
              onClick: Et(d, ["stop"])
            }, {
              default: Ee(() => [
                (G(), Me(Ht(i.value)))
              ]),
              _: 1
            }, 8, ["class"])) : Ie("v-if", !0),
            m.showCheckbox ? (G(), Me(S(Fa), {
              key: 1,
              "model-value": m.checked,
              indeterminate: m.indeterminate,
              disabled: m.disabled,
              onChange: f,
              onClick: v[0] || (v[0] = Et(() => {
              }, ["stop"]))
            }, null, 8, ["model-value", "indeterminate", "disabled"])) : Ie("v-if", !0),
            $(S(FEe), {
              node: vt(Be({}, m.node), { expanded: m.expanded })
            }, null, 8, ["node"])
          ],
          6
        )
      ], 42, VEe);
    };
  }
});
var HEe = /* @__PURE__ */ Je(zEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree-node.vue"]]);
const jEe = /* @__PURE__ */ le({
  name: "ElTreeV2",
  __name: "tree",
  props: kEe,
  emits: AEe,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = So(), a = O(() => o.itemSize);
    at(z_, {
      ctx: {
        emit: l,
        slots: r
      },
      props: o,
      instance: xt()
    }), at($i, void 0);
    const { t: i } = an(), s = Ve("tree"), {
      flattenTree: c,
      isNotEmpty: u,
      listRef: d,
      toggleExpand: f,
      isIndeterminate: p,
      isChecked: m,
      isDisabled: v,
      isCurrent: h,
      isForceHiddenExpandIcon: g,
      handleNodeClick: y,
      handleNodeDrop: b,
      handleNodeCheck: C,
      toggleCheckbox: w,
      getCurrentNode: x,
      getCurrentKey: E,
      setCurrentKey: I,
      getCheckedKeys: T,
      getCheckedNodes: P,
      getHalfCheckedKeys: k,
      getHalfCheckedNodes: N,
      setChecked: R,
      setCheckedKeys: z,
      filter: D,
      setData: F,
      getNode: M,
      expandNode: A,
      collapseNode: L,
      setExpandedKeys: B,
      scrollToNode: V,
      scrollTo: j
    } = BEe(o, l);
    return t({
      toggleCheckbox: w,
      getCurrentNode: x,
      getCurrentKey: E,
      setCurrentKey: I,
      getCheckedKeys: T,
      getCheckedNodes: P,
      getHalfCheckedKeys: k,
      getHalfCheckedNodes: N,
      setChecked: R,
      setCheckedKeys: z,
      filter: D,
      setData: F,
      getNode: M,
      expandNode: A,
      collapseNode: L,
      setExpandedKeys: B,
      scrollToNode: V,
      scrollTo: j
    }), (W, Y) => (G(), ue(
      "div",
      {
        class: X([S(s).b(), { [S(s).m("highlight-current")]: W.highlightCurrent }]),
        role: "tree"
      },
      [
        S(u) ? (G(), Me(S(dV), {
          key: 0,
          ref_key: "listRef",
          ref: d,
          "class-name": S(s).b("virtual-list"),
          data: S(c),
          total: S(c).length,
          height: W.height,
          "item-size": a.value,
          "perf-mode": W.perfMode,
          "scrollbar-always-on": W.scrollbarAlwaysOn
        }, {
          default: Ee(({ data: U, index: te, style: J }) => [
            (G(), Me(HEe, {
              key: U[te].key,
              style: gt(J),
              node: U[te],
              expanded: U[te].expanded,
              "show-checkbox": W.showCheckbox,
              checked: S(m)(U[te]),
              indeterminate: S(p)(U[te]),
              "item-size": a.value,
              disabled: S(v)(U[te]),
              current: S(h)(U[te]),
              "hidden-expand-icon": S(g)(U[te]),
              onClick: S(y),
              onToggle: S(f),
              onCheck: S(C),
              onDrop: S(b)
            }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "item-size", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck", "onDrop"]))
          ]),
          _: 1
        }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode", "scrollbar-always-on"])) : (G(), ue(
          "div",
          {
            key: 1,
            class: X(S(s).e("empty-block"))
          },
          [
            Oe(W.$slots, "empty", {}, () => {
              var U;
              return [
                ve(
                  "span",
                  {
                    class: X(S(s).e("empty-text"))
                  },
                  qe((U = W.emptyText) != null ? U : S(i)("el.tree.emptyText")),
                  3
                )
              ];
            })
          ],
          2
        ))
      ],
      2
    ));
  }
});
var WEe = /* @__PURE__ */ Je(jEe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree-v2/src/tree.vue"]]);
const KEe = Dt(WEe), yz = Symbol("uploadContextKey"), UEe = "ElUpload";
class GEe extends Error {
  constructor(t, n, o, l) {
    super(t), this.name = "UploadAjaxError", this.status = n, this.method = o, this.url = l;
  }
}
function lM(e, t, n) {
  let o;
  return n.response ? o = `${n.response.error || n.response}` : n.responseText ? o = `${n.responseText}` : o = `fail to ${t.method} ${e} ${n.status}`, new GEe(o, n.status, t.method, e);
}
function YEe(e) {
  const t = e.responseText || e.response;
  if (!t)
    return t;
  try {
    return JSON.parse(t);
  } catch (n) {
    return t;
  }
}
const XEe = (e) => {
  typeof XMLHttpRequest == "undefined" && no(UEe, "XMLHttpRequest is undefined");
  const t = new XMLHttpRequest(), n = e.action;
  t.upload && t.upload.addEventListener("progress", (r) => {
    const a = r;
    a.percent = r.total > 0 ? r.loaded / r.total * 100 : 0, e.onProgress(a);
  });
  const o = new FormData();
  if (e.data)
    for (const [r, a] of Object.entries(e.data))
      We(a) && a.length ? o.append(r, ...a) : o.append(r, a);
  o.append(e.filename, e.file, e.file.name), t.addEventListener("error", () => {
    e.onError(lM(n, e, t));
  }), t.addEventListener("load", () => {
    if (t.status < 200 || t.status >= 300)
      return e.onError(lM(n, e, t));
    e.onSuccess(YEe(t));
  }), t.open(e.method, n, !0), e.withCredentials && "withCredentials" in t && (t.withCredentials = !0);
  const l = e.headers || {};
  if (l instanceof Headers)
    l.forEach((r, a) => t.setRequestHeader(a, r));
  else
    for (const [r, a] of Object.entries(l))
      wo(a) || t.setRequestHeader(r, String(a));
  return t.send(o), t;
}, Sz = ["text", "picture", "picture-card"];
let qEe = 1;
const Jx = () => Date.now() + qEe++, Cz = Xe({
  action: {
    type: String,
    default: "#"
  },
  headers: {
    type: ye(Object)
  },
  method: {
    type: String,
    default: "post"
  },
  data: {
    type: ye([Object, Function, Promise]),
    default: () => lo({})
  },
  multiple: Boolean,
  name: {
    type: String,
    default: "file"
  },
  drag: Boolean,
  withCredentials: Boolean,
  showFileList: {
    type: Boolean,
    default: !0
  },
  accept: {
    type: String,
    default: ""
  },
  fileList: {
    type: ye(Array),
    default: () => lo([])
  },
  autoUpload: {
    type: Boolean,
    default: !0
  },
  listType: {
    type: String,
    values: Sz,
    default: "text"
  },
  httpRequest: {
    type: ye(Function),
    default: XEe
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  limit: Number,
  directory: Boolean
}), JEe = Xe(vt(Be({}, Cz), {
  beforeUpload: {
    type: ye(Function),
    default: gn
  },
  beforeRemove: {
    type: ye(Function)
  },
  onRemove: {
    type: ye(Function),
    default: gn
  },
  onChange: {
    type: ye(Function),
    default: gn
  },
  onPreview: {
    type: ye(Function),
    default: gn
  },
  onSuccess: {
    type: ye(Function),
    default: gn
  },
  onProgress: {
    type: ye(Function),
    default: gn
  },
  onError: {
    type: ye(Function),
    default: gn
  },
  onExceed: {
    type: ye(Function),
    default: gn
  },
  crossorigin: {
    type: ye(String)
  }
})), ZEe = Xe({
  files: {
    type: ye(Array),
    default: () => lo([])
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  handlePreview: {
    type: ye(Function),
    default: gn
  },
  listType: {
    type: String,
    values: Sz,
    default: "text"
  },
  crossorigin: {
    type: ye(String)
  }
}), QEe = {
  remove: (e) => !!e
}, eOe = ["tabindex", "aria-disabled", "onKeydown"], tOe = ["src", "crossorigin"], nOe = ["onClick"], oOe = ["title"], lOe = ["onClick"], rOe = ["onClick"], aOe = /* @__PURE__ */ le({
  name: "ElUploadList",
  __name: "upload-list",
  props: ZEe,
  emits: QEe,
  setup(e, { emit: t }) {
    const n = e, o = t, { t: l } = an(), r = Ve("upload"), a = Ve("icon"), i = Ve("list"), s = io(), c = /* @__PURE__ */ H(!1), u = O(() => [
      r.b("list"),
      r.bm("list", n.listType),
      r.is("disabled", s.value)
    ]), d = (f) => {
      o("remove", f);
    };
    return (f, p) => (G(), Me(mp, {
      tag: "ul",
      class: X(u.value),
      name: S(i).b()
    }, {
      default: Ee(() => [
        (G(!0), ue(
          Ge,
          null,
          on(f.files, (m, v) => (G(), ue("li", {
            key: m.uid || m.name,
            class: X([
              S(r).be("list", "item"),
              S(r).is(m.status),
              { focusing: c.value }
            ]),
            tabindex: S(s) ? void 0 : 0,
            "aria-disabled": S(s),
            role: "button",
            onKeydown: uo((h) => !S(s) && d(m), ["delete"]),
            onFocus: p[0] || (p[0] = (h) => c.value = !0),
            onBlur: p[1] || (p[1] = (h) => c.value = !1),
            onClick: p[2] || (p[2] = (h) => c.value = !1)
          }, [
            Oe(f.$slots, "default", {
              file: m,
              index: v
            }, () => [
              f.listType === "picture" || m.status !== "uploading" && f.listType === "picture-card" ? (G(), ue("img", {
                key: 0,
                class: X(S(r).be("list", "item-thumbnail")),
                src: m.url,
                crossorigin: f.crossorigin,
                alt: ""
              }, null, 10, tOe)) : Ie("v-if", !0),
              m.status === "uploading" || f.listType !== "picture-card" ? (G(), ue(
                "div",
                {
                  key: 1,
                  class: X(S(r).be("list", "item-info"))
                },
                [
                  ve("a", {
                    class: X(S(r).be("list", "item-name")),
                    onClick: Et((h) => f.handlePreview(m), ["prevent"])
                  }, [
                    $(S(ut), {
                      class: X(S(a).m("document"))
                    }, {
                      default: Ee(() => [
                        $(S(lse))
                      ]),
                      _: 1
                    }, 8, ["class"]),
                    ve("span", {
                      class: X(S(r).be("list", "item-file-name")),
                      title: m.name
                    }, qe(m.name), 11, oOe)
                  ], 10, nOe),
                  m.status === "uploading" ? (G(), Me(S(eV), {
                    key: 0,
                    type: f.listType === "picture-card" ? "circle" : "line",
                    "stroke-width": f.listType === "picture-card" ? 6 : 2,
                    percentage: Number(m.percentage),
                    style: gt(f.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                  }, null, 8, ["type", "stroke-width", "percentage", "style"])) : Ie("v-if", !0)
                ],
                2
              )) : Ie("v-if", !0),
              ve(
                "label",
                {
                  class: X(S(r).be("list", "item-status-label"))
                },
                [
                  f.listType === "text" ? (G(), Me(S(ut), {
                    key: 0,
                    class: X([S(a).m("upload-success"), S(a).m("circle-check")])
                  }, {
                    default: Ee(() => [
                      $(S(MO))
                    ]),
                    _: 1
                  }, 8, ["class"])) : ["picture-card", "picture"].includes(f.listType) ? (G(), Me(S(ut), {
                    key: 1,
                    class: X([S(a).m("upload-success"), S(a).m("check")])
                  }, {
                    default: Ee(() => [
                      $(S(ch))
                    ]),
                    _: 1
                  }, 8, ["class"])) : Ie("v-if", !0)
                ],
                2
              ),
              S(s) ? Ie("v-if", !0) : (G(), Me(S(ut), {
                key: 2,
                class: X(S(a).m("close")),
                onClick: (h) => d(m)
              }, {
                default: Ee(() => [
                  $(S(aa))
                ]),
                _: 1
              }, 8, ["class", "onClick"])),
              Ie(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
              Ie(" This is a bug which needs to be fixed "),
              Ie(" TODO: Fix the incorrect navigation interaction "),
              S(s) ? Ie("v-if", !0) : (G(), ue(
                "i",
                {
                  key: 3,
                  class: X(S(a).m("close-tip"))
                },
                qe(S(l)("el.upload.deleteTip")),
                3
              )),
              f.listType === "picture-card" ? (G(), ue(
                "span",
                {
                  key: 4,
                  class: X(S(r).be("list", "item-actions"))
                },
                [
                  ve("span", {
                    class: X(S(r).be("list", "item-preview")),
                    onClick: (h) => f.handlePreview(m)
                  }, [
                    $(S(ut), {
                      class: X(S(a).m("zoom-in"))
                    }, {
                      default: Ee(() => [
                        $(S(_7))
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ], 10, lOe),
                  S(s) ? Ie("v-if", !0) : (G(), ue("span", {
                    key: 0,
                    class: X(S(r).be("list", "item-delete")),
                    onClick: (h) => d(m)
                  }, [
                    $(S(ut), {
                      class: X(S(a).m("delete"))
                    }, {
                      default: Ee(() => [
                        $(S(nse))
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ], 10, rOe))
                ],
                2
              )) : Ie("v-if", !0)
            ])
          ], 42, eOe))),
          128
        )),
        Oe(f.$slots, "append")
      ]),
      _: 3
    }, 8, ["class", "name"]));
  }
});
var rM = /* @__PURE__ */ Je(aOe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-list.vue"]]);
const iOe = Xe({
  disabled: {
    type: Boolean,
    default: void 0
  },
  directory: Boolean
}), sOe = {
  file: (e) => We(e)
}, aM = "ElUploadDrag", cOe = /* @__PURE__ */ le({
  name: aM,
  __name: "upload-dragger",
  props: iOe,
  emits: sOe,
  setup(e, { emit: t }) {
    const n = e, o = t;
    ze(yz) || no(
      aM,
      "usage: <el-upload><el-upload-dragger /></el-upload>"
    );
    const r = Ve("upload"), a = /* @__PURE__ */ H(!1), i = io(), s = (p) => new Promise((m, v) => p.file(m, v)), c = (p) => Rt(this, null, function* () {
      try {
        if (p.isFile) {
          const m = yield s(
            p
          );
          return m.isDirectory = !1, [m];
        }
        if (p.isDirectory) {
          const m = p.createReader(), v = () => new Promise(
            (C, w) => m.readEntries(C, w)
          ), h = [];
          let g = yield v();
          for (; g.length > 0; )
            h.push(...g), g = yield v();
          const y = h.map(
            (C) => c(C).catch(() => [])
          ), b = yield Promise.all(y);
          return I0(b);
        }
      } catch (m) {
        return [];
      }
      return [];
    }), u = (p) => Rt(this, null, function* () {
      if (i.value)
        return;
      a.value = !1, p.stopPropagation();
      const m = Array.from(p.dataTransfer.files), v = p.dataTransfer.items || [];
      if (n.directory) {
        const h = Array.from(v).map((y) => {
          var b;
          return (b = y == null ? void 0 : y.webkitGetAsEntry) == null ? void 0 : b.call(y);
        }).filter((y) => y), g = yield Promise.all(h.map(c));
        o("file", I0(g));
        return;
      }
      m.forEach((h, g) => {
        var y;
        const b = v[g], C = (y = b == null ? void 0 : b.webkitGetAsEntry) == null ? void 0 : y.call(b);
        C && (h.isDirectory = C.isDirectory);
      }), o("file", m);
    }), d = () => {
      i.value || (a.value = !0);
    }, f = (p) => {
      p.currentTarget.contains(p.relatedTarget) || (a.value = !1);
    };
    return (p, m) => (G(), ue(
      "div",
      {
        class: X([S(r).b("dragger"), S(r).is("dragover", a.value)]),
        onDrop: Et(u, ["prevent"]),
        onDragover: Et(d, ["prevent"]),
        onDragleave: Et(f, ["prevent"])
      },
      [
        Oe(p.$slots, "default")
      ],
      34
    ));
  }
});
var uOe = /* @__PURE__ */ Je(cOe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-dragger.vue"]]);
const dOe = Xe(vt(Be({}, Cz), {
  beforeUpload: {
    type: ye(Function),
    default: gn
  },
  onRemove: {
    type: ye(Function),
    default: gn
  },
  onStart: {
    type: ye(Function),
    default: gn
  },
  onSuccess: {
    type: ye(
      Function
    ),
    default: gn
  },
  onProgress: {
    type: ye(Function),
    default: gn
  },
  onError: {
    type: ye(Function),
    default: gn
  },
  onExceed: {
    type: ye(Function),
    default: gn
  }
})), fOe = ["tabindex", "aria-disabled", "onKeydown"], pOe = ["name", "disabled", "multiple", "accept", "webkitdirectory"], vOe = /* @__PURE__ */ le({
  name: "ElUploadContent",
  inheritAttrs: !1,
  __name: "upload-content",
  props: dOe,
  setup(e, { expose: t }) {
    const n = e, o = Ve("upload"), l = io(), r = /* @__PURE__ */ Ce(
      {}
    ), a = /* @__PURE__ */ Ce(), i = (v) => {
      if (v.length === 0)
        return;
      const { autoUpload: h, limit: g, fileList: y, multiple: b, onStart: C, onExceed: w } = n;
      if (g && y.length + v.length > g) {
        w(v, y);
        return;
      }
      b || (v = v.slice(0, 1));
      for (const x of v) {
        const E = x;
        E.uid = Jx(), C(E), h && s(E);
      }
    }, s = (v) => Rt(this, null, function* () {
      if (a.value.value = "", !n.beforeUpload)
        return u(v);
      let h, g = {};
      try {
        const b = n.data, C = n.beforeUpload(v);
        g = Gv(n.data) ? sc(n.data) : n.data, h = yield C, Gv(n.data) && Jn(b, g) && (g = sc(n.data));
      } catch (b) {
        h = !1;
      }
      if (h === !1) {
        n.onRemove(v);
        return;
      }
      let y = v;
      h instanceof Blob && (h instanceof File ? y = h : y = new File([h], v.name, {
        type: v.type
      })), u(
        Object.assign(y, {
          uid: v.uid
        }),
        g
      );
    }), c = (v, h) => Rt(this, null, function* () {
      return it(v) ? v(h) : v;
    }), u = (v, h) => Rt(this, null, function* () {
      const {
        headers: g,
        data: y,
        method: b,
        withCredentials: C,
        name: w,
        action: x,
        onProgress: E,
        onSuccess: I,
        onError: T,
        httpRequest: P
      } = n;
      try {
        h = yield c(h != null ? h : y, v);
      } catch (z) {
        n.onRemove(v);
        return;
      }
      const { uid: k } = v, N = {
        headers: g || {},
        withCredentials: C,
        file: v,
        data: h,
        method: b,
        filename: w,
        action: x,
        onProgress: (z) => {
          E(z, v);
        },
        onSuccess: (z) => {
          I(z, v), delete r.value[k];
        },
        onError: (z) => {
          T(z, v), delete r.value[k];
        }
      }, R = P(N);
      r.value[k] = R, R instanceof Promise && R.then(N.onSuccess, N.onError);
    }), d = (v) => {
      const h = v.target.files;
      h && i(Array.from(h));
    }, f = () => {
      l.value || (a.value.value = "", a.value.click());
    }, p = () => {
      f();
    };
    return t({
      abort: (v) => {
        b7(r.value).filter(
          v ? ([g]) => String(v.uid) === g : () => !0
        ).forEach(([g, y]) => {
          y instanceof XMLHttpRequest && y.abort(), delete r.value[g];
        });
      },
      upload: s
    }), (v, h) => (G(), ue("div", {
      class: X([
        S(o).b(),
        S(o).m(v.listType),
        S(o).is("drag", v.drag),
        S(o).is("disabled", S(l))
      ]),
      tabindex: S(l) ? void 0 : 0,
      "aria-disabled": S(l),
      role: "button",
      onClick: f,
      onKeydown: uo(Et(p, ["self"]), ["enter", "space"])
    }, [
      v.drag ? (G(), Me(uOe, {
        key: 0,
        disabled: S(l),
        directory: v.directory,
        onFile: i
      }, {
        default: Ee(() => [
          Oe(v.$slots, "default")
        ]),
        _: 3
      }, 8, ["disabled", "directory"])) : Oe(v.$slots, "default", { key: 1 }),
      ve("input", {
        ref_key: "inputRef",
        ref: a,
        class: X(S(o).e("input")),
        name: v.name,
        disabled: S(l),
        multiple: v.multiple,
        accept: v.accept,
        webkitdirectory: v.directory,
        type: "file",
        onChange: d,
        onClick: h[0] || (h[0] = Et(() => {
        }, ["stop"]))
      }, null, 42, pOe)
    ], 42, fOe));
  }
});
var iM = /* @__PURE__ */ Je(vOe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload-content.vue"]]);
const sM = "ElUpload", cM = (e) => {
  var t;
  (t = e.url) != null && t.startsWith("blob:") && URL.revokeObjectURL(e.url);
}, mOe = (e, t) => {
  const n = c7(
    e,
    "fileList",
    void 0,
    { passive: !0 }
  ), o = (m) => n.value.find((v) => v.uid === m.uid);
  function l(m) {
    var v;
    (v = t.value) == null || v.abort(m);
  }
  function r(m = ["ready", "uploading", "success", "fail"]) {
    n.value = n.value.filter(
      (v) => !m.includes(v.status)
    );
  }
  function a(m) {
    n.value = n.value.filter(
      (v) => v.uid !== m.uid
    );
  }
  const i = (m) => {
    Ke(() => e.onChange(m, n.value));
  }, s = (m, v) => {
    const h = o(v);
    h && (console.error(m), h.status = "fail", a(h), e.onError(m, h, n.value), i(h));
  }, c = (m, v) => {
    const h = o(v);
    h && (e.onProgress(m, h, n.value), h.status = "uploading", h.percentage = Math.round(m.percent));
  }, u = (m, v) => {
    const h = o(v);
    h && (h.status = "success", h.response = m, e.onSuccess(m, h, n.value), i(h));
  }, d = (m) => {
    wo(m.uid) && (m.uid = Jx());
    const v = {
      name: m.name,
      percentage: 0,
      status: "ready",
      size: m.size,
      raw: m,
      uid: m.uid
    };
    if (e.listType === "picture-card" || e.listType === "picture")
      try {
        v.url = URL.createObjectURL(m);
      } catch (h) {
        Gt(sM, h.message), e.onError(h, v, n.value);
      }
    n.value = [...n.value, v], i(v);
  }, f = (m) => Rt(void 0, null, function* () {
    const v = m instanceof File ? o(m) : m;
    v || no(sM, "file to be removed not found");
    const h = (g) => {
      l(g), a(g), e.onRemove(g, n.value), cM(g);
    };
    e.beforeRemove ? (yield e.beforeRemove(v, n.value)) !== !1 && h(v) : h(v);
  });
  function p() {
    n.value.filter(({ status: m }) => m === "ready").forEach(({ raw: m }) => {
      var v;
      return m && ((v = t.value) == null ? void 0 : v.upload(m));
    });
  }
  return pe(
    () => e.listType,
    (m) => {
      m !== "picture-card" && m !== "picture" || (n.value = n.value.map((v) => {
        const { raw: h, url: g } = v;
        if (!g && h)
          try {
            v.url = URL.createObjectURL(h);
          } catch (y) {
            e.onError(y, v, n.value);
          }
        return v;
      }));
    }
  ), pe(
    n,
    (m) => {
      for (const v of m)
        v.uid || (v.uid = Jx()), v.status || (v.status = "success");
    },
    { immediate: !0, deep: !0 }
  ), {
    uploadFiles: n,
    abort: l,
    clearFiles: r,
    handleError: s,
    handleProgress: c,
    handleStart: d,
    handleSuccess: u,
    handleRemove: f,
    submit: p,
    revokeFileObjectURL: cM
  };
}, hOe = /* @__PURE__ */ le({
  name: "ElUpload",
  __name: "upload",
  props: JEe,
  setup(e, { expose: t }) {
    const n = e, o = io(), l = /* @__PURE__ */ Ce(), {
      abort: r,
      submit: a,
      clearFiles: i,
      uploadFiles: s,
      handleStart: c,
      handleError: u,
      handleRemove: d,
      handleSuccess: f,
      handleProgress: p,
      revokeFileObjectURL: m
    } = mOe(n, l), v = O(() => n.listType === "picture-card"), h = O(() => vt(Be({}, n), {
      fileList: s.value,
      onStart: c,
      onProgress: p,
      onSuccess: f,
      onError: u,
      onRemove: d
    }));
    return yt(() => {
      s.value.forEach(m);
    }), at(yz, {
      accept: /* @__PURE__ */ ft(n, "accept")
    }), t({
      abort: r,
      submit: a,
      clearFiles: i,
      handleStart: c,
      handleRemove: d
    }), (g, y) => (G(), ue("div", null, [
      v.value && g.showFileList ? (G(), Me(rM, {
        key: 0,
        disabled: S(o),
        "list-type": g.listType,
        files: S(s),
        crossorigin: g.crossorigin,
        "handle-preview": g.onPreview,
        onRemove: S(d)
      }, or({
        append: Ee(() => [
          $(
            iM,
            Ut({
              ref_key: "uploadRef",
              ref: l
            }, h.value),
            {
              default: Ee(() => [
                g.$slots.trigger ? Oe(g.$slots, "trigger", { key: 0 }) : Ie("v-if", !0),
                !g.$slots.trigger && g.$slots.default ? Oe(g.$slots, "default", { key: 1 }) : Ie("v-if", !0)
              ]),
              _: 3
            },
            16
          )
        ]),
        _: 2
      }, [
        g.$slots.file ? {
          name: "default",
          fn: Ee(({ file: b, index: C }) => [
            Oe(g.$slots, "file", {
              file: b,
              index: C
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : Ie("v-if", !0),
      !v.value || v.value && !g.showFileList ? (G(), Me(
        iM,
        Ut({
          key: 1,
          ref_key: "uploadRef",
          ref: l
        }, h.value),
        {
          default: Ee(() => [
            g.$slots.trigger ? Oe(g.$slots, "trigger", { key: 0 }) : Ie("v-if", !0),
            !g.$slots.trigger && g.$slots.default ? Oe(g.$slots, "default", { key: 1 }) : Ie("v-if", !0)
          ]),
          _: 3
        },
        16
      )) : Ie("v-if", !0),
      g.$slots.trigger ? Oe(g.$slots, "default", { key: 2 }) : Ie("v-if", !0),
      Oe(g.$slots, "tip"),
      !v.value && g.showFileList ? (G(), Me(rM, {
        key: 3,
        disabled: S(o),
        "list-type": g.listType,
        files: S(s),
        crossorigin: g.crossorigin,
        "handle-preview": g.onPreview,
        onRemove: S(d)
      }, or({
        _: 2
      }, [
        g.$slots.file ? {
          name: "default",
          fn: Ee(({ file: b, index: C }) => [
            Oe(g.$slots, "file", {
              file: b,
              index: C
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : Ie("v-if", !0)
    ]));
  }
});
var gOe = /* @__PURE__ */ Je(hOe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/upload/src/upload.vue"]]);
const bOe = Dt(gOe), yOe = Xe({
  zIndex: {
    type: Number,
    default: 9
  },
  rotate: {
    type: Number,
    default: -22
  },
  width: Number,
  height: Number,
  image: String,
  content: {
    type: ye([String, Array]),
    default: "Element Plus"
  },
  font: {
    type: ye(Object)
  },
  gap: {
    type: ye(Array),
    default: () => [100, 100]
  },
  offset: {
    type: ye(Array)
  }
});
function SOe(e) {
  return e.replace(/([A-Z])/g, "-$1").toLowerCase();
}
function COe(e) {
  return Object.keys(e).map(
    (t) => `${SOe(t)}: ${e[t]};`
  ).join(" ");
}
function wOe() {
  return window.devicePixelRatio || 1;
}
const $Oe = (e, t) => {
  let n = !1;
  return e.removedNodes.length && t && (n = Array.from(e.removedNodes).includes(t)), e.type === "attributes" && e.target === t && (n = !0), n;
}, xOe = {
  left: [0, 0.5],
  start: [0, 0.5],
  center: [0.5, 0],
  right: [1, -0.5],
  end: [1, -0.5]
};
function sw(e, t, n = 1) {
  const o = document.createElement("canvas"), l = o.getContext("2d"), r = e * n, a = t * n;
  return o.setAttribute("width", `${r}px`), o.setAttribute("height", `${a}px`), l.save(), [l, o, r, a];
}
function EOe() {
  function e(t, n, o, l, r, a, i, s, c) {
    const [u, d, f, p] = sw(
      l,
      r,
      o
    );
    let m = 0;
    if (t instanceof HTMLImageElement)
      u.drawImage(t, 0, 0, f, p);
    else {
      const {
        color: W,
        fontSize: Y,
        fontStyle: U,
        fontWeight: te,
        fontFamily: J,
        textAlign: re,
        textBaseline: oe
      } = a, q = Number(Y) * o;
      u.font = `${U} normal ${te} ${q}px/${r}px ${J}`, u.fillStyle = W, u.textAlign = re, u.textBaseline = oe;
      const K = We(t) ? t : [t];
      if (oe !== "top" && K[0]) {
        const se = u.measureText(K[0]);
        u.textBaseline = "top";
        const Z = u.measureText(K[0]);
        m = se.actualBoundingBoxAscent - Z.actualBoundingBoxAscent;
      }
      K == null || K.forEach((se, Z) => {
        const [ee, fe] = xOe[re];
        u.fillText(
          se != null ? se : "",
          f * ee + c * fe,
          Z * (q + a.fontGap * o)
        );
      });
    }
    const v = Math.PI / 180 * Number(n), h = Math.max(l, r), [g, y, b] = sw(h, h, o);
    g.translate(b / 2, b / 2), g.rotate(v), f > 0 && p > 0 && g.drawImage(d, -f / 2, -p / 2);
    function C(W, Y) {
      const U = W * Math.cos(v) - Y * Math.sin(v), te = W * Math.sin(v) + Y * Math.cos(v);
      return [U, te];
    }
    let w = 0, x = 0, E = 0, I = 0;
    const T = f / 2, P = p / 2;
    [
      [0 - T, 0 - P],
      [0 + T, 0 - P],
      [0 + T, 0 + P],
      [0 - T, 0 + P]
    ].forEach(([W, Y]) => {
      const [U, te] = C(W, Y);
      w = Math.min(w, U), x = Math.max(x, U), E = Math.min(E, te), I = Math.max(I, te);
    });
    const N = w + b / 2, R = E + b / 2, z = x - w, D = I - E, F = i * o, M = s * o, A = (z + F) * 2, L = D + M, [B, V] = sw(A, L);
    function j(W = 0, Y = 0) {
      B.drawImage(
        y,
        N,
        R,
        z,
        D,
        W,
        Y + m,
        z,
        D
      );
    }
    return j(), j(z + F, -D / 2 - M / 2), j(z + F, +D / 2 + M / 2), [V.toDataURL(), A / o, L / o];
  }
  return e;
}
const OOe = /* @__PURE__ */ le({
  name: "ElWatermark",
  __name: "watermark",
  props: yOe,
  setup(e) {
    const t = {
      position: "relative"
    }, n = e, o = O(() => {
      var k, N;
      return (N = (k = n.font) == null ? void 0 : k.fontGap) != null ? N : 3;
    }), l = O(() => {
      var k, N;
      return (N = (k = n.font) == null ? void 0 : k.color) != null ? N : "rgba(0,0,0,.15)";
    }), r = O(() => {
      var k, N;
      return (N = (k = n.font) == null ? void 0 : k.fontSize) != null ? N : 16;
    }), a = O(() => {
      var k, N;
      return (N = (k = n.font) == null ? void 0 : k.fontWeight) != null ? N : "normal";
    }), i = O(() => {
      var k, N;
      return (N = (k = n.font) == null ? void 0 : k.fontStyle) != null ? N : "normal";
    }), s = O(() => {
      var k, N;
      return (N = (k = n.font) == null ? void 0 : k.fontFamily) != null ? N : "sans-serif";
    }), c = O(() => {
      var k, N;
      return (N = (k = n.font) == null ? void 0 : k.textAlign) != null ? N : "center";
    }), u = O(() => {
      var k, N;
      return (N = (k = n.font) == null ? void 0 : k.textBaseline) != null ? N : "hanging";
    }), d = O(() => n.gap[0]), f = O(() => n.gap[1]), p = O(() => d.value / 2), m = O(() => f.value / 2), v = O(() => {
      var k, N;
      return (N = (k = n.offset) == null ? void 0 : k[0]) != null ? N : p.value;
    }), h = O(() => {
      var k, N;
      return (N = (k = n.offset) == null ? void 0 : k[1]) != null ? N : m.value;
    }), g = () => {
      const k = {
        zIndex: n.zIndex,
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
        backgroundRepeat: "repeat"
      };
      let N = v.value - p.value, R = h.value - m.value;
      return N > 0 && (k.left = `${N}px`, k.width = `calc(100% - ${N}px)`, N = 0), R > 0 && (k.top = `${R}px`, k.height = `calc(100% - ${R}px)`, R = 0), k.backgroundPosition = `${N}px ${R}px`, k;
    }, y = /* @__PURE__ */ Ce(null), b = /* @__PURE__ */ Ce(), C = /* @__PURE__ */ H(!1), w = () => {
      b.value && (b.value.remove(), b.value = void 0);
    }, x = (k, N) => {
      var R;
      y.value && b.value && (C.value = !0, b.value.setAttribute(
        "style",
        COe(vt(Be({}, g()), {
          backgroundImage: `url('${k}')`,
          backgroundSize: `${Math.floor(N)}px`
        }))
      ), (R = y.value) == null || R.append(b.value), setTimeout(() => {
        C.value = !1;
      }));
    }, E = (k) => {
      let N = 120, R = 64, z = 0;
      const { image: D, content: F, width: M, height: A, rotate: L } = n;
      if (!D && k.measureText) {
        k.font = `${Number(r.value)}px ${s.value}`;
        const B = We(F) ? F : [F];
        let V = 0, j = 0;
        B.forEach((Y) => {
          const {
            width: U,
            fontBoundingBoxAscent: te,
            fontBoundingBoxDescent: J,
            actualBoundingBoxAscent: re,
            actualBoundingBoxDescent: oe
          } = k.measureText(Y), q = fn(te) ? re + oe : te + J;
          U > V && (V = Math.ceil(U)), q > j && (j = Math.ceil(q));
        }), N = V, R = j * B.length + (B.length - 1) * o.value;
        const W = Math.PI / 180 * Number(L);
        z = Math.ceil(Math.abs(Math.sin(W) * R) / 2), N += z;
      }
      return [M != null ? M : N, A != null ? A : R, z];
    }, I = EOe(), T = () => {
      const N = document.createElement("canvas").getContext("2d"), R = n.image, z = n.content, D = n.rotate;
      if (N) {
        b.value || (b.value = document.createElement("div"));
        const F = wOe(), [M, A, L] = E(N), B = (V) => {
          const [j, W] = I(
            V || "",
            D,
            F,
            M,
            A,
            {
              color: l.value,
              fontSize: r.value,
              fontStyle: i.value,
              fontWeight: a.value,
              fontFamily: s.value,
              fontGap: o.value,
              textAlign: c.value,
              textBaseline: u.value
            },
            d.value,
            f.value,
            L
          );
          x(j, W);
        };
        if (R) {
          const V = new Image();
          V.onload = () => {
            B(V);
          }, V.onerror = () => {
            B(z);
          }, V.crossOrigin = "anonymous", V.referrerPolicy = "no-referrer", V.src = R;
        } else
          B(z);
      }
    };
    return nt(() => {
      T();
    }), pe(
      () => n,
      () => {
        T();
      },
      {
        deep: !0,
        flush: "post"
      }
    ), yt(() => {
      w();
    }), rh(y, (k) => {
      C.value || k.forEach((N) => {
        $Oe(N, b.value) && (w(), T());
      });
    }, {
      attributes: !0,
      subtree: !0,
      childList: !0
    }), (k, N) => (G(), ue(
      "div",
      {
        ref_key: "containerRef",
        ref: y,
        style: gt([t])
      },
      [
        Oe(k.$slots, "default")
      ],
      4
    ));
  }
});
var _Oe = /* @__PURE__ */ Je(OOe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/watermark/src/watermark.vue"]]);
const IOe = Dt(_Oe), TOe = Xe({
  zIndex: {
    type: Number,
    default: 1001
  },
  visible: Boolean,
  fill: {
    type: String,
    default: "rgba(0,0,0,0.5)"
  },
  pos: {
    type: ye(Object)
  },
  targetAreaClickable: {
    type: Boolean,
    default: !0
  }
}), ep = Math.min, _u = Math.max, J0 = Math.round, gg = Math.floor, gi = (e) => ({
  x: e,
  y: e
}), POe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, kOe = {
  start: "end",
  end: "start"
};
function Zx(e, t, n) {
  return _u(e, ep(t, n));
}
function Sh(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Wu(e) {
  return e.split("-")[0];
}
function Ch(e) {
  return e.split("-")[1];
}
function wz(e) {
  return e === "x" ? "y" : "x";
}
function H_(e) {
  return e === "y" ? "height" : "width";
}
const NOe = /* @__PURE__ */ new Set(["top", "bottom"]);
function nc(e) {
  return NOe.has(Wu(e)) ? "y" : "x";
}
function j_(e) {
  return wz(nc(e));
}
function MOe(e, t, n) {
  n === void 0 && (n = !1);
  const o = Ch(e), l = j_(e), r = H_(l);
  let a = l === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (a = Z0(a)), [a, Z0(a)];
}
function AOe(e) {
  const t = Z0(e);
  return [Qx(e), t, Qx(t)];
}
function Qx(e) {
  return e.replace(/start|end/g, (t) => kOe[t]);
}
const uM = ["left", "right"], dM = ["right", "left"], ROe = ["top", "bottom"], DOe = ["bottom", "top"];
function LOe(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? dM : uM : t ? uM : dM;
    case "left":
    case "right":
      return t ? ROe : DOe;
    default:
      return [];
  }
}
function BOe(e, t, n, o) {
  const l = Ch(e);
  let r = LOe(Wu(e), n === "start", o);
  return l && (r = r.map((a) => a + "-" + l), t && (r = r.concat(r.map(Qx)))), r;
}
function Z0(e) {
  return e.replace(/left|right|bottom|top/g, (t) => POe[t]);
}
function FOe(e) {
  return Be({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, e);
}
function $z(e) {
  return typeof e != "number" ? FOe(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function Q0(e) {
  const {
    x: t,
    y: n,
    width: o,
    height: l
  } = e;
  return {
    width: o,
    height: l,
    top: n,
    left: t,
    right: t + o,
    bottom: n + l,
    x: t,
    y: n
  };
}
function fM(e, t, n) {
  let {
    reference: o,
    floating: l
  } = e;
  const r = nc(t), a = j_(t), i = H_(a), s = Wu(t), c = r === "y", u = o.x + o.width / 2 - l.width / 2, d = o.y + o.height / 2 - l.height / 2, f = o[i] / 2 - l[i] / 2;
  let p;
  switch (s) {
    case "top":
      p = {
        x: u,
        y: o.y - l.height
      };
      break;
    case "bottom":
      p = {
        x: u,
        y: o.y + o.height
      };
      break;
    case "right":
      p = {
        x: o.x + o.width,
        y: d
      };
      break;
    case "left":
      p = {
        x: o.x - l.width,
        y: d
      };
      break;
    default:
      p = {
        x: o.x,
        y: o.y
      };
  }
  switch (Ch(t)) {
    case "start":
      p[a] -= f * (n && c ? -1 : 1);
      break;
    case "end":
      p[a] += f * (n && c ? -1 : 1);
      break;
  }
  return p;
}
const VOe = (e, t, n) => Rt(void 0, null, function* () {
  const {
    placement: o = "bottom",
    strategy: l = "absolute",
    middleware: r = [],
    platform: a
  } = n, i = r.filter(Boolean), s = yield a.isRTL == null ? void 0 : a.isRTL(t);
  let c = yield a.getElementRects({
    reference: e,
    floating: t,
    strategy: l
  }), {
    x: u,
    y: d
  } = fM(c, o, s), f = o, p = {}, m = 0;
  for (let v = 0; v < i.length; v++) {
    const {
      name: h,
      fn: g
    } = i[v], {
      x: y,
      y: b,
      data: C,
      reset: w
    } = yield g({
      x: u,
      y: d,
      initialPlacement: o,
      placement: f,
      strategy: l,
      middlewareData: p,
      rects: c,
      platform: a,
      elements: {
        reference: e,
        floating: t
      }
    });
    u = y != null ? y : u, d = b != null ? b : d, p = vt(Be({}, p), {
      [h]: Be(Be({}, p[h]), C)
    }), w && m <= 50 && (m++, typeof w == "object" && (w.placement && (f = w.placement), w.rects && (c = w.rects === !0 ? yield a.getElementRects({
      reference: e,
      floating: t,
      strategy: l
    }) : w.rects), {
      x: u,
      y: d
    } = fM(c, f, s)), v = -1);
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: l,
    middlewareData: p
  };
});
function W_(e, t) {
  return Rt(this, null, function* () {
    var n;
    t === void 0 && (t = {});
    const {
      x: o,
      y: l,
      platform: r,
      rects: a,
      elements: i,
      strategy: s
    } = e, {
      boundary: c = "clippingAncestors",
      rootBoundary: u = "viewport",
      elementContext: d = "floating",
      altBoundary: f = !1,
      padding: p = 0
    } = Sh(t, e), m = $z(p), h = i[f ? d === "floating" ? "reference" : "floating" : d], g = Q0(yield r.getClippingRect({
      element: (n = yield r.isElement == null ? void 0 : r.isElement(h)) == null || n ? h : h.contextElement || (yield r.getDocumentElement == null ? void 0 : r.getDocumentElement(i.floating)),
      boundary: c,
      rootBoundary: u,
      strategy: s
    })), y = d === "floating" ? {
      x: o,
      y: l,
      width: a.floating.width,
      height: a.floating.height
    } : a.reference, b = yield r.getOffsetParent == null ? void 0 : r.getOffsetParent(i.floating), C = (yield r.isElement == null ? void 0 : r.isElement(b)) ? (yield r.getScale == null ? void 0 : r.getScale(b)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    }, w = Q0(r.convertOffsetParentRelativeRectToViewportRelativeRect ? yield r.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements: i,
      rect: y,
      offsetParent: b,
      strategy: s
    }) : y);
    return {
      top: (g.top - w.top + m.top) / C.y,
      bottom: (w.bottom - g.bottom + m.bottom) / C.y,
      left: (g.left - w.left + m.left) / C.x,
      right: (w.right - g.right + m.right) / C.x
    };
  });
}
const zOe = (e) => ({
  name: "arrow",
  options: e,
  fn(n) {
    return Rt(this, null, function* () {
      const {
        x: o,
        y: l,
        placement: r,
        rects: a,
        platform: i,
        elements: s,
        middlewareData: c
      } = n, {
        element: u,
        padding: d = 0
      } = Sh(e, n) || {};
      if (u == null)
        return {};
      const f = $z(d), p = {
        x: o,
        y: l
      }, m = j_(r), v = H_(m), h = yield i.getDimensions(u), g = m === "y", y = g ? "top" : "left", b = g ? "bottom" : "right", C = g ? "clientHeight" : "clientWidth", w = a.reference[v] + a.reference[m] - p[m] - a.floating[v], x = p[m] - a.reference[m], E = yield i.getOffsetParent == null ? void 0 : i.getOffsetParent(u);
      let I = E ? E[C] : 0;
      (!I || !(yield i.isElement == null ? void 0 : i.isElement(E))) && (I = s.floating[C] || a.floating[v]);
      const T = w / 2 - x / 2, P = I / 2 - h[v] / 2 - 1, k = ep(f[y], P), N = ep(f[b], P), R = k, z = I - h[v] - N, D = I / 2 - h[v] / 2 + T, F = Zx(R, D, z), M = !c.arrow && Ch(r) != null && D !== F && a.reference[v] / 2 - (D < R ? k : N) - h[v] / 2 < 0, A = M ? D < R ? D - R : D - z : 0;
      return {
        [m]: p[m] + A,
        data: Be({
          [m]: F,
          centerOffset: D - F - A
        }, M && {
          alignmentOffset: A
        }),
        reset: M
      };
    });
  }
}), HOe = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    fn(n) {
      return Rt(this, null, function* () {
        var o, l;
        const {
          placement: r,
          middlewareData: a,
          rects: i,
          initialPlacement: s,
          platform: c,
          elements: u
        } = n, D = Sh(e, n), {
          mainAxis: d = !0,
          crossAxis: f = !0,
          fallbackPlacements: p,
          fallbackStrategy: m = "bestFit",
          fallbackAxisSideDirection: v = "none",
          flipAlignment: h = !0
        } = D, g = Hr(D, [
          "mainAxis",
          "crossAxis",
          "fallbackPlacements",
          "fallbackStrategy",
          "fallbackAxisSideDirection",
          "flipAlignment"
        ]);
        if ((o = a.arrow) != null && o.alignmentOffset)
          return {};
        const y = Wu(r), b = nc(s), C = Wu(s) === s, w = yield c.isRTL == null ? void 0 : c.isRTL(u.floating), x = p || (C || !h ? [Z0(s)] : AOe(s)), E = v !== "none";
        !p && E && x.push(...BOe(s, h, v, w));
        const I = [s, ...x], T = yield W_(n, g), P = [];
        let k = ((l = a.flip) == null ? void 0 : l.overflows) || [];
        if (d && P.push(T[y]), f) {
          const F = MOe(r, i, w);
          P.push(T[F[0]], T[F[1]]);
        }
        if (k = [...k, {
          placement: r,
          overflows: P
        }], !P.every((F) => F <= 0)) {
          var N, R;
          const F = (((N = a.flip) == null ? void 0 : N.index) || 0) + 1, M = I[F];
          if (M && (!(f === "alignment" ? b !== nc(M) : !1) || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          k.every((B) => nc(B.placement) === b ? B.overflows[0] > 0 : !0)))
            return {
              data: {
                index: F,
                overflows: k
              },
              reset: {
                placement: M
              }
            };
          let A = (R = k.filter((L) => L.overflows[0] <= 0).sort((L, B) => L.overflows[1] - B.overflows[1])[0]) == null ? void 0 : R.placement;
          if (!A)
            switch (m) {
              case "bestFit": {
                var z;
                const L = (z = k.filter((B) => {
                  if (E) {
                    const V = nc(B.placement);
                    return V === b || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    V === "y";
                  }
                  return !0;
                }).map((B) => [B.placement, B.overflows.filter((V) => V > 0).reduce((V, j) => V + j, 0)]).sort((B, V) => B[1] - V[1])[0]) == null ? void 0 : z[0];
                L && (A = L);
                break;
              }
              case "initialPlacement":
                A = s;
                break;
            }
          if (r !== A)
            return {
              reset: {
                placement: A
              }
            };
        }
        return {};
      });
    }
  };
}, jOe = /* @__PURE__ */ new Set(["left", "top"]);
function WOe(e, t) {
  return Rt(this, null, function* () {
    const {
      placement: n,
      platform: o,
      elements: l
    } = e, r = yield o.isRTL == null ? void 0 : o.isRTL(l.floating), a = Wu(n), i = Ch(n), s = nc(n) === "y", c = jOe.has(a) ? -1 : 1, u = r && s ? -1 : 1, d = Sh(t, e);
    let {
      mainAxis: f,
      crossAxis: p,
      alignmentAxis: m
    } = typeof d == "number" ? {
      mainAxis: d,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: d.mainAxis || 0,
      crossAxis: d.crossAxis || 0,
      alignmentAxis: d.alignmentAxis
    };
    return i && typeof m == "number" && (p = i === "end" ? m * -1 : m), s ? {
      x: p * u,
      y: f * c
    } : {
      x: f * c,
      y: p * u
    };
  });
}
const KOe = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    fn(n) {
      return Rt(this, null, function* () {
        var o, l;
        const {
          x: r,
          y: a,
          placement: i,
          middlewareData: s
        } = n, c = yield WOe(n, e);
        return i === ((o = s.offset) == null ? void 0 : o.placement) && (l = s.arrow) != null && l.alignmentOffset ? {} : {
          x: r + c.x,
          y: a + c.y,
          data: vt(Be({}, c), {
            placement: i
          })
        };
      });
    }
  };
}, UOe = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    fn(n) {
      return Rt(this, null, function* () {
        const {
          x: o,
          y: l,
          placement: r
        } = n, g = Sh(e, n), {
          mainAxis: a = !0,
          crossAxis: i = !1,
          limiter: s = {
            fn: (y) => {
              let {
                x: b,
                y: C
              } = y;
              return {
                x: b,
                y: C
              };
            }
          }
        } = g, c = Hr(g, [
          "mainAxis",
          "crossAxis",
          "limiter"
        ]), u = {
          x: o,
          y: l
        }, d = yield W_(n, c), f = nc(Wu(r)), p = wz(f);
        let m = u[p], v = u[f];
        if (a) {
          const y = p === "y" ? "top" : "left", b = p === "y" ? "bottom" : "right", C = m + d[y], w = m - d[b];
          m = Zx(C, m, w);
        }
        if (i) {
          const y = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", C = v + d[y], w = v - d[b];
          v = Zx(C, v, w);
        }
        const h = s.fn(vt(Be({}, n), {
          [p]: m,
          [f]: v
        }));
        return vt(Be({}, h), {
          data: {
            x: h.x - o,
            y: h.y - l,
            enabled: {
              [p]: a,
              [f]: i
            }
          }
        });
      });
    }
  };
};
function q1() {
  return typeof window != "undefined";
}
function _p(e) {
  return xz(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Ar(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Ai(e) {
  var t;
  return (t = (xz(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function xz(e) {
  return q1() ? e instanceof Node || e instanceof Ar(e).Node : !1;
}
function za(e) {
  return q1() ? e instanceof Element || e instanceof Ar(e).Element : !1;
}
function Ei(e) {
  return q1() ? e instanceof HTMLElement || e instanceof Ar(e).HTMLElement : !1;
}
function pM(e) {
  return !q1() || typeof ShadowRoot == "undefined" ? !1 : e instanceof ShadowRoot || e instanceof Ar(e).ShadowRoot;
}
const GOe = /* @__PURE__ */ new Set(["inline", "contents"]);
function wh(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: o,
    display: l
  } = Ha(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !GOe.has(l);
}
const YOe = /* @__PURE__ */ new Set(["table", "td", "th"]);
function XOe(e) {
  return YOe.has(_p(e));
}
const qOe = [":popover-open", ":modal"];
function J1(e) {
  return qOe.some((t) => {
    try {
      return e.matches(t);
    } catch (n) {
      return !1;
    }
  });
}
const JOe = ["transform", "translate", "scale", "rotate", "perspective"], ZOe = ["transform", "translate", "scale", "rotate", "perspective", "filter"], QOe = ["paint", "layout", "strict", "content"];
function K_(e) {
  const t = U_(), n = za(e) ? Ha(e) : e;
  return JOe.some((o) => n[o] ? n[o] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ZOe.some((o) => (n.willChange || "").includes(o)) || QOe.some((o) => (n.contain || "").includes(o));
}
function e_e(e) {
  let t = $c(e);
  for (; Ei(t) && !tp(t); ) {
    if (K_(t))
      return t;
    if (J1(t))
      return null;
    t = $c(t);
  }
  return null;
}
function U_() {
  return typeof CSS == "undefined" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const t_e = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function tp(e) {
  return t_e.has(_p(e));
}
function Ha(e) {
  return Ar(e).getComputedStyle(e);
}
function Z1(e) {
  return za(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function $c(e) {
  if (_p(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    pM(e) && e.host || // Fallback.
    Ai(e)
  );
  return pM(t) ? t.host : t;
}
function Ez(e) {
  const t = $c(e);
  return tp(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Ei(t) && wh(t) ? t : Ez(t);
}
function xm(e, t, n) {
  var o;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const l = Ez(e), r = l === ((o = e.ownerDocument) == null ? void 0 : o.body), a = Ar(l);
  if (r) {
    const i = e2(a);
    return t.concat(a, a.visualViewport || [], wh(l) ? l : [], i && n ? xm(i) : []);
  }
  return t.concat(l, xm(l, [], n));
}
function e2(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function Oz(e) {
  const t = Ha(e);
  let n = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0;
  const l = Ei(e), r = l ? e.offsetWidth : n, a = l ? e.offsetHeight : o, i = J0(n) !== r || J0(o) !== a;
  return i && (n = r, o = a), {
    width: n,
    height: o,
    $: i
  };
}
function G_(e) {
  return za(e) ? e : e.contextElement;
}
function hf(e) {
  const t = G_(e);
  if (!Ei(t))
    return gi(1);
  const n = t.getBoundingClientRect(), {
    width: o,
    height: l,
    $: r
  } = Oz(t);
  let a = (r ? J0(n.width) : n.width) / o, i = (r ? J0(n.height) : n.height) / l;
  return (!a || !Number.isFinite(a)) && (a = 1), (!i || !Number.isFinite(i)) && (i = 1), {
    x: a,
    y: i
  };
}
const n_e = /* @__PURE__ */ gi(0);
function _z(e) {
  const t = Ar(e);
  return !U_() || !t.visualViewport ? n_e : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function o_e(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Ar(e) ? !1 : t;
}
function Ku(e, t, n, o) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const l = e.getBoundingClientRect(), r = G_(e);
  let a = gi(1);
  t && (o ? za(o) && (a = hf(o)) : a = hf(e));
  const i = o_e(r, n, o) ? _z(r) : gi(0);
  let s = (l.left + i.x) / a.x, c = (l.top + i.y) / a.y, u = l.width / a.x, d = l.height / a.y;
  if (r) {
    const f = Ar(r), p = o && za(o) ? Ar(o) : o;
    let m = f, v = e2(m);
    for (; v && o && p !== m; ) {
      const h = hf(v), g = v.getBoundingClientRect(), y = Ha(v), b = g.left + (v.clientLeft + parseFloat(y.paddingLeft)) * h.x, C = g.top + (v.clientTop + parseFloat(y.paddingTop)) * h.y;
      s *= h.x, c *= h.y, u *= h.x, d *= h.y, s += b, c += C, m = Ar(v), v = e2(m);
    }
  }
  return Q0({
    width: u,
    height: d,
    x: s,
    y: c
  });
}
function Q1(e, t) {
  const n = Z1(e).scrollLeft;
  return t ? t.left + n : Ku(Ai(e)).left + n;
}
function Iz(e, t) {
  const n = e.getBoundingClientRect(), o = n.left + t.scrollLeft - Q1(e, n), l = n.top + t.scrollTop;
  return {
    x: o,
    y: l
  };
}
function l_e(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: o,
    strategy: l
  } = e;
  const r = l === "fixed", a = Ai(o), i = t ? J1(t.floating) : !1;
  if (o === a || i && r)
    return n;
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = gi(1);
  const u = gi(0), d = Ei(o);
  if ((d || !d && !r) && ((_p(o) !== "body" || wh(a)) && (s = Z1(o)), Ei(o))) {
    const p = Ku(o);
    c = hf(o), u.x = p.x + o.clientLeft, u.y = p.y + o.clientTop;
  }
  const f = a && !d && !r ? Iz(a, s) : gi(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - s.scrollLeft * c.x + u.x + f.x,
    y: n.y * c.y - s.scrollTop * c.y + u.y + f.y
  };
}
function r_e(e) {
  return Array.from(e.getClientRects());
}
function a_e(e) {
  const t = Ai(e), n = Z1(e), o = e.ownerDocument.body, l = _u(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), r = _u(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
  let a = -n.scrollLeft + Q1(e);
  const i = -n.scrollTop;
  return Ha(o).direction === "rtl" && (a += _u(t.clientWidth, o.clientWidth) - l), {
    width: l,
    height: r,
    x: a,
    y: i
  };
}
const vM = 25;
function i_e(e, t) {
  const n = Ar(e), o = Ai(e), l = n.visualViewport;
  let r = o.clientWidth, a = o.clientHeight, i = 0, s = 0;
  if (l) {
    r = l.width, a = l.height;
    const u = U_();
    (!u || u && t === "fixed") && (i = l.offsetLeft, s = l.offsetTop);
  }
  const c = Q1(o);
  if (c <= 0) {
    const u = o.ownerDocument, d = u.body, f = getComputedStyle(d), p = u.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, m = Math.abs(o.clientWidth - d.clientWidth - p);
    m <= vM && (r -= m);
  } else c <= vM && (r += c);
  return {
    width: r,
    height: a,
    x: i,
    y: s
  };
}
const s_e = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function c_e(e, t) {
  const n = Ku(e, !0, t === "fixed"), o = n.top + e.clientTop, l = n.left + e.clientLeft, r = Ei(e) ? hf(e) : gi(1), a = e.clientWidth * r.x, i = e.clientHeight * r.y, s = l * r.x, c = o * r.y;
  return {
    width: a,
    height: i,
    x: s,
    y: c
  };
}
function mM(e, t, n) {
  let o;
  if (t === "viewport")
    o = i_e(e, n);
  else if (t === "document")
    o = a_e(Ai(e));
  else if (za(t))
    o = c_e(t, n);
  else {
    const l = _z(e);
    o = {
      x: t.x - l.x,
      y: t.y - l.y,
      width: t.width,
      height: t.height
    };
  }
  return Q0(o);
}
function Tz(e, t) {
  const n = $c(e);
  return n === t || !za(n) || tp(n) ? !1 : Ha(n).position === "fixed" || Tz(n, t);
}
function u_e(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let o = xm(e, [], !1).filter((i) => za(i) && _p(i) !== "body"), l = null;
  const r = Ha(e).position === "fixed";
  let a = r ? $c(e) : e;
  for (; za(a) && !tp(a); ) {
    const i = Ha(a), s = K_(a);
    !s && i.position === "fixed" && (l = null), (r ? !s && !l : !s && i.position === "static" && !!l && s_e.has(l.position) || wh(a) && !s && Tz(e, a)) ? o = o.filter((u) => u !== a) : l = i, a = $c(a);
  }
  return t.set(e, o), o;
}
function d_e(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: o,
    strategy: l
  } = e;
  const a = [...n === "clippingAncestors" ? J1(t) ? [] : u_e(t, this._c) : [].concat(n), o], i = a[0], s = a.reduce((c, u) => {
    const d = mM(t, u, l);
    return c.top = _u(d.top, c.top), c.right = ep(d.right, c.right), c.bottom = ep(d.bottom, c.bottom), c.left = _u(d.left, c.left), c;
  }, mM(t, i, l));
  return {
    width: s.right - s.left,
    height: s.bottom - s.top,
    x: s.left,
    y: s.top
  };
}
function f_e(e) {
  const {
    width: t,
    height: n
  } = Oz(e);
  return {
    width: t,
    height: n
  };
}
function p_e(e, t, n) {
  const o = Ei(t), l = Ai(t), r = n === "fixed", a = Ku(e, !0, r, t);
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const s = gi(0);
  function c() {
    s.x = Q1(l);
  }
  if (o || !o && !r)
    if ((_p(t) !== "body" || wh(l)) && (i = Z1(t)), o) {
      const p = Ku(t, !0, r, t);
      s.x = p.x + t.clientLeft, s.y = p.y + t.clientTop;
    } else l && c();
  r && !o && l && c();
  const u = l && !o && !r ? Iz(l, i) : gi(0), d = a.left + i.scrollLeft - s.x - u.x, f = a.top + i.scrollTop - s.y - u.y;
  return {
    x: d,
    y: f,
    width: a.width,
    height: a.height
  };
}
function cw(e) {
  return Ha(e).position === "static";
}
function hM(e, t) {
  if (!Ei(e) || Ha(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Ai(e) === n && (n = n.ownerDocument.body), n;
}
function Pz(e, t) {
  const n = Ar(e);
  if (J1(e))
    return n;
  if (!Ei(e)) {
    let l = $c(e);
    for (; l && !tp(l); ) {
      if (za(l) && !cw(l))
        return l;
      l = $c(l);
    }
    return n;
  }
  let o = hM(e, t);
  for (; o && XOe(o) && cw(o); )
    o = hM(o, t);
  return o && tp(o) && cw(o) && !K_(o) ? n : o || e_e(e) || n;
}
const v_e = function(e) {
  return Rt(this, null, function* () {
    const t = this.getOffsetParent || Pz, n = this.getDimensions, o = yield n(e.floating);
    return {
      reference: p_e(e.reference, yield t(e.floating), e.strategy),
      floating: {
        x: 0,
        y: 0,
        width: o.width,
        height: o.height
      }
    };
  });
};
function m_e(e) {
  return Ha(e).direction === "rtl";
}
const h_e = {
  convertOffsetParentRelativeRectToViewportRelativeRect: l_e,
  getDocumentElement: Ai,
  getClippingRect: d_e,
  getOffsetParent: Pz,
  getElementRects: v_e,
  getClientRects: r_e,
  getDimensions: f_e,
  getScale: hf,
  isElement: za,
  isRTL: m_e
};
function kz(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function g_e(e, t) {
  let n = null, o;
  const l = Ai(e);
  function r() {
    var i;
    clearTimeout(o), (i = n) == null || i.disconnect(), n = null;
  }
  function a(i, s) {
    i === void 0 && (i = !1), s === void 0 && (s = 1), r();
    const c = e.getBoundingClientRect(), {
      left: u,
      top: d,
      width: f,
      height: p
    } = c;
    if (i || t(), !f || !p)
      return;
    const m = gg(d), v = gg(l.clientWidth - (u + f)), h = gg(l.clientHeight - (d + p)), g = gg(u), b = {
      rootMargin: -m + "px " + -v + "px " + -h + "px " + -g + "px",
      threshold: _u(0, ep(1, s)) || 1
    };
    let C = !0;
    function w(x) {
      const E = x[0].intersectionRatio;
      if (E !== s) {
        if (!C)
          return a();
        E ? a(!1, E) : o = setTimeout(() => {
          a(!1, 1e-7);
        }, 1e3);
      }
      E === 1 && !kz(c, e.getBoundingClientRect()) && a(), C = !1;
    }
    try {
      n = new IntersectionObserver(w, vt(Be({}, b), {
        // Handle <iframe>s
        root: l.ownerDocument
      }));
    } catch (x) {
      n = new IntersectionObserver(w, b);
    }
    n.observe(e);
  }
  return a(!0), r;
}
function b_e(e, t, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: l = !0,
    ancestorResize: r = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: i = typeof IntersectionObserver == "function",
    animationFrame: s = !1
  } = o, c = G_(e), u = l || r ? [...c ? xm(c) : [], ...xm(t)] : [];
  u.forEach((g) => {
    l && g.addEventListener("scroll", n, {
      passive: !0
    }), r && g.addEventListener("resize", n);
  });
  const d = c && i ? g_e(c, n) : null;
  let f = -1, p = null;
  a && (p = new ResizeObserver((g) => {
    let [y] = g;
    y && y.target === c && p && (p.unobserve(t), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var b;
      (b = p) == null || b.observe(t);
    })), n();
  }), c && !s && p.observe(c), p.observe(t));
  let m, v = s ? Ku(e) : null;
  s && h();
  function h() {
    const g = Ku(e);
    v && !kz(v, g) && n(), v = g, m = requestAnimationFrame(h);
  }
  return n(), () => {
    var g;
    u.forEach((y) => {
      l && y.removeEventListener("scroll", n), r && y.removeEventListener("resize", n);
    }), d == null || d(), (g = p) == null || g.disconnect(), p = null, s && cancelAnimationFrame(m);
  };
}
const y_e = W_, S_e = KOe, C_e = UOe, w_e = HOe, $_e = zOe, x_e = (e, t, n) => {
  const o = /* @__PURE__ */ new Map(), l = Be({
    platform: h_e
  }, n), r = vt(Be({}, l.platform), {
    _c: o
  });
  return VOe(e, t, vt(Be({}, l), {
    platform: r
  }));
}, E_e = (e, t, n, o, l) => {
  const r = /* @__PURE__ */ H(null), a = () => {
    let d;
    return rt(e.value) ? d = document.querySelector(e.value) : it(e.value) ? d = e.value() : d = e.value, d;
  }, i = () => {
    const d = a();
    if (!d || !t.value) {
      r.value = null;
      return;
    }
    O_e(d) || d.scrollIntoView(l.value);
    const { left: f, top: p, width: m, height: v } = d.getBoundingClientRect();
    r.value = {
      left: f,
      top: p,
      width: m,
      height: v,
      radius: 0
    };
  };
  nt(() => {
    pe(
      [t, e],
      () => {
        i();
      },
      {
        immediate: !0
      }
    ), window.addEventListener("resize", i);
  }), yt(() => {
    window.removeEventListener("resize", i);
  });
  const s = (d) => {
    var f;
    return (f = We(n.value.offset) ? n.value.offset[d] : n.value.offset) != null ? f : 6;
  }, c = O(() => {
    var d;
    if (!r.value)
      return r.value;
    const f = s(0), p = s(1), m = ((d = n.value) == null ? void 0 : d.radius) || 2;
    return {
      left: r.value.left - f,
      top: r.value.top - p,
      width: r.value.width + f * 2,
      height: r.value.height + p * 2,
      radius: m
    };
  }), u = O(() => {
    const d = a();
    return !o.value || !d || !window.DOMRect ? d || void 0 : {
      getBoundingClientRect() {
        var f, p, m, v;
        return window.DOMRect.fromRect({
          width: ((f = c.value) == null ? void 0 : f.width) || 0,
          height: ((p = c.value) == null ? void 0 : p.height) || 0,
          x: ((m = c.value) == null ? void 0 : m.left) || 0,
          y: ((v = c.value) == null ? void 0 : v.top) || 0
        });
      }
    };
  });
  return {
    mergedPosInfo: c,
    triggerTarget: u
  };
}, eS = Symbol("ElTour");
function O_e(e) {
  const t = window.innerWidth || document.documentElement.clientWidth, n = window.innerHeight || document.documentElement.clientHeight, { top: o, right: l, bottom: r, left: a } = e.getBoundingClientRect();
  return o >= 0 && a >= 0 && l <= t && r <= n;
}
const __e = (e, t, n, o, l, r, a, i) => {
  const s = /* @__PURE__ */ H(), c = /* @__PURE__ */ H(), u = /* @__PURE__ */ H({}), d = {
    x: s,
    y: c,
    placement: o,
    strategy: l,
    middlewareData: u
  }, f = O(() => {
    const g = [
      S_e(S(r)),
      w_e(),
      C_e(),
      I_e()
    ];
    return S(i) && S(n) && g.push(
      $_e({
        element: S(n)
      })
    ), g;
  }), p = () => Rt(void 0, null, function* () {
    if (!Sn)
      return;
    const g = S(e), y = S(t);
    if (!g || !y)
      return;
    const b = yield x_e(g, y, {
      placement: S(o),
      strategy: S(l),
      middleware: S(f)
    });
    im(d).forEach((C) => {
      d[C].value = b[C];
    });
  }), m = O(() => {
    if (!S(e))
      return {
        position: "fixed",
        top: "50%",
        left: "50%",
        transform: "translate3d(-50%, -50%, 0)",
        maxWidth: "100vw",
        zIndex: S(a)
      };
    const { overflow: g } = S(u);
    return {
      position: S(l),
      zIndex: S(a),
      top: S(c) != null ? `${S(c)}px` : "",
      left: S(s) != null ? `${S(s)}px` : "",
      maxWidth: g != null && g.maxWidth ? `${g == null ? void 0 : g.maxWidth}px` : ""
    };
  }), v = O(() => {
    if (!S(i))
      return {};
    const { arrow: g } = S(u);
    return {
      left: (g == null ? void 0 : g.x) != null ? `${g == null ? void 0 : g.x}px` : "",
      top: (g == null ? void 0 : g.y) != null ? `${g == null ? void 0 : g.y}px` : ""
    };
  });
  let h;
  return nt(() => {
    const g = S(e), y = S(t);
    g && y && (h = b_e(g, y, p)), Ot(() => {
      p();
    });
  }), yt(() => {
    h && h();
  }), {
    update: p,
    contentStyle: m,
    arrowStyle: v
  };
}, I_e = () => ({
  name: "overflow",
  fn(t) {
    return Rt(this, null, function* () {
      const n = yield y_e(t);
      let o = 0;
      return n.left > 0 && (o = n.left), n.right > 0 && (o = n.right), {
        data: {
          maxWidth: t.rects.floating.width - o
        }
      };
    });
  }
}), T_e = { style: {
  width: "100%",
  height: "100%"
} }, P_e = ["d"], k_e = /* @__PURE__ */ le({
  name: "ElTourMask",
  inheritAttrs: !1,
  __name: "mask",
  props: TOe,
  setup(e) {
    const t = e, { ns: n } = ze(eS), o = O(() => {
      var u, d;
      return (d = (u = t.pos) == null ? void 0 : u.radius) != null ? d : 2;
    }), l = O(() => {
      const u = o.value, d = `a${u},${u} 0 0 1`;
      return {
        topRight: `${d} ${u},${u}`,
        bottomRight: `${d} ${-u},${u}`,
        bottomLeft: `${d} ${-u},${-u}`,
        topLeft: `${d} ${u},${-u}`
      };
    }), { width: r, height: a } = TO(), i = O(() => {
      const u = r.value, d = a.value, f = l.value, p = `M${u},0 L0,0 L0,${d} L${u},${d} L${u},0 Z`, m = o.value;
      return t.pos ? `${p} M${t.pos.left + m},${t.pos.top} h${t.pos.width - m * 2} ${f.topRight} v${t.pos.height - m * 2} ${f.bottomRight} h${-t.pos.width + m * 2} ${f.bottomLeft} v${-t.pos.height + m * 2} ${f.topLeft} z` : p;
    }), s = O(() => ({
      position: "fixed",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      zIndex: t.zIndex,
      pointerEvents: t.pos && t.targetAreaClickable ? "none" : "auto"
    })), c = O(() => ({
      fill: t.fill,
      pointerEvents: "auto",
      cursor: "auto"
    }));
    return U1(/* @__PURE__ */ ft(t, "visible"), {
      ns: n
    }), (u, d) => u.visible ? (G(), ue(
      "div",
      Ut({
        key: 0,
        class: S(n).e("mask"),
        style: s.value
      }, u.$attrs),
      [
        (G(), ue("svg", T_e, [
          ve("path", {
            class: X(S(n).e("hollow")),
            style: gt(c.value),
            d: i.value
          }, null, 14, P_e)
        ]))
      ],
      16
    )) : Ie("v-if", !0);
  }
});
var N_e = /* @__PURE__ */ Je(k_e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tour/src/mask.vue"]]);
const M_e = ["absolute", "fixed"], A_e = [
  "top-start",
  "top-end",
  "top",
  "bottom-start",
  "bottom-end",
  "bottom",
  "left-start",
  "left-end",
  "left",
  "right-start",
  "right-end",
  "right"
], Y_ = Xe({
  placement: {
    type: ye(String),
    values: A_e,
    default: "bottom"
  },
  reference: {
    type: ye(Object),
    default: null
  },
  strategy: {
    type: ye(String),
    values: M_e,
    default: "absolute"
  },
  offset: {
    type: Number,
    default: 10
  },
  showArrow: Boolean,
  zIndex: {
    type: Number,
    default: 2001
  }
}), R_e = {
  close: () => !0
}, D_e = ["data-side"], L_e = /* @__PURE__ */ le({
  name: "ElTourContent",
  __name: "content",
  props: Y_,
  emits: R_e,
  setup(e, { emit: t }) {
    const n = e, o = t, l = /* @__PURE__ */ H(n.placement), r = /* @__PURE__ */ H(n.strategy), a = /* @__PURE__ */ H(null), i = /* @__PURE__ */ H(null);
    pe(
      () => n.placement,
      () => {
        l.value = n.placement;
      }
    );
    const { contentStyle: s, arrowStyle: c } = __e(
      /* @__PURE__ */ ft(n, "reference"),
      a,
      i,
      l,
      r,
      /* @__PURE__ */ ft(n, "offset"),
      /* @__PURE__ */ ft(n, "zIndex"),
      /* @__PURE__ */ ft(n, "showArrow")
    ), u = O(() => l.value.split("-")[0]), { ns: d } = ze(eS), f = () => {
      o("close");
    }, p = (m) => {
      m.detail.focusReason === "pointer" && m.preventDefault();
    };
    return (m, v) => (G(), ue("div", {
      ref_key: "contentRef",
      ref: a,
      style: gt(S(s)),
      class: X(S(d).e("content")),
      "data-side": u.value,
      tabindex: "-1"
    }, [
      $(S(xp), {
        loop: "",
        trapped: "",
        "focus-start-el": "container",
        "focus-trap-el": a.value || void 0,
        onReleaseRequested: f,
        onFocusoutPrevented: p
      }, {
        default: Ee(() => [
          Oe(m.$slots, "default")
        ]),
        _: 3
      }, 8, ["focus-trap-el"]),
      m.showArrow ? (G(), ue(
        "span",
        {
          key: 0,
          ref_key: "arrowRef",
          ref: i,
          style: gt(S(c)),
          class: X(S(d).e("arrow"))
        },
        null,
        6
      )) : Ie("v-if", !0)
    ], 14, D_e));
  }
});
var B_e = /* @__PURE__ */ Je(L_e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tour/src/content.vue"]]), F_e = /* @__PURE__ */ le({
  name: "ElTourSteps",
  props: {
    current: {
      type: Number,
      default: 0
    }
  },
  emits: ["update-total"],
  setup(e, { slots: t, emit: n }) {
    let o = 0;
    return () => {
      var l, r;
      const a = (l = t.default) == null ? void 0 : l.call(t), i = [];
      let s = 0;
      function c(u) {
        We(u) && u.forEach((d) => {
          var f;
          ((f = (d == null ? void 0 : d.type) || {}) == null ? void 0 : f.name) === "ElTourStep" && (i.push(d), s += 1);
        });
      }
      return a.length && c(Nr((r = a[0]) == null ? void 0 : r.children)), o !== s && (o = s, n("update-total", s)), i.length ? i[e.current] : null;
    };
  }
});
const V_e = Xe({
  modelValue: Boolean,
  current: {
    type: Number,
    default: 0
  },
  showArrow: {
    type: Boolean,
    default: !0
  },
  showClose: {
    type: Boolean,
    default: !0
  },
  closeIcon: {
    type: Pn
  },
  placement: Y_.placement,
  contentStyle: {
    type: ye([Object])
  },
  mask: {
    type: ye([Boolean, Object]),
    default: !0
  },
  gap: {
    type: ye(Object),
    default: () => ({
      offset: 6,
      radius: 2
    })
  },
  zIndex: {
    type: Number
  },
  scrollIntoViewOptions: {
    type: ye([Boolean, Object]),
    default: () => ({
      block: "center"
    })
  },
  type: {
    type: ye(String)
  },
  appendTo: {
    type: sh.to.type,
    default: "body"
  },
  closeOnPressEscape: {
    type: Boolean,
    default: !0
  },
  targetAreaClickable: {
    type: Boolean,
    default: !0
  }
}), z_e = {
  [It]: (e) => Tn(e),
  "update:current": (e) => mt(e),
  close: (e) => mt(e),
  finish: () => !0,
  change: (e) => mt(e)
}, H_e = /* @__PURE__ */ le({
  name: "ElTour",
  inheritAttrs: !1,
  __name: "tour",
  props: V_e,
  emits: z_e,
  setup(e, { emit: t }) {
    const n = e, o = t, l = Ve("tour"), r = /* @__PURE__ */ H(0), a = /* @__PURE__ */ H(), i = c7(n, "current", o, {
      passive: !0
    }), s = O(() => {
      var P;
      return (P = a.value) == null ? void 0 : P.target;
    }), c = O(() => [
      l.b(),
      g.value === "primary" ? l.m("primary") : ""
    ]), u = O(
      () => {
        var P;
        return ((P = a.value) == null ? void 0 : P.placement) || n.placement;
      }
    ), d = O(
      () => {
        var P, k;
        return (k = (P = a.value) == null ? void 0 : P.contentStyle) != null ? k : n.contentStyle;
      }
    ), f = O(() => {
      var P, k;
      return (k = (P = a.value) == null ? void 0 : P.mask) != null ? k : n.mask;
    }), p = O(() => !!f.value && n.modelValue), m = O(
      () => Tn(f.value) ? void 0 : f.value
    ), v = O(
      () => {
        var P, k;
        return !!s.value && ((k = (P = a.value) == null ? void 0 : P.showArrow) != null ? k : n.showArrow);
      }
    ), h = O(
      () => {
        var P, k;
        return (k = (P = a.value) == null ? void 0 : P.scrollIntoViewOptions) != null ? k : n.scrollIntoViewOptions;
      }
    ), g = O(() => {
      var P, k;
      return (k = (P = a.value) == null ? void 0 : P.type) != null ? k : n.type;
    }), { nextZIndex: y } = ah(), b = y(), C = O(() => {
      var P;
      return (P = n.zIndex) != null ? P : b;
    }), { mergedPosInfo: w, triggerTarget: x } = E_e(
      s,
      /* @__PURE__ */ ft(n, "modelValue"),
      /* @__PURE__ */ ft(n, "gap"),
      f,
      h
    );
    pe(
      () => n.modelValue,
      (P) => {
        P || (i.value = 0);
      }
    );
    const E = () => {
      n.closeOnPressEscape && (o(It, !1), o("close", i.value));
    }, I = (P) => {
      r.value = P;
    }, T = So();
    return at(eS, {
      currentStep: a,
      current: i,
      total: r,
      showClose: /* @__PURE__ */ ft(n, "showClose"),
      closeIcon: /* @__PURE__ */ ft(n, "closeIcon"),
      mergedType: g,
      ns: l,
      slots: T,
      updateModelValue(P) {
        o(It, P);
      },
      onClose() {
        o("close", i.value);
      },
      onFinish() {
        o("finish");
      },
      onChange() {
        o(en, i.value);
      }
    }), (P, k) => (G(), ue(
      Ge,
      null,
      [
        $(S($p), { to: P.appendTo }, {
          default: Ee(() => {
            var N, R;
            return [
              ve(
                "div",
                Ut({ class: c.value }, P.$attrs),
                [
                  $(N_e, {
                    visible: p.value,
                    fill: (N = m.value) == null ? void 0 : N.color,
                    style: gt((R = m.value) == null ? void 0 : R.style),
                    pos: S(w),
                    "z-index": C.value,
                    "target-area-clickable": P.targetAreaClickable
                  }, null, 8, ["visible", "fill", "style", "pos", "z-index", "target-area-clickable"]),
                  P.modelValue ? (G(), Me(B_e, {
                    key: S(i),
                    reference: S(x),
                    placement: u.value,
                    "show-arrow": v.value,
                    "z-index": C.value,
                    style: gt(d.value),
                    onClose: E
                  }, {
                    default: Ee(() => [
                      $(S(F_e), {
                        current: S(i),
                        onUpdateTotal: I
                      }, {
                        default: Ee(() => [
                          Oe(P.$slots, "default")
                        ]),
                        _: 3
                      }, 8, ["current"])
                    ]),
                    _: 3
                  }, 8, ["reference", "placement", "show-arrow", "z-index", "style"])) : Ie("v-if", !0)
                ],
                16
              )
            ];
          }),
          _: 3
        }, 8, ["to"]),
        Ie(" just for IDE "),
        Ie("v-if", !0)
      ],
      64
    ));
  }
});
var j_e = /* @__PURE__ */ Je(H_e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tour/src/tour.vue"]]);
const W_e = Xe({
  target: {
    type: ye([String, Object, Function])
  },
  title: String,
  description: String,
  showClose: {
    type: Boolean,
    default: void 0
  },
  closeIcon: {
    type: Pn
  },
  showArrow: {
    type: Boolean,
    default: void 0
  },
  placement: Y_.placement,
  mask: {
    type: ye([Boolean, Object]),
    default: void 0
  },
  contentStyle: {
    type: ye([Object])
  },
  prevButtonProps: {
    type: ye(Object)
  },
  nextButtonProps: {
    type: ye(Object)
  },
  scrollIntoViewOptions: {
    type: ye([Boolean, Object]),
    default: void 0
  },
  type: {
    type: ye(String)
  }
}), K_e = {
  close: () => !0
}, U_e = ["aria-label"], G_e = /* @__PURE__ */ le({
  name: "ElTourStep",
  __name: "step",
  props: W_e,
  emits: K_e,
  setup(e, { emit: t }) {
    const n = e, o = t, { Close: l } = I7, { t: r } = an(), {
      currentStep: a,
      current: i,
      total: s,
      showClose: c,
      closeIcon: u,
      mergedType: d,
      ns: f,
      slots: p,
      updateModelValue: m,
      onClose: v,
      onFinish: h,
      onChange: g
    } = ze(eS);
    pe(
      n,
      (P) => {
        a.value = P;
      },
      {
        immediate: !0
      }
    );
    const y = O(() => {
      var P;
      return (P = n.showClose) != null ? P : c.value;
    }), b = O(
      () => {
        var P, k;
        return (k = (P = n.closeIcon) != null ? P : u.value) != null ? k : l;
      }
    ), C = (P) => {
      if (P)
        return Cp(P, ["children", "onClick"]);
    }, w = () => {
      var P, k;
      i.value -= 1, (P = n.prevButtonProps) != null && P.onClick && ((k = n.prevButtonProps) == null || k.onClick()), g();
    }, x = () => {
      var P;
      i.value >= s.value - 1 ? E() : i.value += 1, (P = n.nextButtonProps) != null && P.onClick && n.nextButtonProps.onClick(), g();
    }, E = () => {
      I(), h();
    }, I = () => {
      m(!1), v(), o("close");
    }, T = (P) => {
      const k = P.target;
      if (k != null && k.isContentEditable)
        return;
      switch (Nn(P)) {
        case Ye.left:
          P.preventDefault(), i.value > 0 && w();
          break;
        case Ye.right:
          P.preventDefault(), x();
          break;
      }
    };
    return nt(() => {
      window.addEventListener("keydown", T);
    }), yt(() => {
      window.removeEventListener("keydown", T);
    }), (P, k) => (G(), ue(
      Ge,
      null,
      [
        y.value ? (G(), ue("button", {
          key: 0,
          "aria-label": S(r)("el.tour.close"),
          class: X(S(f).e("closebtn")),
          type: "button",
          onClick: I
        }, [
          $(S(ut), {
            class: X(S(f).e("close"))
          }, {
            default: Ee(() => [
              (G(), Me(Ht(b.value)))
            ]),
            _: 1
          }, 8, ["class"])
        ], 10, U_e)) : Ie("v-if", !0),
        ve(
          "header",
          {
            class: X([S(f).e("header"), { "show-close": S(c) }])
          },
          [
            Oe(P.$slots, "header", {}, () => [
              ve(
                "span",
                {
                  role: "heading",
                  class: X(S(f).e("title"))
                },
                qe(P.title),
                3
              )
            ])
          ],
          2
        ),
        ve(
          "div",
          {
            class: X(S(f).e("body"))
          },
          [
            Oe(P.$slots, "default", {}, () => [
              ve(
                "span",
                null,
                qe(P.description),
                1
              )
            ])
          ],
          2
        ),
        ve(
          "footer",
          {
            class: X(S(f).e("footer"))
          },
          [
            ve(
              "div",
              {
                class: X(S(f).b("indicators"))
              },
              [
                S(p).indicators ? (G(), Me(Ht(S(p).indicators), {
                  key: 0,
                  current: S(i),
                  total: S(s)
                }, null, 8, ["current", "total"])) : (G(!0), ue(
                  Ge,
                  { key: 1 },
                  on(S(s), (N, R) => (G(), ue(
                    "span",
                    {
                      key: N,
                      class: X([S(f).b("indicator"), S(f).is("active", R === S(i))])
                    },
                    null,
                    2
                  ))),
                  128
                ))
              ],
              2
            ),
            ve(
              "div",
              {
                class: X(S(f).b("buttons"))
              },
              [
                S(i) > 0 ? (G(), Me(S(Qo), Ut({
                  key: 0,
                  size: "small",
                  type: S(d)
                }, C(P.prevButtonProps), { onClick: w }), {
                  default: Ee(() => {
                    var N, R;
                    return [
                      Ft(
                        qe((R = (N = P.prevButtonProps) == null ? void 0 : N.children) != null ? R : S(r)("el.tour.previous")),
                        1
                      )
                    ];
                  }),
                  _: 1
                }, 16, ["type"])) : Ie("v-if", !0),
                S(i) <= S(s) - 1 ? (G(), Me(S(Qo), Ut({
                  key: 1,
                  size: "small",
                  type: S(d) === "primary" ? "default" : "primary"
                }, C(P.nextButtonProps), { onClick: x }), {
                  default: Ee(() => {
                    var N, R;
                    return [
                      Ft(
                        qe((R = (N = P.nextButtonProps) == null ? void 0 : N.children) != null ? R : S(i) === S(s) - 1 ? S(r)("el.tour.finish") : S(r)("el.tour.next")),
                        1
                      )
                    ];
                  }),
                  _: 1
                }, 16, ["type"])) : Ie("v-if", !0)
              ],
              2
            )
          ],
          2
        )
      ],
      64
    ));
  }
});
var Nz = /* @__PURE__ */ Je(G_e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tour/src/step.vue"]]);
const Y_e = Dt(j_e, {
  TourStep: Nz
}), X_e = oo(Nz), q_e = Xe({
  container: {
    type: ye([
      String,
      Object
    ])
  },
  offset: {
    type: Number,
    default: 0
  },
  bound: {
    type: Number,
    default: 15
  },
  duration: {
    type: Number,
    default: 300
  },
  marker: {
    type: Boolean,
    default: !0
  },
  type: {
    type: ye(String),
    default: "default"
  },
  direction: {
    type: ye(String),
    default: "vertical"
  },
  selectScrollTop: Boolean
}), J_e = {
  change: (e) => rt(e),
  click: (e, t) => e instanceof MouseEvent && (rt(t) || fn(t))
}, Mz = Symbol("anchor"), bg = (e) => {
  if (!Sn || e === "")
    return null;
  if (rt(e))
    try {
      return document.querySelector(e);
    } catch (t) {
      return null;
    }
  return e;
};
function Z_e(e) {
  let t = 0;
  const n = (...o) => {
    t && vs(t), t = Ci(() => {
      e(...o), t = 0;
    });
  };
  return n.cancel = () => {
    vs(t), t = 0;
  }, n;
}
const Q_e = /* @__PURE__ */ le({
  name: "ElAnchor",
  __name: "anchor",
  props: q_e,
  emits: J_e,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = So(), a = /* @__PURE__ */ H(""), i = /* @__PURE__ */ H({}), s = /* @__PURE__ */ H(null), c = /* @__PURE__ */ H(null), u = /* @__PURE__ */ H(), d = {};
    let f = !1, p = 0;
    const m = Ve("anchor"), v = O(() => [
      m.b(),
      o.type === "underline" ? m.m("underline") : "",
      m.m(o.direction)
    ]), h = (N) => {
      d[N.href] = N.el;
    }, g = (N) => {
      delete d[N];
    }, y = (N) => {
      a.value !== N && (a.value = N, l(en, N));
    };
    let b = null, C = "";
    const w = (N) => {
      if (!u.value)
        return;
      const R = bg(N);
      if (!R)
        return;
      if (b) {
        if (C === N)
          return;
        b();
      }
      C = N, f = !0;
      const z = f3(R, u.value), D = gx(R, z), F = z.scrollHeight - z.clientHeight, M = Math.min(D - o.offset, F);
      b = _ie(
        u.value,
        p,
        M,
        o.duration,
        () => {
          setTimeout(() => {
            f = !1, C = "";
          }, 20);
        }
      );
    }, x = (N) => {
      N && (y(N), w(N));
    }, E = (N, R) => {
      l("click", N, R), x(R);
    }, I = Z_e(() => {
      u.value && (p = p3(u.value));
      const N = T();
      f || fn(N) || y(N);
    }), T = () => {
      if (!u.value)
        return;
      const N = p3(u.value), R = [];
      for (const z of Object.keys(d)) {
        const D = bg(z);
        if (!D)
          continue;
        const F = f3(D, u.value), M = gx(D, F);
        R.push({
          top: M - o.offset - o.bound,
          href: z
        });
      }
      R.sort((z, D) => z.top - D.top);
      for (let z = 0; z < R.length; z++) {
        const D = R[z], F = R[z + 1];
        if (z === 0 && N === 0)
          return o.selectScrollTop ? D.href : "";
        if (D.top <= N && (!F || F.top > N))
          return D.href;
      }
    }, P = () => {
      const N = bg(o.container);
      !N || oh(N) ? u.value = window : u.value = N;
    };
    wn(u, "scroll", I);
    const k = () => {
      Ke(() => {
        if (!s.value || !c.value || !a.value) {
          i.value = {};
          return;
        }
        const N = d[a.value];
        if (!N) {
          i.value = {};
          return;
        }
        const R = s.value.getBoundingClientRect(), z = c.value.getBoundingClientRect(), D = N.getBoundingClientRect();
        if (o.direction === "horizontal") {
          const F = D.left - R.left;
          i.value = {
            left: `${F}px`,
            width: `${D.width}px`,
            opacity: 1
          };
        } else {
          const F = D.top - R.top + (D.height - z.height) / 2;
          i.value = {
            top: `${F}px`,
            opacity: 1
          };
        }
      });
    };
    return pe(a, k), pe(() => {
      var N;
      return (N = r.default) == null ? void 0 : N.call(r);
    }, k), nt(() => {
      P();
      const N = decodeURIComponent(window.location.hash);
      bg(N) ? x(N) : I();
    }), pe(
      () => o.container,
      () => {
        P();
      }
    ), at(Mz, {
      ns: m,
      direction: o.direction,
      currentAnchor: a,
      addLink: h,
      removeLink: g,
      handleClick: E
    }), t({
      scrollTo: x
    }), (N, R) => (G(), ue(
      "div",
      {
        ref_key: "anchorRef",
        ref: s,
        class: X(v.value)
      },
      [
        N.marker ? (G(), ue(
          "div",
          {
            key: 0,
            ref_key: "markerRef",
            ref: c,
            class: X(S(m).e("marker")),
            style: gt(i.value)
          },
          null,
          6
        )) : Ie("v-if", !0),
        ve(
          "div",
          {
            class: X(S(m).e("list"))
          },
          [
            Oe(N.$slots, "default")
          ],
          2
        )
      ],
      2
    ));
  }
});
var eIe = /* @__PURE__ */ Je(Q_e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/anchor/src/anchor.vue"]]);
const tIe = Xe({
  title: String,
  href: String
}), nIe = ["href"], oIe = /* @__PURE__ */ le({
  name: "ElAnchorLink",
  __name: "anchor-link",
  props: tIe,
  setup(e) {
    const t = e, n = /* @__PURE__ */ H(null), {
      ns: o,
      direction: l,
      currentAnchor: r,
      addLink: a,
      removeLink: i,
      handleClick: s
    } = ze(Mz), c = O(() => [
      o.e("link"),
      o.is("active", r.value === t.href)
    ]), u = (d) => {
      s(d, t.href);
    };
    return pe(
      () => t.href,
      (d, f) => {
        Ke(() => {
          f && i(f), d && a({
            href: d,
            el: n.value
          });
        });
      }
    ), nt(() => {
      const { href: d } = t;
      d && a({
        href: d,
        el: n.value
      });
    }), yt(() => {
      const { href: d } = t;
      d && i(d);
    }), (d, f) => (G(), ue(
      "div",
      {
        class: X(S(o).e("item"))
      },
      [
        ve("a", {
          ref_key: "linkRef",
          ref: n,
          class: X(c.value),
          href: d.href,
          onClick: u
        }, [
          Oe(d.$slots, "default", {}, () => [
            Ft(
              qe(d.title),
              1
            )
          ])
        ], 10, nIe),
        d.$slots["sub-link"] && S(l) === "vertical" ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(o).e("list"))
          },
          [
            Oe(d.$slots, "sub-link")
          ],
          2
        )) : Ie("v-if", !0)
      ],
      2
    ));
  }
});
var Az = /* @__PURE__ */ Je(oIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/anchor/src/anchor-link.vue"]]);
const lIe = Dt(eIe, {
  AnchorLink: Az
}), rIe = oo(Az), Rz = {
  label: "label",
  value: "value",
  disabled: "disabled"
}, aIe = Xe(Be({
  direction: {
    type: ye(String),
    default: "horizontal"
  },
  options: {
    type: ye(Array),
    default: () => []
  },
  modelValue: {
    type: [String, Number, Boolean],
    default: void 0
  },
  props: {
    type: ye(Object),
    default: () => Rz
  },
  block: Boolean,
  size: Bo,
  disabled: {
    type: Boolean,
    default: void 0
  },
  validateEvent: {
    type: Boolean,
    default: !0
  },
  id: String,
  name: String
}, zl(["ariaLabel"]))), iIe = {
  [It]: (e) => rt(e) || mt(e) || Tn(e),
  [en]: (e) => rt(e) || mt(e) || Tn(e)
}, sIe = ["id", "aria-label", "aria-labelledby"], cIe = ["name", "disabled", "checked", "onChange"], uIe = /* @__PURE__ */ le({
  name: "ElSegmented",
  __name: "segmented",
  props: aIe,
  emits: iIe,
  setup(e, { emit: t }) {
    const n = e, o = t, l = Ve("segmented"), r = ml(), a = Mo(), i = io(), { formItem: s } = cl(), { inputId: c, isLabeledByFormItem: u } = zr(n, {
      formItemContext: s
    }), d = /* @__PURE__ */ H(null), f = nie(), p = /* @__PURE__ */ kt({
      isInit: !1,
      width: 0,
      height: 0,
      translateX: 0,
      translateY: 0,
      focusVisible: !1
    }), m = (N, R) => {
      const z = g(R);
      o(It, z), o(en, z), N.target.checked = z === n.modelValue;
    }, v = O(() => Be(Be({}, Rz), n.props)), h = (N) => N, g = (N) => Mt(N) ? N[v.value.value] : N, y = (N) => Mt(N) ? N[v.value.label] : N, b = (N) => !!(i.value || Mt(N) && N[v.value.disabled]), C = (N) => n.modelValue === g(N), w = (N) => n.options.find((R) => g(R) === N), x = (N) => [
      l.e("item"),
      l.is("selected", C(N)),
      l.is("disabled", b(N))
    ], E = () => {
      if (!d.value)
        return;
      const N = d.value.querySelector(
        ".is-selected"
      ), R = d.value.querySelector(
        ".is-selected input"
      );
      if (!N || !R) {
        p.width = 0, p.height = 0, p.translateX = 0, p.translateY = 0, p.focusVisible = !1;
        return;
      }
      p.isInit = !0, n.direction === "vertical" ? (p.height = N.offsetHeight, p.translateY = N.offsetTop) : (p.width = N.offsetWidth, p.translateX = N.offsetLeft);
      try {
        p.focusVisible = R.matches(":focus-visible");
      } catch (z) {
      }
    }, I = O(() => [
      l.b(),
      l.m(a.value),
      l.is("block", n.block)
    ]), T = O(() => ({
      width: n.direction === "vertical" ? "100%" : `${p.width}px`,
      height: n.direction === "vertical" ? `${p.height}px` : "100%",
      transform: n.direction === "vertical" ? `translateY(${p.translateY}px)` : `translateX(${p.translateX}px)`,
      display: p.isInit ? "block" : "none"
    })), P = O(() => [
      l.e("item-selected"),
      l.is("disabled", b(w(n.modelValue))),
      l.is("focus-visible", p.focusVisible)
    ]), k = O(() => n.name || r.value);
    return Xn(d, E), pe(f, E), pe(
      () => n.modelValue,
      () => {
        var N;
        E(), n.validateEvent && ((N = s == null ? void 0 : s.validate) == null || N.call(s, "change").catch((R) => Gt(R)));
      },
      {
        flush: "post"
      }
    ), (N, R) => N.options.length ? (G(), ue("div", {
      key: 0,
      id: S(c),
      ref_key: "segmentedRef",
      ref: d,
      class: X(I.value),
      role: "radiogroup",
      "aria-label": S(u) ? void 0 : N.ariaLabel || "segmented",
      "aria-labelledby": S(u) ? S(s).labelId : void 0
    }, [
      ve(
        "div",
        {
          class: X([S(l).e("group"), S(l).m(N.direction)])
        },
        [
          ve(
            "div",
            {
              style: gt(T.value),
              class: X(P.value)
            },
            null,
            6
          ),
          (G(!0), ue(
            Ge,
            null,
            on(N.options, (z, D) => (G(), ue(
              "label",
              {
                key: D,
                class: X(x(z))
              },
              [
                ve("input", {
                  class: X(S(l).e("item-input")),
                  type: "radio",
                  name: k.value,
                  disabled: b(z),
                  checked: C(z),
                  onChange: (F) => m(F, z)
                }, null, 42, cIe),
                ve(
                  "div",
                  {
                    class: X(S(l).e("item-label"))
                  },
                  [
                    Oe(N.$slots, "default", {
                      item: h(z)
                    }, () => [
                      Ft(
                        qe(y(z)),
                        1
                      )
                    ])
                  ],
                  2
                )
              ],
              2
            ))),
            128
          ))
        ],
        2
      )
    ], 10, sIe)) : Ie("v-if", !0);
  }
});
var dIe = /* @__PURE__ */ Je(uIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/segmented/src/segmented.vue"]]);
const fIe = Dt(dIe), pIe = (e, t) => {
  const n = e.toLowerCase();
  return (t.label || t.value || "").toLowerCase().includes(n);
}, vIe = (e, t, n) => {
  const { selectionEnd: o } = e;
  if (o === null)
    return;
  const l = e.value, r = ll(t);
  let a = -1, i;
  for (let s = o - 1; s >= 0; --s) {
    const c = l[s];
    if (c === n || c === `
` || c === "\r") {
      a = s;
      continue;
    }
    if (r.includes(c)) {
      const u = a === -1 ? o : a;
      i = {
        pattern: l.slice(s + 1, u),
        start: s + 1,
        end: u,
        prefix: c,
        prefixIndex: s,
        splitIndex: a,
        selectionEnd: o
      };
      break;
    }
  }
  return i;
}, mIe = (e, t = {
  debug: !1,
  useSelectionEnd: !1
}) => {
  const n = e.selectionStart !== null ? e.selectionStart : 0, o = e.selectionEnd !== null ? e.selectionEnd : 0, l = t.useSelectionEnd ? o : n, r = [
    "direction",
    "boxSizing",
    "width",
    "height",
    "overflowX",
    "overflowY",
    "borderTopWidth",
    "borderRightWidth",
    "borderBottomWidth",
    "borderLeftWidth",
    "borderStyle",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft",
    "fontStyle",
    "fontVariant",
    "fontWeight",
    "fontStretch",
    "fontSize",
    "fontSizeAdjust",
    "lineHeight",
    "fontFamily",
    "textAlign",
    "textTransform",
    "textIndent",
    "textDecoration",
    "letterSpacing",
    "wordSpacing",
    "tabSize",
    "MozTabSize"
  ];
  if (t.debug) {
    const f = document.querySelector(
      "#input-textarea-caret-position-mirror-div"
    );
    f != null && f.parentNode && f.parentNode.removeChild(f);
  }
  const a = document.createElement("div");
  a.id = "input-textarea-caret-position-mirror-div", document.body.appendChild(a);
  const i = a.style, s = window.getComputedStyle(e), c = e.nodeName === "INPUT";
  i.whiteSpace = c ? "nowrap" : "pre-wrap", c || (i.wordWrap = "break-word"), i.position = "absolute", t.debug || (i.visibility = "hidden"), r.forEach((f) => {
    if (c && f === "lineHeight")
      if (s.boxSizing === "border-box") {
        const p = Number.parseInt(s.height), m = Number.parseInt(s.paddingTop) + Number.parseInt(s.paddingBottom) + Number.parseInt(s.borderTopWidth) + Number.parseInt(s.borderBottomWidth), v = m + Number.parseInt(s.lineHeight);
        p > v ? i.lineHeight = `${p - m}px` : p === v ? i.lineHeight = s.lineHeight : i.lineHeight = "0";
      } else
        i.lineHeight = s.height;
    else
      i[f] = s[f];
  }), DO() ? e.scrollHeight > Number.parseInt(s.height) && (i.overflowY = "scroll") : i.overflow = "hidden", a.textContent = e.value.slice(0, Math.max(0, l)), c && a.textContent && (a.textContent = a.textContent.replace(/\s/g, ""));
  const u = document.createElement("span");
  u.textContent = e.value.slice(Math.max(0, l)) || ".", u.style.position = "relative", u.style.left = `${-e.scrollLeft}px`, u.style.top = `${-e.scrollTop}px`, a.appendChild(u);
  const d = {
    top: u.offsetTop + Number.parseInt(s.borderTopWidth),
    left: u.offsetLeft + Number.parseInt(s.borderLeftWidth),
    height: Number.parseInt(s.fontSize) * 1.5
  };
  return t.debug ? u.style.backgroundColor = "#aaa" : document.body.removeChild(a), d.left >= e.clientWidth && (d.left = e.clientWidth), d;
}, hIe = Xe(vt(Be({}, uh), {
  options: {
    type: ye(Array),
    default: () => []
  },
  prefix: {
    type: ye([String, Array]),
    default: "@",
    validator: (e) => rt(e) ? e.length === 1 : e.every((t) => rt(t) && t.length === 1)
  },
  split: {
    type: String,
    default: " ",
    validator: (e) => e.length === 1
  },
  filterOption: {
    type: ye([Boolean, Function]),
    default: () => pIe,
    validator: (e) => e === !1 ? !0 : it(e)
  },
  placement: {
    type: ye(String),
    default: "bottom"
  },
  showArrow: Boolean,
  offset: {
    type: Number,
    default: 0
  },
  whole: Boolean,
  checkIsWhole: {
    type: ye(
      Function
    )
  },
  modelValue: String,
  loading: Boolean,
  popperClass: In.popperClass,
  popperStyle: In.popperStyle,
  popperOptions: {
    type: ye(Object),
    default: () => ({})
  },
  props: {
    type: ye(Object),
    default: () => Dz
  }
})), gIe = {
  [It]: (e) => rt(e),
  "whole-remove": (e, t) => rt(e) && rt(t),
  input: (e) => rt(e),
  search: (e, t) => rt(e) && rt(t),
  select: (e, t) => Mt(e) && rt(t),
  focus: (e) => e instanceof FocusEvent,
  blur: (e) => e instanceof FocusEvent
}, Dz = {
  value: "value",
  label: "label",
  disabled: "disabled"
}, bIe = Xe({
  options: {
    type: ye(Array),
    default: () => []
  },
  loading: Boolean,
  disabled: Boolean,
  contentId: String,
  ariaLabel: String
}), yIe = {
  select: (e) => rt(e.value)
}, SIe = ["id", "aria-disabled", "aria-selected", "onMousemove", "onClick"], CIe = /* @__PURE__ */ le({
  name: "ElMentionDropdown",
  __name: "mention-dropdown",
  props: bIe,
  emits: yIe,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = Ve("mention"), { t: a } = an(), i = /* @__PURE__ */ H(-1), s = /* @__PURE__ */ H(), c = /* @__PURE__ */ H(), u = /* @__PURE__ */ H(), d = (C, w) => [
      r.be("dropdown", "item"),
      r.is("hovering", i.value === w),
      r.is("disabled", C.disabled || o.disabled)
    ], f = (C) => {
      C.disabled || o.disabled || l("select", C);
    }, p = (C) => {
      i.value = C;
    }, m = O(
      () => o.disabled || o.options.every((C) => C.disabled)
    ), v = O(() => o.options[i.value]), h = () => {
      v.value && l("select", v.value);
    }, g = (C) => {
      const { options: w } = o;
      if (w.length === 0 || m.value)
        return;
      C === "next" ? (i.value++, i.value === w.length && (i.value = 0)) : C === "prev" && (i.value--, i.value < 0 && (i.value = w.length - 1));
      const x = w[i.value];
      if (x.disabled) {
        g(C);
        return;
      }
      Ke(() => y(x));
    }, y = (C) => {
      var w, x, E, I;
      const { options: T } = o, P = T.findIndex((N) => N.value === C.value), k = (w = c.value) == null ? void 0 : w[P];
      if (k) {
        const N = (E = (x = u.value) == null ? void 0 : x.querySelector) == null ? void 0 : E.call(
          x,
          `.${r.be("dropdown", "wrap")}`
        );
        N && NO(N, k);
      }
      (I = s.value) == null || I.handleScroll();
    };
    return pe(() => o.options, () => {
      m.value || o.options.length === 0 ? i.value = -1 : i.value = 0;
    }, {
      immediate: !0
    }), t({
      hoveringIndex: i,
      navigateOptions: g,
      selectHoverOption: h,
      hoverOption: v
    }), (C, w) => (G(), ue(
      "div",
      {
        ref_key: "dropdownRef",
        ref: u,
        class: X(S(r).b("dropdown"))
      },
      [
        C.$slots.header ? (G(), ue(
          "div",
          {
            key: 0,
            class: X(S(r).be("dropdown", "header"))
          },
          [
            Oe(C.$slots, "header")
          ],
          2
        )) : Ie("v-if", !0),
        _t($(S(Ba), {
          id: C.contentId,
          ref_key: "scrollbarRef",
          ref: s,
          tag: "ul",
          "wrap-class": S(r).be("dropdown", "wrap"),
          "view-class": S(r).be("dropdown", "list"),
          role: "listbox",
          "aria-label": C.ariaLabel,
          "aria-orientation": "vertical"
        }, {
          default: Ee(() => [
            (G(!0), ue(
              Ge,
              null,
              on(C.options, (x, E) => (G(), ue("li", {
                id: `${C.contentId}-${E}`,
                ref_for: !0,
                ref_key: "optionRefs",
                ref: c,
                key: E,
                class: X(d(x, E)),
                role: "option",
                "aria-disabled": x.disabled || C.disabled || void 0,
                "aria-selected": i.value === E,
                onMousemove: (I) => p(E),
                onClick: Et((I) => f(x), ["stop"])
              }, [
                Oe(C.$slots, "label", {
                  item: x,
                  index: E
                }, () => {
                  var I;
                  return [
                    ve(
                      "span",
                      null,
                      qe((I = x.label) != null ? I : x.value),
                      1
                    )
                  ];
                })
              ], 42, SIe))),
              128
            ))
          ]),
          _: 3
        }, 8, ["id", "wrap-class", "view-class", "aria-label"]), [
          [Jt, C.options.length > 0 && !C.loading]
        ]),
        C.loading ? (G(), ue(
          "div",
          {
            key: 1,
            class: X(S(r).be("dropdown", "loading"))
          },
          [
            Oe(C.$slots, "loading", {}, () => [
              Ft(
                qe(S(a)("el.mention.loading")),
                1
              )
            ])
          ],
          2
        )) : Ie("v-if", !0),
        C.$slots.footer ? (G(), ue(
          "div",
          {
            key: 2,
            class: X(S(r).be("dropdown", "footer"))
          },
          [
            Oe(C.$slots, "footer")
          ],
          2
        )) : Ie("v-if", !0)
      ],
      2
    ));
  }
});
var wIe = /* @__PURE__ */ Je(CIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/mention/src/mention-dropdown.vue"]]);
const $Ie = /* @__PURE__ */ le({
  name: "ElMention",
  inheritAttrs: !1,
  __name: "mention",
  props: hIe,
  emits: gIe,
  setup(e, { expose: t, emit: n }) {
    const o = e, l = n, r = O(() => La(o, Object.keys(uh))), a = Ve("mention"), i = io(), s = ml(), c = /* @__PURE__ */ H(), u = /* @__PURE__ */ H(), d = /* @__PURE__ */ H(), f = /* @__PURE__ */ H(!1), p = /* @__PURE__ */ H(), m = /* @__PURE__ */ H(), v = O(
      () => o.showArrow ? o.placement : `${o.placement}-start`
    ), h = O(
      () => o.showArrow ? ["bottom", "top"] : ["bottom-start", "top-start"]
    ), g = O(() => Be(Be({}, Dz), o.props)), y = (M) => {
      const A = {
        label: M[g.value.label],
        value: M[g.value.value],
        disabled: M[g.value.disabled]
      };
      return Be(Be({}, M), A);
    }, b = O(() => o.options.map(y)), C = O(() => {
      const { filterOption: M } = o;
      return !m.value || !M ? b.value : b.value.filter(
        (A) => M(m.value.pattern, A)
      );
    }), w = O(() => f.value && (!!C.value.length || o.loading)), x = O(() => {
      var M;
      return `${s.value}-${(M = d.value) == null ? void 0 : M.hoveringIndex}`;
    }), E = (M) => {
      l(It, M), l(Po, M), z();
    }, I = (M) => {
      var A, L, B, V;
      if ((A = c.value) != null && A.isComposing)
        return;
      const j = Nn(M);
      switch (j) {
        case Ye.left:
        case Ye.right:
          z();
          break;
        case Ye.up:
        case Ye.down:
          if (!f.value)
            return;
          M.preventDefault(), (L = d.value) == null || L.navigateOptions(
            j === Ye.up ? "prev" : "next"
          );
          break;
        case Ye.enter:
        case Ye.numpadEnter:
          if (!f.value) {
            o.type !== "textarea" && z();
            return;
          }
          M.preventDefault(), (B = d.value) != null && B.hoverOption ? (V = d.value) == null || V.selectHoverOption() : f.value = !1;
          break;
        case Ye.esc:
          if (!f.value)
            return;
          M.preventDefault(), f.value = !1;
          break;
        case Ye.backspace:
          if (o.whole && m.value) {
            const { splitIndex: W, selectionEnd: Y, pattern: U, prefixIndex: te, prefix: J } = m.value, re = R();
            if (!re)
              return;
            const oe = re.value, q = b.value.find((se) => se.value === U);
            if ((it(o.checkIsWhole) ? o.checkIsWhole(U, J) : q) && W !== -1 && W + 1 === Y) {
              M.preventDefault();
              const se = oe.slice(0, te) + oe.slice(W + 1);
              l(It, se), l(Po, se), l("whole-remove", U, J);
              const Z = te;
              Ke(() => {
                re.selectionStart = Z, re.selectionEnd = Z, F();
              });
            }
          }
      }
    }, { wrapperRef: T } = Os(c, {
      disabled: i,
      afterFocus() {
        z();
      },
      beforeBlur(M) {
        var A;
        return (A = u.value) == null ? void 0 : A.isFocusInsideContent(M);
      },
      afterBlur() {
        f.value = !1;
      }
    }), P = () => {
      z();
    }, k = (M) => o.options.find((A) => M.value === A[g.value.value]), N = (M) => {
      if (!m.value)
        return;
      const A = R();
      if (!A)
        return;
      const L = A.value, { split: B } = o, V = L.slice(m.value.end), j = V.startsWith(B), W = `${M.value}${j ? "" : B}`, Y = L.slice(0, m.value.start) + W + V;
      l(It, Y), l(Po, Y), l("select", k(M), m.value.prefix);
      const U = m.value.start + W.length + (j ? 1 : 0);
      Ke(() => {
        A.selectionStart = U, A.selectionEnd = U, A.focus(), F();
      });
    }, R = () => {
      var M, A;
      return o.type === "textarea" ? (M = c.value) == null ? void 0 : M.textarea : (A = c.value) == null ? void 0 : A.input;
    }, z = () => {
      setTimeout(() => {
        D(), F(), Ke(() => {
          var M;
          return (M = u.value) == null ? void 0 : M.updatePopper();
        });
      }, 0);
    }, D = () => {
      const M = R();
      if (!M)
        return;
      const A = mIe(M), L = M.getBoundingClientRect(), B = T.value.getBoundingClientRect();
      p.value = {
        position: "absolute",
        width: 0,
        height: `${A.height}px`,
        left: `${A.left + L.left - B.left}px`,
        top: `${A.top + L.top - B.top}px`
      };
    }, F = () => {
      const M = R();
      if (document.activeElement !== M) {
        f.value = !1;
        return;
      }
      const { prefix: A, split: L } = o;
      if (m.value = vIe(M, A, L), m.value && m.value.splitIndex === -1) {
        f.value = !0, l("search", m.value.pattern, m.value.prefix);
        return;
      }
      f.value = !1;
    };
    return t({
      input: c,
      tooltip: u,
      dropdownVisible: w
    }), (M, A) => (G(), ue(
      "div",
      {
        ref_key: "wrapperRef",
        ref: T,
        class: X(S(a).b())
      },
      [
        $(S(Nl), Ut(Ut(r.value, M.$attrs), {
          ref_key: "elInputRef",
          ref: c,
          "model-value": M.modelValue,
          disabled: S(i),
          role: w.value ? "combobox" : void 0,
          "aria-activedescendant": w.value ? x.value || "" : void 0,
          "aria-controls": w.value ? S(s) : void 0,
          "aria-expanded": w.value || void 0,
          "aria-label": M.ariaLabel,
          "aria-autocomplete": w.value ? "none" : void 0,
          "aria-haspopup": w.value ? "listbox" : void 0,
          onInput: E,
          onKeydown: I,
          onMousedown: P
        }), or({
          _: 2
        }, [
          on(M.$slots, (L, B) => ({
            name: B,
            fn: Ee((V) => [
              Oe(M.$slots, B, cs(us(V)))
            ])
          }))
        ]), 1040, ["model-value", "disabled", "role", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label", "aria-autocomplete", "aria-haspopup"]),
        $(S(al), {
          ref_key: "tooltipRef",
          ref: u,
          visible: w.value,
          "popper-class": [S(a).e("popper"), M.popperClass],
          "popper-style": M.popperStyle,
          "popper-options": M.popperOptions,
          placement: v.value,
          "fallback-placements": h.value,
          effect: "light",
          pure: "",
          offset: M.offset,
          "show-arrow": M.showArrow
        }, {
          default: Ee(() => [
            ve(
              "div",
              {
                style: gt(p.value)
              },
              null,
              4
            )
          ]),
          content: Ee(() => [
            $(wIe, {
              ref_key: "dropdownRef",
              ref: d,
              options: C.value,
              disabled: S(i),
              loading: M.loading,
              "content-id": S(s),
              "aria-label": M.ariaLabel,
              onSelect: N,
              onClick: A[0] || (A[0] = Et((L) => {
                var B;
                return (B = c.value) == null ? void 0 : B.focus();
              }, ["stop"]))
            }, or({
              _: 2
            }, [
              on(M.$slots, (L, B) => ({
                name: B,
                fn: Ee((V) => [
                  Oe(M.$slots, B, cs(us(V)))
                ])
              }))
            ]), 1032, ["options", "disabled", "loading", "content-id", "aria-label"])
          ]),
          _: 3
        }, 8, ["visible", "popper-class", "popper-style", "popper-options", "placement", "fallback-placements", "offset", "show-arrow"])
      ],
      2
    ));
  }
});
var xIe = /* @__PURE__ */ Je($Ie, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/mention/src/mention.vue"]]);
const EIe = Dt(xIe), OIe = Xe({
  layout: {
    type: String,
    default: "horizontal",
    values: ["horizontal", "vertical"]
  },
  lazy: Boolean
}), _Ie = {
  resizeStart: (e, t) => !0,
  resize: (e, t) => !0,
  resizeEnd: (e, t) => !0,
  collapse: (e, t, n) => !0
}, Lz = Symbol(
  "splitterRootContextKey"
);
function IIe(e) {
  const t = /* @__PURE__ */ H(), { width: n, height: o } = tx(t), l = O(() => e.value === "horizontal" ? n.value : o.value);
  return { containerEl: t, containerSize: l };
}
function X_(e) {
  return Number(e.slice(0, -1)) / 100;
}
function q_(e) {
  return Number(e.slice(0, -2));
}
function J_(e) {
  return rt(e) && e.endsWith("%");
}
function Z_(e) {
  return rt(e) && e.endsWith("px");
}
function TIe(e, t) {
  const n = O(() => e.value.map((i) => i.size)), o = O(() => e.value.length), l = /* @__PURE__ */ H([]);
  pe([n, o, t], () => {
    var i;
    let s = [], c = 0;
    for (let d = 0; d < o.value; d += 1) {
      const f = (i = e.value[d]) == null ? void 0 : i.size;
      if (J_(f))
        s[d] = X_(f);
      else if (Z_(f))
        s[d] = q_(f) / t.value;
      else if (f || f === 0) {
        const p = Number(f);
        Number.isNaN(p) || (s[d] = p / t.value);
      } else
        c += 1, s[d] = void 0;
    }
    const u = s.reduce((d, f) => d + (f || 0), 0);
    if (u > 1 || !c) {
      const d = 1 / u;
      s = s.map((f) => f === void 0 ? 0 : f * d);
    } else {
      const d = (1 - u) / c;
      s = s.map((f) => f === void 0 ? d : f);
    }
    l.value = s;
  });
  const r = (i) => i * t.value, a = O(() => l.value.map(r));
  return { percentSizes: l, pxSizes: a };
}
function PIe(e, t, n, o) {
  const l = (h) => h * t.value || 0;
  function r(h, g) {
    return J_(h) ? l(X_(h)) : Z_(h) ? q_(h) : h != null ? h : g;
  }
  const a = /* @__PURE__ */ H(0), i = /* @__PURE__ */ H(null);
  let s = [], c = gn;
  const u = O(
    () => e.value.map((h) => [h.min, h.max])
  );
  pe(o, () => {
    if (a.value) {
      const h = new MouseEvent("mouseup", { bubbles: !0 });
      window.dispatchEvent(h);
    }
  });
  const d = (h) => {
    a.value = 0, i.value = { index: h, confirmed: !1 }, s = n.value;
  }, f = (h, g) => {
    var y, b;
    let C = null;
    if ((!i.value || !i.value.confirmed) && g !== 0) {
      if (g > 0)
        C = h, i.value = { index: h, confirmed: !0 };
      else
        for (let R = h; R >= 0; R -= 1)
          if (s[R] > 0) {
            C = R, i.value = { index: R, confirmed: !0 };
            break;
          }
    }
    const w = (b = C != null ? C : (y = i.value) == null ? void 0 : y.index) != null ? b : h, x = [...s], E = w + 1, I = r(u.value[w][0], 0), T = r(u.value[E][0], 0), P = r(
      u.value[w][1],
      t.value || 0
    ), k = r(
      u.value[E][1],
      t.value || 0
    );
    let N = g;
    x[w] + N < I && (N = I - x[w]), x[E] - N < T && (N = x[E] - T), x[w] + N > P && (N = P - x[w]), x[E] - N > k && (N = x[E] - k), x[w] += N, x[E] -= N, a.value = N, c = () => {
      e.value.forEach((R, z) => {
        R.size = x[z];
      }), c = gn;
    }, o.value || c();
  }, p = () => {
    o.value && c(), a.value = 0, i.value = null, s = [];
  }, m = [];
  return {
    lazyOffset: a,
    onMoveStart: d,
    onMoving: f,
    onMoveEnd: p,
    movingIndex: i,
    onCollapse: (h, g) => {
      m.length || m.push(...n.value);
      const y = n.value, b = g === "start" ? h : h + 1, C = g === "start" ? h + 1 : h, w = y[b], x = y[C];
      if (w !== 0 && x !== 0)
        y[b] = 0, y[C] += w, m[h] = w;
      else {
        const E = w + x, I = m[h], T = E - I;
        y[C] = I, y[b] = T;
      }
      e.value.forEach((E, I) => {
        E.size = y[I];
      });
    }
  };
}
const kIe = /* @__PURE__ */ le({
  name: "ElSplitter",
  __name: "splitter",
  props: OIe,
  emits: _Ie,
  setup(e, { emit: t }) {
    const n = Ve("splitter"), o = t, l = e, r = /* @__PURE__ */ ft(l, "layout"), a = /* @__PURE__ */ ft(l, "lazy"), { containerEl: i, containerSize: s } = IIe(r), {
      removeChild: c,
      children: u,
      addChild: d,
      ChildrenSorter: f
    } = z1(xt(), "ElSplitterPanel");
    pe(u, () => {
      h.value = null, u.value.forEach((P, k) => {
        P.setIndex(k);
      });
    });
    const { percentSizes: p, pxSizes: m } = TIe(u, s), {
      lazyOffset: v,
      movingIndex: h,
      onMoveStart: g,
      onMoving: y,
      onMoveEnd: b,
      onCollapse: C
    } = PIe(u, s, m, a), w = O(() => ({
      [n.cssVarBlockName("bar-offset")]: a.value ? `${v.value}px` : void 0
    }));
    return at(
      Lz,
      /* @__PURE__ */ kt({
        panels: u,
        percentSizes: p,
        pxSizes: m,
        layout: r,
        lazy: a,
        movingIndex: h,
        containerSize: s,
        onMoveStart: (P) => {
          g(P), o("resizeStart", P, m.value);
        },
        onMoving: (P, k) => {
          y(P, k), a.value || o("resize", P, m.value);
        },
        onMoveEnd: (P) => Rt(this, null, function* () {
          b(), yield Ke(), o("resizeEnd", P, m.value);
        }),
        onCollapse: (P, k) => {
          C(P, k), o("collapse", P, k, m.value);
        },
        registerPanel: d,
        unregisterPanel: c
      })
    ), (P, k) => (G(), ue(
      "div",
      {
        ref_key: "containerEl",
        ref: i,
        class: X([S(n).b(), S(n).e(r.value)]),
        style: gt(w.value)
      },
      [
        Oe(P.$slots, "default"),
        $(S(f)),
        Ie(" Prevent iframe touch events from breaking "),
        S(h) ? (G(), ue(
          "div",
          {
            key: 0,
            class: X([S(n).e("mask"), S(n).e(`mask-${r.value}`)])
          },
          null,
          2
        )) : Ie("v-if", !0)
      ],
      6
    ));
  }
});
var NIe = /* @__PURE__ */ Je(kIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/splitter/src/splitter.vue"]]);
function MIe(e) {
  return e && Mt(e) ? e : {
    start: !!e,
    end: !!e
  };
}
function gM(e, t, n, o) {
  return !!(e != null && e.collapsible.end && t > 0 || n != null && n.collapsible.start && o === 0 && t > 0);
}
const AIe = /* @__PURE__ */ le({
  name: "ElSplitterBar",
  __name: "split-bar",
  props: {
    index: {
      type: Number,
      required: !0
    },
    layout: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "horizontal"
    },
    resizable: {
      type: Boolean,
      default: !0
    },
    lazy: Boolean,
    startCollapsible: Boolean,
    endCollapsible: Boolean
  },
  emits: ["moveStart", "moving", "moveEnd", "collapse"],
  setup(e, { emit: t }) {
    const n = Ve("splitter-bar"), o = e, l = t, r = O(() => o.layout === "horizontal"), a = O(() => r.value ? { width: 0 } : { height: 0 }), i = O(() => ({
      width: r.value ? "16px" : "100%",
      height: r.value ? "100%" : "16px",
      cursor: o.resizable ? r.value ? "ew-resize" : "ns-resize" : "auto",
      touchAction: "none"
    })), s = O(() => {
      const y = n.e("dragger");
      return {
        [`${y}-horizontal`]: r.value,
        [`${y}-vertical`]: !r.value,
        [`${y}-active`]: !!c.value
      };
    }), c = /* @__PURE__ */ H(null), u = (y) => {
      o.resizable && (c.value = [y.pageX, y.pageY], l("moveStart", o.index), window.addEventListener("mouseup", m), window.addEventListener("mousemove", f));
    }, d = (y) => {
      if (o.resizable && y.touches.length === 1) {
        y.preventDefault();
        const b = y.touches[0];
        c.value = [b.pageX, b.pageY], l("moveStart", o.index), window.addEventListener("touchend", v), window.addEventListener("touchmove", p);
      }
    }, f = (y) => {
      const { pageX: b, pageY: C } = y, w = b - c.value[0], x = C - c.value[1], E = r.value ? w : x;
      l("moving", o.index, E);
    }, p = (y) => {
      if (y.touches.length === 1) {
        y.preventDefault();
        const b = y.touches[0], C = b.pageX - c.value[0], w = b.pageY - c.value[1], x = r.value ? C : w;
        l("moving", o.index, x);
      }
    }, m = () => {
      c.value = null, window.removeEventListener("mouseup", m), window.removeEventListener("mousemove", f), l("moveEnd", o.index);
    }, v = () => {
      c.value = null, window.removeEventListener("touchend", v), window.removeEventListener("touchmove", p), l("moveEnd", o.index);
    }, h = O(() => r.value ? ms : A1), g = O(() => r.value ? Rl : Ni);
    return (y, b) => (G(), ue(
      "div",
      {
        class: X([S(n).b()]),
        style: gt(a.value)
      },
      [
        e.startCollapsible ? (G(), ue(
          "div",
          {
            key: 0,
            class: X([S(n).e("collapse-icon"), S(n).e(`${e.layout}-collapse-icon-start`)]),
            onClick: b[0] || (b[0] = (C) => l("collapse", e.index, "start"))
          },
          [
            Oe(y.$slots, "start-collapsible", {}, () => [
              (G(), Me(Ht(h.value), { style: { width: "12px", height: "12px" } }))
            ])
          ],
          2
        )) : Ie("v-if", !0),
        ve(
          "div",
          {
            class: X([
              S(n).e("dragger"),
              s.value,
              S(n).is("disabled", !e.resizable),
              S(n).is("lazy", e.resizable && e.lazy)
            ]),
            style: gt(i.value),
            onMousedown: u,
            onTouchstart: d
          },
          null,
          38
        ),
        e.endCollapsible ? (G(), ue(
          "div",
          {
            key: 1,
            class: X([S(n).e("collapse-icon"), S(n).e(`${e.layout}-collapse-icon-end`)]),
            onClick: b[1] || (b[1] = (C) => l("collapse", e.index, "end"))
          },
          [
            Oe(y.$slots, "end-collapsible", {}, () => [
              (G(), Me(Ht(g.value), { style: { width: "12px", height: "12px" } }))
            ])
          ],
          2
        )) : Ie("v-if", !0)
      ],
      6
    ));
  }
});
var RIe = /* @__PURE__ */ Je(AIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/splitter/src/split-bar.vue"]]);
const DIe = Xe({
  min: {
    type: [String, Number]
  },
  max: {
    type: [String, Number]
  },
  size: {
    type: [String, Number]
  },
  resizable: {
    type: Boolean,
    default: !0
  },
  collapsible: Boolean
}), LIe = {
  "update:size": (e) => typeof e == "number" || typeof e == "string"
}, bM = "ElSplitterPanel", BIe = /* @__PURE__ */ le({
  name: bM,
  __name: "split-panel",
  props: DIe,
  emits: LIe,
  setup(e, { expose: t, emit: n }) {
    const o = Ve("splitter-panel"), l = e, r = n, a = ze(Lz);
    a || no(
      bM,
      "usage: <el-splitter><el-splitter-panel /></el-splitter/>"
    );
    const { panels: i, layout: s, lazy: c, containerSize: u, pxSizes: d } = /* @__PURE__ */ to(a), {
      registerPanel: f,
      unregisterPanel: p,
      onCollapse: m,
      onMoveEnd: v,
      onMoveStart: h,
      onMoving: g
    } = a, y = /* @__PURE__ */ H(), b = xt(), C = b.uid, w = /* @__PURE__ */ H(0), x = O(() => i.value[w.value]), E = (A) => {
      w.value = A;
    }, I = O(() => {
      var A;
      return x.value && (A = d.value[w.value]) != null ? A : 0;
    }), T = O(() => {
      var A;
      return x.value && (A = d.value[w.value + 1]) != null ? A : 0;
    }), P = O(() => x.value ? i.value[w.value + 1] : null), k = O(() => {
      var A;
      return P.value ? l.resizable && ((A = P.value) == null ? void 0 : A.resizable) && (I.value !== 0 || !l.min) && (T.value !== 0 || !P.value.min) : !1;
    }), N = O(() => x.value ? w.value !== i.value.length - 1 : !1), R = O(
      () => gM(x.value, I.value, P.value, T.value)
    ), z = O(
      () => gM(P.value, T.value, x.value, I.value)
    );
    function D(A) {
      return J_(A) ? X_(A) * u.value || 0 : Z_(A) ? q_(A) : A != null ? A : 0;
    }
    let F = !1;
    pe(
      () => l.size,
      () => {
        if (!F && x.value) {
          if (!u.value) {
            x.value.size = l.size;
            return;
          }
          const A = D(l.size), L = D(l.max), B = D(l.min), V = Math.min(Math.max(A, B || 0), L || A);
          V !== A && r("update:size", V), x.value.size = V;
        }
      }
    ), pe(
      () => {
        var A;
        return (A = x.value) == null ? void 0 : A.size;
      },
      (A) => {
        A !== l.size && (F = !0, r("update:size", A), Ke(() => F = !1));
      }
    ), pe(
      () => l.resizable,
      (A) => {
        x.value && (x.value.resizable = A);
      }
    );
    const M = /* @__PURE__ */ kt(vt(Be({
      el: y.value,
      uid: C,
      getVnode: () => b.vnode,
      setIndex: E
    }, l), {
      collapsible: O(() => MIe(l.collapsible))
    }));
    return f(M), yt(() => p(M)), t({
      splitterPanelRef: y
    }), (A, L) => (G(), ue(
      Ge,
      null,
      [
        ve(
          "div",
          Ut({
            ref_key: "panelEl",
            ref: y,
            class: [S(o).b()],
            style: { flexBasis: `${I.value}px` }
          }, A.$attrs),
          [
            Oe(A.$slots, "default")
          ],
          16
        ),
        N.value ? (G(), Me(RIe, {
          key: 0,
          index: w.value,
          layout: S(s),
          lazy: S(c),
          resizable: k.value,
          "start-collapsible": R.value,
          "end-collapsible": z.value,
          onMoveStart: S(h),
          onMoving: S(g),
          onMoveEnd: S(v),
          onCollapse: S(m)
        }, {
          "start-collapsible": Ee(() => [
            Oe(A.$slots, "start-collapsible")
          ]),
          "end-collapsible": Ee(() => [
            Oe(A.$slots, "end-collapsible")
          ]),
          _: 3
        }, 8, ["index", "layout", "lazy", "resizable", "start-collapsible", "end-collapsible", "onMoveStart", "onMoving", "onMoveEnd", "onCollapse"])) : Ie("v-if", !0)
      ],
      64
    ));
  }
});
var Bz = /* @__PURE__ */ Je(BIe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/splitter/src/split-panel.vue"]]);
const FIe = Dt(NIe, {
  SplitPanel: Bz
}), VIe = oo(Bz);
var zIe = [
  Pie,
  Jse,
  Rde,
  S2e,
  Vde,
  zde,
  Gde,
  uF,
  ofe,
  lfe,
  Qo,
  hF,
  Spe,
  xpe,
  Vpe,
  zpe,
  Rve,
  HF,
  Vve,
  Fa,
  Qpe,
  o_,
  Wve,
  rme,
  ame,
  j1,
  e9,
  Ame,
  Lme,
  Wme,
  Kme,
  Ume,
  Gme,
  Yme,
  Uge,
  x9,
  tbe,
  nbe,
  gbe,
  M9,
  Pbe,
  h0e,
  g0e,
  b0e,
  H9,
  Bye,
  Fye,
  ut,
  Jye,
  U9,
  Nl,
  G9,
  v1e,
  S1e,
  D1e,
  L1e,
  B1e,
  F1e,
  K1e,
  ESe,
  PSe,
  BSe,
  rF,
  eV,
  VF,
  dve,
  uve,
  QSe,
  oCe,
  cCe,
  Ba,
  wc,
  R0,
  ppe,
  WCe,
  JCe,
  ZCe,
  bwe,
  $we,
  vV,
  Nwe,
  Fwe,
  Vwe,
  qwe,
  uxe,
  dxe,
  y2e,
  M2e,
  A2e,
  fs,
  D_,
  hhe,
  H2e,
  G2e,
  Y2e,
  al,
  iEe,
  F_,
  TEe,
  KEe,
  bOe,
  IOe,
  Y_e,
  X_e,
  lIe,
  rIe,
  fIe,
  EIe,
  FIe,
  VIe
];
const Ir = "ElInfiniteScroll", HIe = 50, jIe = 200, WIe = 0, KIe = {
  delay: {
    type: Number,
    default: jIe
  },
  distance: {
    type: Number,
    default: WIe
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  immediate: {
    type: Boolean,
    default: !0
  }
}, Q_ = (e, t) => Object.entries(KIe).reduce((n, [o, l]) => {
  var r, a;
  const { type: i, default: s } = l, c = e.getAttribute(`infinite-scroll-${o}`);
  let u = (a = (r = t[c]) != null ? r : c) != null ? a : s;
  return u = u === "false" ? !1 : u, u = i(u), n[o] = Number.isNaN(u) ? s : u, n;
}, {}), Fz = (e) => {
  const { observer: t } = e[Ir];
  t && (t.disconnect(), delete e[Ir].observer);
}, UIe = (e, t) => {
  const { container: n, containerEl: o, instance: l, observer: r, lastScrollTop: a } = e[Ir], { disabled: i, distance: s } = Q_(e, l), { clientHeight: c, scrollHeight: u, scrollTop: d } = o, f = d - a;
  if (e[Ir].lastScrollTop = d, r || i || f < 0)
    return;
  let p = !1;
  if (n === e)
    p = u - (c + d) <= s;
  else {
    const { clientTop: m, scrollHeight: v } = e, h = gx(e, o);
    p = d + c >= h + m + v - s;
  }
  p && t.call(l);
};
function uw(e, t) {
  const { containerEl: n, instance: o } = e[Ir], { disabled: l } = Q_(e, o);
  l || n.clientHeight === 0 || (n.scrollHeight <= n.clientHeight ? t.call(o) : Fz(e));
}
const GIe = {
  mounted(e, t) {
    return Rt(this, null, function* () {
      const { instance: n, value: o } = t;
      hi(
        {
          scope: Ir,
          from: "the directive v-infinite-scroll",
          replacement: "the el-scrollbar infinite scroll",
          version: "3.0.0",
          ref: "https://element-plus.org/en-US/component/scrollbar#infinite-scroll"
        },
        !0
      ), it(o) || no(Ir, "'v-infinite-scroll' binding value must be a function"), yield Ke();
      const { delay: l, immediate: r } = Q_(e, n), a = kO(e, !0), i = a === window ? document.documentElement : a, s = Qs(UIe.bind(null, e, o), l);
      if (a) {
        if (e[Ir] = {
          instance: n,
          container: a,
          containerEl: i,
          delay: l,
          cb: o,
          onScroll: s,
          lastScrollTop: i.scrollTop
        }, r) {
          const c = new MutationObserver(
            Qs(uw.bind(null, e, o), HIe)
          );
          e[Ir].observer = c, c.observe(e, { childList: !0, subtree: !0 }), uw(e, o);
        }
        a.addEventListener("scroll", s);
      }
    });
  },
  unmounted(e) {
    if (!e[Ir])
      return;
    const { container: t, onScroll: n } = e[Ir];
    t == null || t.removeEventListener("scroll", n), Fz(e);
  },
  updated(e) {
    return Rt(this, null, function* () {
      if (!e[Ir])
        yield Ke();
      else {
        const { containerEl: t, cb: n, observer: o } = e[Ir];
        t.clientHeight && o && uw(e, n);
      }
    });
  }
}, t2 = GIe;
t2.install = (e) => {
  e.directive("InfiniteScroll", t2);
};
const YIe = t2;
function XIe(e, t) {
  let n;
  const o = /* @__PURE__ */ H(!1), l = /* @__PURE__ */ kt(vt(Be({}, e), {
    originalPosition: "",
    originalOverflow: "",
    visible: !1
  }));
  function r(p) {
    l.text = p;
  }
  function a() {
    const p = l.parent, m = f.ns;
    if (!p.vLoadingAddClassList) {
      let v = p.getAttribute("loading-number");
      v = Number.parseInt(v) - 1, v ? p.setAttribute("loading-number", v.toString()) : (Al(p, m.bm("parent", "relative")), p.removeAttribute("loading-number")), Al(p, m.bm("parent", "hidden"));
    }
    i(), d.unmount();
  }
  function i() {
    var p, m;
    (m = (p = f.$el) == null ? void 0 : p.parentNode) == null || m.removeChild(f.$el);
  }
  function s() {
    var p;
    e.beforeClose && !e.beforeClose() || (o.value = !0, clearTimeout(n), n = setTimeout(c, 400), l.visible = !1, (p = e.closed) == null || p.call(e));
  }
  function c() {
    if (!o.value)
      return;
    const p = l.parent;
    o.value = !1, p.vLoadingAddClassList = void 0, a();
  }
  const d = ZE(/* @__PURE__ */ le({
    name: "ElLoading",
    setup(p, { expose: m }) {
      const { ns: v, zIndex: h } = M1("loading");
      return m({
        ns: v,
        zIndex: h
      }), () => {
        const g = l.spinner || l.svg, y = ht(
          "svg",
          Be({
            class: "circular",
            viewBox: l.svgViewBox ? l.svgViewBox : "0 0 50 50"
          }, g ? { innerHTML: g } : {}),
          [
            ht("circle", {
              class: "path",
              cx: "25",
              cy: "25",
              r: "20",
              fill: "none"
            })
          ]
        ), b = l.text ? ht("p", { class: v.b("text") }, [l.text]) : void 0;
        return ht(
          Vn,
          {
            name: v.b("fade"),
            onAfterLeave: c
          },
          {
            default: Ee(() => [
              _t(
                $(
                  "div",
                  {
                    style: {
                      backgroundColor: l.background || ""
                    },
                    class: [
                      v.b("mask"),
                      l.customClass,
                      v.is("fullscreen", l.fullscreen)
                    ]
                  },
                  [
                    ht(
                      "div",
                      {
                        class: v.b("spinner")
                      },
                      [y, b]
                    )
                  ]
                ),
                [[Jt, l.visible]]
              )
            ])
          }
        );
      };
    }
  }));
  Object.assign(d._context, t != null ? t : {});
  const f = d.mount(document.createElement("div"));
  return vt(Be({}, /* @__PURE__ */ to(l)), {
    setText: r,
    removeElLoadingChild: i,
    close: s,
    handleAfterLeave: c,
    vm: f,
    get $el() {
      return f.$el;
    }
  });
}
let yg;
const gf = function(e = {}, t) {
  if (!Sn)
    return;
  const n = qIe(e);
  if (n.fullscreen && yg)
    return yg;
  const o = XIe(
    vt(Be({}, n), {
      closed: () => {
        var r;
        (r = n.closed) == null || r.call(n), n.fullscreen && (yg = void 0);
      }
    }),
    t != null ? t : gf._context
  );
  JIe(n, n.parent, o), yM(n, n.parent, o), n.parent.vLoadingAddClassList = () => yM(n, n.parent, o);
  let l = n.parent.getAttribute("loading-number");
  return l ? l = `${Number.parseInt(l) + 1}` : l = "1", n.parent.setAttribute("loading-number", l), n.parent.appendChild(o.$el), Ke(() => o.visible.value = n.visible), n.fullscreen && (yg = o), o;
}, qIe = (e) => {
  var t, n, o, l;
  let r;
  return rt(e.target) ? r = (t = document.querySelector(e.target)) != null ? t : document.body : r = e.target || document.body, {
    parent: r === document.body || e.body ? document.body : r,
    background: e.background || "",
    svg: e.svg || "",
    svgViewBox: e.svgViewBox || "",
    spinner: e.spinner || !1,
    text: e.text || "",
    fullscreen: r === document.body && ((n = e.fullscreen) != null ? n : !0),
    lock: (o = e.lock) != null ? o : !1,
    customClass: e.customClass || "",
    visible: (l = e.visible) != null ? l : !0,
    beforeClose: e.beforeClose,
    closed: e.closed,
    target: r
  };
}, JIe = (e, t, n) => Rt(void 0, null, function* () {
  const { nextZIndex: o } = n.vm.zIndex || n.vm._.exposed.zIndex, l = {};
  if (e.fullscreen)
    n.originalPosition.value = ts(document.body, "position"), n.originalOverflow.value = ts(document.body, "overflow"), l.zIndex = o();
  else if (e.parent === document.body) {
    n.originalPosition.value = ts(document.body, "position"), yield Ke();
    for (const r of ["top", "left"]) {
      const a = r === "top" ? "scrollTop" : "scrollLeft";
      l[r] = `${e.target.getBoundingClientRect()[r] + document.body[a] + document.documentElement[a] - Number.parseInt(ts(document.body, `margin-${r}`), 10)}px`;
    }
    for (const r of ["height", "width"])
      l[r] = `${e.target.getBoundingClientRect()[r]}px`;
  } else
    n.originalPosition.value = ts(t, "position");
  for (const [r, a] of Object.entries(l))
    n.$el.style[r] = a;
}), yM = (e, t, n) => {
  const o = n.vm.ns || n.vm._.exposed.ns;
  ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? Al(t, o.bm("parent", "relative")) : Zr(t, o.bm("parent", "relative")), e.fullscreen && e.lock ? Zr(t, o.bm("parent", "hidden")) : Al(t, o.bm("parent", "hidden"));
};
gf._context = null;
const hv = Symbol("ElLoading"), Qc = (e) => `element-loading-${Si(e)}`, SM = (e, t) => {
  var n, o, l, r;
  const a = t.instance, i = (p) => Mt(t.value) ? t.value[p] : void 0, s = (p) => {
    const m = rt(p) && (a == null ? void 0 : a[p]) || p;
    return /* @__PURE__ */ H(m);
  }, c = (p) => s(
    i(p) || e.getAttribute(Qc(p))
  ), u = (n = i("fullscreen")) != null ? n : t.modifiers.fullscreen, d = {
    text: c("text"),
    svg: c("svg"),
    svgViewBox: c("svgViewBox"),
    spinner: c("spinner"),
    background: c("background"),
    customClass: c("customClass"),
    fullscreen: u,
    target: (o = i("target")) != null ? o : u ? void 0 : e,
    body: (l = i("body")) != null ? l : t.modifiers.body,
    lock: (r = i("lock")) != null ? r : t.modifiers.lock
  }, f = gf(d);
  f._context = Nv._context, e[hv] = {
    options: d,
    instance: f
  };
}, ZIe = (e, t) => {
  for (const n of Object.keys(e))
    /* @__PURE__ */ kn(e[n]) && (e[n].value = t[n]);
}, Nv = {
  mounted(e, t) {
    t.value && SM(e, t);
  },
  updated(e, t) {
    const n = e[hv];
    if (!t.value) {
      n == null || n.instance.close(), e[hv] = null;
      return;
    }
    n ? ZIe(
      n.options,
      Mt(t.value) ? t.value : {
        text: e.getAttribute(Qc("text")),
        svg: e.getAttribute(Qc("svg")),
        svgViewBox: e.getAttribute(Qc("svgViewBox")),
        spinner: e.getAttribute(Qc("spinner")),
        background: e.getAttribute(Qc("background")),
        customClass: e.getAttribute(Qc("customClass"))
      }
    ) : SM(e, t);
  },
  unmounted(e) {
    var t;
    (t = e[hv]) == null || t.instance.close(), e[hv] = null;
  }
};
Nv._context = null;
const QIe = {
  install(e) {
    gf._context = e._context, Nv._context = e._context, e.directive("loading", Nv), e.config.globalProperties.$loading = gf;
  },
  directive: Nv,
  service: gf
}, Vz = [
  "primary",
  "success",
  "info",
  "warning",
  "error"
], zz = [
  "top",
  "top-left",
  "top-right",
  "bottom",
  "bottom-left",
  "bottom-right"
], bf = "top", xl = lo({
  customClass: "",
  dangerouslyUseHTMLString: !1,
  duration: 3e3,
  icon: void 0,
  id: "",
  message: "",
  onClose: void 0,
  showClose: !1,
  type: "info",
  plain: !1,
  offset: 16,
  placement: void 0,
  zIndex: 0,
  grouping: !1,
  repeatNum: 1,
  appendTo: Sn ? document.body : void 0
}), eTe = Xe({
  customClass: {
    type: String,
    default: xl.customClass
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: xl.dangerouslyUseHTMLString
  },
  duration: {
    type: Number,
    default: xl.duration
  },
  icon: {
    type: Pn,
    default: xl.icon
  },
  id: {
    type: String,
    default: xl.id
  },
  message: {
    type: ye([
      String,
      Object,
      Function
    ]),
    default: xl.message
  },
  onClose: {
    type: ye(Function),
    default: xl.onClose
  },
  showClose: {
    type: Boolean,
    default: xl.showClose
  },
  type: {
    type: String,
    values: Vz,
    default: xl.type
  },
  plain: {
    type: Boolean,
    default: xl.plain
  },
  offset: {
    type: Number,
    default: xl.offset
  },
  placement: {
    type: String,
    values: zz,
    default: xl.placement
  },
  zIndex: {
    type: Number,
    default: xl.zIndex
  },
  grouping: {
    type: Boolean,
    default: xl.grouping
  },
  repeatNum: {
    type: Number,
    default: xl.repeatNum
  }
}), tTe = {
  destroy: () => !0
}, Oa = /* @__PURE__ */ o1(
  {}
), nTe = (e) => (Oa[e] || (Oa[e] = /* @__PURE__ */ o1([])), Oa[e]), oTe = (e, t) => {
  const n = Oa[t] || [], o = n.findIndex((a) => a.id === e), l = n[o];
  let r;
  return o > 0 && (r = n[o - 1]), { current: l, prev: r };
}, lTe = (e, t) => {
  const { prev: n } = oTe(e, t);
  return n ? n.vm.exposed.bottom.value : 0;
}, rTe = (e, t, n) => (Oa[n] || []).findIndex((r) => r.id === e) > 0 ? 16 : t, aTe = ["id"], iTe = ["innerHTML"], sTe = /* @__PURE__ */ le({
  name: "ElMessage",
  __name: "message",
  props: eTe,
  emits: tTe,
  setup(e, { expose: t, emit: n }) {
    const { Close: o } = RO, l = e, r = n, a = /* @__PURE__ */ H(!1), { ns: i, zIndex: s } = M1("message"), { currentZIndex: c, nextZIndex: u } = s, d = /* @__PURE__ */ H(), f = /* @__PURE__ */ H(!1), p = /* @__PURE__ */ H(0);
    let m;
    const v = O(
      () => l.type ? l.type === "error" ? "danger" : l.type : "info"
    ), h = O(() => {
      const R = l.type;
      return { [i.bm("icon", R)]: R && Sc[R] };
    }), g = O(
      () => l.icon || Sc[l.type] || ""
    ), y = O(() => l.placement || bf), b = O(() => lTe(l.id, y.value)), C = O(() => rTe(l.id, l.offset, y.value) + b.value), w = O(() => p.value + C.value), x = O(() => y.value.includes("left") ? i.is("left") : y.value.includes("right") ? i.is("right") : i.is("center")), E = O(
      () => y.value.startsWith("top") ? "top" : "bottom"
    ), I = O(() => ({
      [E.value]: `${C.value}px`,
      zIndex: c.value
    }));
    function T() {
      l.duration !== 0 && ({ stop: m } = jf(() => {
        k();
      }, l.duration));
    }
    function P() {
      m == null || m();
    }
    function k() {
      f.value = !1, Ke(() => {
        var R;
        a.value || ((R = l.onClose) == null || R.call(l), r("destroy"));
      });
    }
    function N(R) {
      Nn(R) === Ye.esc && k();
    }
    return nt(() => {
      T(), u(), f.value = !0;
    }), pe(
      () => l.repeatNum,
      () => {
        P(), T();
      }
    ), wn(document, "keydown", N), Xn(d, () => {
      p.value = d.value.getBoundingClientRect().height;
    }), t({
      visible: f,
      bottom: w,
      close: k
    }), (R, z) => (G(), Me(Vn, {
      name: S(i).b("fade"),
      onBeforeEnter: z[0] || (z[0] = (D) => a.value = !0),
      onBeforeLeave: R.onClose,
      onAfterLeave: z[1] || (z[1] = (D) => R.$emit("destroy")),
      persisted: ""
    }, {
      default: Ee(() => [
        _t(ve("div", {
          id: R.id,
          ref_key: "messageRef",
          ref: d,
          class: X([
            S(i).b(),
            { [S(i).m(R.type)]: R.type },
            S(i).is("closable", R.showClose),
            S(i).is("plain", R.plain),
            S(i).is("bottom", E.value === "bottom"),
            x.value,
            R.customClass
          ]),
          style: gt(I.value),
          role: "alert",
          onMouseenter: P,
          onMouseleave: T
        }, [
          R.repeatNum > 1 ? (G(), Me(S(uF), {
            key: 0,
            value: R.repeatNum,
            type: v.value,
            class: X(S(i).e("badge"))
          }, null, 8, ["value", "type", "class"])) : Ie("v-if", !0),
          g.value ? (G(), Me(S(ut), {
            key: 1,
            class: X([S(i).e("icon"), h.value])
          }, {
            default: Ee(() => [
              (G(), Me(Ht(g.value)))
            ]),
            _: 1
          }, 8, ["class"])) : Ie("v-if", !0),
          Oe(R.$slots, "default", {}, () => [
            R.dangerouslyUseHTMLString ? (G(), ue(
              Ge,
              { key: 1 },
              [
                Ie(" Caution here, message could've been compromised, never use user's input as message "),
                ve("p", {
                  class: X(S(i).e("content")),
                  innerHTML: R.message
                }, null, 10, iTe)
              ],
              2112
            )) : (G(), ue(
              "p",
              {
                key: 0,
                class: X(S(i).e("content"))
              },
              qe(R.message),
              3
            ))
          ]),
          R.showClose ? (G(), Me(S(ut), {
            key: 2,
            class: X(S(i).e("closeBtn")),
            onClick: Et(k, ["stop"])
          }, {
            default: Ee(() => [
              $(S(o))
            ]),
            _: 1
          }, 8, ["class"])) : Ie("v-if", !0)
        ], 46, aTe), [
          [Jt, f.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var cTe = /* @__PURE__ */ Je(sTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
let uTe = 1;
const dTe = (e) => {
  if (!e.appendTo)
    e.appendTo = document.body;
  else if (rt(e.appendTo)) {
    let n = document.querySelector(e.appendTo);
    tr(n) || (Gt(
      "ElMessage",
      "the appendTo option is not an HTMLElement. Falling back to document.body."
    ), n = document.body), e.appendTo = n;
  }
}, fTe = (e) => {
  !e.placement && rt(_l.placement) && _l.placement && (e.placement = _l.placement), e.placement || (e.placement = bf), zz.includes(e.placement) || (Gt(
    "ElMessage",
    `Invalid placement: ${e.placement}. Falling back to '${bf}'.`
  ), e.placement = bf);
}, Hz = (e) => {
  const t = !e || rt(e) || dn(e) || it(e) ? { message: e } : e, n = Be(Be({}, xl), t);
  return dTe(n), fTe(n), Tn(_l.grouping) && !n.grouping && (n.grouping = _l.grouping), mt(_l.duration) && n.duration === 3e3 && (n.duration = _l.duration), mt(_l.offset) && n.offset === 16 && (n.offset = _l.offset), Tn(_l.showClose) && !n.showClose && (n.showClose = _l.showClose), Tn(_l.plain) && !n.plain && (n.plain = _l.plain), n;
}, pTe = (e) => {
  const t = e.props.placement || bf, n = Oa[t], o = n.indexOf(e);
  if (o === -1)
    return;
  n.splice(o, 1);
  const { handler: l } = e;
  l.close();
}, vTe = (o, n) => {
  var l = o, { appendTo: e } = l, t = Hr(l, ["appendTo"]);
  const r = `message_${uTe++}`, a = t.onClose, i = document.createElement("div"), s = vt(Be({}, t), {
    id: r,
    onClose: () => {
      a == null || a(), pTe(f);
    },
    onDestroy: () => {
      Bl(null, i);
    }
  }), c = $(
    cTe,
    s,
    it(s.message) || dn(s.message) ? {
      default: it(s.message) ? s.message : () => s.message
    } : null
  );
  c.appContext = n || Uu._context, Bl(c, i), e.appendChild(i.firstElementChild);
  const u = c.component, f = {
    id: r,
    vnode: c,
    vm: u,
    handler: {
      close: () => {
        u.exposed.close();
      }
    },
    props: c.component.props
  };
  return f;
}, Uu = (e = {}, t) => {
  if (!Sn)
    return { close: () => {
    } };
  const n = Hz(e), o = nTe(
    n.placement || bf
  );
  if (n.grouping && o.length) {
    const r = o.find(
      ({ vnode: a }) => {
        var i;
        return ((i = a.props) == null ? void 0 : i.message) === n.message;
      }
    );
    if (r)
      return r.props.repeatNum += 1, r.props.type = n.type, r.handler;
  }
  if (mt(_l.max) && o.length >= _l.max)
    return { close: () => {
    } };
  const l = vTe(n, t);
  return o.push(l), l.handler;
};
Vz.forEach((e) => {
  Uu[e] = (t = {}, n) => {
    const o = Hz(t);
    return Uu(vt(Be({}, o), { type: e }), n);
  };
});
function mTe(e) {
  for (const t in Oa)
    if (hn(Oa, t)) {
      const n = [...Oa[t]];
      for (const o of n)
        (!e || e === o.props.type) && o.handler.close();
    }
}
function hTe(e) {
  if (!Oa[e])
    return;
  [...Oa[e]].forEach((n) => n.handler.close());
}
Uu.closeAll = mTe;
Uu.closeAllByPlacement = hTe;
Uu._context = null;
const gTe = y7(Uu, "$message"), n2 = "_trap-focus-children", hu = [], CM = (e) => {
  var t;
  if (hu.length === 0)
    return;
  const n = Nn(e), o = hu[hu.length - 1][n2];
  if (o.length > 0 && n === Ye.tab) {
    if (o.length === 1) {
      e.preventDefault(), document.activeElement !== o[0] && o[0].focus();
      return;
    }
    const l = e.shiftKey, r = e.target === o[0], a = e.target === o[o.length - 1];
    if (r && l && (e.preventDefault(), o[o.length - 1].focus()), a && !l && (e.preventDefault(), o[0].focus()), process.env.NODE_ENV === "test") {
      const i = o.indexOf(e.target);
      i !== -1 && ((t = o[l ? i - 1 : i + 1]) == null || t.focus());
    }
  }
}, bTe = {
  beforeMount(e) {
    e[n2] = y3(e), hu.push(e), hu.length <= 1 && document.addEventListener("keydown", CM);
  },
  updated(e) {
    Ke(() => {
      e[n2] = y3(e);
    });
  },
  unmounted() {
    hu.shift(), hu.length === 0 && document.removeEventListener("keydown", CM);
  }
}, yTe = /* @__PURE__ */ le({
  name: "ElMessageBox",
  directives: {
    TrapFocus: bTe
  },
  components: Be({
    ElButton: Qo,
    ElFocusTrap: xp,
    ElInput: Nl,
    ElOverlay: h_,
    ElIcon: ut
  }, RO),
  inheritAttrs: !1,
  props: {
    buttonSize: {
      type: String,
      validator: gV
    },
    modal: {
      type: Boolean,
      default: !0
    },
    lockScroll: {
      type: Boolean,
      default: !0
    },
    showClose: {
      type: Boolean,
      default: !0
    },
    closeOnClickModal: {
      type: Boolean,
      default: !0
    },
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    closeOnHashChange: {
      type: Boolean,
      default: !0
    },
    center: Boolean,
    draggable: Boolean,
    overflow: Boolean,
    roundButton: Boolean,
    container: {
      type: String,
      default: "body"
    },
    boxType: {
      type: String,
      default: ""
    }
  },
  emits: ["vanish", "action"],
  setup(e, { emit: t }) {
    const {
      locale: n,
      zIndex: o,
      ns: l,
      size: r
    } = M1(
      "message-box",
      O(() => e.buttonSize)
    ), { t: a } = n, { nextZIndex: i } = o, s = /* @__PURE__ */ H(!1), c = /* @__PURE__ */ kt({
      autofocus: !0,
      beforeClose: null,
      callback: null,
      cancelButtonText: "",
      cancelButtonClass: "",
      confirmButtonText: "",
      confirmButtonClass: "",
      cancelButtonType: "",
      confirmButtonType: "primary",
      customClass: "",
      customStyle: {},
      dangerouslyUseHTMLString: !1,
      distinguishCancelAndClose: !1,
      icon: "",
      closeIcon: "",
      inputPattern: null,
      inputPlaceholder: "",
      inputType: "text",
      inputValue: "",
      inputValidator: void 0,
      inputErrorMessage: "",
      message: "",
      modalFade: !0,
      modalClass: "",
      showCancelButton: !1,
      showConfirmButton: !0,
      type: "",
      title: void 0,
      showInput: !1,
      action: "",
      confirmButtonLoading: !1,
      cancelButtonLoading: !1,
      confirmButtonLoadingIcon: wa(wi),
      cancelButtonLoadingIcon: wa(wi),
      confirmButtonDisabled: !1,
      editorErrorMessage: "",
      validateError: !1,
      zIndex: i()
    }), u = O(() => {
      const M = c.type;
      return { [l.bm("icon", M)]: M && Sc[M] };
    }), d = ml(), f = ml(), p = O(() => {
      const M = c.type;
      return c.icon || M && Sc[M] || "";
    }), m = O(() => !!c.message), v = /* @__PURE__ */ H(), h = /* @__PURE__ */ H(), g = /* @__PURE__ */ H(), y = /* @__PURE__ */ H(), b = /* @__PURE__ */ H(), C = O(() => c.confirmButtonClass);
    pe(
      () => c.inputValue,
      (M) => Rt(this, null, function* () {
        yield Ke(), e.boxType === "prompt" && M && R();
      }),
      { immediate: !0 }
    ), pe(
      () => s.value,
      (M) => {
        var A, L;
        M && (e.boxType !== "prompt" && (c.autofocus ? g.value = (L = (A = b.value) == null ? void 0 : A.$el) != null ? L : v.value : g.value = v.value), c.zIndex = i()), e.boxType === "prompt" && (M ? Ke().then(() => {
          var B;
          y.value && y.value.$el && (c.autofocus ? g.value = (B = z()) != null ? B : v.value : g.value = v.value);
        }) : (c.editorErrorMessage = "", c.validateError = !1));
      }
    );
    const w = O(() => e.draggable), x = O(() => e.overflow), { isDragging: E } = T9(v, h, w, x);
    nt(() => Rt(this, null, function* () {
      yield Ke(), e.closeOnHashChange && window.addEventListener("hashchange", I);
    })), yt(() => {
      e.closeOnHashChange && window.removeEventListener("hashchange", I);
    });
    function I() {
      s.value && (s.value = !1, Ke(() => {
        c.action && t("action", c.action);
      }));
    }
    const T = () => {
      e.closeOnClickModal && N(c.distinguishCancelAndClose ? "close" : "cancel");
    }, P = m_(T), k = (M) => {
      if (c.inputType !== "textarea")
        return M.preventDefault(), N("confirm");
    }, N = (M) => {
      var A;
      e.boxType === "prompt" && M === "confirm" && !R() || (c.action = M, c.beforeClose ? (A = c.beforeClose) == null || A.call(c, M, c, I) : I());
    }, R = () => {
      if (e.boxType === "prompt") {
        const M = c.inputPattern;
        if (M && !M.test(c.inputValue || ""))
          return c.editorErrorMessage = c.inputErrorMessage || a("el.messagebox.error"), c.validateError = !0, !1;
        const A = c.inputValidator;
        if (it(A)) {
          const L = A(c.inputValue);
          if (L === !1)
            return c.editorErrorMessage = c.inputErrorMessage || a("el.messagebox.error"), c.validateError = !0, !1;
          if (rt(L))
            return c.editorErrorMessage = L, c.validateError = !0, !1;
        }
      }
      return c.editorErrorMessage = "", c.validateError = !1, !0;
    }, z = () => {
      var M, A;
      const L = (M = y.value) == null ? void 0 : M.$refs;
      return (A = L == null ? void 0 : L.input) != null ? A : L == null ? void 0 : L.textarea;
    }, D = () => {
      N("close");
    }, F = () => {
      e.closeOnPressEscape && D();
    };
    return e.lockScroll && U1(s, { ns: l }), vt(Be({}, /* @__PURE__ */ to(c)), {
      ns: l,
      overlayEvent: P,
      visible: s,
      hasMessage: m,
      typeClass: u,
      contentId: d,
      inputId: f,
      btnSize: r,
      iconComponent: p,
      confirmButtonClasses: C,
      rootRef: v,
      focusStartRef: g,
      headerRef: h,
      inputRef: y,
      isDragging: E,
      confirmRef: b,
      doClose: I,
      handleClose: D,
      onCloseRequested: F,
      handleWrapperClick: T,
      handleInputEnter: k,
      handleAction: N,
      t: a
    });
  }
}), STe = ["aria-label", "aria-describedby"], CTe = ["aria-label"], wTe = ["id"];
function $Te(e, t, n, o, l, r) {
  const a = yn("el-icon"), i = yn("el-input"), s = yn("el-button"), c = yn("el-focus-trap"), u = yn("el-overlay");
  return G(), Me(Vn, {
    name: "fade-in-linear",
    onAfterLeave: t[11] || (t[11] = (d) => e.$emit("vanish")),
    persisted: ""
  }, {
    default: Ee(() => [
      _t($(u, {
        "z-index": e.zIndex,
        "overlay-class": [e.ns.is("message-box"), e.modalClass],
        mask: e.modal
      }, {
        default: Ee(() => [
          ve("div", {
            role: "dialog",
            "aria-label": e.title,
            "aria-modal": "true",
            "aria-describedby": e.showInput ? void 0 : e.contentId,
            class: X(`${e.ns.namespace.value}-overlay-message-box`),
            onClick: t[8] || (t[8] = (...d) => e.overlayEvent.onClick && e.overlayEvent.onClick(...d)),
            onMousedown: t[9] || (t[9] = (...d) => e.overlayEvent.onMousedown && e.overlayEvent.onMousedown(...d)),
            onMouseup: t[10] || (t[10] = (...d) => e.overlayEvent.onMouseup && e.overlayEvent.onMouseup(...d))
          }, [
            $(c, {
              loop: "",
              trapped: e.visible,
              "focus-trap-el": e.rootRef,
              "focus-start-el": e.focusStartRef,
              onReleaseRequested: e.onCloseRequested
            }, {
              default: Ee(() => [
                ve(
                  "div",
                  {
                    ref: "rootRef",
                    class: X([
                      e.ns.b(),
                      e.customClass,
                      e.ns.is("draggable", e.draggable),
                      e.ns.is("dragging", e.isDragging),
                      { [e.ns.m("center")]: e.center }
                    ]),
                    style: gt(e.customStyle),
                    tabindex: "-1",
                    onClick: t[7] || (t[7] = Et(() => {
                    }, ["stop"]))
                  },
                  [
                    e.title !== null && e.title !== void 0 ? (G(), ue(
                      "div",
                      {
                        key: 0,
                        ref: "headerRef",
                        class: X([e.ns.e("header"), { "show-close": e.showClose }])
                      },
                      [
                        ve(
                          "div",
                          {
                            class: X(e.ns.e("title"))
                          },
                          [
                            e.iconComponent && e.center ? (G(), Me(a, {
                              key: 0,
                              class: X([e.ns.e("status"), e.typeClass])
                            }, {
                              default: Ee(() => [
                                (G(), Me(Ht(e.iconComponent)))
                              ]),
                              _: 1
                            }, 8, ["class"])) : Ie("v-if", !0),
                            ve(
                              "span",
                              null,
                              qe(e.title),
                              1
                            )
                          ],
                          2
                        ),
                        e.showClose ? (G(), ue("button", {
                          key: 0,
                          type: "button",
                          class: X(e.ns.e("headerbtn")),
                          "aria-label": e.t("el.messagebox.close"),
                          onClick: t[0] || (t[0] = (d) => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel")),
                          onKeydown: t[1] || (t[1] = uo(Et((d) => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"]))
                        }, [
                          $(a, {
                            class: X(e.ns.e("close"))
                          }, {
                            default: Ee(() => [
                              (G(), Me(Ht(e.closeIcon || "close")))
                            ]),
                            _: 1
                          }, 8, ["class"])
                        ], 42, CTe)) : Ie("v-if", !0)
                      ],
                      2
                    )) : Ie("v-if", !0),
                    ve("div", {
                      id: e.contentId,
                      class: X(e.ns.e("content"))
                    }, [
                      ve(
                        "div",
                        {
                          class: X(e.ns.e("container"))
                        },
                        [
                          e.iconComponent && !e.center && e.hasMessage ? (G(), Me(a, {
                            key: 0,
                            class: X([e.ns.e("status"), e.typeClass])
                          }, {
                            default: Ee(() => [
                              (G(), Me(Ht(e.iconComponent)))
                            ]),
                            _: 1
                          }, 8, ["class"])) : Ie("v-if", !0),
                          e.hasMessage ? (G(), ue(
                            "div",
                            {
                              key: 1,
                              class: X(e.ns.e("message"))
                            },
                            [
                              Oe(e.$slots, "default", {}, () => [
                                e.dangerouslyUseHTMLString ? (G(), Me(Ht(e.showInput ? "label" : "p"), {
                                  key: 1,
                                  for: e.showInput ? e.inputId : void 0,
                                  innerHTML: e.message
                                }, null, 8, ["for", "innerHTML"])) : (G(), Me(Ht(e.showInput ? "label" : "p"), {
                                  key: 0,
                                  for: e.showInput ? e.inputId : void 0,
                                  textContent: qe(e.message)
                                }, null, 8, ["for", "textContent"]))
                              ])
                            ],
                            2
                          )) : Ie("v-if", !0)
                        ],
                        2
                      ),
                      _t(ve(
                        "div",
                        {
                          class: X(e.ns.e("input"))
                        },
                        [
                          $(i, {
                            id: e.inputId,
                            ref: "inputRef",
                            modelValue: e.inputValue,
                            "onUpdate:modelValue": t[2] || (t[2] = (d) => e.inputValue = d),
                            type: e.inputType,
                            placeholder: e.inputPlaceholder,
                            "aria-invalid": e.validateError,
                            class: X({ invalid: e.validateError }),
                            onKeydown: uo(e.handleInputEnter, ["enter"])
                          }, null, 8, ["id", "modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                          ve(
                            "div",
                            {
                              class: X(e.ns.e("errormsg")),
                              style: gt({
                                visibility: e.editorErrorMessage ? "visible" : "hidden"
                              })
                            },
                            qe(e.editorErrorMessage),
                            7
                          )
                        ],
                        2
                      ), [
                        [Jt, e.showInput]
                      ])
                    ], 10, wTe),
                    ve(
                      "div",
                      {
                        class: X(e.ns.e("btns"))
                      },
                      [
                        e.showCancelButton ? (G(), Me(s, {
                          key: 0,
                          type: e.cancelButtonType === "text" ? "" : e.cancelButtonType,
                          text: e.cancelButtonType === "text",
                          loading: e.cancelButtonLoading,
                          "loading-icon": e.cancelButtonLoadingIcon,
                          class: X([e.cancelButtonClass]),
                          round: e.roundButton,
                          size: e.btnSize,
                          onClick: t[3] || (t[3] = (d) => e.handleAction("cancel")),
                          onKeydown: t[4] || (t[4] = uo(Et((d) => e.handleAction("cancel"), ["prevent"]), ["enter"]))
                        }, {
                          default: Ee(() => [
                            Ft(
                              qe(e.cancelButtonText || e.t("el.messagebox.cancel")),
                              1
                            )
                          ]),
                          _: 1
                        }, 8, ["type", "text", "loading", "loading-icon", "class", "round", "size"])) : Ie("v-if", !0),
                        _t($(s, {
                          ref: "confirmRef",
                          type: e.confirmButtonType === "text" ? "" : e.confirmButtonType,
                          text: e.confirmButtonType === "text",
                          loading: e.confirmButtonLoading,
                          "loading-icon": e.confirmButtonLoadingIcon,
                          class: X([e.confirmButtonClasses]),
                          round: e.roundButton,
                          disabled: e.confirmButtonDisabled,
                          size: e.btnSize,
                          onClick: t[5] || (t[5] = (d) => e.handleAction("confirm")),
                          onKeydown: t[6] || (t[6] = uo(Et((d) => e.handleAction("confirm"), ["prevent"]), ["enter"]))
                        }, {
                          default: Ee(() => [
                            Ft(
                              qe(e.confirmButtonText || e.t("el.messagebox.confirm")),
                              1
                            )
                          ]),
                          _: 1
                        }, 8, ["type", "text", "loading", "loading-icon", "class", "round", "disabled", "size"]), [
                          [Jt, e.showConfirmButton]
                        ])
                      ],
                      2
                    )
                  ],
                  6
                )
              ]),
              _: 3
            }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
          ], 42, STe)
        ]),
        _: 3
      }, 8, ["z-index", "overlay-class", "mask"]), [
        [Jt, e.visible]
      ])
    ]),
    _: 3
  });
}
var xTe = /* @__PURE__ */ Je(yTe, [["render", $Te], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/message-box/src/index.vue"]]);
const Em = /* @__PURE__ */ new Map(), ETe = (e) => {
  let t = document.body;
  return e.appendTo && (rt(e.appendTo) && (t = document.querySelector(e.appendTo)), tr(e.appendTo) && (t = e.appendTo), tr(t) || (Gt(
    "ElMessageBox",
    "the appendTo option is not an HTMLElement. Falling back to document.body."
  ), t = document.body)), t;
}, OTe = (e, t, n = null) => {
  const o = $(
    xTe,
    e,
    it(e.message) || dn(e.message) ? {
      default: it(e.message) ? e.message : () => e.message
    } : null
  );
  return o.appContext = n, Bl(o, t), ETe(e).appendChild(t.firstElementChild), o.component;
}, _Te = () => document.createElement("div"), ITe = (e, t) => {
  const n = _Te();
  e.onVanish = () => {
    Bl(null, n), Em.delete(l);
  }, e.onAction = (r) => {
    const a = Em.get(l);
    let i;
    e.showInput ? i = { value: l.inputValue, action: r } : i = r, e.callback ? e.callback(i, o.proxy) : r === "cancel" || r === "close" ? e.distinguishCancelAndClose && r !== "cancel" ? a.reject("close") : a.reject("cancel") : a.resolve(i);
  };
  const o = OTe(e, n, t), l = o.proxy;
  for (const r in e)
    hn(e, r) && !hn(l.$props, r) && (r === "closeIcon" && Mt(e[r]) ? l[r] = wa(e[r]) : l[r] = e[r]);
  return l.visible = !0, l;
};
function Ip(e, t = null) {
  if (!Sn)
    return Promise.reject();
  let n;
  return rt(e) || dn(e) ? e = {
    message: e
  } : n = e.callback, new Promise((o, l) => {
    const r = ITe(
      e,
      t != null ? t : Ip._context
    );
    Em.set(r, {
      options: e,
      callback: n,
      resolve: o,
      reject: l
    });
  });
}
const TTe = ["alert", "confirm", "prompt"], PTe = {
  alert: { closeOnPressEscape: !1, closeOnClickModal: !1 },
  confirm: { showCancelButton: !0 },
  prompt: { showCancelButton: !0, showInput: !0 }
};
TTe.forEach((e) => {
  Ip[e] = kTe(
    e
  );
});
function kTe(e) {
  return (t, n, o, l) => {
    let r = "";
    return Mt(n) ? (o = n, r = "") : fn(n) ? r = "" : r = n, Ip(
      Object.assign(
        Be({
          title: r,
          message: t,
          type: ""
        }, PTe[e]),
        o,
        {
          boxType: e
        }
      ),
      l
    );
  };
}
Ip.close = () => {
  Em.forEach((e, t) => {
    t.doClose();
  }), Em.clear();
};
Ip._context = null;
const Vs = Ip;
Vs.install = (e) => {
  Vs._context = e._context, e.config.globalProperties.$msgbox = Vs, e.config.globalProperties.$messageBox = Vs, e.config.globalProperties.$alert = Vs.alert, e.config.globalProperties.$confirm = Vs.confirm, e.config.globalProperties.$prompt = Vs.prompt;
};
const NTe = Vs, jz = [
  "primary",
  "success",
  "info",
  "warning",
  "error"
], MTe = Xe({
  customClass: {
    type: String,
    default: ""
  },
  dangerouslyUseHTMLString: Boolean,
  duration: {
    type: Number,
    default: 4500
  },
  icon: {
    type: Pn
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: ye([
      String,
      Object,
      Function
    ]),
    default: ""
  },
  offset: {
    type: Number,
    default: 0
  },
  onClick: {
    type: ye(Function),
    default: () => {
    }
  },
  onClose: {
    type: ye(Function),
    required: !0
  },
  position: {
    type: String,
    values: ["top-right", "top-left", "bottom-right", "bottom-left"],
    default: "top-right"
  },
  showClose: {
    type: Boolean,
    default: !0
  },
  title: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    values: [...jz, ""],
    default: ""
  },
  zIndex: Number,
  closeIcon: {
    type: Pn,
    default: aa
  }
}), ATe = {
  destroy: () => !0
}, RTe = ["id"], DTe = ["textContent"], LTe = { key: 0 }, BTe = ["innerHTML"], FTe = /* @__PURE__ */ le({
  name: "ElNotification",
  __name: "notification",
  props: MTe,
  emits: ATe,
  setup(e, { expose: t }) {
    const n = e, { ns: o, zIndex: l } = M1("notification"), { nextZIndex: r, currentZIndex: a } = l, i = /* @__PURE__ */ H(!1);
    let s;
    const c = O(() => {
      const y = n.type;
      return y && Sc[n.type] ? o.m(y) : "";
    }), u = O(() => n.type && Sc[n.type] || n.icon), d = O(
      () => n.position.endsWith("right") ? "right" : "left"
    ), f = O(
      () => n.position.startsWith("top") ? "top" : "bottom"
    ), p = O(() => {
      var y;
      return {
        [f.value]: `${n.offset}px`,
        zIndex: (y = n.zIndex) != null ? y : a.value
      };
    });
    function m() {
      n.duration > 0 && ({ stop: s } = jf(() => {
        i.value && h();
      }, n.duration));
    }
    function v() {
      s == null || s();
    }
    function h() {
      i.value = !1;
    }
    function g(y) {
      switch (Nn(y)) {
        case Ye.delete:
        case Ye.backspace:
          v();
          break;
        case Ye.esc:
          i.value && h();
          break;
        default:
          m();
          break;
      }
    }
    return nt(() => {
      m(), r(), i.value = !0;
    }), wn(document, "keydown", g), t({
      visible: i,
      close: h
    }), (y, b) => (G(), Me(Vn, {
      name: S(o).b("fade"),
      onBeforeLeave: y.onClose,
      onAfterLeave: b[1] || (b[1] = (C) => y.$emit("destroy")),
      persisted: ""
    }, {
      default: Ee(() => [
        _t(ve("div", {
          id: y.id,
          class: X([S(o).b(), y.customClass, d.value]),
          style: gt(p.value),
          role: "alert",
          onMouseenter: v,
          onMouseleave: m,
          onClick: b[0] || (b[0] = (...C) => y.onClick && y.onClick(...C))
        }, [
          u.value ? (G(), Me(S(ut), {
            key: 0,
            class: X([S(o).e("icon"), c.value])
          }, {
            default: Ee(() => [
              (G(), Me(Ht(u.value)))
            ]),
            _: 1
          }, 8, ["class"])) : Ie("v-if", !0),
          ve(
            "div",
            {
              class: X(S(o).e("group"))
            },
            [
              ve("h2", {
                class: X(S(o).e("title")),
                textContent: qe(y.title)
              }, null, 10, DTe),
              _t(ve(
                "div",
                {
                  class: X(S(o).e("content")),
                  style: gt(y.title ? void 0 : { margin: 0 })
                },
                [
                  Oe(y.$slots, "default", {}, () => [
                    y.dangerouslyUseHTMLString ? (G(), ue(
                      Ge,
                      { key: 1 },
                      [
                        Ie(" Caution here, message could've been compromised, never use user's input as message "),
                        ve("p", { innerHTML: y.message }, null, 8, BTe)
                      ],
                      2112
                    )) : (G(), ue(
                      "p",
                      LTe,
                      qe(y.message),
                      1
                    ))
                  ])
                ],
                6
              ), [
                [Jt, y.message]
              ]),
              y.showClose ? (G(), Me(S(ut), {
                key: 0,
                class: X(S(o).e("closeBtn")),
                onClick: Et(h, ["stop"])
              }, {
                default: Ee(() => [
                  (G(), Me(Ht(y.closeIcon)))
                ]),
                _: 1
              }, 8, ["class"])) : Ie("v-if", !0)
            ],
            2
          )
        ], 46, RTe), [
          [Jt, i.value]
        ])
      ]),
      _: 3
    }, 8, ["name", "onBeforeLeave"]));
  }
});
var VTe = /* @__PURE__ */ Je(FTe, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/notification/src/notification.vue"]]);
const np = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": []
}, ey = 16;
let zTe = 1;
const Gu = function(e = {}, t) {
  if (!Sn)
    return { close: () => {
    } };
  (rt(e) || dn(e)) && (e = { message: e });
  const n = e.position || "top-right";
  let o = e.offset || 0;
  np[n].forEach(({ vm: u }) => {
    var d;
    o += (((d = u.el) == null ? void 0 : d.offsetHeight) || 0) + ey;
  }), o += ey;
  const l = `notification_${zTe++}`, r = e.onClose, a = vt(Be({}, e), {
    offset: o,
    id: l,
    onClose: () => {
      HTe(l, n, r);
    }
  });
  let i = document.body;
  tr(e.appendTo) ? i = e.appendTo : rt(e.appendTo) && (i = document.querySelector(e.appendTo)), tr(i) || (Gt(
    "ElNotification",
    "the appendTo option is not an HTMLElement. Falling back to document.body."
  ), i = document.body);
  const s = document.createElement("div"), c = $(
    VTe,
    a,
    it(a.message) ? a.message : dn(a.message) ? () => a.message : null
  );
  return c.appContext = fn(t) ? Gu._context : t, c.props.onDestroy = () => {
    Bl(null, s);
  }, Bl(c, s), np[n].push({ vm: c }), i.appendChild(s.firstElementChild), {
    close: () => {
      c.component.exposed.visible.value = !1;
    }
  };
};
jz.forEach((e) => {
  Gu[e] = (t = {}, n) => ((rt(t) || dn(t)) && (t = {
    message: t
  }), Gu(vt(Be({}, t), { type: e }), n));
});
function HTe(e, t, n) {
  const o = np[t], l = o.findIndex(
    ({ vm: c }) => {
      var u;
      return ((u = c.component) == null ? void 0 : u.props.id) === e;
    }
  );
  if (l === -1)
    return;
  const { vm: r } = o[l];
  if (!r)
    return;
  n == null || n(r);
  const a = r.el.offsetHeight, i = t.split("-")[0];
  o.splice(l, 1);
  const s = o.length;
  if (!(s < 1))
    for (let c = l; c < s; c++) {
      const { el: u, component: d } = o[c].vm, f = Number.parseInt(u.style[i], 10) - a - ey;
      d.props.offset = f;
    }
}
function jTe() {
  for (const e of Object.values(np))
    e.forEach(({ vm: t }) => {
      t.component.exposed.visible.value = !1;
    });
}
function WTe(e = "top-right") {
  var t, n, o, l;
  let r = ((o = (n = (t = np[e][0]) == null ? void 0 : t.vm.component) == null ? void 0 : n.props) == null ? void 0 : o.offset) || 0;
  for (const { vm: a } of np[e])
    a.component.props.offset = r, r += (((l = a.el) == null ? void 0 : l.offsetHeight) || 0) + ey;
}
Gu.closeAll = jTe;
Gu.updateOffsets = WTe;
Gu._context = null;
const KTe = y7(Gu, "$notify");
var UTe = [
  YIe,
  QIe,
  gTe,
  NTe,
  KTe,
  Q9
], GTe = bie([...zIe, ...UTe]);
function Om(e) {
  "@babel/helpers - typeof";
  return Om = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Om(e);
}
function YTe(e, t) {
  if (Om(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(e, t);
    if (Om(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function XTe(e) {
  var t = YTe(e, "string");
  return Om(t) == "symbol" ? t : t + "";
}
function qTe(e, t, n) {
  return (t = XTe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function wM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(e, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function Q(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wM(Object(n), !0).forEach(function(o) {
      qTe(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wM(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
function _() {
  return _ = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n) ({}).hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, _.apply(null, arguments);
}
const o2 = (e) => typeof e == "function", JTe = Array.isArray, ZTe = (e) => typeof e == "string", QTe = (e) => e !== null && typeof e == "object", ePe = /^on[^a-z]/, tPe = (e) => ePe.test(e), eI = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
}, nPe = /-(\w)/g, Tp = eI((e) => e.replace(nPe, (t, n) => n ? n.toUpperCase() : "")), oPe = /\B([A-Z])/g, lPe = eI((e) => e.replace(oPe, "-$1").toLowerCase()), rPe = eI((e) => e.charAt(0).toUpperCase() + e.slice(1)), aPe = Object.prototype.hasOwnProperty, $M = (e, t) => aPe.call(e, t);
function iPe(e, t, n, o) {
  const l = e[n];
  if (l != null) {
    const r = $M(l, "default");
    if (r && o === void 0) {
      const a = l.default;
      o = l.type !== Function && o2(a) ? a() : a;
    }
    l.type === Boolean && (!$M(t, n) && !r ? o = !1 : o === "" && (o = !0));
  }
  return o;
}
function sPe(e) {
  return Object.keys(e).reduce((t, n) => ((n.startsWith("data-") || n.startsWith("aria-")) && (t[n] = e[n]), t), {});
}
function ru(e) {
  return typeof e == "number" ? `${e}px` : e;
}
function Jd(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
  return typeof e == "function" ? e(t) : e != null ? e : n;
}
function cPe(e) {
  let t;
  const n = new Promise((l) => {
    t = e(() => {
      l(!0);
    });
  }), o = () => {
    t == null || t();
  };
  return o.then = (l, r) => n.then(l, r), o.promise = n, o;
}
function ke() {
  const e = [];
  for (let t = 0; t < arguments.length; t++) {
    const n = t < 0 || arguments.length <= t ? void 0 : arguments[t];
    if (n) {
      if (ZTe(n))
        e.push(n);
      else if (JTe(n))
        for (let o = 0; o < n.length; o++) {
          const l = ke(n[o]);
          l && e.push(l);
        }
      else if (QTe(n))
        for (const o in n)
          n[o] && e.push(o);
    }
  }
  return e.join(" ");
}
var Wz = function() {
  if (typeof Map != "undefined")
    return Map;
  function e(t, n) {
    var o = -1;
    return t.some(function(l, r) {
      return l[0] === n ? (o = r, !0) : !1;
    }), o;
  }
  return (
    /** @class */
    function() {
      function t() {
        this.__entries__ = [];
      }
      return Object.defineProperty(t.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.get = function(n) {
        var o = e(this.__entries__, n), l = this.__entries__[o];
        return l && l[1];
      }, t.prototype.set = function(n, o) {
        var l = e(this.__entries__, n);
        ~l ? this.__entries__[l][1] = o : this.__entries__.push([n, o]);
      }, t.prototype.delete = function(n) {
        var o = this.__entries__, l = e(o, n);
        ~l && o.splice(l, 1);
      }, t.prototype.has = function(n) {
        return !!~e(this.__entries__, n);
      }, t.prototype.clear = function() {
        this.__entries__.splice(0);
      }, t.prototype.forEach = function(n, o) {
        o === void 0 && (o = null);
        for (var l = 0, r = this.__entries__; l < r.length; l++) {
          var a = r[l];
          n.call(o, a[1], a[0]);
        }
      }, t;
    }()
  );
}(), l2 = typeof window != "undefined" && typeof document != "undefined" && window.document === document, ty = function() {
  return typeof global != "undefined" && global.Math === Math ? global : typeof self != "undefined" && self.Math === Math ? self : typeof window != "undefined" && window.Math === Math ? window : Function("return this")();
}(), uPe = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(ty) : function(e) {
    return setTimeout(function() {
      return e(Date.now());
    }, 1e3 / 60);
  };
}(), dPe = 2;
function fPe(e, t) {
  var n = !1, o = !1, l = 0;
  function r() {
    n && (n = !1, e()), o && i();
  }
  function a() {
    uPe(r);
  }
  function i() {
    var s = Date.now();
    if (n) {
      if (s - l < dPe)
        return;
      o = !0;
    } else
      n = !0, o = !1, setTimeout(a, t);
    l = s;
  }
  return i;
}
var pPe = 20, vPe = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], mPe = typeof MutationObserver != "undefined", hPe = (
  /** @class */
  function() {
    function e() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = fPe(this.refresh.bind(this), pPe);
    }
    return e.prototype.addObserver = function(t) {
      ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_();
    }, e.prototype.removeObserver = function(t) {
      var n = this.observers_, o = n.indexOf(t);
      ~o && n.splice(o, 1), !n.length && this.connected_ && this.disconnect_();
    }, e.prototype.refresh = function() {
      var t = this.updateObservers_();
      t && this.refresh();
    }, e.prototype.updateObservers_ = function() {
      var t = this.observers_.filter(function(n) {
        return n.gatherActive(), n.hasActive();
      });
      return t.forEach(function(n) {
        return n.broadcastActive();
      }), t.length > 0;
    }, e.prototype.connect_ = function() {
      !l2 || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), mPe ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, e.prototype.disconnect_ = function() {
      !l2 || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, e.prototype.onTransitionEnd_ = function(t) {
      var n = t.propertyName, o = n === void 0 ? "" : n, l = vPe.some(function(r) {
        return !!~o.indexOf(r);
      });
      l && this.refresh();
    }, e.getInstance = function() {
      return this.instance_ || (this.instance_ = new e()), this.instance_;
    }, e.instance_ = null, e;
  }()
), Kz = function(e, t) {
  for (var n = 0, o = Object.keys(t); n < o.length; n++) {
    var l = o[n];
    Object.defineProperty(e, l, {
      value: t[l],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return e;
}, op = function(e) {
  var t = e && e.ownerDocument && e.ownerDocument.defaultView;
  return t || ty;
}, Uz = tS(0, 0, 0, 0);
function ny(e) {
  return parseFloat(e) || 0;
}
function xM(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  return t.reduce(function(o, l) {
    var r = e["border-" + l + "-width"];
    return o + ny(r);
  }, 0);
}
function gPe(e) {
  for (var t = ["top", "right", "bottom", "left"], n = {}, o = 0, l = t; o < l.length; o++) {
    var r = l[o], a = e["padding-" + r];
    n[r] = ny(a);
  }
  return n;
}
function bPe(e) {
  var t = e.getBBox();
  return tS(0, 0, t.width, t.height);
}
function yPe(e) {
  var t = e.clientWidth, n = e.clientHeight;
  if (!t && !n)
    return Uz;
  var o = op(e).getComputedStyle(e), l = gPe(o), r = l.left + l.right, a = l.top + l.bottom, i = ny(o.width), s = ny(o.height);
  if (o.boxSizing === "border-box" && (Math.round(i + r) !== t && (i -= xM(o, "left", "right") + r), Math.round(s + a) !== n && (s -= xM(o, "top", "bottom") + a)), !CPe(e)) {
    var c = Math.round(i + r) - t, u = Math.round(s + a) - n;
    Math.abs(c) !== 1 && (i -= c), Math.abs(u) !== 1 && (s -= u);
  }
  return tS(l.left, l.top, i, s);
}
var SPe = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement != "undefined" ? function(e) {
    return e instanceof op(e).SVGGraphicsElement;
  } : function(e) {
    return e instanceof op(e).SVGElement && typeof e.getBBox == "function";
  };
}();
function CPe(e) {
  return e === op(e).document.documentElement;
}
function wPe(e) {
  return l2 ? SPe(e) ? bPe(e) : yPe(e) : Uz;
}
function $Pe(e) {
  var t = e.x, n = e.y, o = e.width, l = e.height, r = typeof DOMRectReadOnly != "undefined" ? DOMRectReadOnly : Object, a = Object.create(r.prototype);
  return Kz(a, {
    x: t,
    y: n,
    width: o,
    height: l,
    top: n,
    right: t + o,
    bottom: l + n,
    left: t
  }), a;
}
function tS(e, t, n, o) {
  return { x: e, y: t, width: n, height: o };
}
var xPe = (
  /** @class */
  function() {
    function e(t) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = tS(0, 0, 0, 0), this.target = t;
    }
    return e.prototype.isActive = function() {
      var t = wPe(this.target);
      return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight;
    }, e.prototype.broadcastRect = function() {
      var t = this.contentRect_;
      return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t;
    }, e;
  }()
), EPe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, n) {
      var o = $Pe(n);
      Kz(this, { target: t, contentRect: o });
    }
    return e;
  }()
), OPe = (
  /** @class */
  function() {
    function e(t, n, o) {
      if (this.activeObservations_ = [], this.observations_ = new Wz(), typeof t != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = t, this.controller_ = n, this.callbackCtx_ = o;
    }
    return e.prototype.observe = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element == "undefined" || !(Element instanceof Object))) {
        if (!(t instanceof op(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) || (n.set(t, new xPe(t)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, e.prototype.unobserve = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element == "undefined" || !(Element instanceof Object))) {
        if (!(t instanceof op(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) && (n.delete(t), n.size || this.controller_.removeObserver(this));
      }
    }, e.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, e.prototype.gatherActive = function() {
      var t = this;
      this.clearActive(), this.observations_.forEach(function(n) {
        n.isActive() && t.activeObservations_.push(n);
      });
    }, e.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var t = this.callbackCtx_, n = this.activeObservations_.map(function(o) {
          return new EPe(o.target, o.broadcastRect());
        });
        this.callback_.call(t, n, t), this.clearActive();
      }
    }, e.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, e.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, e;
  }()
), Gz = typeof WeakMap != "undefined" ? /* @__PURE__ */ new WeakMap() : new Wz(), Yz = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      if (!(this instanceof e))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var n = hPe.getInstance(), o = new OPe(t, n, this);
      Gz.set(this, o);
    }
    return e;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(e) {
  Yz.prototype[e] = function() {
    var t;
    return (t = Gz.get(this))[e].apply(t, arguments);
  };
});
var tI = function() {
  return typeof ty.ResizeObserver != "undefined" ? ty.ResizeObserver : Yz;
}();
const r2 = (e) => e != null && e !== "", sn = (e, t) => {
  const n = _({}, e);
  return Object.keys(t).forEach((o) => {
    const l = n[o];
    if (l)
      l.type || l.default ? l.default = t[o] : l.def ? l.def(t[o]) : n[o] = {
        type: l,
        default: t[o]
      };
    else
      throw new Error(`not have ${o} prop`);
  }), n;
}, nI = (e) => {
  const t = Object.keys(e), n = {}, o = {}, l = {};
  for (let r = 0, a = t.length; r < a; r++) {
    const i = t[r];
    tPe(i) ? (n[i[2].toLowerCase() + i.slice(3)] = e[i], o[i] = e[i]) : l[i] = e[i];
  }
  return {
    onEvents: o,
    events: n,
    extraAttrs: l
  };
}, _Pe = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const n = {}, o = /;(?![^(]*\))/g, l = /:(.+)/;
  return typeof e == "object" ? e : (e.split(o).forEach(function(r) {
    if (r) {
      const a = r.split(l);
      if (a.length > 1) {
        const i = t ? Tp(a[0].trim()) : a[0].trim();
        n[i] = a[1].trim();
      }
    }
  }), n);
}, os = (e, t) => e[t] !== void 0, Xz = Symbol("skipFlatten"), Fn = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  const n = Array.isArray(e) ? e : [e], o = [];
  return n.forEach((l) => {
    Array.isArray(l) ? o.push(...Fn(l, t)) : l && l.type === Ge ? l.key === Xz ? o.push(l) : o.push(...Fn(l.children, t)) : l && dn(l) ? t && !$h(l) ? o.push(l) : t || o.push(l) : r2(l) && o.push(l);
  }), o;
}, nS = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (dn(e))
    return e.type === Ge ? t === "default" ? Fn(e.children) : [] : e.children && e.children[t] ? Fn(e.children[t](n)) : [];
  {
    const o = e.$slots[t] && e.$slots[t](n);
    return Fn(o);
  }
}, nr = (e) => {
  var t;
  let n = ((t = e == null ? void 0 : e.vnode) === null || t === void 0 ? void 0 : t.el) || e && (e.$el || e);
  for (; n && !n.tagName; )
    n = n.nextSibling;
  return n;
}, qz = (e) => {
  const t = {};
  if (e.$ && e.$.vnode) {
    const n = e.$.vnode.props || {};
    Object.keys(e.$props).forEach((o) => {
      const l = e.$props[o], r = lPe(o);
      (l !== void 0 || r in n) && (t[o] = l);
    });
  } else if (dn(e) && typeof e.type == "object") {
    const n = e.props || {}, o = {};
    Object.keys(n).forEach((r) => {
      o[Tp(r)] = n[r];
    });
    const l = e.type.props || {};
    Object.keys(l).forEach((r) => {
      const a = iPe(l, o, r, o[r]);
      (a !== void 0 || r in o) && (t[r] = a);
    });
  }
  return t;
}, Jz = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, l;
  if (e.$) {
    const r = e[t];
    if (r !== void 0)
      return typeof r == "function" && o ? r(n) : r;
    l = e.$slots[t], l = o && l ? l(n) : l;
  } else if (dn(e)) {
    const r = e.props && e.props[t];
    if (r !== void 0 && e.props !== null)
      return typeof r == "function" && o ? r(n) : r;
    e.type === Ge ? l = e.children : e.children && e.children[t] && (l = e.children[t], l = o && l ? l(n) : l);
  }
  return Array.isArray(l) && (l = Fn(l), l = l.length === 1 ? l[0] : l, l = l.length === 0 ? void 0 : l), l;
};
function EM() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = {};
  return e.$ ? n = _(_({}, n), e.$attrs) : n = _(_({}, n), e.props), nI(n)[t ? "onEvents" : "events"];
}
function IPe(e) {
  const n = ((dn(e) ? e.props : e.$attrs) || {}).class || {};
  let o = {};
  return typeof n == "string" ? n.split(" ").forEach((l) => {
    o[l.trim()] = !0;
  }) : Array.isArray(n) ? ke(n).split(" ").forEach((l) => {
    o[l.trim()] = !0;
  }) : o = _(_({}, o), n), o;
}
function Zz(e, t) {
  let o = ((dn(e) ? e.props : e.$attrs) || {}).style || {};
  return typeof o == "string" && (o = _Pe(o, t)), o;
}
function TPe(e) {
  return e.length === 1 && e[0].type === Ge;
}
function PPe(e) {
  return e == null || e === "" || Array.isArray(e) && e.length === 0;
}
function $h(e) {
  return e && (e.type === qn || e.type === Ge && e.children.length === 0 || e.type === Vr && e.children.trim() === "");
}
function kPe(e) {
  return e && e.type === Vr;
}
function mo() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  const t = [];
  return e.forEach((n) => {
    Array.isArray(n) ? t.push(...n) : (n == null ? void 0 : n.type) === Ge ? t.push(...mo(n.children)) : t.push(n);
  }), t.filter((n) => !$h(n));
}
function ov(e) {
  if (e) {
    const t = mo(e);
    return t.length ? t : void 0;
  } else
    return e;
}
function Io(e) {
  return Array.isArray(e) && e.length === 1 && (e = e[0]), e && e.__v_isVNode && typeof e.type != "symbol";
}
function Wo(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
  var o, l;
  return (o = t[n]) !== null && o !== void 0 ? o : (l = e[n]) === null || l === void 0 ? void 0 : l.call(e);
}
const ca = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ResizeObserver",
  props: {
    disabled: Boolean,
    onResize: Function
  },
  emits: ["resize"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = /* @__PURE__ */ kt({
      width: 0,
      height: 0,
      offsetHeight: 0,
      offsetWidth: 0
    });
    let l = null, r = null;
    const a = () => {
      r && (r.disconnect(), r = null);
    }, i = (u) => {
      const {
        onResize: d
      } = e, f = u[0].target, {
        width: p,
        height: m
      } = f.getBoundingClientRect(), {
        offsetWidth: v,
        offsetHeight: h
      } = f, g = Math.floor(p), y = Math.floor(m);
      if (o.width !== g || o.height !== y || o.offsetWidth !== v || o.offsetHeight !== h) {
        const b = {
          width: g,
          height: y,
          offsetWidth: v,
          offsetHeight: h
        };
        _(o, b), d && Promise.resolve().then(() => {
          d(_(_({}, b), {
            offsetWidth: v,
            offsetHeight: h
          }), f);
        });
      }
    }, s = xt(), c = () => {
      const {
        disabled: u
      } = e;
      if (u) {
        a();
        return;
      }
      const d = nr(s);
      d !== l && (a(), l = d), !r && d && (r = new tI(i), r.observe(d));
    };
    return nt(() => {
      c();
    }), $o(() => {
      c();
    }), Uo(() => {
      a();
    }), pe(() => e.disabled, () => {
      c();
    }, {
      flush: "post"
    }), () => {
      var u;
      return (u = n.default) === null || u === void 0 ? void 0 : u.call(n)[0];
    };
  }
});
let Qz = (e) => setTimeout(e, 16), eH = (e) => clearTimeout(e);
typeof window != "undefined" && "requestAnimationFrame" in window && (Qz = (e) => window.requestAnimationFrame(e), eH = (e) => window.cancelAnimationFrame(e));
let OM = 0;
const oI = /* @__PURE__ */ new Map();
function tH(e) {
  oI.delete(e);
}
function rn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  OM += 1;
  const n = OM;
  function o(l) {
    if (l === 0)
      tH(n), e();
    else {
      const r = Qz(() => {
        o(l - 1);
      });
      oI.set(n, r);
    }
  }
  return o(t), n;
}
rn.cancel = (e) => {
  const t = oI.get(e);
  return tH(t), eH(t);
};
function a2(e) {
  let t;
  const n = (l) => () => {
    t = null, e(...l);
  }, o = function() {
    if (t == null) {
      for (var l = arguments.length, r = new Array(l), a = 0; a < l; a++)
        r[a] = arguments[a];
      t = rn(n(r));
    }
  };
  return o.cancel = () => {
    rn.cancel(t), t = null;
  }, o;
}
const $l = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return t;
}, NPe = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return t;
}, po = (e) => {
  const t = e;
  return t.install = function(n) {
    n.component(t.displayName || t.name, e);
  }, e;
};
function Yu() {
  return {
    type: [Function, Array]
  };
}
function Nt(e) {
  return {
    type: Object,
    default: e
  };
}
function Qe(e) {
  return {
    type: Boolean,
    default: e
  };
}
function Fe(e) {
  return {
    type: Function,
    default: e
  };
}
function Wn(e, t) {
  return {
    validator: () => !0,
    default: e
  };
}
function Pl() {
  return {
    validator: () => !0
  };
}
function $n(e) {
  return {
    type: Array,
    default: e
  };
}
function At(e) {
  return {
    type: String,
    default: e
  };
}
function zt(e, t) {
  return e ? {
    type: e,
    default: t
  } : Wn(t);
}
let Ho = !1;
try {
  const e = Object.defineProperty({}, "passive", {
    get() {
      Ho = !0;
    }
  });
  window.addEventListener("testPassive", null, e), window.removeEventListener("testPassive", null, e);
} catch (e) {
}
function vo(e, t, n, o) {
  if (e && e.addEventListener) {
    let l = o;
    l === void 0 && Ho && (t === "touchstart" || t === "touchmove" || t === "wheel") && (l = {
      passive: !1
    }), e.addEventListener(t, n, l);
  }
  return {
    remove: () => {
      e && e.removeEventListener && e.removeEventListener(t, n);
    }
  };
}
function Sg(e) {
  return e !== window ? e.getBoundingClientRect() : {
    top: 0,
    bottom: window.innerHeight
  };
}
function _M(e, t, n) {
  if (n !== void 0 && t.top > e.top - n)
    return `${n + t.top}px`;
}
function IM(e, t, n) {
  if (n !== void 0 && t.bottom < e.bottom + n) {
    const o = window.innerHeight - t.bottom;
    return `${n + o}px`;
  }
}
const nH = ["resize", "scroll", "touchstart", "touchmove", "touchend", "pageshow", "load"];
let Mv = [];
function TM(e, t) {
  if (!e) return;
  let n = Mv.find((o) => o.target === e);
  n ? n.affixList.push(t) : (n = {
    target: e,
    affixList: [t],
    eventHandlers: {}
  }, Mv.push(n), nH.forEach((o) => {
    n.eventHandlers[o] = vo(e, o, () => {
      n.affixList.forEach((l) => {
        const {
          lazyUpdatePosition: r
        } = l.exposed;
        r();
      }, (o === "touchstart" || o === "touchmove") && Ho ? {
        passive: !0
      } : !1);
    });
  }));
}
function PM(e) {
  const t = Mv.find((n) => {
    const o = n.affixList.some((l) => l === e);
    return o && (n.affixList = n.affixList.filter((l) => l !== e)), o;
  });
  t && t.affixList.length === 0 && (Mv = Mv.filter((n) => n !== t), nH.forEach((n) => {
    const o = t.eventHandlers[n];
    o && o.remove && o.remove();
  }));
}
const lI = "anticon", oH = Symbol("GlobalFormContextKey"), MPe = (e) => {
  at(oH, e);
}, APe = () => ze(oH, {
  validateMessages: O(() => {
  })
}), RPe = () => ({
  iconPrefixCls: String,
  getTargetContainer: {
    type: Function
  },
  getPopupContainer: {
    type: Function
  },
  prefixCls: String,
  getPrefixCls: {
    type: Function
  },
  renderEmpty: {
    type: Function
  },
  transformCellText: {
    type: Function
  },
  csp: Nt(),
  input: Nt(),
  autoInsertSpaceInButton: {
    type: Boolean,
    default: void 0
  },
  locale: Nt(),
  pageHeader: Nt(),
  componentSize: {
    type: String
  },
  componentDisabled: {
    type: Boolean,
    default: void 0
  },
  direction: {
    type: String,
    default: "ltr"
  },
  space: Nt(),
  virtual: {
    type: Boolean,
    default: void 0
  },
  dropdownMatchSelectWidth: {
    type: [Number, Boolean],
    default: !0
  },
  form: Nt(),
  pagination: Nt(),
  theme: Nt(),
  select: Nt(),
  wave: Nt()
}), rI = Symbol("configProvider"), lH = {
  getPrefixCls: (e, t) => t || (e ? `ant-${e}` : "ant"),
  iconPrefixCls: O(() => lI),
  getPopupContainer: O(() => () => document.body),
  direction: O(() => "ltr")
}, oS = () => ze(rI, lH), DPe = (e) => at(rI, e), rH = Symbol("DisabledContextKey"), Cr = () => ze(rH, /* @__PURE__ */ H(void 0)), aH = (e) => {
  const t = Cr();
  return at(rH, O(() => {
    var n;
    return (n = e.value) !== null && n !== void 0 ? n : t.value;
  })), e;
}, iH = {
  // Options.jsx
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "",
  // Pagination.jsx
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages"
}, LPe = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "Ok",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: !0,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
}, sH = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
}, _m = {
  lang: _({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, LPe),
  timePickerLocale: _({}, sH)
}, $r = "${label} is not a valid ${type}", rr = {
  locale: "en",
  Pagination: iH,
  DatePicker: _m,
  TimePicker: sH,
  Calendar: _m,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: $r,
        method: $r,
        array: $r,
        object: $r,
        number: $r,
        date: $r,
        boolean: $r,
        integer: $r,
        float: $r,
        regexp: $r,
        email: $r,
        url: $r,
        hex: $r
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  }
}, sd = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "LocaleReceiver",
  props: {
    componentName: String,
    defaultLocale: {
      type: [Object, Function]
    },
    children: {
      type: Function
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = ze("localeData", {}), l = O(() => {
      const {
        componentName: a = "global",
        defaultLocale: i
      } = e, s = i || rr[a || "global"], {
        antLocale: c
      } = o, u = a && c ? c[a] : {};
      return _(_({}, typeof s == "function" ? s() : s), u || {});
    }), r = O(() => {
      const {
        antLocale: a
      } = o, i = a && a.locale;
      return a && a.exist && !i ? rr.locale : i;
    });
    return () => {
      const a = e.children || n.default, {
        antLocale: i
      } = o;
      return a == null ? void 0 : a(l.value, r.value, i);
    };
  }
});
function fa(e, t, n) {
  const o = ze("localeData", {});
  return [O(() => {
    const {
      antLocale: r
    } = o, a = S(t) || rr[e || "global"], i = e && r ? r[e] : {};
    return _(_(_({}, typeof a == "function" ? a() : a), i || {}), S(n) || {});
  })];
}
function aI(e) {
  for (var t = 0, n, o = 0, l = e.length; l >= 4; ++o, l -= 4)
    n = e.charCodeAt(o) & 255 | (e.charCodeAt(++o) & 255) << 8 | (e.charCodeAt(++o) & 255) << 16 | (e.charCodeAt(++o) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (l) {
    case 3:
      t ^= (e.charCodeAt(o + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(o + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(o) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
const kM = "%";
class BPe {
  constructor(t) {
    this.cache = /* @__PURE__ */ new Map(), this.instanceId = t;
  }
  get(t) {
    return this.cache.get(Array.isArray(t) ? t.join(kM) : t) || null;
  }
  update(t, n) {
    const o = Array.isArray(t) ? t.join(kM) : t, l = this.cache.get(o), r = n(l);
    r === null ? this.cache.delete(o) : this.cache.set(o, r);
  }
}
const cH = "data-token-hash", Iu = "data-css-hash", FPe = "data-cache-path", Zd = "__cssinjs_instance__";
function Im() {
  const e = Math.random().toString(12).slice(2);
  if (typeof document != "undefined" && document.head && document.body) {
    const t = document.body.querySelectorAll(`style[${Iu}]`) || [], {
      firstChild: n
    } = document.head;
    Array.from(t).forEach((l) => {
      l[Zd] = l[Zd] || e, l[Zd] === e && document.head.insertBefore(l, n);
    });
    const o = {};
    Array.from(document.querySelectorAll(`style[${Iu}]`)).forEach((l) => {
      var r;
      const a = l.getAttribute(Iu);
      o[a] ? l[Zd] === e && ((r = l.parentNode) === null || r === void 0 || r.removeChild(l)) : o[a] = !0;
    });
  }
  return new BPe(e);
}
const uH = Symbol("StyleContextKey"), VPe = () => {
  var e, t, n;
  const o = xt();
  let l;
  if (o && o.appContext) {
    const r = (n = (t = (e = o.appContext) === null || e === void 0 ? void 0 : e.config) === null || t === void 0 ? void 0 : t.globalProperties) === null || n === void 0 ? void 0 : n.__ANTDV_CSSINJS_CACHE__;
    r ? l = r : (l = Im(), o.appContext.config.globalProperties && (o.appContext.config.globalProperties.__ANTDV_CSSINJS_CACHE__ = l));
  } else
    l = Im();
  return l;
}, dH = {
  cache: Im(),
  defaultCache: !0,
  hashPriority: "low"
}, lS = () => {
  const e = VPe();
  return ze(uH, /* @__PURE__ */ Ce(_(_({}, dH), {
    cache: e
  })));
}, zPe = (e) => {
  const t = lS(), n = /* @__PURE__ */ Ce(_(_({}, dH), {
    cache: Im()
  }));
  return pe([() => S(e), t], () => {
    const o = _({}, t.value), l = S(e);
    Object.keys(l).forEach((a) => {
      const i = l[a];
      l[a] !== void 0 && (o[a] = i);
    });
    const {
      cache: r
    } = l;
    o.cache = o.cache || Im(), o.defaultCache = !r && t.value.defaultCache, n.value = o;
  }, {
    immediate: !0
  }), at(uH, n), n;
}, HPe = () => ({
  autoClear: Qe(),
  /** @private Test only. Not work in production. */
  mock: At(),
  /**
   * Only set when you need ssr to extract style on you own.
   * If not provided, it will auto create <style /> on the end of Provider in server side.
   */
  cache: Nt(),
  /** Tell children that this context is default generated context */
  defaultCache: Qe(),
  /** Use `:where` selector to reduce hashId css selector priority */
  hashPriority: At(),
  /** Tell cssinjs where to inject style in */
  container: zt(),
  /** Component wil render inline  `<style />` for fallback in SSR. Not recommend. */
  ssrInline: Qe(),
  /** Transform css before inject in document. Please note that `transformers` do not support dynamic update */
  transformers: $n(),
  /**
   * Linters to lint css before inject in document.
   * Styles will be linted after transforming.
   * Please note that `linters` do not support dynamic update.
   */
  linters: $n()
}), jPe = po(/* @__PURE__ */ le({
  name: "AStyleProvider",
  inheritAttrs: !1,
  props: HPe(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return zPe(e), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}));
function WPe() {
  return !1;
}
let i2 = !1;
function KPe() {
  return i2;
}
const UPe = process.env.NODE_ENV === "production" ? WPe : KPe;
if (process.env.NODE_ENV !== "production" && typeof module != "undefined" && module && module.hot && typeof window != "undefined") {
  const e = window;
  if (typeof e.webpackHotUpdate == "function") {
    const t = e.webpackHotUpdate;
    e.webpackHotUpdate = function() {
      return i2 = !0, setTimeout(() => {
        i2 = !1;
      }, 0), t(...arguments);
    };
  }
}
function fH(e, t, n, o) {
  const l = lS(), r = /* @__PURE__ */ Ce(""), a = /* @__PURE__ */ Ce();
  Ot(() => {
    r.value = [e, ...t.value].join("%");
  });
  const i = UPe(), s = (c) => {
    l.value.cache.update(c, (u) => {
      const [d = 0, f] = u || [];
      return d - 1 === 0 ? (o == null || o(f, !1), null) : [d - 1, f];
    });
  };
  return pe(r, (c, u) => {
    u && s(u), l.value.cache.update(c, (d) => {
      const [f = 0, p] = d || [];
      let m = p;
      process.env.NODE_ENV !== "production" && p && i && (o == null || o(m, i), m = null);
      const v = m || n();
      return [f + 1, v];
    }), a.value = l.value.cache.get(r.value)[1];
  }, {
    immediate: !0
  }), yt(() => {
    s(r.value);
  }), a;
}
function Fl() {
  return !!(typeof window != "undefined" && window.document && window.document.createElement);
}
function Xs(e, t) {
  return e && e.contains ? e.contains(t) : !1;
}
const NM = "data-vc-order", GPe = "vc-util-key", s2 = /* @__PURE__ */ new Map();
function pH() {
  let {
    mark: e
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return e ? e.startsWith("data-") ? e : `data-${e}` : GPe;
}
function rS(e) {
  return e.attachTo ? e.attachTo : document.querySelector("head") || document.body;
}
function YPe(e) {
  return e === "queue" ? "prependQueue" : e ? "prepend" : "append";
}
function vH(e) {
  return Array.from((s2.get(e) || e).children).filter((t) => t.tagName === "STYLE");
}
function mH(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!Fl())
    return null;
  const {
    csp: n,
    prepend: o
  } = t, l = document.createElement("style");
  l.setAttribute(NM, YPe(o)), n != null && n.nonce && (l.nonce = n == null ? void 0 : n.nonce), l.innerHTML = e;
  const r = rS(t), {
    firstChild: a
  } = r;
  if (o) {
    if (o === "queue") {
      const i = vH(r).filter((s) => ["prepend", "prependQueue"].includes(s.getAttribute(NM)));
      if (i.length)
        return r.insertBefore(l, i[i.length - 1].nextSibling), l;
    }
    r.insertBefore(l, a);
  } else
    r.appendChild(l);
  return l;
}
function hH(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const n = rS(t);
  return vH(n).find((o) => o.getAttribute(pH(t)) === e);
}
function oy(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const n = hH(e, t);
  n && rS(t).removeChild(n);
}
function XPe(e, t) {
  const n = s2.get(e);
  if (!n || !Xs(document, n)) {
    const o = mH("", t), {
      parentNode: l
    } = o;
    s2.set(e, l), e.removeChild(o);
  }
}
function Tm(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var o, l, r;
  const a = rS(n);
  XPe(a, n);
  const i = hH(t, n);
  if (i)
    return !((o = n.csp) === null || o === void 0) && o.nonce && i.nonce !== ((l = n.csp) === null || l === void 0 ? void 0 : l.nonce) && (i.nonce = (r = n.csp) === null || r === void 0 ? void 0 : r.nonce), i.innerHTML !== e && (i.innerHTML = e), i;
  const s = mH(e, n);
  return s.setAttribute(pH(n), t), s;
}
function qPe(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
class lp {
  constructor() {
    this.cache = /* @__PURE__ */ new Map(), this.keys = [], this.cacheCallTimes = 0;
  }
  size() {
    return this.keys.length;
  }
  internalGet(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, o = {
      map: this.cache
    };
    return t.forEach((l) => {
      var r;
      o ? o = (r = o == null ? void 0 : o.map) === null || r === void 0 ? void 0 : r.get(l) : o = void 0;
    }), o != null && o.value && n && (o.value[1] = this.cacheCallTimes++), o == null ? void 0 : o.value;
  }
  get(t) {
    var n;
    return (n = this.internalGet(t, !0)) === null || n === void 0 ? void 0 : n[0];
  }
  has(t) {
    return !!this.internalGet(t);
  }
  set(t, n) {
    if (!this.has(t)) {
      if (this.size() + 1 > lp.MAX_CACHE_SIZE + lp.MAX_CACHE_OFFSET) {
        const [l] = this.keys.reduce((r, a) => {
          const [, i] = r;
          return this.internalGet(a)[1] < i ? [a, this.internalGet(a)[1]] : r;
        }, [this.keys[0], this.cacheCallTimes]);
        this.delete(l);
      }
      this.keys.push(t);
    }
    let o = this.cache;
    t.forEach((l, r) => {
      if (r === t.length - 1)
        o.set(l, {
          value: [n, this.cacheCallTimes++]
        });
      else {
        const a = o.get(l);
        a ? a.map || (a.map = /* @__PURE__ */ new Map()) : o.set(l, {
          map: /* @__PURE__ */ new Map()
        }), o = o.get(l).map;
      }
    });
  }
  deleteByPath(t, n) {
    var o;
    const l = t.get(n[0]);
    if (n.length === 1)
      return l.map ? t.set(n[0], {
        map: l.map
      }) : t.delete(n[0]), (o = l.value) === null || o === void 0 ? void 0 : o[0];
    const r = this.deleteByPath(l.map, n.slice(1));
    return (!l.map || l.map.size === 0) && !l.value && t.delete(n[0]), r;
  }
  delete(t) {
    if (this.has(t))
      return this.keys = this.keys.filter((n) => !qPe(n, t)), this.deleteByPath(this.cache, t);
  }
}
lp.MAX_CACHE_SIZE = 20;
lp.MAX_CACHE_OFFSET = 5;
let c2 = {};
function bn(e, t) {
  process.env.NODE_ENV !== "production" && !e && console !== void 0 && console.error(`Warning: ${t}`);
}
function gH(e, t) {
  process.env.NODE_ENV !== "production" && !e && console !== void 0 && console.warn(`Note: ${t}`);
}
function JPe() {
  c2 = {};
}
function bH(e, t, n) {
  !t && !c2[n] && (e(!1, n), c2[n] = !0);
}
function pr(e, t) {
  bH(bn, e, t);
}
function u2(e, t) {
  bH(gH, e, t);
}
function ZPe() {
}
let Hn = ZPe;
process.env.NODE_ENV !== "production" && (Hn = (e, t, n) => {
  pr(e, `[ant-design-vue: ${t}] ${n}`), process.env.NODE_ENV === "test" && JPe();
});
let MM = 0;
class yH {
  constructor(t) {
    this.derivatives = Array.isArray(t) ? t : [t], this.id = MM, t.length === 0 && Hn(t.length > 0, "[Ant Design Vue CSS-in-JS] Theme should have at least one derivative function."), MM += 1;
  }
  getDerivativeToken(t) {
    return this.derivatives.reduce((n, o) => o(t, n), void 0);
  }
}
const dw = new lp();
function SH(e) {
  const t = Array.isArray(e) ? e : [e];
  return dw.has(t) || dw.set(t, new yH(t)), dw.get(t);
}
const AM = /* @__PURE__ */ new WeakMap();
function ly(e) {
  let t = AM.get(e) || "";
  return t || (Object.keys(e).forEach((n) => {
    const o = e[n];
    t += n, o instanceof yH ? t += o.id : o && typeof o == "object" ? t += ly(o) : t += o;
  }), AM.set(e, t)), t;
}
function QPe(e, t) {
  return aI(`${t}_${ly(e)}`);
}
const Av = `random-${Date.now()}-${Math.random()}`.replace(/\./g, ""), CH = "_bAmBoO_";
function eke(e, t, n) {
  var o, l;
  if (Fl()) {
    Tm(e, Av);
    const r = document.createElement("div");
    r.style.position = "fixed", r.style.left = "0", r.style.top = "0", t == null || t(r), document.body.appendChild(r), process.env.NODE_ENV !== "production" && (r.innerHTML = "Test", r.style.zIndex = "9999999");
    const a = n ? n(r) : (o = getComputedStyle(r).content) === null || o === void 0 ? void 0 : o.includes(CH);
    return (l = r.parentNode) === null || l === void 0 || l.removeChild(r), oy(Av), a;
  }
  return !1;
}
let fw;
function tke() {
  return fw === void 0 && (fw = eke(`@layer ${Av} { .${Av} { content: "${CH}"!important; } }`, (e) => {
    e.className = Av;
  })), fw;
}
const RM = {}, nke = process.env.NODE_ENV === "production", oke = process.env.NODE_ENV === "prerender", lke = !nke && !oke ? "css-dev-only-do-not-override" : "css", au = /* @__PURE__ */ new Map();
function rke(e) {
  au.set(e, (au.get(e) || 0) + 1);
}
function ake(e, t) {
  typeof document != "undefined" && document.querySelectorAll(`style[${cH}="${e}"]`).forEach((o) => {
    var l;
    o[Zd] === t && ((l = o.parentNode) === null || l === void 0 || l.removeChild(o));
  });
}
const ike = 0;
function ske(e, t) {
  au.set(e, (au.get(e) || 0) - 1);
  const n = Array.from(au.keys()), o = n.filter((l) => (au.get(l) || 0) <= 0);
  n.length - o.length > ike && o.forEach((l) => {
    ake(l, t), au.delete(l);
  });
}
const cke = (e, t, n, o) => {
  const l = n.getDerivativeToken(e);
  let r = _(_({}, l), t);
  return o && (r = o(r)), r;
};
function uke(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ H({});
  const o = lS(), l = O(() => _({}, ...t.value)), r = O(() => ly(l.value)), a = O(() => ly(n.value.override || RM));
  return fH("token", O(() => [n.value.salt || "", e.value.id, r.value, a.value]), () => {
    const {
      salt: s = "",
      override: c = RM,
      formatToken: u,
      getComputedToken: d
    } = n.value, f = d ? d(l.value, c, e.value) : cke(l.value, c, e.value, u), p = QPe(f, s);
    f._tokenKey = p, rke(p);
    const m = `${lke}-${aI(p)}`;
    return f._hashId = m, [f, m];
  }, (s) => {
    var c;
    ske(s[0]._tokenKey, (c = o.value) === null || c === void 0 ? void 0 : c.cache.instanceId);
  });
}
var dke = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, wH = "comm", $H = "rule", xH = "decl", fke = "@import", pke = "@namespace", vke = "@keyframes", mke = "@layer", EH = Math.abs, iI = String.fromCharCode;
function OH(e) {
  return e.trim();
}
function Eb(e, t, n) {
  return e.replace(t, n);
}
function hke(e, t, n) {
  return e.indexOf(t, n);
}
function yf(e, t) {
  return e.charCodeAt(t) | 0;
}
function rp(e, t, n) {
  return e.slice(t, n);
}
function ii(e) {
  return e.length;
}
function gke(e) {
  return e.length;
}
function Cg(e, t) {
  return t.push(e), e;
}
var aS = 1, ap = 1, _H = 0, ua = 0, Jo = 0, Pp = "";
function sI(e, t, n, o, l, r, a, i) {
  return { value: e, root: t, parent: n, type: o, props: l, children: r, line: aS, column: ap, length: a, return: "", siblings: i };
}
function bke() {
  return Jo;
}
function yke() {
  return Jo = ua > 0 ? yf(Pp, --ua) : 0, ap--, Jo === 10 && (ap = 1, aS--), Jo;
}
function _a() {
  return Jo = ua < _H ? yf(Pp, ua++) : 0, ap++, Jo === 10 && (ap = 1, aS++), Jo;
}
function oc() {
  return yf(Pp, ua);
}
function Ob() {
  return ua;
}
function iS(e, t) {
  return rp(Pp, e, t);
}
function Pm(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function Ske(e) {
  return aS = ap = 1, _H = ii(Pp = e), ua = 0, [];
}
function Cke(e) {
  return Pp = "", e;
}
function pw(e) {
  return OH(iS(ua - 1, d2(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function wke(e) {
  for (; (Jo = oc()) && Jo < 33; )
    _a();
  return Pm(e) > 2 || Pm(Jo) > 3 ? "" : " ";
}
function $ke(e, t) {
  for (; --t && _a() && !(Jo < 48 || Jo > 102 || Jo > 57 && Jo < 65 || Jo > 70 && Jo < 97); )
    ;
  return iS(e, Ob() + (t < 6 && oc() == 32 && _a() == 32));
}
function d2(e) {
  for (; _a(); )
    switch (Jo) {
      case e:
        return ua;
      case 34:
      case 39:
        e !== 34 && e !== 39 && d2(Jo);
        break;
      case 40:
        e === 41 && d2(e);
        break;
      case 92:
        _a();
        break;
    }
  return ua;
}
function xke(e, t) {
  for (; _a() && e + Jo !== 57; )
    if (e + Jo === 84 && oc() === 47)
      break;
  return "/*" + iS(t, ua - 1) + "*" + iI(e === 47 ? e : _a());
}
function Eke(e) {
  for (; !Pm(oc()); )
    _a();
  return iS(e, ua);
}
function Oke(e) {
  return Cke(_b("", null, null, null, [""], e = Ske(e), 0, [0], e));
}
function _b(e, t, n, o, l, r, a, i, s) {
  for (var c = 0, u = 0, d = a, f = 0, p = 0, m = 0, v = 1, h = 1, g = 1, y = 0, b = "", C = l, w = r, x = o, E = b; h; )
    switch (m = y, y = _a()) {
      case 40:
        if (m != 108 && yf(E, d - 1) == 58) {
          hke(E += Eb(pw(y), "&", "&\f"), "&\f", EH(c ? i[c - 1] : 0)) != -1 && (g = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        E += pw(y);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        E += wke(m);
        break;
      case 92:
        E += $ke(Ob() - 1, 7);
        continue;
      case 47:
        switch (oc()) {
          case 42:
          case 47:
            Cg(_ke(xke(_a(), Ob()), t, n, s), s), (Pm(m || 1) == 5 || Pm(oc() || 1) == 5) && ii(E) && rp(E, -1, void 0) !== " " && (E += " ");
            break;
          default:
            E += "/";
        }
        break;
      case 123 * v:
        i[c++] = ii(E) * g;
      case 125 * v:
      case 59:
      case 0:
        switch (y) {
          case 0:
          case 125:
            h = 0;
          case 59 + u:
            g == -1 && (E = Eb(E, /\f/g, "")), p > 0 && (ii(E) - d || v === 0 && m === 47) && Cg(p > 32 ? LM(E + ";", o, n, d - 1, s) : LM(Eb(E, " ", "") + ";", o, n, d - 2, s), s);
            break;
          case 59:
            E += ";";
          default:
            if (Cg(x = DM(E, t, n, c, u, l, i, b, C = [], w = [], d, r), r), y === 123)
              if (u === 0)
                _b(E, t, x, x, C, r, d, i, w);
              else {
                switch (f) {
                  case 99:
                    if (yf(E, 3) === 110) break;
                  case 108:
                    if (yf(E, 2) === 97) break;
                  default:
                    u = 0;
                  case 100:
                  case 109:
                  case 115:
                }
                u ? _b(e, x, x, o && Cg(DM(e, x, x, 0, 0, l, i, b, l, C = [], d, w), w), l, w, d, i, o ? C : w) : _b(E, x, x, x, [""], w, 0, i, w);
              }
        }
        c = u = p = 0, v = g = 1, b = E = "", d = a;
        break;
      case 58:
        d = 1 + ii(E), p = m;
      default:
        if (v < 1) {
          if (y == 123)
            --v;
          else if (y == 125 && v++ == 0 && yke() == 125)
            continue;
        }
        switch (E += iI(y), y * v) {
          case 38:
            g = u > 0 ? 1 : (E += "\f", -1);
            break;
          case 44:
            i[c++] = (ii(E) - 1) * g, g = 1;
            break;
          case 64:
            oc() === 45 && (E += pw(_a())), f = oc(), u = d = ii(b = E += Eke(Ob())), y++;
            break;
          case 45:
            m === 45 && ii(E) == 2 && (v = 0);
        }
    }
  return r;
}
function DM(e, t, n, o, l, r, a, i, s, c, u, d) {
  for (var f = l - 1, p = l === 0 ? r : [""], m = gke(p), v = 0, h = 0, g = 0; v < o; ++v)
    for (var y = 0, b = rp(e, f + 1, f = EH(h = a[v])), C = e; y < m; ++y)
      (C = OH(h > 0 ? p[y] + " " + b : Eb(b, /&\f/g, p[y]))) && (s[g++] = C);
  return sI(e, t, n, l === 0 ? $H : i, s, c, u, d);
}
function _ke(e, t, n, o) {
  return sI(e, t, n, wH, iI(bke()), rp(e, 2, -2), 0, o);
}
function LM(e, t, n, o, l) {
  return sI(e, t, n, xH, rp(e, 0, o), rp(e, o + 1, -1), o, l);
}
function f2(e, t) {
  for (var n = "", o = 0; o < e.length; o++)
    n += t(e[o], o, e, t) || "";
  return n;
}
function Ike(e, t, n, o) {
  switch (e.type) {
    case mke:
      if (e.children.length) break;
    case fke:
    case pke:
    case xH:
      return e.return = e.return || e.value;
    case wH:
      return "";
    case vke:
      return e.return = e.value + "{" + f2(e.children, o) + "}";
    case $H:
      if (!ii(e.value = e.props.join(","))) return "";
  }
  return ii(n = f2(e.children, o)) ? e.return = e.value + "{" + n + "}" : "";
}
function IH(e, t) {
  const {
    path: n,
    parentSelectors: o
  } = t;
  pr(!1, `[Ant Design Vue CSS-in-JS] ${n ? `Error in '${n}': ` : ""}${e}${o.length ? ` Selector info: ${o.join(" -> ")}` : ""}`);
}
const Tke = (e, t, n) => {
  if (e === "content") {
    const o = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
    (typeof t != "string" || ["normal", "none", "initial", "inherit", "unset"].indexOf(t) === -1 && !o.test(t) && (t.charAt(0) !== t.charAt(t.length - 1) || t.charAt(0) !== '"' && t.charAt(0) !== "'")) && IH(`You seem to be using a value for 'content' without quotes, try replacing it with \`content: '"${t}"'\`.`, n);
  }
}, Pke = (e, t, n) => {
  e === "animation" && n.hashId && t !== "none" && IH(`You seem to be using hashed animation '${t}', in which case 'animationName' with Keyframe as value is recommended.`, n);
}, BM = "data-ant-cssinjs-cache-path", kke = "_FILE_STYLE__";
let Tu, TH = !0;
function Nke() {
  var e;
  if (!Tu && (Tu = {}, Fl())) {
    const t = document.createElement("div");
    t.className = BM, t.style.position = "fixed", t.style.visibility = "hidden", t.style.top = "-9999px", document.body.appendChild(t);
    let n = getComputedStyle(t).content || "";
    n = n.replace(/^"/, "").replace(/"$/, ""), n.split(";").forEach((l) => {
      const [r, a] = l.split(":");
      Tu[r] = a;
    });
    const o = document.querySelector(`style[${BM}]`);
    o && (TH = !1, (e = o.parentNode) === null || e === void 0 || e.removeChild(o)), document.body.removeChild(t);
  }
}
function Mke(e) {
  return Nke(), !!Tu[e];
}
function Ake(e) {
  const t = Tu[e];
  let n = null;
  if (t && Fl())
    if (TH)
      n = kke;
    else {
      const o = document.querySelector(`style[${Iu}="${Tu[e]}"]`);
      o ? n = o.innerHTML : delete Tu[e];
    }
  return [n, t];
}
const FM = Fl(), PH = "_skip_check_", kH = "_multi_value_";
function VM(e) {
  return f2(Oke(e), Ike).replace(/\{%%%\:[^;];}/g, ";");
}
function Rke(e) {
  return typeof e == "object" && e && (PH in e || kH in e);
}
function Dke(e, t, n) {
  if (!t)
    return e;
  const o = `.${t}`, l = n === "low" ? `:where(${o})` : o;
  return e.split(",").map((a) => {
    var i;
    const s = a.trim().split(/\s+/);
    let c = s[0] || "";
    const u = ((i = c.match(/^\w+/)) === null || i === void 0 ? void 0 : i[0]) || "";
    return c = `${u}${l}${c.slice(u.length)}`, [c, ...s.slice(1)].join(" ");
  }).join(",");
}
const p2 = /* @__PURE__ */ new Set();
process.env.NODE_ENV;
const v2 = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    root: n,
    injectHash: o,
    parentSelectors: l
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: !0,
    parentSelectors: []
  };
  const {
    hashId: r,
    layer: a,
    path: i,
    hashPriority: s,
    transformers: c = [],
    linters: u = []
  } = t;
  let d = "", f = {};
  function p(h) {
    const g = h.getName(r);
    if (!f[g]) {
      const [y] = v2(h.style, t, {
        root: !1,
        parentSelectors: l
      });
      f[g] = `@keyframes ${h.getName(r)}${y}`;
    }
  }
  function m(h) {
    let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return h.forEach((y) => {
      Array.isArray(y) ? m(y, g) : y && g.push(y);
    }), g;
  }
  if (m(Array.isArray(e) ? e : [e]).forEach((h) => {
    const g = typeof h == "string" && !n ? {} : h;
    if (typeof g == "string")
      d += `${g}
`;
    else if (g._keyframe)
      p(g);
    else {
      const y = c.reduce((b, C) => {
        var w;
        return ((w = C == null ? void 0 : C.visit) === null || w === void 0 ? void 0 : w.call(C, b)) || b;
      }, g);
      Object.keys(y).forEach((b) => {
        var C;
        const w = y[b];
        if (typeof w == "object" && w && (b !== "animationName" || !w._keyframe) && !Rke(w)) {
          let x = !1, E = b.trim(), I = !1;
          (n || o) && r ? E.startsWith("@") ? x = !0 : E = Dke(b, r, s) : n && !r && (E === "&" || E === "") && (E = "", I = !0);
          const [T, P] = v2(w, t, {
            root: I,
            injectHash: x,
            parentSelectors: [...l, E]
          });
          f = _(_({}, f), P), d += `${E}${T}`;
        } else {
          let x = function(I, T) {
            process.env.NODE_ENV !== "production" && (typeof w != "object" || !(w != null && w[PH])) && [Tke, Pke, ...u].forEach((N) => N(I, T, {
              path: i,
              hashId: r,
              parentSelectors: l
            }));
            const P = I.replace(/[A-Z]/g, (N) => `-${N.toLowerCase()}`);
            let k = T;
            !dke[I] && typeof k == "number" && k !== 0 && (k = `${k}px`), I === "animationName" && (T != null && T._keyframe) && (p(T), k = T.getName(r)), d += `${P}:${k};`;
          };
          const E = (C = w == null ? void 0 : w.value) !== null && C !== void 0 ? C : w;
          typeof w == "object" && (w != null && w[kH]) && Array.isArray(E) ? E.forEach((I) => {
            x(b, I);
          }) : x(b, E);
        }
      });
    }
  }), !n)
    d = `{${d}}`;
  else if (a && tke()) {
    const h = a.split(",");
    d = `@layer ${h[h.length - 1].trim()} {${d}}`, h.length > 1 && (d = `@layer ${a}{%%%:%}${d}`);
  }
  return [d, f];
};
function Lke(e, t) {
  return aI(`${e.join("%")}${t}`);
}
function m2(e, t) {
  const n = lS(), o = O(() => e.value.token._tokenKey), l = O(() => [o.value, ...e.value.path]);
  let r = FM;
  return process.env.NODE_ENV !== "production" && n.value.mock !== void 0 && (r = n.value.mock === "client"), fH(
    "style",
    l,
    // Create cache if needed
    () => {
      const {
        path: a,
        hashId: i,
        layer: s,
        nonce: c,
        clientOnly: u,
        order: d = 0
      } = e.value, f = l.value.join("|");
      if (Mke(f)) {
        const [E, I] = Ake(f);
        if (E)
          return [E, o.value, I, {}, u, d];
      }
      const p = t(), {
        hashPriority: m,
        container: v,
        transformers: h,
        linters: g,
        cache: y
      } = n.value, [b, C] = v2(p, {
        hashId: i,
        hashPriority: m,
        layer: s,
        path: a.join("-"),
        transformers: h,
        linters: g
      }), w = VM(b), x = Lke(l.value, w);
      if (r) {
        const E = {
          mark: Iu,
          prepend: "queue",
          attachTo: v,
          priority: d
        }, I = typeof c == "function" ? c() : c;
        I && (E.csp = {
          nonce: I
        });
        const T = Tm(w, x, E);
        T[Zd] = y.instanceId, T.setAttribute(cH, o.value), process.env.NODE_ENV !== "production" && T.setAttribute(FPe, l.value.join("|")), Object.keys(C).forEach((P) => {
          p2.has(P) || (p2.add(P), Tm(VM(C[P]), `_effect-${P}`, {
            mark: Iu,
            prepend: "queue",
            attachTo: v
          }));
        });
      }
      return [w, o.value, x, C, u, d];
    },
    // Remove cache if no need
    (a, i) => {
      let [, , s] = a;
      (i || n.value.autoClear) && FM && oy(s, {
        mark: Iu
      });
    }
  ), (a) => a;
}
class mn {
  constructor(t, n) {
    this._keyframe = !0, this.name = t, this.style = n;
  }
  getName() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return t ? `${t}-${this.name}` : this.name;
  }
}
const Bke = {
  // cssinjs
  StyleProvider: jPe
}, NH = "4.2.6", km = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
var wg = 2, zM = 0.16, Fke = 0.05, Vke = 0.05, zke = 0.15, MH = 5, AH = 4, Hke = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function HM(e) {
  var t = e.r, n = e.g, o = e.b, l = cx(t, n, o);
  return {
    h: l.h * 360,
    s: l.s,
    v: l.v
  };
}
function $g(e) {
  var t = e.r, n = e.g, o = e.b;
  return "#".concat(ux(t, n, o, !1));
}
function jke(e, t, n) {
  var o = n / 100, l = {
    r: (t.r - e.r) * o + e.r,
    g: (t.g - e.g) * o + e.g,
    b: (t.b - e.b) * o + e.b
  };
  return l;
}
function jM(e, t, n) {
  var o;
  return Math.round(e.h) >= 60 && Math.round(e.h) <= 240 ? o = n ? Math.round(e.h) - wg * t : Math.round(e.h) + wg * t : o = n ? Math.round(e.h) + wg * t : Math.round(e.h) - wg * t, o < 0 ? o += 360 : o >= 360 && (o -= 360), o;
}
function WM(e, t, n) {
  if (e.h === 0 && e.s === 0)
    return e.s;
  var o;
  return n ? o = e.s - zM * t : t === AH ? o = e.s + zM : o = e.s + Fke * t, o > 1 && (o = 1), n && t === MH && o > 0.1 && (o = 0.1), o < 0.06 && (o = 0.06), Number(o.toFixed(2));
}
function KM(e, t, n) {
  var o;
  return n ? o = e.v + Vke * t : o = e.v - zke * t, o > 1 && (o = 1), Number(o.toFixed(2));
}
function Xu(e) {
  for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = [], o = zd(e), l = MH; l > 0; l -= 1) {
    var r = HM(o), a = $g(zd({
      h: jM(r, l, !0),
      s: WM(r, l, !0),
      v: KM(r, l, !0)
    }));
    n.push(a);
  }
  n.push($g(o));
  for (var i = 1; i <= AH; i += 1) {
    var s = HM(o), c = $g(zd({
      h: jM(s, i),
      s: WM(s, i),
      v: KM(s, i)
    }));
    n.push(c);
  }
  return t.theme === "dark" ? Hke.map(function(u) {
    var d = u.index, f = u.opacity, p = $g(jke(zd(t.backgroundColor || "#141414"), zd(n[d]), f * 100));
    return p;
  }) : n;
}
var Sf = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
}, Dl = {}, vw = {};
Object.keys(Sf).forEach(function(e) {
  Dl[e] = Xu(Sf[e]), Dl[e].primary = Dl[e][5], vw[e] = Xu(Sf[e], {
    theme: "dark",
    backgroundColor: "#141414"
  }), vw[e].primary = vw[e][5];
});
Dl.red;
Dl.volcano;
var Wke = Dl.gold;
Dl.orange;
Dl.yellow;
Dl.lime;
Dl.green;
Dl.cyan;
var Kke = Dl.blue;
Dl.geekblue;
Dl.purple;
Dl.magenta;
Dl.grey;
const Uke = (e) => {
  const {
    controlHeight: t
  } = e;
  return {
    controlHeightSM: t * 0.75,
    controlHeightXS: t * 0.5,
    controlHeightLG: t * 1.25
  };
};
function Gke(e) {
  const {
    sizeUnit: t,
    sizeStep: n
  } = e;
  return {
    sizeXXL: t * (n + 8),
    sizeXL: t * (n + 4),
    sizeLG: t * (n + 2),
    sizeMD: t * (n + 1),
    sizeMS: t * n,
    size: t * n,
    sizeSM: t * (n - 1),
    sizeXS: t * (n - 2),
    sizeXXS: t * (n - 3)
    // 4
  };
}
const RH = {
  blue: "#1677ff",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  pink: "#eb2f96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
}, sS = _(_({}, RH), {
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: !1
});
function Yke(e, t) {
  let {
    generateColorPalettes: n,
    generateNeutralColorPalettes: o
  } = t;
  const {
    colorSuccess: l,
    colorWarning: r,
    colorError: a,
    colorInfo: i,
    colorPrimary: s,
    colorBgBase: c,
    colorTextBase: u
  } = e, d = n(s), f = n(l), p = n(r), m = n(a), v = n(i), h = o(c, u);
  return _(_({}, h), {
    colorPrimaryBg: d[1],
    colorPrimaryBgHover: d[2],
    colorPrimaryBorder: d[3],
    colorPrimaryBorderHover: d[4],
    colorPrimaryHover: d[5],
    colorPrimary: d[6],
    colorPrimaryActive: d[7],
    colorPrimaryTextHover: d[8],
    colorPrimaryText: d[9],
    colorPrimaryTextActive: d[10],
    colorSuccessBg: f[1],
    colorSuccessBgHover: f[2],
    colorSuccessBorder: f[3],
    colorSuccessBorderHover: f[4],
    colorSuccessHover: f[4],
    colorSuccess: f[6],
    colorSuccessActive: f[7],
    colorSuccessTextHover: f[8],
    colorSuccessText: f[9],
    colorSuccessTextActive: f[10],
    colorErrorBg: m[1],
    colorErrorBgHover: m[2],
    colorErrorBorder: m[3],
    colorErrorBorderHover: m[4],
    colorErrorHover: m[5],
    colorError: m[6],
    colorErrorActive: m[7],
    colorErrorTextHover: m[8],
    colorErrorText: m[9],
    colorErrorTextActive: m[10],
    colorWarningBg: p[1],
    colorWarningBgHover: p[2],
    colorWarningBorder: p[3],
    colorWarningBorderHover: p[4],
    colorWarningHover: p[4],
    colorWarning: p[6],
    colorWarningActive: p[7],
    colorWarningTextHover: p[8],
    colorWarningText: p[9],
    colorWarningTextActive: p[10],
    colorInfoBg: v[1],
    colorInfoBgHover: v[2],
    colorInfoBorder: v[3],
    colorInfoBorderHover: v[4],
    colorInfoHover: v[4],
    colorInfo: v[6],
    colorInfoActive: v[7],
    colorInfoTextHover: v[8],
    colorInfoText: v[9],
    colorInfoTextActive: v[10],
    colorBgMask: new xn("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
const Xke = (e) => {
  let t = e, n = e, o = e, l = e;
  return e < 6 && e >= 5 ? t = e + 1 : e < 16 && e >= 6 ? t = e + 2 : e >= 16 && (t = 16), e < 7 && e >= 5 ? n = 4 : e < 8 && e >= 7 ? n = 5 : e < 14 && e >= 8 ? n = 6 : e < 16 && e >= 14 ? n = 7 : e >= 16 && (n = 8), e < 6 && e >= 2 ? o = 1 : e >= 6 && (o = 2), e > 4 && e < 8 ? l = 4 : e >= 8 && (l = 6), {
    borderRadius: e > 16 ? 16 : e,
    borderRadiusXS: o,
    borderRadiusSM: n,
    borderRadiusLG: t,
    borderRadiusOuter: l
  };
};
function qke(e) {
  const {
    motionUnit: t,
    motionBase: n,
    borderRadius: o,
    lineWidth: l
  } = e;
  return _({
    // motion
    motionDurationFast: `${(n + t).toFixed(1)}s`,
    motionDurationMid: `${(n + t * 2).toFixed(1)}s`,
    motionDurationSlow: `${(n + t * 3).toFixed(1)}s`,
    // line
    lineWidthBold: l + 1
  }, Xke(o));
}
const Hi = (e, t) => new xn(e).setAlpha(t).toRgbString(), lv = (e, t) => new xn(e).darken(t).toHexString(), Jke = (e) => {
  const t = Xu(e);
  return {
    1: t[0],
    2: t[1],
    3: t[2],
    4: t[3],
    5: t[4],
    6: t[5],
    7: t[6],
    8: t[4],
    9: t[5],
    10: t[6]
    // 8: colors[7],
    // 9: colors[8],
    // 10: colors[9],
  };
}, Zke = (e, t) => {
  const n = e || "#fff", o = t || "#000";
  return {
    colorBgBase: n,
    colorTextBase: o,
    colorText: Hi(o, 0.88),
    colorTextSecondary: Hi(o, 0.65),
    colorTextTertiary: Hi(o, 0.45),
    colorTextQuaternary: Hi(o, 0.25),
    colorFill: Hi(o, 0.15),
    colorFillSecondary: Hi(o, 0.06),
    colorFillTertiary: Hi(o, 0.04),
    colorFillQuaternary: Hi(o, 0.02),
    colorBgLayout: lv(n, 4),
    colorBgContainer: lv(n, 0),
    colorBgElevated: lv(n, 0),
    colorBgSpotlight: Hi(o, 0.85),
    colorBorder: lv(n, 15),
    colorBorderSecondary: lv(n, 6)
  };
};
function Qke(e) {
  const t = new Array(10).fill(null).map((n, o) => {
    const l = o - 1, r = e * Math.pow(2.71828, l / 5), a = o > 1 ? Math.floor(r) : Math.ceil(r);
    return Math.floor(a / 2) * 2;
  });
  return t[1] = e, t.map((n) => {
    const o = n + 8;
    return {
      size: n,
      lineHeight: o / n
    };
  });
}
const e4e = (e) => {
  const t = Qke(e), n = t.map((l) => l.size), o = t.map((l) => l.lineHeight);
  return {
    fontSizeSM: n[0],
    fontSize: n[1],
    fontSizeLG: n[2],
    fontSizeXL: n[3],
    fontSizeHeading1: n[6],
    fontSizeHeading2: n[5],
    fontSizeHeading3: n[4],
    fontSizeHeading4: n[3],
    fontSizeHeading5: n[2],
    lineHeight: o[1],
    lineHeightLG: o[2],
    lineHeightSM: o[0],
    lineHeightHeading1: o[6],
    lineHeightHeading2: o[5],
    lineHeightHeading3: o[4],
    lineHeightHeading4: o[3],
    lineHeightHeading5: o[2]
  };
};
function t4e(e) {
  const t = Object.keys(RH).map((n) => {
    const o = Xu(e[n]);
    return new Array(10).fill(1).reduce((l, r, a) => (l[`${n}-${a + 1}`] = o[a], l), {});
  }).reduce((n, o) => (n = _(_({}, n), o), n), {});
  return _(_(_(_(_(_(_({}, e), t), Yke(e, {
    generateColorPalettes: Jke,
    generateNeutralColorPalettes: Zke
  })), e4e(e.fontSize)), Gke(e)), Uke(e)), qke(e));
}
function mw(e) {
  return e >= 0 && e <= 255;
}
function xg(e, t) {
  const {
    r: n,
    g: o,
    b: l,
    a: r
  } = new xn(e).toRgb();
  if (r < 1)
    return e;
  const {
    r: a,
    g: i,
    b: s
  } = new xn(t).toRgb();
  for (let c = 0.01; c <= 1; c += 0.01) {
    const u = Math.round((n - a * (1 - c)) / c), d = Math.round((o - i * (1 - c)) / c), f = Math.round((l - s * (1 - c)) / c);
    if (mw(u) && mw(d) && mw(f))
      return new xn({
        r: u,
        g: d,
        b: f,
        a: Math.round(c * 100) / 100
      }).toRgbString();
  }
  return new xn({
    r: n,
    g: o,
    b: l,
    a: 1
  }).toRgbString();
}
var n4e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function o4e(e) {
  const {
    override: t
  } = e, n = n4e(e, ["override"]), o = _({}, t);
  Object.keys(sS).forEach((p) => {
    delete o[p];
  });
  const l = _(_({}, n), o), r = 480, a = 576, i = 768, s = 992, c = 1200, u = 1600, d = 2e3;
  return _(_(_({}, l), {
    colorLink: l.colorInfoText,
    colorLinkHover: l.colorInfoHover,
    colorLinkActive: l.colorInfoActive,
    // ============== Background ============== //
    colorFillContent: l.colorFillSecondary,
    colorFillContentHover: l.colorFill,
    colorFillAlter: l.colorFillQuaternary,
    colorBgContainerDisabled: l.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: l.colorBgContainer,
    colorSplit: xg(l.colorBorderSecondary, l.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: l.colorTextQuaternary,
    colorTextDisabled: l.colorTextQuaternary,
    colorTextHeading: l.colorText,
    colorTextLabel: l.colorTextSecondary,
    colorTextDescription: l.colorTextTertiary,
    colorTextLightSolid: l.colorWhite,
    colorHighlight: l.colorError,
    colorBgTextHover: l.colorFillSecondary,
    colorBgTextActive: l.colorFill,
    colorIcon: l.colorTextTertiary,
    colorIconHover: l.colorText,
    colorErrorOutline: xg(l.colorErrorBg, l.colorBgContainer),
    colorWarningOutline: xg(l.colorWarningBg, l.colorBgContainer),
    // Font
    fontSizeIcon: l.fontSizeSM,
    // Control
    lineWidth: l.lineWidth,
    controlOutlineWidth: l.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: l.controlHeight / 2,
    controlItemBgHover: l.colorFillTertiary,
    controlItemBgActive: l.colorPrimaryBg,
    controlItemBgActiveHover: l.colorPrimaryBgHover,
    controlItemBgActiveDisabled: l.colorFill,
    controlTmpOutline: l.colorFillQuaternary,
    controlOutline: xg(l.colorPrimaryBg, l.colorBgContainer),
    lineType: l.lineType,
    borderRadius: l.borderRadius,
    borderRadiusXS: l.borderRadiusXS,
    borderRadiusSM: l.borderRadiusSM,
    borderRadiusLG: l.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: l.sizeXXS,
    paddingXS: l.sizeXS,
    paddingSM: l.sizeSM,
    padding: l.size,
    paddingMD: l.sizeMD,
    paddingLG: l.sizeLG,
    paddingXL: l.sizeXL,
    paddingContentHorizontalLG: l.sizeLG,
    paddingContentVerticalLG: l.sizeMS,
    paddingContentHorizontal: l.sizeMS,
    paddingContentVertical: l.sizeSM,
    paddingContentHorizontalSM: l.size,
    paddingContentVerticalSM: l.sizeXS,
    marginXXS: l.sizeXXS,
    marginXS: l.sizeXS,
    marginSM: l.sizeSM,
    margin: l.size,
    marginMD: l.sizeMD,
    marginLG: l.sizeLG,
    marginXL: l.sizeXL,
    marginXXL: l.sizeXXL,
    boxShadow: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS: r,
    screenXSMin: r,
    screenXSMax: a - 1,
    screenSM: a,
    screenSMMin: a,
    screenSMMax: i - 1,
    screenMD: i,
    screenMDMin: i,
    screenMDMax: s - 1,
    screenLG: s,
    screenLGMin: s,
    screenLGMax: c - 1,
    screenXL: c,
    screenXLMin: c,
    screenXLMax: u - 1,
    screenXXL: u,
    screenXXLMin: u,
    screenXXLMax: d - 1,
    screenXXXL: d,
    screenXXXLMin: d,
    // FIXME: component box-shadow, should be removed
    boxShadowPopoverArrow: "3px 3px 7px rgba(0, 0, 0, 0.1)",
    boxShadowCard: `
      0 1px 2px -2px ${new xn("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new xn("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new xn("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), o);
}
const cS = (e) => ({
  // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
  // And Typography use this to generate link style which should not do this.
  color: e.colorLink,
  textDecoration: "none",
  outline: "none",
  cursor: "pointer",
  transition: `color ${e.motionDurationSlow}`,
  "&:focus, &:hover": {
    color: e.colorLinkHover
  },
  "&:active": {
    color: e.colorLinkActive
  }
}), cI = (e, t, n, o, l) => {
  const r = e / 2, a = 0, i = r, s = n * 1 / Math.sqrt(2), c = r - n * (1 - 1 / Math.sqrt(2)), u = r - t * (1 / Math.sqrt(2)), d = n * (Math.sqrt(2) - 1) + t * (1 / Math.sqrt(2)), f = 2 * r - u, p = d, m = 2 * r - s, v = c, h = 2 * r - a, g = i, y = r * Math.sqrt(2) + n * (Math.sqrt(2) - 2), b = n * (Math.sqrt(2) - 1);
  return {
    pointerEvents: "none",
    width: e,
    height: e,
    overflow: "hidden",
    "&::after": {
      content: '""',
      position: "absolute",
      width: y,
      height: y,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: !0,
        value: `0 0 ${t}px 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow: l,
      zIndex: 0,
      background: "transparent"
    },
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width: e,
      height: e / 2,
      background: o,
      clipPath: {
        _multi_value_: !0,
        value: [`polygon(${b}px 100%, 50% ${b}px, ${2 * r - b}px 100%, ${b}px 100%)`, `path('M ${a} ${i} A ${n} ${n} 0 0 0 ${s} ${c} L ${u} ${d} A ${t} ${t} 0 0 1 ${f} ${p} L ${m} ${v} A ${n} ${n} 0 0 0 ${h} ${g} Z')`]
      },
      content: '""'
    }
  };
};
function ry(e, t) {
  return km.reduce((n, o) => {
    const l = e[`${o}-1`], r = e[`${o}-3`], a = e[`${o}-6`], i = e[`${o}-7`];
    return _(_({}, n), t(o, {
      lightColor: l,
      lightBorderColor: r,
      darkColor: a,
      textColor: i
    }));
  }, {});
}
const Fo = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
}, nn = (e) => ({
  boxSizing: "border-box",
  margin: 0,
  padding: 0,
  color: e.colorText,
  fontSize: e.fontSize,
  // font-variant: @font-variant-base;
  lineHeight: e.lineHeight,
  listStyle: "none",
  // font-feature-settings: @font-feature-settings-base;
  fontFamily: e.fontFamily
}), cd = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
}), ja = () => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
}), l4e = (e) => ({
  a: {
    color: e.colorLink,
    textDecoration: e.linkDecoration,
    backgroundColor: "transparent",
    outline: "none",
    cursor: "pointer",
    transition: `color ${e.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    "&:hover": {
      color: e.colorLinkHover
    },
    "&:active": {
      color: e.colorLinkActive
    },
    "&:active,\n  &:hover": {
      textDecoration: e.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: e.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: e.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
}), r4e = (e, t) => {
  const {
    fontFamily: n,
    fontSize: o
  } = e, l = `[class^="${t}"], [class*=" ${t}"]`;
  return {
    [l]: {
      fontFamily: n,
      fontSize: o,
      boxSizing: "border-box",
      "&::before, &::after": {
        boxSizing: "border-box"
      },
      [l]: {
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        }
      }
    }
  };
}, bs = (e) => ({
  outline: `${e.lineWidthBold}px solid ${e.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
}), ys = (e) => ({
  "&:focus-visible": _({}, bs(e))
});
function Zt(e, t, n) {
  return (o) => {
    const l = O(() => o == null ? void 0 : o.value), [r, a, i] = _s(), {
      getPrefixCls: s,
      iconPrefixCls: c
    } = oS(), u = O(() => s()), d = O(() => ({
      theme: r.value,
      token: a.value,
      hashId: i.value,
      path: ["Shared", u.value]
    }));
    m2(d, () => [{
      // Link
      "&": l4e(a.value)
    }]);
    const f = O(() => ({
      theme: r.value,
      token: a.value,
      hashId: i.value,
      path: [e, l.value, c.value]
    }));
    return [m2(f, () => {
      const {
        token: p,
        flush: m
      } = i4e(a.value), v = typeof n == "function" ? n(p) : n, h = _(_({}, v), a.value[e]), g = `.${l.value}`, y = Vt(p, {
        componentCls: g,
        prefixCls: l.value,
        iconCls: `.${c.value}`,
        antCls: `.${u.value}`
      }, h), b = t(y, {
        hashId: i.value,
        prefixCls: l.value,
        rootPrefixCls: u.value,
        iconPrefixCls: c.value,
        overrideComponentToken: a.value[e]
      });
      return m(e, h), [r4e(a.value, l.value), b];
    }), i];
  };
}
const DH = process.env.NODE_ENV !== "production" || typeof CSSINJS_STATISTIC != "undefined";
let h2 = !0;
function Vt() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  if (!DH)
    return _({}, ...t);
  h2 = !1;
  const o = {};
  return t.forEach((l) => {
    Object.keys(l).forEach((a) => {
      Object.defineProperty(o, a, {
        configurable: !0,
        enumerable: !0,
        get: () => l[a]
      });
    });
  }), h2 = !0, o;
}
function a4e() {
}
function i4e(e) {
  let t, n = e, o = a4e;
  return DH && (t = /* @__PURE__ */ new Set(), n = new Proxy(e, {
    get(l, r) {
      return h2 && t.add(r), l[r];
    }
  }), o = (l, r) => {
    Array.from(t);
  }), {
    token: n,
    keys: t,
    flush: o
  };
}
const s4e = SH(t4e), LH = {
  token: sS,
  hashed: !0
}, BH = Symbol("DesignTokenContext"), g2 = /* @__PURE__ */ Ce(), c4e = (e) => {
  at(BH, e), pe(e, () => {
    g2.value = S(e), lf(g2);
  }, {
    immediate: !0,
    deep: !0
  });
}, u4e = /* @__PURE__ */ le({
  props: {
    value: Nt()
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return c4e(O(() => e.value)), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
});
function _s() {
  const e = ze(BH, O(() => g2.value || LH)), t = O(() => `${NH}-${e.value.hashed || ""}`), n = O(() => e.value.theme || s4e), o = uke(n, O(() => [sS, e.value.token]), O(() => ({
    salt: t.value,
    override: _({
      override: e.value.token
    }, e.value.components),
    formatToken: o4e
  })));
  return [n, O(() => o.value[0]), O(() => e.value.hashed ? o.value[1] : "")];
}
const uI = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  setup() {
    const [, e] = _s(), t = O(() => new xn(e.value.colorBgBase).toHsl().l < 0.5 ? {
      opacity: 0.65
    } : {});
    return () => $("svg", {
      style: t.value,
      width: "184",
      height: "152",
      viewBox: "0 0 184 152",
      xmlns: "http://www.w3.org/2000/svg"
    }, [$("g", {
      fill: "none",
      "fill-rule": "evenodd"
    }, [$("g", {
      transform: "translate(24 31.67)"
    }, [$("ellipse", {
      "fill-opacity": ".8",
      fill: "#F5F5F7",
      cx: "67.797",
      cy: "106.89",
      rx: "67.797",
      ry: "12.668"
    }, null), $("path", {
      d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
      fill: "#AEB8C2"
    }, null), $("path", {
      d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
      fill: "url(#linearGradient-1)",
      transform: "translate(13.56)"
    }, null), $("path", {
      d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
      fill: "#F5F5F7"
    }, null), $("path", {
      d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
      fill: "#DCE0E6"
    }, null)]), $("path", {
      d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
      fill: "#DCE0E6"
    }, null), $("g", {
      transform: "translate(149.65 15.383)",
      fill: "#FFF"
    }, [$("ellipse", {
      cx: "20.654",
      cy: "3.167",
      rx: "2.849",
      ry: "2.815"
    }, null), $("path", {
      d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
    }, null)])])]);
  }
});
uI.PRESENTED_IMAGE_DEFAULT = !0;
const FH = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  setup() {
    const [, e] = _s(), t = O(() => {
      const {
        colorFill: n,
        colorFillTertiary: o,
        colorFillQuaternary: l,
        colorBgContainer: r
      } = e.value;
      return {
        borderColor: new xn(n).onBackground(r).toHexString(),
        shadowColor: new xn(o).onBackground(r).toHexString(),
        contentColor: new xn(l).onBackground(r).toHexString()
      };
    });
    return () => $("svg", {
      width: "64",
      height: "41",
      viewBox: "0 0 64 41",
      xmlns: "http://www.w3.org/2000/svg"
    }, [$("g", {
      transform: "translate(0 1)",
      fill: "none",
      "fill-rule": "evenodd"
    }, [$("ellipse", {
      fill: t.value.shadowColor,
      cx: "32",
      cy: "33",
      rx: "32",
      ry: "7"
    }, null), $("g", {
      "fill-rule": "nonzero",
      stroke: t.value.borderColor
    }, [$("path", {
      d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }, null), $("path", {
      d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
      fill: t.value.contentColor
    }, null)])])]);
  }
});
FH.PRESENTED_IMAGE_SIMPLE = !0;
const d4e = (e) => {
  const {
    componentCls: t,
    margin: n,
    marginXS: o,
    marginXL: l,
    fontSize: r,
    lineHeight: a
  } = e;
  return {
    [t]: {
      marginInline: o,
      fontSize: r,
      lineHeight: a,
      textAlign: "center",
      //  &-image hashId
      [`${t}-image`]: {
        height: e.emptyImgHeight,
        marginBottom: o,
        opacity: e.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          height: "100%",
          margin: "auto"
        }
      },
      //  &-footer hashId
      [`${t}-footer`]: {
        marginTop: n
      },
      "&-normal": {
        marginBlock: l,
        color: e.colorTextDisabled,
        [`${t}-image`]: {
          height: e.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: o,
        color: e.colorTextDisabled,
        [`${t}-image`]: {
          height: e.emptyImgHeightSM
        }
      }
    }
  };
}, f4e = Zt("Empty", (e) => {
  const {
    componentCls: t,
    controlHeightLG: n
  } = e, o = Vt(e, {
    emptyImgCls: `${t}-img`,
    emptyImgHeight: n * 2.5,
    emptyImgHeightMD: n,
    emptyImgHeightSM: n * 0.875
  });
  return [d4e(o)];
});
var p4e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const v4e = () => ({
  prefixCls: String,
  imageStyle: Nt(),
  image: Wn(),
  description: Wn()
}), dI = /* @__PURE__ */ le({
  name: "AEmpty",
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: v4e(),
  setup(e, t) {
    let {
      slots: n = {},
      attrs: o
    } = t;
    const {
      direction: l,
      prefixCls: r
    } = bt("empty", e), [a, i] = f4e(r);
    return () => {
      var s, c;
      const u = r.value, d = _(_({}, e), o), {
        image: f = ((s = n.image) === null || s === void 0 ? void 0 : s.call(n)) || ht(uI),
        description: p = ((c = n.description) === null || c === void 0 ? void 0 : c.call(n)) || void 0,
        imageStyle: m,
        class: v = ""
      } = d, h = p4e(d, ["image", "description", "imageStyle", "class"]), g = typeof f == "function" ? f() : f, y = typeof g == "object" && "type" in g && g.type.PRESENTED_IMAGE_SIMPLE;
      return a($(sd, {
        componentName: "Empty",
        children: (b) => {
          const C = typeof p != "undefined" ? p : b.description, w = typeof C == "string" ? C : "empty";
          let x = null;
          return typeof g == "string" ? x = $("img", {
            alt: w,
            src: g
          }, null) : x = g, $("div", Q({
            class: ke(u, v, i.value, {
              [`${u}-normal`]: y,
              [`${u}-rtl`]: l.value === "rtl"
            })
          }, h), [$("div", {
            class: `${u}-image`,
            style: m
          }, [x]), C && $("p", {
            class: `${u}-description`
          }, [C]), n.default && $("div", {
            class: `${u}-footer`
          }, [mo(n.default())])]);
        }
      }, null));
    };
  }
});
dI.PRESENTED_IMAGE_DEFAULT = () => ht(uI);
dI.PRESENTED_IMAGE_SIMPLE = () => ht(FH);
const qs = po(dI), fI = (e) => {
  const {
    prefixCls: t
  } = bt("empty", e);
  return ((o) => {
    switch (o) {
      case "Table":
      case "List":
        return $(qs, {
          image: qs.PRESENTED_IMAGE_SIMPLE
        }, null);
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return $(qs, {
          image: qs.PRESENTED_IMAGE_SIMPLE,
          class: `${t.value}-small`
        }, null);
      default:
        return $(qs, null, null);
    }
  })(e.componentName);
};
function m4e(e) {
  return $(fI, {
    componentName: e
  }, null);
}
const VH = Symbol("SizeContextKey"), zH = () => ze(VH, /* @__PURE__ */ H(void 0)), HH = (e) => {
  const t = zH();
  return at(VH, O(() => e.value || t.value)), e;
}, bt = (e, t) => {
  const n = zH(), o = Cr(), l = ze(rI, _(_({}, lH), {
    renderEmpty: (E) => ht(fI, {
      componentName: E
    })
  })), r = O(() => l.getPrefixCls(e, t.prefixCls)), a = O(() => {
    var E, I;
    return (E = t.direction) !== null && E !== void 0 ? E : (I = l.direction) === null || I === void 0 ? void 0 : I.value;
  }), i = O(() => {
    var E;
    return (E = t.iconPrefixCls) !== null && E !== void 0 ? E : l.iconPrefixCls.value;
  }), s = O(() => l.getPrefixCls()), c = O(() => {
    var E;
    return (E = l.autoInsertSpaceInButton) === null || E === void 0 ? void 0 : E.value;
  }), u = l.renderEmpty, d = l.space, f = l.pageHeader, p = l.form, m = O(() => {
    var E, I;
    return (E = t.getTargetContainer) !== null && E !== void 0 ? E : (I = l.getTargetContainer) === null || I === void 0 ? void 0 : I.value;
  }), v = O(() => {
    var E, I, T;
    return (I = (E = t.getContainer) !== null && E !== void 0 ? E : t.getPopupContainer) !== null && I !== void 0 ? I : (T = l.getPopupContainer) === null || T === void 0 ? void 0 : T.value;
  }), h = O(() => {
    var E, I;
    return (E = t.dropdownMatchSelectWidth) !== null && E !== void 0 ? E : (I = l.dropdownMatchSelectWidth) === null || I === void 0 ? void 0 : I.value;
  }), g = O(() => {
    var E;
    return (t.virtual === void 0 ? ((E = l.virtual) === null || E === void 0 ? void 0 : E.value) !== !1 : t.virtual !== !1) && h.value !== !1;
  }), y = O(() => t.size || n.value), b = O(() => {
    var E, I, T;
    return (E = t.autocomplete) !== null && E !== void 0 ? E : (T = (I = l.input) === null || I === void 0 ? void 0 : I.value) === null || T === void 0 ? void 0 : T.autocomplete;
  }), C = O(() => {
    var E;
    return (E = t.disabled) !== null && E !== void 0 ? E : o.value;
  }), w = O(() => {
    var E;
    return (E = t.csp) !== null && E !== void 0 ? E : l.csp;
  }), x = O(() => {
    var E, I;
    return (E = t.wave) !== null && E !== void 0 ? E : (I = l.wave) === null || I === void 0 ? void 0 : I.value;
  });
  return {
    configProvider: l,
    prefixCls: r,
    direction: a,
    size: y,
    getTargetContainer: m,
    getPopupContainer: v,
    space: d,
    pageHeader: f,
    form: p,
    autoInsertSpaceInButton: c,
    renderEmpty: u,
    virtual: g,
    dropdownMatchSelectWidth: h,
    rootPrefixCls: s,
    getPrefixCls: l.getPrefixCls,
    autocomplete: b,
    csp: w,
    iconPrefixCls: i,
    disabled: C,
    select: l.select,
    wave: x
  };
};
function pn(e, t) {
  const n = _({}, e);
  for (let o = 0; o < t.length; o += 1) {
    const l = t[o];
    delete n[l];
  }
  return n;
}
const h4e = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      position: "fixed",
      zIndex: e.zIndexPopup
    }
  };
}, g4e = Zt("Affix", (e) => {
  const t = Vt(e, {
    zIndexPopup: e.zIndexBase + 10
  });
  return [h4e(t)];
});
function b4e() {
  return typeof window != "undefined" ? window : null;
}
var Qd;
(function(e) {
  e[e.None = 0] = "None", e[e.Prepare = 1] = "Prepare";
})(Qd || (Qd = {}));
const y4e = () => ({
  /**
   * 
   */
  offsetTop: Number,
  /**  */
  offsetBottom: Number,
  /**  Affix  DOM  */
  target: {
    type: Function,
    default: b4e
  },
  prefixCls: String,
  /**  */
  onChange: Function,
  onTestUpdatePosition: Function
}), S4e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AAffix",
  inheritAttrs: !1,
  props: y4e(),
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      expose: l,
      attrs: r
    } = t;
    const a = /* @__PURE__ */ Ce(), i = /* @__PURE__ */ Ce(), s = /* @__PURE__ */ kt({
      affixStyle: void 0,
      placeholderStyle: void 0,
      status: Qd.None,
      lastAffix: !1,
      prevTarget: null,
      timeout: null
    }), c = xt(), u = O(() => e.offsetBottom === void 0 && e.offsetTop === void 0 ? 0 : e.offsetTop), d = O(() => e.offsetBottom), f = () => {
      const {
        status: b,
        lastAffix: C
      } = s, {
        target: w
      } = e;
      if (b !== Qd.Prepare || !i.value || !a.value || !w)
        return;
      const x = w();
      if (!x)
        return;
      const E = {
        status: Qd.None
      }, I = Sg(a.value);
      if (I.top === 0 && I.left === 0 && I.width === 0 && I.height === 0)
        return;
      const T = Sg(x), P = _M(I, T, u.value), k = IM(I, T, d.value);
      if (!(I.top === 0 && I.left === 0 && I.width === 0 && I.height === 0)) {
        if (P !== void 0) {
          const N = `${I.width}px`, R = `${I.height}px`;
          E.affixStyle = {
            position: "fixed",
            top: P,
            width: N,
            height: R
          }, E.placeholderStyle = {
            width: N,
            height: R
          };
        } else if (k !== void 0) {
          const N = `${I.width}px`, R = `${I.height}px`;
          E.affixStyle = {
            position: "fixed",
            bottom: k,
            width: N,
            height: R
          }, E.placeholderStyle = {
            width: N,
            height: R
          };
        }
        E.lastAffix = !!E.affixStyle, C !== E.lastAffix && o("change", E.lastAffix), _(s, E);
      }
    }, p = () => {
      _(s, {
        status: Qd.Prepare,
        affixStyle: void 0,
        placeholderStyle: void 0
      }), process.env.NODE_ENV === "test" && o("testUpdatePosition");
    }, m = a2(() => {
      p();
    }), v = a2(() => {
      const {
        target: b
      } = e, {
        affixStyle: C
      } = s;
      if (b && C) {
        const w = b();
        if (w && a.value) {
          const x = Sg(w), E = Sg(a.value), I = _M(E, x, u.value), T = IM(E, x, d.value);
          if (I !== void 0 && C.top === I || T !== void 0 && C.bottom === T)
            return;
        }
      }
      p();
    });
    l({
      updatePosition: m,
      lazyUpdatePosition: v
    }), pe(() => e.target, (b) => {
      const C = (b == null ? void 0 : b()) || null;
      s.prevTarget !== C && (PM(c), C && (TM(C, c), m()), s.prevTarget = C);
    }), pe(() => [e.offsetTop, e.offsetBottom], m), nt(() => {
      const {
        target: b
      } = e;
      b && (s.timeout = setTimeout(() => {
        TM(b(), c), m();
      }));
    }), $o(() => {
      f();
    }), Uo(() => {
      clearTimeout(s.timeout), PM(c), m.cancel(), v.cancel();
    });
    const {
      prefixCls: h
    } = bt("affix", e), [g, y] = g4e(h);
    return () => {
      var b;
      const {
        affixStyle: C,
        placeholderStyle: w,
        status: x
      } = s, E = ke({
        [h.value]: C,
        [y.value]: !0
      }), I = pn(e, ["prefixCls", "offsetTop", "offsetBottom", "target", "onChange", "onTestUpdatePosition"]);
      return g($(ca, {
        onResize: m
      }, {
        default: () => [$("div", Q(Q(Q({}, I), r), {}, {
          ref: a,
          "data-measure-status": x
        }), [C && $("div", {
          style: w,
          "aria-hidden": "true"
        }, null), $("div", {
          class: E,
          ref: i,
          style: C
        }, [(b = n.default) === null || b === void 0 ? void 0 : b.call(n)])])]
      }));
    };
  }
}), jH = po(S4e);
function UM(e) {
  return typeof e == "object" && e != null && e.nodeType === 1;
}
function GM(e, t) {
  return (!t || e !== "hidden") && e !== "visible" && e !== "clip";
}
function hw(e, t) {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    var n = getComputedStyle(e, null);
    return GM(n.overflowY, t) || GM(n.overflowX, t) || function(o) {
      var l = function(r) {
        if (!r.ownerDocument || !r.ownerDocument.defaultView) return null;
        try {
          return r.ownerDocument.defaultView.frameElement;
        } catch (a) {
          return null;
        }
      }(o);
      return !!l && (l.clientHeight < o.scrollHeight || l.clientWidth < o.scrollWidth);
    }(e);
  }
  return !1;
}
function Eg(e, t, n, o, l, r, a, i) {
  return r < e && a > t || r > e && a < t ? 0 : r <= e && i <= n || a >= t && i >= n ? r - e - o : a > t && i < n || r < e && i > n ? a - t + l : 0;
}
var YM = function(e, t) {
  var n = window, o = t.scrollMode, l = t.block, r = t.inline, a = t.boundary, i = t.skipOverflowHiddenElements, s = typeof a == "function" ? a : function(ee) {
    return ee !== a;
  };
  if (!UM(e)) throw new TypeError("Invalid target");
  for (var c, u, d = document.scrollingElement || document.documentElement, f = [], p = e; UM(p) && s(p); ) {
    if ((p = (u = (c = p).parentElement) == null ? c.getRootNode().host || null : u) === d) {
      f.push(p);
      break;
    }
    p != null && p === document.body && hw(p) && !hw(document.documentElement) || p != null && hw(p, i) && f.push(p);
  }
  for (var m = n.visualViewport ? n.visualViewport.width : innerWidth, v = n.visualViewport ? n.visualViewport.height : innerHeight, h = window.scrollX || pageXOffset, g = window.scrollY || pageYOffset, y = e.getBoundingClientRect(), b = y.height, C = y.width, w = y.top, x = y.right, E = y.bottom, I = y.left, T = l === "start" || l === "nearest" ? w : l === "end" ? E : w + b / 2, P = r === "center" ? I + C / 2 : r === "end" ? x : I, k = [], N = 0; N < f.length; N++) {
    var R = f[N], z = R.getBoundingClientRect(), D = z.height, F = z.width, M = z.top, A = z.right, L = z.bottom, B = z.left;
    if (o === "if-needed" && w >= 0 && I >= 0 && E <= v && x <= m && w >= M && E <= L && I >= B && x <= A) return k;
    var V = getComputedStyle(R), j = parseInt(V.borderLeftWidth, 10), W = parseInt(V.borderTopWidth, 10), Y = parseInt(V.borderRightWidth, 10), U = parseInt(V.borderBottomWidth, 10), te = 0, J = 0, re = "offsetWidth" in R ? R.offsetWidth - R.clientWidth - j - Y : 0, oe = "offsetHeight" in R ? R.offsetHeight - R.clientHeight - W - U : 0, q = "offsetWidth" in R ? R.offsetWidth === 0 ? 0 : F / R.offsetWidth : 0, K = "offsetHeight" in R ? R.offsetHeight === 0 ? 0 : D / R.offsetHeight : 0;
    if (d === R) te = l === "start" ? T : l === "end" ? T - v : l === "nearest" ? Eg(g, g + v, v, W, U, g + T, g + T + b, b) : T - v / 2, J = r === "start" ? P : r === "center" ? P - m / 2 : r === "end" ? P - m : Eg(h, h + m, m, j, Y, h + P, h + P + C, C), te = Math.max(0, te + g), J = Math.max(0, J + h);
    else {
      te = l === "start" ? T - M - W : l === "end" ? T - L + U + oe : l === "nearest" ? Eg(M, L, D, W, U + oe, T, T + b, b) : T - (M + D / 2) + oe / 2, J = r === "start" ? P - B - j : r === "center" ? P - (B + F / 2) + re / 2 : r === "end" ? P - A + Y + re : Eg(B, A, F, j, Y + re, P, P + C, C);
      var se = R.scrollLeft, Z = R.scrollTop;
      T += Z - (te = Math.max(0, Math.min(Z + te / K, R.scrollHeight - D / K + oe))), P += se - (J = Math.max(0, Math.min(se + J / q, R.scrollWidth - F / q + re)));
    }
    k.push({ el: R, top: te, left: J });
  }
  return k;
};
function WH(e) {
  return e === Object(e) && Object.keys(e).length !== 0;
}
function C4e(e, t) {
  t === void 0 && (t = "auto");
  var n = "scrollBehavior" in document.body.style;
  e.forEach(function(o) {
    var l = o.el, r = o.top, a = o.left;
    l.scroll && n ? l.scroll({
      top: r,
      left: a,
      behavior: t
    }) : (l.scrollTop = r, l.scrollLeft = a);
  });
}
function w4e(e) {
  return e === !1 ? {
    block: "end",
    inline: "nearest"
  } : WH(e) ? e : {
    block: "start",
    inline: "nearest"
  };
}
function KH(e, t) {
  var n = e.isConnected || e.ownerDocument.documentElement.contains(e);
  if (WH(t) && typeof t.behavior == "function")
    return t.behavior(n ? YM(e, t) : []);
  if (n) {
    var o = w4e(t);
    return C4e(YM(e, o), o.behavior);
  }
}
function $4e(e, t, n, o) {
  const l = n - t;
  return e /= o / 2, e < 1 ? l / 2 * e * e * e + t : l / 2 * ((e -= 2) * e * e + 2) + t;
}
function b2(e) {
  return e != null && e === e.window;
}
function pI(e, t) {
  var n, o;
  if (typeof window == "undefined")
    return 0;
  const l = "scrollTop";
  let r = 0;
  return b2(e) ? r = e.scrollY : e instanceof Document ? r = e.documentElement[l] : (e instanceof HTMLElement || e) && (r = e[l]), e && !b2(e) && typeof r != "number" && (r = (o = ((n = e.ownerDocument) !== null && n !== void 0 ? n : e).documentElement) === null || o === void 0 ? void 0 : o[l]), r;
}
function vI(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    getContainer: n = () => window,
    callback: o,
    duration: l = 450
  } = t, r = n(), a = pI(r), i = Date.now(), s = () => {
    const u = Date.now() - i, d = $4e(u > l ? l : u, a, e, l);
    b2(r) ? r.scrollTo(window.scrollX, d) : r instanceof Document ? r.documentElement.scrollTop = d : r.scrollTop = d, u < l ? rn(s) : typeof o == "function" && o();
  };
  rn(s);
}
function Og() {
}
const UH = Symbol("anchorContextKey"), x4e = (e) => {
  at(UH, e);
}, E4e = () => ze(UH, {
  registerLink: Og,
  unregisterLink: Og,
  scrollTo: Og,
  activeLink: O(() => ""),
  handleClick: Og,
  direction: O(() => "vertical")
}), O4e = (e) => {
  const {
    componentCls: t,
    holderOffsetBlock: n,
    motionDurationSlow: o,
    lineWidthBold: l,
    colorPrimary: r,
    lineType: a,
    colorSplit: i
  } = e;
  return {
    [`${t}-wrapper`]: {
      marginBlockStart: -n,
      paddingBlockStart: n,
      // delete overflow: auto
      // overflow: 'auto',
      backgroundColor: "transparent",
      [t]: _(_({}, nn(e)), {
        position: "relative",
        paddingInlineStart: l,
        [`${t}-link`]: {
          paddingBlock: e.anchorPaddingBlock,
          paddingInline: `${e.anchorPaddingInline}px 0`,
          "&-title": _(_({}, Fo), {
            position: "relative",
            display: "block",
            marginBlockEnd: e.anchorTitleBlock,
            color: e.colorText,
            transition: `all ${e.motionDurationSlow}`,
            "&:only-child": {
              marginBlockEnd: 0
            }
          }),
          [`&-active > ${t}-link-title`]: {
            color: e.colorPrimary
          },
          // link link
          [`${t}-link`]: {
            paddingBlock: e.anchorPaddingBlockSecondary
          }
        }
      }),
      [`&:not(${t}-wrapper-horizontal)`]: {
        [t]: {
          "&::before": {
            position: "absolute",
            left: {
              _skip_check_: !0,
              value: 0
            },
            top: 0,
            height: "100%",
            borderInlineStart: `${l}px ${a} ${i}`,
            content: '" "'
          },
          [`${t}-ink`]: {
            position: "absolute",
            left: {
              _skip_check_: !0,
              value: 0
            },
            display: "none",
            transform: "translateY(-50%)",
            transition: `top ${o} ease-in-out`,
            width: l,
            backgroundColor: r,
            [`&${t}-ink-visible`]: {
              display: "inline-block"
            }
          }
        }
      },
      [`${t}-fixed ${t}-ink ${t}-ink`]: {
        display: "none"
      }
    }
  };
}, _4e = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    lineWidthBold: o,
    colorPrimary: l
  } = e;
  return {
    [`${t}-wrapper-horizontal`]: {
      position: "relative",
      "&::before": {
        position: "absolute",
        left: {
          _skip_check_: !0,
          value: 0
        },
        right: {
          _skip_check_: !0,
          value: 0
        },
        bottom: 0,
        borderBottom: `1px ${e.lineType} ${e.colorSplit}`,
        content: '" "'
      },
      [t]: {
        overflowX: "scroll",
        position: "relative",
        display: "flex",
        scrollbarWidth: "none",
        "&::-webkit-scrollbar": {
          display: "none"
          /* Safari and Chrome */
        },
        [`${t}-link:first-of-type`]: {
          paddingInline: 0
        },
        [`${t}-ink`]: {
          position: "absolute",
          bottom: 0,
          transition: `left ${n} ease-in-out, width ${n} ease-in-out`,
          height: o,
          backgroundColor: l
        }
      }
    }
  };
}, I4e = Zt("Anchor", (e) => {
  const {
    fontSize: t,
    fontSizeLG: n,
    padding: o,
    paddingXXS: l
  } = e, r = Vt(e, {
    holderOffsetBlock: l,
    anchorPaddingBlock: l,
    anchorPaddingBlockSecondary: l / 2,
    anchorPaddingInline: o,
    anchorTitleBlock: t / 14 * 3,
    anchorBallSize: n / 2
  });
  return [O4e(r), _4e(r)];
}), T4e = () => ({
  prefixCls: String,
  href: String,
  title: Wn(),
  target: String,
  /* private use  */
  customTitleProps: Nt()
}), mI = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AAnchorLink",
  inheritAttrs: !1,
  props: sn(T4e(), {
    href: "#"
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t, l = null;
    const {
      handleClick: r,
      scrollTo: a,
      unregisterLink: i,
      registerLink: s,
      activeLink: c
    } = E4e(), {
      prefixCls: u
    } = bt("anchor", e), d = (f) => {
      const {
        href: p
      } = e;
      r(f, {
        title: l,
        href: p
      }), a(p);
    };
    return pe(() => e.href, (f, p) => {
      Ke(() => {
        i(p), s(f);
      });
    }), nt(() => {
      s(e.href);
    }), yt(() => {
      i(e.href);
    }), () => {
      var f;
      const {
        href: p,
        target: m,
        title: v = n.title,
        customTitleProps: h = {}
      } = e, g = u.value;
      l = typeof v == "function" ? v(h) : v;
      const y = c.value === p, b = ke(`${g}-link`, {
        [`${g}-link-active`]: y
      }, o.class), C = ke(`${g}-link-title`, {
        [`${g}-link-title-active`]: y
      });
      return $("div", Q(Q({}, o), {}, {
        class: b
      }), [$("a", {
        class: C,
        href: p,
        title: typeof l == "string" ? l : "",
        target: m,
        onClick: d
      }, [n.customTitle ? n.customTitle(h) : l]), (f = n.default) === null || f === void 0 ? void 0 : f.call(n)]);
    };
  }
});
function P4e(e, t) {
  for (var n = 0; n < t.length; n++) {
    var o = t[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
  }
}
function GH(e, t, n) {
  return n && P4e(e, n), e;
}
function Ib() {
  return (Ib = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }).apply(this, arguments);
}
function YH(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
function XH(e, t) {
  if (e == null) return {};
  var n, o, l = {}, r = Object.keys(e);
  for (o = 0; o < r.length; o++) t.indexOf(n = r[o]) >= 0 || (l[n] = e[n]);
  return l;
}
function XM(e) {
  return ((t = e) != null && typeof t == "object" && Array.isArray(t) === !1) == 1 && Object.prototype.toString.call(e) === "[object Object]";
  var t;
}
var qH = Object.prototype, JH = qH.toString, k4e = qH.hasOwnProperty, ZH = /^\s*function (\w+)/;
function qM(e) {
  var t, n = (t = e == null ? void 0 : e.type) !== null && t !== void 0 ? t : e;
  if (n) {
    var o = n.toString().match(ZH);
    return o ? o[1] : "";
  }
  return "";
}
var qu = function(e) {
  var t, n;
  return XM(e) !== !1 && typeof (t = e.constructor) == "function" && XM(n = t.prototype) !== !1 && n.hasOwnProperty("isPrototypeOf") !== !1;
}, QH = function(e) {
  return e;
}, yr = QH;
if (process.env.NODE_ENV !== "production") {
  var N4e = typeof console != "undefined";
  yr = N4e ? function(e) {
    console.warn("[VueTypes warn]: " + e);
  } : QH;
}
var Nm = function(e, t) {
  return k4e.call(e, t);
}, M4e = Number.isInteger || function(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
}, ip = Array.isArray || function(e) {
  return JH.call(e) === "[object Array]";
}, sp = function(e) {
  return JH.call(e) === "[object Function]";
}, ay = function(e) {
  return qu(e) && Nm(e, "_vueTypes_name");
}, ej = function(e) {
  return qu(e) && (Nm(e, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function(t) {
    return Nm(e, t);
  }));
};
function hI(e, t) {
  return Object.defineProperty(e.bind(t), "__original", { value: e });
}
function ud(e, t, n) {
  var o, l = !0, r = "";
  o = qu(e) ? e : { type: e };
  var a = ay(o) ? o._vueTypes_name + " - " : "";
  if (ej(o) && o.type !== null) {
    if (o.type === void 0 || o.type === !0 || !o.required && t === void 0) return l;
    ip(o.type) ? (l = o.type.some(function(d) {
      return ud(d, t) === !0;
    }), r = o.type.map(function(d) {
      return qM(d);
    }).join(" or ")) : l = (r = qM(o)) === "Array" ? ip(t) : r === "Object" ? qu(t) : r === "String" || r === "Number" || r === "Boolean" || r === "Function" ? function(d) {
      if (d == null) return "";
      var f = d.constructor.toString().match(ZH);
      return f ? f[1] : "";
    }(t) === r : t instanceof o.type;
  }
  if (!l) {
    var i = a + 'value "' + t + '" should be of type "' + r + '"';
    return i;
  }
  if (Nm(o, "validator") && sp(o.validator)) {
    var s = yr, c = [];
    if (yr = function(d) {
      c.push(d);
    }, l = o.validator(t), yr = s, !l) {
      var u = (c.length > 1 ? "* " : "") + c.join(`
* `);
      return c.length = 0, u;
    }
  }
  return l;
}
function Lr(e, t) {
  var n = Object.defineProperties(t, { _vueTypes_name: { value: e, writable: !0 }, isRequired: { get: function() {
    return this.required = !0, this;
  } }, def: { value: function(l) {
    return l !== void 0 || this.default ? sp(l) || ud(this, l) === !0 ? (this.default = ip(l) ? function() {
      return [].concat(l);
    } : qu(l) ? function() {
      return Object.assign({}, l);
    } : l, this) : (yr(this._vueTypes_name + ' - invalid default value: "' + l + '"'), this) : this;
  } } }), o = n.validator;
  return sp(o) && (n.validator = hI(o, n)), n;
}
function Oi(e, t) {
  var n = Lr(e, t);
  return Object.defineProperty(n, "validate", { value: function(o) {
    return sp(this.validator) && yr(this._vueTypes_name + ` - calling .validate() will overwrite the current custom validator function. Validator info:
` + JSON.stringify(this)), this.validator = hI(o, this), this;
  } });
}
function JM(e, t, n) {
  var o, l, r = (o = t, l = {}, Object.getOwnPropertyNames(o).forEach(function(d) {
    l[d] = Object.getOwnPropertyDescriptor(o, d);
  }), Object.defineProperties({}, l));
  if (r._vueTypes_name = e, !qu(n)) return r;
  var a, i, s = n.validator, c = XH(n, ["validator"]);
  if (sp(s)) {
    var u = r.validator;
    u && (u = (i = (a = u).__original) !== null && i !== void 0 ? i : a), r.validator = hI(u ? function(d) {
      return u.call(this, d) && s.call(this, d);
    } : s, r);
  }
  return Object.assign(r, c);
}
function uS(e) {
  return e.replace(/^(?!\s*$)/gm, "  ");
}
var A4e = function() {
  return Oi("any", {});
}, R4e = function() {
  return Oi("function", { type: Function });
}, D4e = function() {
  return Oi("boolean", { type: Boolean });
}, L4e = function() {
  return Oi("string", { type: String });
}, B4e = function() {
  return Oi("number", { type: Number });
}, F4e = function() {
  return Oi("array", { type: Array });
}, V4e = function() {
  return Oi("object", { type: Object });
}, z4e = function() {
  return Lr("integer", { type: Number, validator: function(e) {
    return M4e(e);
  } });
}, H4e = function() {
  return Lr("symbol", { validator: function(e) {
    return typeof e == "symbol";
  } });
};
function j4e(e, t) {
  if (t === void 0 && (t = "custom validation failed"), typeof e != "function") throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return Lr(e.name || "<<anonymous function>>", { validator: function(n) {
    var o = e(n);
    return o || yr(this._vueTypes_name + " - " + t), o;
  } });
}
function W4e(e) {
  if (!ip(e)) throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  var t = 'oneOf - value should be one of "' + e.join('", "') + '".', n = e.reduce(function(o, l) {
    if (l != null) {
      var r = l.constructor;
      o.indexOf(r) === -1 && o.push(r);
    }
    return o;
  }, []);
  return Lr("oneOf", { type: n.length > 0 ? n : void 0, validator: function(o) {
    var l = e.indexOf(o) !== -1;
    return l || yr(t), l;
  } });
}
function K4e(e) {
  if (!ip(e)) throw new TypeError("[VueTypes error]: You must provide an array as argument");
  for (var t = !1, n = [], o = 0; o < e.length; o += 1) {
    var l = e[o];
    if (ej(l)) {
      if (ay(l) && l._vueTypes_name === "oneOf") {
        n = n.concat(l.type);
        continue;
      }
      if (sp(l.validator) && (t = !0), l.type !== !0 && l.type) {
        n = n.concat(l.type);
        continue;
      }
    }
    n.push(l);
  }
  return n = n.filter(function(r, a) {
    return n.indexOf(r) === a;
  }), Lr("oneOfType", t ? { type: n, validator: function(r) {
    var a = [], i = e.some(function(s) {
      var c = ud(ay(s) && s._vueTypes_name === "oneOf" ? s.type || null : s, r);
      return typeof c == "string" && a.push(c), c === !0;
    });
    return i || yr("oneOfType - provided value does not match any of the " + a.length + ` passed-in validators:
` + uS(a.join(`
`))), i;
  } } : { type: n });
}
function U4e(e) {
  return Lr("arrayOf", { type: Array, validator: function(t) {
    var n, o = t.every(function(l) {
      return (n = ud(e, l)) === !0;
    });
    return o || yr(`arrayOf - value validation error:
` + uS(n)), o;
  } });
}
function G4e(e) {
  return Lr("instanceOf", { type: e });
}
function Y4e(e) {
  return Lr("objectOf", { type: Object, validator: function(t) {
    var n, o = Object.keys(t).every(function(l) {
      return (n = ud(e, t[l])) === !0;
    });
    return o || yr(`objectOf - value validation error:
` + uS(n)), o;
  } });
}
function X4e(e) {
  var t = Object.keys(e), n = t.filter(function(l) {
    var r;
    return !!(!((r = e[l]) === null || r === void 0) && r.required);
  }), o = Lr("shape", { type: Object, validator: function(l) {
    var r = this;
    if (!qu(l)) return !1;
    var a = Object.keys(l);
    if (n.length > 0 && n.some(function(s) {
      return a.indexOf(s) === -1;
    })) {
      var i = n.filter(function(s) {
        return a.indexOf(s) === -1;
      });
      return yr(i.length === 1 ? 'shape - required property "' + i[0] + '" is not defined.' : 'shape - required properties "' + i.join('", "') + '" are not defined.'), !1;
    }
    return a.every(function(s) {
      if (t.indexOf(s) === -1) return r._vueTypes_isLoose === !0 || (yr('shape - shape definition does not include a "' + s + '" property. Allowed keys: "' + t.join('", "') + '".'), !1);
      var c = ud(e[s], l[s]);
      return typeof c == "string" && yr('shape - "' + s + `" property validation error:
 ` + uS(c)), c === !0;
    });
  } });
  return Object.defineProperty(o, "_vueTypes_isLoose", { writable: !0, value: !1 }), Object.defineProperty(o, "loose", { get: function() {
    return this._vueTypes_isLoose = !0, this;
  } }), o;
}
var ni = function() {
  function e() {
  }
  return e.extend = function(t) {
    var n = this;
    if (ip(t)) return t.forEach(function(d) {
      return n.extend(d);
    }), this;
    var o = t.name, l = t.validate, r = l !== void 0 && l, a = t.getter, i = a !== void 0 && a, s = XH(t, ["name", "validate", "getter"]);
    if (Nm(this, o)) throw new TypeError('[VueTypes error]: Type "' + o + '" already defined');
    var c, u = s.type;
    return ay(u) ? (delete s.type, Object.defineProperty(this, o, i ? { get: function() {
      return JM(o, u, s);
    } } : { value: function() {
      var d, f = JM(o, u, s);
      return f.validator && (f.validator = (d = f.validator).bind.apply(d, [f].concat([].slice.call(arguments)))), f;
    } })) : (c = i ? { get: function() {
      var d = Object.assign({}, s);
      return r ? Oi(o, d) : Lr(o, d);
    }, enumerable: !0 } : { value: function() {
      var d, f, p = Object.assign({}, s);
      return d = r ? Oi(o, p) : Lr(o, p), p.validator && (d.validator = (f = p.validator).bind.apply(f, [d].concat([].slice.call(arguments)))), d;
    }, enumerable: !0 }, Object.defineProperty(this, o, c));
  }, GH(e, null, [{ key: "any", get: function() {
    return A4e();
  } }, { key: "func", get: function() {
    return R4e().def(this.defaults.func);
  } }, { key: "bool", get: function() {
    return D4e().def(this.defaults.bool);
  } }, { key: "string", get: function() {
    return L4e().def(this.defaults.string);
  } }, { key: "number", get: function() {
    return B4e().def(this.defaults.number);
  } }, { key: "array", get: function() {
    return F4e().def(this.defaults.array);
  } }, { key: "object", get: function() {
    return V4e().def(this.defaults.object);
  } }, { key: "integer", get: function() {
    return z4e().def(this.defaults.integer);
  } }, { key: "symbol", get: function() {
    return H4e();
  } }]), e;
}();
function tj(e) {
  var t;
  return e === void 0 && (e = { func: function() {
  }, bool: !0, string: "", number: 0, array: function() {
    return [];
  }, object: function() {
    return {};
  }, integer: 0 }), (t = function(n) {
    function o() {
      return n.apply(this, arguments) || this;
    }
    return YH(o, n), GH(o, null, [{ key: "sensibleDefaults", get: function() {
      return Ib({}, this.defaults);
    }, set: function(l) {
      this.defaults = l !== !1 ? Ib({}, l !== !0 ? l : e) : {};
    } }]), o;
  }(ni)).defaults = Ib({}, e), t;
}
ni.defaults = {}, ni.custom = j4e, ni.oneOf = W4e, ni.instanceOf = G4e, ni.oneOfType = K4e, ni.arrayOf = U4e, ni.objectOf = Y4e, ni.shape = X4e, ni.utils = { validate: function(e, t) {
  return ud(t, e) === !0;
}, toType: function(e, t, n) {
  return n === void 0 && (n = !1), n ? Oi(e, t) : Lr(e, t);
} };
(function(e) {
  function t() {
    return e.apply(this, arguments) || this;
  }
  return YH(t, e), t;
})(tj());
const de = tj({
  func: void 0,
  bool: void 0,
  string: void 0,
  number: void 0,
  array: void 0,
  object: void 0,
  integer: void 0
});
de.extend([{
  name: "looseBool",
  getter: !0,
  type: Boolean,
  default: void 0
}, {
  name: "style",
  getter: !0,
  type: [String, Object],
  default: void 0
}, {
  name: "VueNode",
  getter: !0,
  type: null
}]);
function nj(e) {
  return e.default = void 0, e;
}
const un = (e, t, n) => {
  pr(e, `[ant-design-vue: ${t}] ${n}`);
};
function q4e() {
  return window;
}
function ZM(e, t) {
  if (!e.getClientRects().length)
    return 0;
  const n = e.getBoundingClientRect();
  return n.width || n.height ? t === window ? (t = e.ownerDocument.documentElement, n.top - t.clientTop) : n.top - t.getBoundingClientRect().top : n.top;
}
const QM = /#([\S ]+)$/, J4e = () => ({
  prefixCls: String,
  offsetTop: Number,
  bounds: Number,
  affix: {
    type: Boolean,
    default: !0
  },
  showInkInFixed: {
    type: Boolean,
    default: !1
  },
  getContainer: Function,
  wrapperClass: String,
  wrapperStyle: {
    type: Object,
    default: void 0
  },
  getCurrentAnchor: Function,
  targetOffset: Number,
  items: $n(),
  direction: de.oneOf(["vertical", "horizontal"]).def("vertical"),
  onChange: Function,
  onClick: Function
}), iu = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AAnchor",
  inheritAttrs: !1,
  props: J4e(),
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      slots: l,
      expose: r
    } = t;
    var a;
    const {
      prefixCls: i,
      getTargetContainer: s,
      direction: c
    } = bt("anchor", e), u = O(() => {
      var I;
      return (I = e.direction) !== null && I !== void 0 ? I : "vertical";
    });
    process.env.NODE_ENV !== "production" && un(e.items && typeof l.default != "function", "Anchor", "`Anchor children` is deprecated. Please use `items` instead."), process.env.NODE_ENV !== "production" && un(!(u.value === "horizontal" && (!((a = e.items) === null || a === void 0) && a.some((I) => "children" in I))), "Anchor", "`Anchor items#children` is not supported when `Anchor` direction is horizontal.");
    const d = /* @__PURE__ */ H(null), f = /* @__PURE__ */ H(), p = /* @__PURE__ */ kt({
      links: [],
      scrollContainer: null,
      scrollEvent: null,
      animating: !1
    }), m = /* @__PURE__ */ H(null), v = O(() => {
      const {
        getContainer: I
      } = e;
      return I || (s == null ? void 0 : s.value) || q4e;
    }), h = function() {
      let I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, T = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
      const P = [], k = v.value();
      return p.links.forEach((N) => {
        const R = QM.exec(N.toString());
        if (!R)
          return;
        const z = document.getElementById(R[1]);
        if (z) {
          const D = ZM(z, k);
          D < I + T && P.push({
            link: N,
            top: D
          });
        }
      }), P.length ? P.reduce((R, z) => z.top > R.top ? z : R).link : "";
    }, g = (I) => {
      const {
        getCurrentAnchor: T
      } = e;
      m.value !== I && (m.value = typeof T == "function" ? T(I) : I, n("change", I));
    }, y = (I) => {
      const {
        offsetTop: T,
        targetOffset: P
      } = e;
      g(I);
      const k = QM.exec(I);
      if (!k)
        return;
      const N = document.getElementById(k[1]);
      if (!N)
        return;
      const R = v.value(), z = pI(R), D = ZM(N, R);
      let F = z + D;
      F -= P !== void 0 ? P : T || 0, p.animating = !0, vI(F, {
        callback: () => {
          p.animating = !1;
        },
        getContainer: v.value
      });
    };
    r({
      scrollTo: y
    });
    const b = () => {
      if (p.animating)
        return;
      const {
        offsetTop: I,
        bounds: T,
        targetOffset: P
      } = e, k = h(P !== void 0 ? P : I || 0, T);
      g(k);
    }, C = () => {
      const I = f.value.querySelector(`.${i.value}-link-title-active`);
      if (I && d.value) {
        const T = u.value === "horizontal";
        d.value.style.top = T ? "" : `${I.offsetTop + I.clientHeight / 2}px`, d.value.style.height = T ? "" : `${I.clientHeight}px`, d.value.style.left = T ? `${I.offsetLeft}px` : "", d.value.style.width = T ? `${I.clientWidth}px` : "", T && KH(I, {
          scrollMode: "if-needed",
          block: "nearest"
        });
      }
    };
    x4e({
      registerLink: (I) => {
        p.links.includes(I) || p.links.push(I);
      },
      unregisterLink: (I) => {
        const T = p.links.indexOf(I);
        T !== -1 && p.links.splice(T, 1);
      },
      activeLink: m,
      scrollTo: y,
      handleClick: (I, T) => {
        n("click", I, T);
      },
      direction: u
    }), nt(() => {
      Ke(() => {
        const I = v.value();
        p.scrollContainer = I, p.scrollEvent = vo(p.scrollContainer, "scroll", b), b();
      });
    }), yt(() => {
      p.scrollEvent && p.scrollEvent.remove();
    }), $o(() => {
      if (p.scrollEvent) {
        const I = v.value();
        p.scrollContainer !== I && (p.scrollContainer = I, p.scrollEvent.remove(), p.scrollEvent = vo(p.scrollContainer, "scroll", b), b());
      }
      C();
    });
    const w = (I) => Array.isArray(I) ? I.map((T) => {
      const {
        children: P,
        key: k,
        href: N,
        target: R,
        class: z,
        style: D,
        title: F
      } = T;
      return $(mI, {
        key: k,
        href: N,
        target: R,
        class: z,
        style: D,
        title: F,
        customTitleProps: T
      }, {
        default: () => [u.value === "vertical" ? w(P) : null],
        customTitle: l.customTitle
      });
    }) : null, [x, E] = I4e(i);
    return () => {
      var I;
      const {
        offsetTop: T,
        affix: P,
        showInkInFixed: k
      } = e, N = i.value, R = ke(`${N}-ink`, {
        [`${N}-ink-visible`]: m.value
      }), z = ke(E.value, e.wrapperClass, `${N}-wrapper`, {
        [`${N}-wrapper-horizontal`]: u.value === "horizontal",
        [`${N}-rtl`]: c.value === "rtl"
      }), D = ke(N, {
        [`${N}-fixed`]: !P && !k
      }), F = _({
        maxHeight: T ? `calc(100vh - ${T}px)` : "100vh"
      }, e.wrapperStyle), M = $("div", {
        class: z,
        style: F,
        ref: f
      }, [$("div", {
        class: D
      }, [$("span", {
        class: R,
        ref: d
      }, null), Array.isArray(e.items) ? w(e.items) : (I = l.default) === null || I === void 0 ? void 0 : I.call(l)])]);
      return x(P ? $(jH, Q(Q({}, o), {}, {
        offsetTop: T,
        target: v.value
      }), {
        default: () => [M]
      }) : M);
    };
  }
});
iu.Link = mI;
iu.install = function(e) {
  return e.component(iu.name, iu), e.component(iu.Link.name, iu.Link), e;
};
function e8(e, t) {
  const {
    key: n
  } = e;
  let o;
  return "value" in e && ({
    value: o
  } = e), n != null ? n : o !== void 0 ? o : `rc-index-key-${t}`;
}
function oj(e, t) {
  const {
    label: n,
    value: o,
    options: l
  } = e || {};
  return {
    label: n || (t ? "children" : "label"),
    value: o || "value",
    options: l || "options"
  };
}
function Z4e(e) {
  let {
    fieldNames: t,
    childrenAsData: n
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const o = [], {
    label: l,
    value: r,
    options: a
  } = oj(t, !1);
  function i(s, c) {
    s.forEach((u) => {
      const d = u[l];
      if (c || !(a in u)) {
        const f = u[r];
        o.push({
          key: e8(u, o.length),
          groupOption: c,
          data: u,
          label: d,
          value: f
        });
      } else {
        let f = d;
        f === void 0 && n && (f = u.label), o.push({
          key: e8(u, o.length),
          group: !0,
          data: u,
          label: f
        }), i(u[a], !0);
      }
    });
  }
  return i(e, !1), o;
}
function y2(e) {
  const t = _({}, e);
  return "props" in t || Object.defineProperty(t, "props", {
    get() {
      return bn(!1, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`."), t;
    }
  }), t;
}
function Q4e(e, t) {
  if (!t || !t.length)
    return null;
  let n = !1;
  function o(r, a) {
    let [i, ...s] = a;
    if (!i)
      return [r];
    const c = r.split(i);
    return n = n || c.length > 1, c.reduce((u, d) => [...u, ...o(d, s)], []).filter((u) => u);
  }
  const l = o(e, t);
  return n ? l : null;
}
function e3e() {
  return "";
}
function t3e(e) {
  return e ? e.ownerDocument : window.document;
}
function lj() {
}
const rj = () => ({
  action: de.oneOfType([de.string, de.arrayOf(de.string)]).def([]),
  showAction: de.any.def([]),
  hideAction: de.any.def([]),
  getPopupClassNameFromAlign: de.any.def(e3e),
  onPopupVisibleChange: Function,
  afterPopupVisibleChange: de.func.def(lj),
  popup: de.any,
  arrow: de.bool.def(!0),
  popupStyle: {
    type: Object,
    default: void 0
  },
  prefixCls: de.string.def("rc-trigger-popup"),
  popupClassName: de.string.def(""),
  popupPlacement: String,
  builtinPlacements: de.object,
  popupTransitionName: String,
  popupAnimation: de.any,
  mouseEnterDelay: de.number.def(0),
  mouseLeaveDelay: de.number.def(0.1),
  zIndex: Number,
  focusDelay: de.number.def(0),
  blurDelay: de.number.def(0.15),
  getPopupContainer: Function,
  getDocument: de.func.def(t3e),
  forceRender: {
    type: Boolean,
    default: void 0
  },
  destroyPopupOnHide: {
    type: Boolean,
    default: !1
  },
  mask: {
    type: Boolean,
    default: !1
  },
  maskClosable: {
    type: Boolean,
    default: !0
  },
  // onPopupAlign: PropTypes.func.def(noop),
  popupAlign: de.object.def(() => ({})),
  popupVisible: {
    type: Boolean,
    default: void 0
  },
  defaultPopupVisible: {
    type: Boolean,
    default: !1
  },
  maskTransitionName: String,
  maskAnimation: String,
  stretch: String,
  alignPoint: {
    type: Boolean,
    default: void 0
  },
  autoDestroy: {
    type: Boolean,
    default: !1
  },
  mobile: Object,
  getTriggerDOMNode: Function
}), gI = {
  visible: Boolean,
  prefixCls: String,
  zIndex: Number,
  destroyPopupOnHide: Boolean,
  forceRender: Boolean,
  arrow: {
    type: Boolean,
    default: !0
  },
  // Legacy Motion
  animation: [String, Object],
  transitionName: String,
  // Measure
  stretch: {
    type: String
  },
  // Align
  align: {
    type: Object
  },
  point: {
    type: Object
  },
  getRootDomNode: {
    type: Function
  },
  getClassNameFromAlign: {
    type: Function
  },
  onAlign: {
    type: Function
  },
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onTouchstart: {
    type: Function
  }
}, n3e = _(_({}, gI), {
  mobile: {
    type: Object
  }
}), o3e = _(_({}, gI), {
  mask: Boolean,
  mobile: {
    type: Object
  },
  maskAnimation: String,
  maskTransitionName: String
});
function bI(e) {
  let {
    prefixCls: t,
    animation: n,
    transitionName: o
  } = e;
  return n ? {
    name: `${t}-${n}`
  } : o ? {
    name: o
  } : {};
}
function aj(e) {
  const {
    prefixCls: t,
    visible: n,
    zIndex: o,
    mask: l,
    maskAnimation: r,
    maskTransitionName: a
  } = e;
  if (!l)
    return null;
  let i = {};
  return (a || r) && (i = bI({
    prefixCls: t,
    transitionName: a,
    animation: r
  })), $(Vn, Q({
    appear: !0
  }, i), {
    default: () => [_t($("div", {
      style: {
        zIndex: o
      },
      class: `${t}-mask`
    }, null), [[s1("if"), n]])]
  });
}
aj.displayName = "Mask";
const l3e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "MobilePopupInner",
  inheritAttrs: !1,
  props: n3e,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup(e, t) {
    let {
      expose: n,
      slots: o
    } = t;
    const l = /* @__PURE__ */ H();
    return n({
      forceAlign: () => {
      },
      getElement: () => l.value
    }), () => {
      var r;
      const {
        zIndex: a,
        visible: i,
        prefixCls: s,
        mobile: {
          popupClassName: c,
          popupStyle: u,
          popupMotion: d = {},
          popupRender: f
        } = {}
      } = e, p = _({
        zIndex: a
      }, u);
      let m = Fn((r = o.default) === null || r === void 0 ? void 0 : r.call(o));
      m.length > 1 && (m = $("div", {
        class: `${s}-content`
      }, [m])), f && (m = f(m));
      const v = ke(s, c);
      return $(Vn, Q({
        ref: l
      }, d), {
        default: () => [i ? $("div", {
          class: v,
          style: p
        }, [m]) : null]
      });
    };
  }
});
var r3e = function(e, t, n, o) {
  function l(r) {
    return r instanceof n ? r : new n(function(a) {
      a(r);
    });
  }
  return new (n || (n = Promise))(function(r, a) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (d) {
        a(d);
      }
    }
    function s(u) {
      try {
        c(o.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? r(u.value) : l(u.value).then(i, s);
    }
    c((o = o.apply(e, t || [])).next());
  });
};
const t8 = ["measure", "align", null, "motion"], a3e = (e, t) => {
  const n = /* @__PURE__ */ Ce(null), o = /* @__PURE__ */ Ce(), l = /* @__PURE__ */ Ce(!1);
  function r(s) {
    l.value || (n.value = s);
  }
  function a() {
    rn.cancel(o.value);
  }
  function i(s) {
    a(), o.value = rn(() => {
      let c = n.value;
      switch (n.value) {
        case "align":
          c = "motion";
          break;
        case "motion":
          c = "stable";
          break;
      }
      r(c), s == null || s();
    });
  }
  return pe(e, () => {
    r("measure");
  }, {
    immediate: !0,
    flush: "post"
  }), nt(() => {
    pe(n, () => {
      switch (n.value) {
        case "measure":
          t();
          break;
      }
      n.value && (o.value = rn(() => r3e(void 0, void 0, void 0, function* () {
        const s = t8.indexOf(n.value), c = t8[s + 1];
        c && s !== -1 && r(c);
      })));
    }, {
      immediate: !0,
      flush: "post"
    });
  }), yt(() => {
    l.value = !0, a();
  }), [n, i];
}, i3e = (e) => {
  const t = /* @__PURE__ */ Ce({
    width: 0,
    height: 0
  });
  function n(l) {
    t.value = {
      width: l.offsetWidth,
      height: l.offsetHeight
    };
  }
  return [O(() => {
    const l = {};
    if (e.value) {
      const {
        width: r,
        height: a
      } = t.value;
      e.value.indexOf("height") !== -1 && a ? l.height = `${a}px` : e.value.indexOf("minHeight") !== -1 && a && (l.minHeight = `${a}px`), e.value.indexOf("width") !== -1 && r ? l.width = `${r}px` : e.value.indexOf("minWidth") !== -1 && r && (l.minWidth = `${r}px`);
    }
    return l;
  }), n];
};
function n8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(e, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function o8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? n8(Object(n), !0).forEach(function(o) {
      s3e(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : n8(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
function S2(e) {
  "@babel/helpers - typeof";
  return S2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, S2(e);
}
function s3e(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var rv, c3e = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  // IE did it wrong again ...
  ms: "-ms-",
  O: "-o-"
};
function iy() {
  if (rv !== void 0)
    return rv;
  rv = "";
  var e = document.createElement("p").style, t = "Transform";
  for (var n in c3e)
    n + t in e && (rv = n);
  return rv;
}
function ij() {
  return iy() ? "".concat(iy(), "TransitionProperty") : "transitionProperty";
}
function dS() {
  return iy() ? "".concat(iy(), "Transform") : "transform";
}
function l8(e, t) {
  var n = ij();
  n && (e.style[n] = t, n !== "transitionProperty" && (e.style.transitionProperty = t));
}
function gw(e, t) {
  var n = dS();
  n && (e.style[n] = t, n !== "transform" && (e.style.transform = t));
}
function u3e(e) {
  return e.style.transitionProperty || e.style[ij()];
}
function d3e(e) {
  var t = window.getComputedStyle(e, null), n = t.getPropertyValue("transform") || t.getPropertyValue(dS());
  if (n && n !== "none") {
    var o = n.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(o[12] || o[4], 0),
      y: parseFloat(o[13] || o[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var f3e = /matrix\((.*)\)/, p3e = /matrix3d\((.*)\)/;
function v3e(e, t) {
  var n = window.getComputedStyle(e, null), o = n.getPropertyValue("transform") || n.getPropertyValue(dS());
  if (o && o !== "none") {
    var l, r = o.match(f3e);
    if (r)
      r = r[1], l = r.split(",").map(function(i) {
        return parseFloat(i, 10);
      }), l[4] = t.x, l[5] = t.y, gw(e, "matrix(".concat(l.join(","), ")"));
    else {
      var a = o.match(p3e)[1];
      l = a.split(",").map(function(i) {
        return parseFloat(i, 10);
      }), l[12] = t.x, l[13] = t.y, gw(e, "matrix3d(".concat(l.join(","), ")"));
    }
  } else
    gw(e, "translateX(".concat(t.x, "px) translateY(").concat(t.y, "px) translateZ(0)"));
}
var m3e = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source, xh;
function r8(e) {
  var t = e.style.display;
  e.style.display = "none", e.offsetHeight, e.style.display = t;
}
function Cf(e, t, n) {
  var o = n;
  if (S2(t) === "object") {
    for (var l in t)
      t.hasOwnProperty(l) && Cf(e, l, t[l]);
    return;
  }
  if (typeof o != "undefined") {
    typeof o == "number" && (o = "".concat(o, "px")), e.style[t] = o;
    return;
  }
  return xh(e, t);
}
function h3e(e) {
  var t, n, o, l = e.ownerDocument, r = l.body, a = l && l.documentElement;
  return t = e.getBoundingClientRect(), n = Math.floor(t.left), o = Math.floor(t.top), n -= a.clientLeft || r.clientLeft || 0, o -= a.clientTop || r.clientTop || 0, {
    left: n,
    top: o
  };
}
function sj(e, t) {
  var n = e["page".concat(t ? "Y" : "X", "Offset")], o = "scroll".concat(t ? "Top" : "Left");
  if (typeof n != "number") {
    var l = e.document;
    n = l.documentElement[o], typeof n != "number" && (n = l.body[o]);
  }
  return n;
}
function cj(e) {
  return sj(e);
}
function uj(e) {
  return sj(e, !0);
}
function Mm(e) {
  var t = h3e(e), n = e.ownerDocument, o = n.defaultView || n.parentWindow;
  return t.left += cj(o), t.top += uj(o), t;
}
function yI(e) {
  return e != null && e == e.window;
}
function dj(e) {
  return yI(e) ? e.document : e.nodeType === 9 ? e : e.ownerDocument;
}
function g3e(e, t, n) {
  var o = n, l = "", r = dj(e);
  return o = o || r.defaultView.getComputedStyle(e, null), o && (l = o.getPropertyValue(t) || o[t]), l;
}
var b3e = new RegExp("^(".concat(m3e, ")(?!px)[a-z%]+$"), "i"), y3e = /^(top|right|bottom|left)$/, bw = "currentStyle", yw = "runtimeStyle", Kc = "left", S3e = "px";
function C3e(e, t) {
  var n = e[bw] && e[bw][t];
  if (b3e.test(n) && !y3e.test(t)) {
    var o = e.style, l = o[Kc], r = e[yw][Kc];
    e[yw][Kc] = e[bw][Kc], o[Kc] = t === "fontSize" ? "1em" : n || 0, n = o.pixelLeft + S3e, o[Kc] = l, e[yw][Kc] = r;
  }
  return n === "" ? "auto" : n;
}
typeof window != "undefined" && (xh = window.getComputedStyle ? g3e : C3e);
function _g(e, t) {
  return e === "left" ? t.useCssRight ? "right" : e : t.useCssBottom ? "bottom" : e;
}
function a8(e) {
  if (e === "left")
    return "right";
  if (e === "right")
    return "left";
  if (e === "top")
    return "bottom";
  if (e === "bottom")
    return "top";
}
function i8(e, t, n) {
  Cf(e, "position") === "static" && (e.style.position = "relative");
  var o = -999, l = -999, r = _g("left", n), a = _g("top", n), i = a8(r), s = a8(a);
  r !== "left" && (o = 999), a !== "top" && (l = 999);
  var c = "", u = Mm(e);
  ("left" in t || "top" in t) && (c = u3e(e) || "", l8(e, "none")), "left" in t && (e.style[i] = "", e.style[r] = "".concat(o, "px")), "top" in t && (e.style[s] = "", e.style[a] = "".concat(l, "px")), r8(e);
  var d = Mm(e), f = {};
  for (var p in t)
    if (t.hasOwnProperty(p)) {
      var m = _g(p, n), v = p === "left" ? o : l, h = u[p] - d[p];
      m === p ? f[m] = v + h : f[m] = v - h;
    }
  Cf(e, f), r8(e), ("left" in t || "top" in t) && l8(e, c);
  var g = {};
  for (var y in t)
    if (t.hasOwnProperty(y)) {
      var b = _g(y, n), C = t[y] - u[y];
      y === b ? g[b] = f[b] + C : g[b] = f[b] - C;
    }
  Cf(e, g);
}
function w3e(e, t) {
  var n = Mm(e), o = d3e(e), l = {
    x: o.x,
    y: o.y
  };
  "left" in t && (l.x = o.x + t.left - n.left), "top" in t && (l.y = o.y + t.top - n.top), v3e(e, l);
}
function $3e(e, t, n) {
  if (n.ignoreShake) {
    var o = Mm(e), l = o.left.toFixed(0), r = o.top.toFixed(0), a = t.left.toFixed(0), i = t.top.toFixed(0);
    if (l === a && r === i)
      return;
  }
  n.useCssRight || n.useCssBottom ? i8(e, t, n) : n.useCssTransform && dS() in document.body.style ? w3e(e, t) : i8(e, t, n);
}
function SI(e, t) {
  for (var n = 0; n < e.length; n++)
    t(e[n]);
}
function fj(e) {
  return xh(e, "boxSizing") === "border-box";
}
var x3e = ["margin", "border", "padding"], C2 = -1, E3e = 2, w2 = 1, O3e = 0;
function _3e(e, t, n) {
  var o = {}, l = e.style, r;
  for (r in t)
    t.hasOwnProperty(r) && (o[r] = l[r], l[r] = t[r]);
  n.call(e);
  for (r in t)
    t.hasOwnProperty(r) && (l[r] = o[r]);
}
function gv(e, t, n) {
  var o = 0, l, r, a;
  for (r = 0; r < t.length; r++)
    if (l = t[r], l)
      for (a = 0; a < n.length; a++) {
        var i = void 0;
        l === "border" ? i = "".concat(l).concat(n[a], "Width") : i = l + n[a], o += parseFloat(xh(e, i)) || 0;
      }
  return o;
}
var fi = {
  getParent: function(t) {
    var n = t;
    do
      n.nodeType === 11 && n.host ? n = n.host : n = n.parentNode;
    while (n && n.nodeType !== 1 && n.nodeType !== 9);
    return n;
  }
};
SI(["Width", "Height"], function(e) {
  fi["doc".concat(e)] = function(t) {
    var n = t.document;
    return Math.max(
      // firefox chrome documentElement.scrollHeight< body.scrollHeight
      // ie standard mode : documentElement.scrollHeight> body.scrollHeight
      n.documentElement["scroll".concat(e)],
      // quirks : documentElement.scrollHeight 
      n.body["scroll".concat(e)],
      fi["viewport".concat(e)](n)
    );
  }, fi["viewport".concat(e)] = function(t) {
    var n = "client".concat(e), o = t.document, l = o.body, r = o.documentElement, a = r[n];
    return o.compatMode === "CSS1Compat" && a || l && l[n] || a;
  };
});
function s8(e, t, n) {
  var o = n;
  if (yI(e))
    return t === "width" ? fi.viewportWidth(e) : fi.viewportHeight(e);
  if (e.nodeType === 9)
    return t === "width" ? fi.docWidth(e) : fi.docHeight(e);
  var l = t === "width" ? ["Left", "Right"] : ["Top", "Bottom"], r = Math.floor(t === "width" ? e.getBoundingClientRect().width : e.getBoundingClientRect().height), a = fj(e), i = 0;
  (r == null || r <= 0) && (r = void 0, i = xh(e, t), (i == null || Number(i) < 0) && (i = e.style[t] || 0), i = Math.floor(parseFloat(i)) || 0), o === void 0 && (o = a ? w2 : C2);
  var s = r !== void 0 || a, c = r || i;
  return o === C2 ? s ? c - gv(e, ["border", "padding"], l) : i : s ? o === w2 ? c : c + (o === E3e ? -gv(e, ["border"], l) : gv(e, ["margin"], l)) : i + gv(e, x3e.slice(o), l);
}
var I3e = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function c8() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var o, l = t[0];
  return l.offsetWidth !== 0 ? o = s8.apply(void 0, t) : _3e(l, I3e, function() {
    o = s8.apply(void 0, t);
  }), o;
}
SI(["width", "height"], function(e) {
  var t = e.charAt(0).toUpperCase() + e.slice(1);
  fi["outer".concat(t)] = function(o, l) {
    return o && c8(o, e, l ? O3e : w2);
  };
  var n = e === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  fi[e] = function(o, l) {
    var r = l;
    if (r !== void 0) {
      if (o) {
        var a = fj(o);
        return a && (r += gv(o, ["padding", "border"], n)), Cf(o, e, r);
      }
      return;
    }
    return o && c8(o, e, C2);
  };
});
function pj(e, t) {
  for (var n in t)
    t.hasOwnProperty(n) && (e[n] = t[n]);
  return e;
}
var On = {
  getWindow: function(t) {
    if (t && t.document && t.setTimeout)
      return t;
    var n = t.ownerDocument || t;
    return n.defaultView || n.parentWindow;
  },
  getDocument: dj,
  offset: function(t, n, o) {
    if (typeof n != "undefined")
      $3e(t, n, o || {});
    else
      return Mm(t);
  },
  isWindow: yI,
  each: SI,
  css: Cf,
  clone: function(t) {
    var n, o = {};
    for (n in t)
      t.hasOwnProperty(n) && (o[n] = t[n]);
    var l = t.overflow;
    if (l)
      for (n in t)
        t.hasOwnProperty(n) && (o.overflow[n] = t.overflow[n]);
    return o;
  },
  mix: pj,
  getWindowScrollLeft: function(t) {
    return cj(t);
  },
  getWindowScrollTop: function(t) {
    return uj(t);
  },
  merge: function() {
    for (var t = {}, n = 0; n < arguments.length; n++)
      On.mix(t, n < 0 || arguments.length <= n ? void 0 : arguments[n]);
    return t;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
pj(On, fi);
var Sw = On.getParent;
function $2(e) {
  if (On.isWindow(e) || e.nodeType === 9)
    return null;
  var t = On.getDocument(e), n = t.body, o, l = On.css(e, "position"), r = l === "fixed" || l === "absolute";
  if (!r)
    return e.nodeName.toLowerCase() === "html" ? null : Sw(e);
  for (o = Sw(e); o && o !== n && o.nodeType !== 9; o = Sw(o))
    if (l = On.css(o, "position"), l !== "static")
      return o;
  return null;
}
var u8 = On.getParent;
function T3e(e) {
  if (On.isWindow(e) || e.nodeType === 9)
    return !1;
  var t = On.getDocument(e), n = t.body, o = null;
  for (
    o = u8(e);
    //  document.documentElement 
    o && o !== n && o !== t;
    o = u8(o)
  ) {
    var l = On.css(o, "position");
    if (l === "fixed")
      return !0;
  }
  return !1;
}
function CI(e, t) {
  for (var n = {
    left: 0,
    right: 1 / 0,
    top: 0,
    bottom: 1 / 0
  }, o = $2(e), l = On.getDocument(e), r = l.defaultView || l.parentWindow, a = l.body, i = l.documentElement; o; ) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || o.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    o !== a && o !== i && On.css(o, "overflow") !== "visible") {
      var s = On.offset(o);
      s.left += o.clientLeft, s.top += o.clientTop, n.top = Math.max(n.top, s.top), n.right = Math.min(
        n.right,
        // consider area without scrollBar
        s.left + o.clientWidth
      ), n.bottom = Math.min(n.bottom, s.top + o.clientHeight), n.left = Math.max(n.left, s.left);
    } else if (o === a || o === i)
      break;
    o = $2(o);
  }
  var c = null;
  if (!On.isWindow(e) && e.nodeType !== 9) {
    c = e.style.position;
    var u = On.css(e, "position");
    u === "absolute" && (e.style.position = "fixed");
  }
  var d = On.getWindowScrollLeft(r), f = On.getWindowScrollTop(r), p = On.viewportWidth(r), m = On.viewportHeight(r), v = i.scrollWidth, h = i.scrollHeight, g = window.getComputedStyle(a);
  if (g.overflowX === "hidden" && (v = r.innerWidth), g.overflowY === "hidden" && (h = r.innerHeight), e.style && (e.style.position = c), t || T3e(e))
    n.left = Math.max(n.left, d), n.top = Math.max(n.top, f), n.right = Math.min(n.right, d + p), n.bottom = Math.min(n.bottom, f + m);
  else {
    var y = Math.max(v, d + p);
    n.right = Math.min(n.right, y);
    var b = Math.max(h, f + m);
    n.bottom = Math.min(n.bottom, b);
  }
  return n.top >= 0 && n.left >= 0 && n.bottom > n.top && n.right > n.left ? n : null;
}
function P3e(e, t, n, o) {
  var l = On.clone(e), r = {
    width: t.width,
    height: t.height
  };
  return o.adjustX && l.left < n.left && (l.left = n.left), o.resizeWidth && l.left >= n.left && l.left + r.width > n.right && (r.width -= l.left + r.width - n.right), o.adjustX && l.left + r.width > n.right && (l.left = Math.max(n.right - r.width, n.left)), o.adjustY && l.top < n.top && (l.top = n.top), o.resizeHeight && l.top >= n.top && l.top + r.height > n.bottom && (r.height -= l.top + r.height - n.bottom), o.adjustY && l.top + r.height > n.bottom && (l.top = Math.max(n.bottom - r.height, n.top)), On.mix(l, r);
}
function wI(e) {
  var t, n, o;
  if (!On.isWindow(e) && e.nodeType !== 9)
    t = On.offset(e), n = On.outerWidth(e), o = On.outerHeight(e);
  else {
    var l = On.getWindow(e);
    t = {
      left: On.getWindowScrollLeft(l),
      top: On.getWindowScrollTop(l)
    }, n = On.viewportWidth(l), o = On.viewportHeight(l);
  }
  return t.width = n, t.height = o, t;
}
function d8(e, t) {
  var n = t.charAt(0), o = t.charAt(1), l = e.width, r = e.height, a = e.left, i = e.top;
  return n === "c" ? i += r / 2 : n === "b" && (i += r), o === "c" ? a += l / 2 : o === "r" && (a += l), {
    left: a,
    top: i
  };
}
function Ig(e, t, n, o, l) {
  var r = d8(t, n[1]), a = d8(e, n[0]), i = [a.left - r.left, a.top - r.top];
  return {
    left: Math.round(e.left - i[0] + o[0] - l[0]),
    top: Math.round(e.top - i[1] + o[1] - l[1])
  };
}
function f8(e, t, n) {
  return e.left < n.left || e.left + t.width > n.right;
}
function p8(e, t, n) {
  return e.top < n.top || e.top + t.height > n.bottom;
}
function k3e(e, t, n) {
  return e.left > n.right || e.left + t.width < n.left;
}
function N3e(e, t, n) {
  return e.top > n.bottom || e.top + t.height < n.top;
}
function Tg(e, t, n) {
  var o = [];
  return On.each(e, function(l) {
    o.push(l.replace(t, function(r) {
      return n[r];
    }));
  }), o;
}
function Pg(e, t) {
  return e[t] = -e[t], e;
}
function v8(e, t) {
  var n;
  return /%$/.test(e) ? n = parseInt(e.substring(0, e.length - 1), 10) / 100 * t : n = parseInt(e, 10), n || 0;
}
function m8(e, t) {
  e[0] = v8(e[0], t.width), e[1] = v8(e[1], t.height);
}
function vj(e, t, n, o) {
  var l = n.points, r = n.offset || [0, 0], a = n.targetOffset || [0, 0], i = n.overflow, s = n.source || e;
  r = [].concat(r), a = [].concat(a), i = i || {};
  var c = {}, u = 0, d = !!(i && i.alwaysByViewport), f = CI(s, d), p = wI(s);
  m8(r, p), m8(a, t);
  var m = Ig(p, t, l, r, a), v = On.merge(p, m);
  if (f && (i.adjustX || i.adjustY) && o) {
    if (i.adjustX && f8(m, p, f)) {
      var h = Tg(l, /[lr]/gi, {
        l: "r",
        r: "l"
      }), g = Pg(r, 0), y = Pg(a, 0), b = Ig(p, t, h, g, y);
      k3e(b, p, f) || (u = 1, l = h, r = g, a = y);
    }
    if (i.adjustY && p8(m, p, f)) {
      var C = Tg(l, /[tb]/gi, {
        t: "b",
        b: "t"
      }), w = Pg(r, 1), x = Pg(a, 1), E = Ig(p, t, C, w, x);
      N3e(E, p, f) || (u = 1, l = C, r = w, a = x);
    }
    u && (m = Ig(p, t, l, r, a), On.mix(v, m));
    var I = f8(m, p, f), T = p8(m, p, f);
    if (I || T) {
      var P = l;
      I && (P = Tg(l, /[lr]/gi, {
        l: "r",
        r: "l"
      })), T && (P = Tg(l, /[tb]/gi, {
        t: "b",
        b: "t"
      })), l = P, r = n.offset || [0, 0], a = n.targetOffset || [0, 0];
    }
    c.adjustX = i.adjustX && I, c.adjustY = i.adjustY && T, (c.adjustX || c.adjustY) && (v = P3e(m, p, f, c));
  }
  return v.width !== p.width && On.css(s, "width", On.width(s) + v.width - p.width), v.height !== p.height && On.css(s, "height", On.height(s) + v.height - p.height), On.offset(s, {
    left: v.left,
    top: v.top
  }, {
    useCssRight: n.useCssRight,
    useCssBottom: n.useCssBottom,
    useCssTransform: n.useCssTransform,
    ignoreShake: n.ignoreShake
  }), {
    points: l,
    offset: r,
    targetOffset: a,
    overflow: c
  };
}
function M3e(e, t) {
  var n = CI(e, t), o = wI(e);
  return !n || o.left + o.width <= n.left || o.top + o.height <= n.top || o.left >= n.right || o.top >= n.bottom;
}
function $I(e, t, n) {
  var o = n.target || t, l = wI(o), r = !M3e(o, n.overflow && n.overflow.alwaysByViewport);
  return vj(e, l, n, r);
}
$I.__getOffsetParent = $2;
$I.__getVisibleRectForElement = CI;
function A3e(e, t, n) {
  var o, l, r = On.getDocument(e), a = r.defaultView || r.parentWindow, i = On.getWindowScrollLeft(a), s = On.getWindowScrollTop(a), c = On.viewportWidth(a), u = On.viewportHeight(a);
  "pageX" in t ? o = t.pageX : o = i + t.clientX, "pageY" in t ? l = t.pageY : l = s + t.clientY;
  var d = {
    left: o,
    top: l,
    width: 0,
    height: 0
  }, f = o >= 0 && o <= i + c && l >= 0 && l <= s + u, p = [n.points[0], "cc"];
  return vj(e, d, o8(o8({}, n), {}, {
    points: p
  }), f);
}
function _n(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, l = e;
  if (Array.isArray(e) && (l = mo(e)[0]), !l)
    return null;
  const r = No(l, t, o);
  return r.props = n ? _(_({}, r.props), t) : r.props, Hn(typeof r.props.class != "object", "class must be string"), r;
}
function R3e(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  return e.map((o) => _n(o, t, n));
}
function Rv(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (Array.isArray(e))
    return e.map((l) => Rv(l, t, n, o));
  {
    if (!dn(e))
      return e;
    const l = _n(e, t, n, o);
    return Array.isArray(l.children) && (l.children = Rv(l.children)), l;
  }
}
function D3e(e, t, n) {
  Bl(No(e, _({}, t)), n);
}
const mj = (e) => (e || []).some((t) => dn(t) ? !(t.type === qn || t.type === Ge && !mj(t.children)) : !0) ? e : null;
function fS(e, t, n, o) {
  var l;
  const r = (l = e[t]) === null || l === void 0 ? void 0 : l.call(e, n);
  return mj(r) ? r : o == null ? void 0 : o();
}
const pS = (e) => {
  if (!e)
    return !1;
  if (e.offsetParent)
    return !0;
  if (e.getBBox) {
    const t = e.getBBox();
    if (t.width || t.height)
      return !0;
  }
  if (e.getBoundingClientRect) {
    const t = e.getBoundingClientRect();
    if (t.width || t.height)
      return !0;
  }
  return !1;
};
function L3e(e, t) {
  return e === t ? !0 : !e || !t ? !1 : "pageX" in t && "pageY" in t ? e.pageX === t.pageX && e.pageY === t.pageY : "clientX" in t && "clientY" in t ? e.clientX === t.clientX && e.clientY === t.clientY : !1;
}
function B3e(e, t) {
  e !== document.activeElement && Xs(t, e) && typeof e.focus == "function" && e.focus();
}
function h8(e, t) {
  let n = null, o = null;
  function l(a) {
    let [{
      target: i
    }] = a;
    if (!document.documentElement.contains(i)) return;
    const {
      width: s,
      height: c
    } = i.getBoundingClientRect(), u = Math.floor(s), d = Math.floor(c);
    (n !== u || o !== d) && Promise.resolve().then(() => {
      t({
        width: u,
        height: d
      });
    }), n = u, o = d;
  }
  const r = new tI(l);
  return e && r.observe(e), () => {
    r.disconnect();
  };
}
const F3e = (e, t) => {
  let n = !1, o = null;
  function l() {
    clearTimeout(o);
  }
  function r(a) {
    if (!n || a === !0) {
      if (e() === !1)
        return;
      n = !0, l(), o = setTimeout(() => {
        n = !1;
      }, t.value);
    } else
      l(), o = setTimeout(() => {
        n = !1, r();
      }, t.value);
  }
  return [r, () => {
    n = !1, l();
  }];
}, V3e = {
  align: Object,
  target: [Object, Function],
  onAlign: Function,
  monitorBufferTime: Number,
  monitorWindowResize: Boolean,
  disabled: Boolean
};
function g8(e) {
  return typeof e != "function" ? null : e();
}
function b8(e) {
  return typeof e != "object" || !e ? null : e;
}
const z3e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Align",
  props: V3e,
  emits: ["align"],
  setup(e, t) {
    let {
      expose: n,
      slots: o
    } = t;
    const l = /* @__PURE__ */ H({}), r = /* @__PURE__ */ H(), [a, i] = F3e(() => {
      const {
        disabled: f,
        target: p,
        align: m,
        onAlign: v
      } = e;
      if (!f && p && r.value) {
        const h = r.value;
        let g;
        const y = g8(p), b = b8(p);
        l.value.element = y, l.value.point = b, l.value.align = m;
        const {
          activeElement: C
        } = document;
        return y && pS(y) ? g = $I(h, y, m) : b && (g = A3e(h, b, m)), B3e(C, h), v && g && v(h, g), !0;
      }
      return !1;
    }, O(() => e.monitorBufferTime)), s = /* @__PURE__ */ H({
      cancel: () => {
      }
    }), c = /* @__PURE__ */ H({
      cancel: () => {
      }
    }), u = () => {
      const f = e.target, p = g8(f), m = b8(f);
      r.value !== c.value.element && (c.value.cancel(), c.value.element = r.value, c.value.cancel = h8(r.value, a)), (l.value.element !== p || !L3e(l.value.point, m) || !Jn(l.value.align, e.align)) && (a(), s.value.element !== p && (s.value.cancel(), s.value.element = p, s.value.cancel = h8(p, a)));
    };
    nt(() => {
      Ke(() => {
        u();
      });
    }), $o(() => {
      Ke(() => {
        u();
      });
    }), pe(() => e.disabled, (f) => {
      f ? i() : a();
    }, {
      immediate: !0,
      flush: "post"
    });
    const d = /* @__PURE__ */ H(null);
    return pe(() => e.monitorWindowResize, (f) => {
      f ? d.value || (d.value = vo(window, "resize", a)) : d.value && (d.value.remove(), d.value = null);
    }, {
      flush: "post"
    }), Uo(() => {
      s.value.cancel(), c.value.cancel(), d.value && d.value.remove(), i();
    }), n({
      forceAlign: () => a(!0)
    }), () => {
      const f = o == null ? void 0 : o.default();
      return f ? _n(f[0], {
        ref: r
      }, !0, !0) : null;
    };
  }
});
$l("bottomLeft", "bottomRight", "topLeft", "topRight");
const xI = (e) => e !== void 0 && (e === "topLeft" || e === "topRight") ? "slide-down" : "slide-up", da = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _(e ? {
    name: e,
    appear: !0,
    // type: 'animation',
    // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
    // appearActiveClass: `antdv-base-transtion`,
    // appearToClass: `${transitionName}-appear ${transitionName}-appear-active`,
    enterFromClass: `${e}-enter ${e}-enter-prepare ${e}-enter-start`,
    enterActiveClass: `${e}-enter ${e}-enter-prepare`,
    enterToClass: `${e}-enter ${e}-enter-active`,
    leaveFromClass: ` ${e}-leave`,
    leaveActiveClass: `${e}-leave ${e}-leave-active`,
    leaveToClass: `${e}-leave ${e}-leave-active`
  } : {
    css: !1
  }, t);
}, vS = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return _(e ? {
    name: e,
    appear: !0,
    // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
    appearActiveClass: `${e}`,
    appearToClass: `${e}-appear ${e}-appear-active`,
    enterFromClass: `${e}-appear ${e}-enter ${e}-appear-prepare ${e}-enter-prepare`,
    enterActiveClass: `${e}`,
    enterToClass: `${e}-enter ${e}-appear ${e}-appear-active ${e}-enter-active`,
    leaveActiveClass: `${e} ${e}-leave`,
    leaveToClass: `${e}-leave-active`
  } : {
    css: !1
  }, t);
}, Vl = (e, t, n) => n !== void 0 ? n : `${e}-${t}`, H3e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "PopupInner",
  inheritAttrs: !1,
  props: gI,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup(e, t) {
    let {
      expose: n,
      attrs: o,
      slots: l
    } = t;
    const r = /* @__PURE__ */ Ce(), a = /* @__PURE__ */ Ce(), i = /* @__PURE__ */ Ce(), [s, c] = i3e(/* @__PURE__ */ ft(e, "stretch")), u = () => {
      e.stretch && c(e.getRootDomNode());
    }, d = /* @__PURE__ */ Ce(!1);
    let f;
    pe(() => e.visible, (x) => {
      clearTimeout(f), x ? f = setTimeout(() => {
        d.value = e.visible;
      }) : d.value = !1;
    }, {
      immediate: !0
    });
    const [p, m] = a3e(d, u), v = /* @__PURE__ */ Ce(), h = () => e.point ? e.point : e.getRootDomNode, g = () => {
      var x;
      (x = r.value) === null || x === void 0 || x.forceAlign();
    }, y = (x, E) => {
      var I;
      const T = e.getClassNameFromAlign(E), P = i.value;
      i.value !== T && (i.value = T), p.value === "align" && (P !== T ? Promise.resolve().then(() => {
        g();
      }) : m(() => {
        var k;
        (k = v.value) === null || k === void 0 || k.call(v);
      }), (I = e.onAlign) === null || I === void 0 || I.call(e, x, E));
    }, b = O(() => {
      const x = typeof e.animation == "object" ? e.animation : bI(e);
      return ["onAfterEnter", "onAfterLeave"].forEach((E) => {
        const I = x[E];
        x[E] = (T) => {
          m(), p.value = "stable", I == null || I(T);
        };
      }), x;
    }), C = () => new Promise((x) => {
      v.value = x;
    });
    pe([b, p], () => {
      !b.value && p.value === "motion" && m();
    }, {
      immediate: !0
    }), n({
      forceAlign: g,
      getElement: () => a.value.$el || a.value
    });
    const w = O(() => {
      var x;
      return !(!((x = e.align) === null || x === void 0) && x.points && (p.value === "align" || p.value === "stable"));
    });
    return () => {
      var x;
      const {
        zIndex: E,
        align: I,
        prefixCls: T,
        destroyPopupOnHide: P,
        onMouseenter: k,
        onMouseleave: N,
        onTouchstart: R = () => {
        },
        onMousedown: z
      } = e, D = p.value, F = [_(_({}, s.value), {
        zIndex: E,
        opacity: D === "motion" || D === "stable" || !d.value ? null : 0,
        // pointerEvents: statusValue === 'stable' ? null : 'none',
        pointerEvents: !d.value && D !== "stable" ? "none" : null
      }), o.style];
      let M = Fn((x = l.default) === null || x === void 0 ? void 0 : x.call(l, {
        visible: e.visible
      }));
      M.length > 1 && (M = $("div", {
        class: `${T}-content`
      }, [M]));
      const A = ke(T, o.class, i.value, !e.arrow && `${T}-arrow-hidden`), B = d.value || !e.visible ? da(b.value.name, b.value) : {};
      return $(Vn, Q(Q({
        ref: a
      }, B), {}, {
        onBeforeEnter: C
      }), {
        default: () => !P || e.visible ? _t($(z3e, {
          target: h(),
          key: "popup",
          ref: r,
          monitorWindowResize: !0,
          disabled: w.value,
          align: I,
          onAlign: y
        }, {
          default: () => $("div", {
            class: A,
            onMouseenter: k,
            onMouseleave: N,
            onMousedown: Et(z, ["capture"]),
            [Ho ? "onTouchstartPassive" : "onTouchstart"]: Et(R, ["capture"]),
            style: F
          }, [M])
        }), [[Jt, d.value]]) : null
      });
    };
  }
}), j3e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Popup",
  inheritAttrs: !1,
  props: o3e,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: l
    } = t;
    const r = /* @__PURE__ */ Ce(!1), a = /* @__PURE__ */ Ce(!1), i = /* @__PURE__ */ Ce(), s = /* @__PURE__ */ Ce();
    return pe([() => e.visible, () => e.mobile], () => {
      r.value = e.visible, e.visible && e.mobile && (a.value = !0);
    }, {
      immediate: !0,
      flush: "post"
    }), l({
      forceAlign: () => {
        var c;
        (c = i.value) === null || c === void 0 || c.forceAlign();
      },
      getElement: () => {
        var c;
        return (c = i.value) === null || c === void 0 ? void 0 : c.getElement();
      }
    }), () => {
      const c = _(_(_({}, e), n), {
        visible: r.value
      }), u = a.value ? $(l3e, Q(Q({}, c), {}, {
        mobile: e.mobile,
        ref: i
      }), {
        default: o.default
      }) : $(H3e, Q(Q({}, c), {}, {
        ref: i
      }), {
        default: o.default
      });
      return $("div", {
        ref: s
      }, [$(aj, c, null), u]);
    };
  }
});
function W3e(e, t, n) {
  return n ? e[0] === t[0] : e[0] === t[0] && e[1] === t[1];
}
function y8(e, t, n) {
  const o = e[t] || {};
  return _(_({}, o), n);
}
function K3e(e, t, n, o) {
  const {
    points: l
  } = n, r = Object.keys(e);
  for (let a = 0; a < r.length; a += 1) {
    const i = r[a];
    if (W3e(e[i].points, l, o))
      return `${t}-placement-${i}`;
  }
  return "";
}
const dd = {
  methods: {
    setState() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0, n = typeof e == "function" ? e(this.$data, this.$props) : e;
      if (this.getDerivedStateFromProps) {
        const o = this.getDerivedStateFromProps(qz(this), _(_({}, this.$data), n));
        if (o === null)
          return;
        n = _(_({}, n), o || {});
      }
      _(this.$data, n), this._.isMounted && this.$forceUpdate(), Ke(() => {
        t && t();
      });
    },
    __emit() {
      const e = [].slice.call(arguments, 0);
      let t = e[0];
      t = `on${t[0].toUpperCase()}${t.substring(1)}`;
      const n = this.$props[t] || this.$attrs[t];
      if (e.length && n)
        if (Array.isArray(n))
          for (let o = 0, l = n.length; o < l; o++)
            n[o](...e.slice(1));
        else
          n(...e.slice(1));
    }
  }
}, hj = Symbol("PortalContextKey"), EI = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inTriggerContext: !0
  };
  at(hj, {
    inTriggerContext: t.inTriggerContext,
    shouldRender: O(() => {
      const {
        sPopupVisible: n,
        popupRef: o,
        forceRender: l,
        autoDestroy: r
      } = e || {};
      let a = !1;
      return (n || o || l) && (a = !0), !n && r && (a = !1), a;
    })
  });
}, U3e = () => {
  EI({}, {
    inTriggerContext: !1
  });
  const e = ze(hj, {
    shouldRender: O(() => !1),
    inTriggerContext: !1
  });
  return {
    shouldRender: O(() => e.shouldRender.value || e.inTriggerContext === !1)
  };
}, gj = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Portal",
  inheritAttrs: !1,
  props: {
    getContainer: de.func.isRequired,
    didUpdate: Function
  },
  setup(e, t) {
    let {
      slots: n
    } = t, o = !0, l;
    const {
      shouldRender: r
    } = U3e();
    function a() {
      r.value && (l = e.getContainer());
    }
    _c(() => {
      o = !1, a();
    }), nt(() => {
      l || a();
    });
    const i = pe(r, () => {
      r.value && !l && (l = e.getContainer()), l && i();
    });
    return $o(() => {
      Ke(() => {
        var s;
        r.value && ((s = e.didUpdate) === null || s === void 0 || s.call(e, e));
      });
    }), () => {
      var s;
      return r.value ? o ? (s = n.default) === null || s === void 0 ? void 0 : s.call(n) : l ? $(a1, {
        to: l
      }, n) : null : null;
    };
  }
});
let Cw;
function sy(e) {
  if (typeof document == "undefined")
    return 0;
  if (Cw === void 0) {
    const t = document.createElement("div");
    t.style.width = "100%", t.style.height = "200px";
    const n = document.createElement("div"), o = n.style;
    o.position = "absolute", o.top = "0", o.left = "0", o.pointerEvents = "none", o.visibility = "hidden", o.width = "200px", o.height = "150px", o.overflow = "hidden", n.appendChild(t), document.body.appendChild(n);
    const l = t.offsetWidth;
    n.style.overflow = "scroll";
    let r = t.offsetWidth;
    l === r && (r = n.clientWidth), document.body.removeChild(n), Cw = l - r;
  }
  return Cw;
}
function S8(e) {
  const t = e.match(/^(.*)px$/), n = Number(t == null ? void 0 : t[1]);
  return Number.isNaN(n) ? sy() : n;
}
function G3e(e) {
  if (typeof document == "undefined" || !e || !(e instanceof Element))
    return {
      width: 0,
      height: 0
    };
  const {
    width: t,
    height: n
  } = getComputedStyle(e, "::-webkit-scrollbar");
  return {
    width: S8(t),
    height: S8(n)
  };
}
const Y3e = `vc-util-locker-${Date.now()}`;
let C8 = 0;
function X3e() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
function q3e(e) {
  const t = O(() => !!e && !!e.value);
  C8 += 1;
  const n = `${Y3e}_${C8}`;
  Ot((o) => {
    if (Fl()) {
      if (t.value) {
        const l = sy(), r = X3e();
        Tm(`
html body {
  overflow-y: hidden;
  ${r ? `width: calc(100% - ${l}px);` : ""}
}`, n);
      } else
        oy(n);
      o(() => {
        oy(n);
      });
    }
  }, {
    flush: "post"
  });
}
let Uc = 0;
const Tb = Fl(), w8 = (e) => {
  if (!Tb)
    return null;
  if (e) {
    if (typeof e == "string")
      return document.querySelectorAll(e)[0];
    if (typeof e == "function")
      return e();
    if (typeof e == "object" && e instanceof window.HTMLElement)
      return e;
  }
  return document.body;
}, Eh = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "PortalWrapper",
  inheritAttrs: !1,
  props: {
    wrapperClassName: String,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getContainer: de.any,
    visible: {
      type: Boolean,
      default: void 0
    },
    autoLock: Qe(),
    didUpdate: Function
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = /* @__PURE__ */ Ce(), l = /* @__PURE__ */ Ce(), r = /* @__PURE__ */ Ce(), a = /* @__PURE__ */ Ce(1), i = Fl() && document.createElement("div"), s = () => {
      var p, m;
      o.value === i && ((m = (p = o.value) === null || p === void 0 ? void 0 : p.parentNode) === null || m === void 0 || m.removeChild(o.value)), o.value = null;
    };
    let c = null;
    const u = function() {
      return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) || o.value && !o.value.parentNode ? (c = w8(e.getContainer), c ? (c.appendChild(o.value), !0) : !1) : !0;
    }, d = () => Tb ? (o.value || (o.value = i, u(!0)), f(), o.value) : null, f = () => {
      const {
        wrapperClassName: p
      } = e;
      o.value && p && p !== o.value.className && (o.value.className = p);
    };
    return $o(() => {
      f(), u();
    }), q3e(O(() => e.autoLock && e.visible && Fl() && (o.value === document.body || o.value === i))), nt(() => {
      let p = !1;
      pe([() => e.visible, () => e.getContainer], (m, v) => {
        let [h, g] = m, [y, b] = v;
        Tb && (c = w8(e.getContainer), c === document.body && (h && !y ? Uc += 1 : p && (Uc -= 1))), p && (typeof g == "function" && typeof b == "function" ? g.toString() !== b.toString() : g !== b) && s(), p = !0;
      }, {
        immediate: !0,
        flush: "post"
      }), Ke(() => {
        u() || (r.value = rn(() => {
          a.value += 1;
        }));
      });
    }), yt(() => {
      const {
        visible: p
      } = e;
      Tb && c === document.body && (Uc = p && Uc ? Uc - 1 : Uc), s(), rn.cancel(r.value);
    }), () => {
      const {
        forceRender: p,
        visible: m
      } = e;
      let v = null;
      const h = {
        getOpenCount: () => Uc,
        getContainer: d
      };
      return a.value && (p || m || l.value) && (v = $(gj, {
        getContainer: d,
        ref: l,
        didUpdate: e.didUpdate
      }, {
        default: () => {
          var g;
          return (g = n.default) === null || g === void 0 ? void 0 : g.call(n, h);
        }
      })), v;
    };
  }
}), J3e = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu"], fd = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Trigger",
  mixins: [dd],
  inheritAttrs: !1,
  props: rj(),
  setup(e) {
    const t = O(() => {
      const {
        popupPlacement: l,
        popupAlign: r,
        builtinPlacements: a
      } = e;
      return l && a ? y8(a, l, r) : r;
    }), n = /* @__PURE__ */ Ce(null), o = (l) => {
      n.value = l;
    };
    return {
      vcTriggerContext: ze("vcTriggerContext", {}),
      popupRef: n,
      setPopupRef: o,
      triggerRef: /* @__PURE__ */ Ce(null),
      align: t,
      focusTime: null,
      clickOutsideHandler: null,
      contextmenuOutsideHandler1: null,
      contextmenuOutsideHandler2: null,
      touchOutsideHandler: null,
      attachId: null,
      delayTimer: null,
      hasPopupMouseDown: !1,
      preClickTime: null,
      preTouchTime: null,
      mouseDownTimeout: null,
      childOriginEvents: {}
    };
  },
  data() {
    const e = this.$props;
    let t;
    return this.popupVisible !== void 0 ? t = !!e.popupVisible : t = !!e.defaultPopupVisible, J3e.forEach((n) => {
      this[`fire${n}`] = (o) => {
        this.fireEvents(n, o);
      };
    }), {
      prevPopupVisible: t,
      sPopupVisible: t,
      point: null
    };
  },
  watch: {
    popupVisible(e) {
      e !== void 0 && (this.prevPopupVisible = this.sPopupVisible, this.sPopupVisible = e);
    }
  },
  created() {
    at("vcTriggerContext", {
      onPopupMouseDown: this.onPopupMouseDown,
      onPopupMouseenter: this.onPopupMouseenter,
      onPopupMouseleave: this.onPopupMouseleave
    }), EI(this);
  },
  deactivated() {
    this.setPopupVisible(!1);
  },
  mounted() {
    this.$nextTick(() => {
      this.updatedCal();
    });
  },
  updated() {
    this.$nextTick(() => {
      this.updatedCal();
    });
  },
  beforeUnmount() {
    this.clearDelayTimer(), this.clearOutsideHandler(), clearTimeout(this.mouseDownTimeout), rn.cancel(this.attachId);
  },
  methods: {
    updatedCal() {
      const e = this.$props;
      if (this.$data.sPopupVisible) {
        let n;
        !this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow()) && (n = e.getDocument(this.getRootDomNode()), this.clickOutsideHandler = vo(n, "mousedown", this.onDocumentClick)), this.touchOutsideHandler || (n = n || e.getDocument(this.getRootDomNode()), this.touchOutsideHandler = vo(n, "touchstart", this.onDocumentClick, Ho ? {
          passive: !1
        } : !1)), !this.contextmenuOutsideHandler1 && this.isContextmenuToShow() && (n = n || e.getDocument(this.getRootDomNode()), this.contextmenuOutsideHandler1 = vo(n, "scroll", this.onContextmenuClose)), !this.contextmenuOutsideHandler2 && this.isContextmenuToShow() && (this.contextmenuOutsideHandler2 = vo(window, "blur", this.onContextmenuClose));
      } else
        this.clearOutsideHandler();
    },
    onMouseenter(e) {
      const {
        mouseEnterDelay: t
      } = this.$props;
      this.fireEvents("onMouseenter", e), this.delaySetPopupVisible(!0, t, t ? null : e);
    },
    onMouseMove(e) {
      this.fireEvents("onMousemove", e), this.setPoint(e);
    },
    onMouseleave(e) {
      this.fireEvents("onMouseleave", e), this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay);
    },
    onPopupMouseenter() {
      const {
        vcTriggerContext: e = {}
      } = this;
      e.onPopupMouseenter && e.onPopupMouseenter(), this.clearDelayTimer();
    },
    onPopupMouseleave(e) {
      var t;
      if (e && e.relatedTarget && !e.relatedTarget.setTimeout && Xs((t = this.popupRef) === null || t === void 0 ? void 0 : t.getElement(), e.relatedTarget))
        return;
      this.isMouseLeaveToHide() && this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay);
      const {
        vcTriggerContext: n = {}
      } = this;
      n.onPopupMouseleave && n.onPopupMouseleave(e);
    },
    onFocus(e) {
      this.fireEvents("onFocus", e), this.clearDelayTimer(), this.isFocusToShow() && (this.focusTime = Date.now(), this.delaySetPopupVisible(!0, this.$props.focusDelay));
    },
    onMousedown(e) {
      this.fireEvents("onMousedown", e), this.preClickTime = Date.now();
    },
    onTouchstart(e) {
      this.fireEvents("onTouchstart", e), this.preTouchTime = Date.now();
    },
    onBlur(e) {
      Xs(e.target, e.relatedTarget || document.activeElement) || (this.fireEvents("onBlur", e), this.clearDelayTimer(), this.isBlurToHide() && this.delaySetPopupVisible(!1, this.$props.blurDelay));
    },
    onContextmenu(e) {
      e.preventDefault(), this.fireEvents("onContextmenu", e), this.setPopupVisible(!0, e);
    },
    onContextmenuClose() {
      this.isContextmenuToShow() && this.close();
    },
    onClick(e) {
      if (this.fireEvents("onClick", e), this.focusTime) {
        let n;
        if (this.preClickTime && this.preTouchTime ? n = Math.min(this.preClickTime, this.preTouchTime) : this.preClickTime ? n = this.preClickTime : this.preTouchTime && (n = this.preTouchTime), Math.abs(n - this.focusTime) < 20)
          return;
        this.focusTime = 0;
      }
      this.preClickTime = 0, this.preTouchTime = 0, this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && e && e.preventDefault && e.preventDefault(), e && e.domEvent && e.domEvent.preventDefault();
      const t = !this.$data.sPopupVisible;
      (this.isClickToHide() && !t || t && this.isClickToShow()) && this.setPopupVisible(!this.$data.sPopupVisible, e);
    },
    onPopupMouseDown() {
      const {
        vcTriggerContext: e = {}
      } = this;
      this.hasPopupMouseDown = !0, clearTimeout(this.mouseDownTimeout), this.mouseDownTimeout = setTimeout(() => {
        this.hasPopupMouseDown = !1;
      }, 0), e.onPopupMouseDown && e.onPopupMouseDown(...arguments);
    },
    onDocumentClick(e) {
      if (this.$props.mask && !this.$props.maskClosable)
        return;
      const t = e.target, n = this.getRootDomNode(), o = this.getPopupDomNode();
      // mousedown on the target should also close popup when action is contextMenu.
      // https://github.com/ant-design/ant-design/issues/29853
      (!Xs(n, t) || this.isContextMenuOnly()) && !Xs(o, t) && !this.hasPopupMouseDown && this.delaySetPopupVisible(!1, 0.1);
    },
    getPopupDomNode() {
      var e;
      return ((e = this.popupRef) === null || e === void 0 ? void 0 : e.getElement()) || null;
    },
    getRootDomNode() {
      var e, t, n, o;
      const {
        getTriggerDOMNode: l
      } = this.$props;
      if (l) {
        const r = ((t = (e = this.triggerRef) === null || e === void 0 ? void 0 : e.$el) === null || t === void 0 ? void 0 : t.nodeName) === "#comment" ? null : nr(this.triggerRef);
        return nr(l(r));
      }
      try {
        const r = ((o = (n = this.triggerRef) === null || n === void 0 ? void 0 : n.$el) === null || o === void 0 ? void 0 : o.nodeName) === "#comment" ? null : nr(this.triggerRef);
        if (r)
          return r;
      } catch (r) {
      }
      return nr(this);
    },
    handleGetPopupClassFromAlign(e) {
      const t = [], n = this.$props, {
        popupPlacement: o,
        builtinPlacements: l,
        prefixCls: r,
        alignPoint: a,
        getPopupClassNameFromAlign: i
      } = n;
      return o && l && t.push(K3e(l, r, e, a)), i && t.push(i(e)), t.join(" ");
    },
    getPopupAlign() {
      const e = this.$props, {
        popupPlacement: t,
        popupAlign: n,
        builtinPlacements: o
      } = e;
      return t && o ? y8(o, t, n) : n;
    },
    getComponent() {
      const e = {};
      this.isMouseEnterToShow() && (e.onMouseenter = this.onPopupMouseenter), this.isMouseLeaveToHide() && (e.onMouseleave = this.onPopupMouseleave), e.onMousedown = this.onPopupMouseDown, e[Ho ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
      const {
        handleGetPopupClassFromAlign: t,
        getRootDomNode: n,
        $attrs: o
      } = this, {
        prefixCls: l,
        destroyPopupOnHide: r,
        popupClassName: a,
        popupAnimation: i,
        popupTransitionName: s,
        popupStyle: c,
        mask: u,
        maskAnimation: d,
        maskTransitionName: f,
        zIndex: p,
        stretch: m,
        alignPoint: v,
        mobile: h,
        arrow: g,
        forceRender: y
      } = this.$props, {
        sPopupVisible: b,
        point: C
      } = this.$data, w = _(_({
        prefixCls: l,
        arrow: g,
        destroyPopupOnHide: r,
        visible: b,
        point: v ? C : null,
        align: this.align,
        animation: i,
        getClassNameFromAlign: t,
        stretch: m,
        getRootDomNode: n,
        mask: u,
        zIndex: p,
        transitionName: s,
        maskAnimation: d,
        maskTransitionName: f,
        class: a,
        style: c,
        onAlign: o.onPopupAlign || lj
      }, e), {
        ref: this.setPopupRef,
        mobile: h,
        forceRender: y
      });
      return $(j3e, w, {
        default: this.$slots.popup || (() => Jz(this, "popup"))
      });
    },
    attachParent(e) {
      rn.cancel(this.attachId);
      const {
        getPopupContainer: t,
        getDocument: n
      } = this.$props, o = this.getRootDomNode();
      let l;
      t ? (o || t.length === 0) && (l = t(o)) : l = n(this.getRootDomNode()).body, l ? l.appendChild(e) : this.attachId = rn(() => {
        this.attachParent(e);
      });
    },
    getContainer() {
      const {
        $props: e
      } = this, {
        getDocument: t
      } = e, n = t(this.getRootDomNode()).createElement("div");
      return n.style.position = "absolute", n.style.top = "0", n.style.left = "0", n.style.width = "100%", this.attachParent(n), n;
    },
    setPopupVisible(e, t) {
      const {
        alignPoint: n,
        sPopupVisible: o,
        onPopupVisibleChange: l
      } = this;
      this.clearDelayTimer(), o !== e && (os(this, "popupVisible") || this.setState({
        sPopupVisible: e,
        prevPopupVisible: o
      }), l && l(e)), n && t && e && this.setPoint(t);
    },
    setPoint(e) {
      const {
        alignPoint: t
      } = this.$props;
      !t || !e || this.setState({
        point: {
          pageX: e.pageX,
          pageY: e.pageY
        }
      });
    },
    handlePortalUpdate() {
      this.prevPopupVisible !== this.sPopupVisible && this.afterPopupVisibleChange(this.sPopupVisible);
    },
    delaySetPopupVisible(e, t, n) {
      const o = t * 1e3;
      if (this.clearDelayTimer(), o) {
        const l = n ? {
          pageX: n.pageX,
          pageY: n.pageY
        } : null;
        this.delayTimer = setTimeout(() => {
          this.setPopupVisible(e, l), this.clearDelayTimer();
        }, o);
      } else
        this.setPopupVisible(e, n);
    },
    clearDelayTimer() {
      this.delayTimer && (clearTimeout(this.delayTimer), this.delayTimer = null);
    },
    clearOutsideHandler() {
      this.clickOutsideHandler && (this.clickOutsideHandler.remove(), this.clickOutsideHandler = null), this.contextmenuOutsideHandler1 && (this.contextmenuOutsideHandler1.remove(), this.contextmenuOutsideHandler1 = null), this.contextmenuOutsideHandler2 && (this.contextmenuOutsideHandler2.remove(), this.contextmenuOutsideHandler2 = null), this.touchOutsideHandler && (this.touchOutsideHandler.remove(), this.touchOutsideHandler = null);
    },
    createTwoChains(e) {
      let t = () => {
      };
      const n = EM(this);
      return this.childOriginEvents[e] && n[e] ? this[`fire${e}`] : (t = this.childOriginEvents[e] || n[e] || t, t);
    },
    isClickToShow() {
      const {
        action: e,
        showAction: t
      } = this.$props;
      return e.indexOf("click") !== -1 || t.indexOf("click") !== -1;
    },
    isContextMenuOnly() {
      const {
        action: e
      } = this.$props;
      return e === "contextmenu" || e.length === 1 && e[0] === "contextmenu";
    },
    isContextmenuToShow() {
      const {
        action: e,
        showAction: t
      } = this.$props;
      return e.indexOf("contextmenu") !== -1 || t.indexOf("contextmenu") !== -1;
    },
    isClickToHide() {
      const {
        action: e,
        hideAction: t
      } = this.$props;
      return e.indexOf("click") !== -1 || t.indexOf("click") !== -1;
    },
    isMouseEnterToShow() {
      const {
        action: e,
        showAction: t
      } = this.$props;
      return e.indexOf("hover") !== -1 || t.indexOf("mouseenter") !== -1;
    },
    isMouseLeaveToHide() {
      const {
        action: e,
        hideAction: t
      } = this.$props;
      return e.indexOf("hover") !== -1 || t.indexOf("mouseleave") !== -1;
    },
    isFocusToShow() {
      const {
        action: e,
        showAction: t
      } = this.$props;
      return e.indexOf("focus") !== -1 || t.indexOf("focus") !== -1;
    },
    isBlurToHide() {
      const {
        action: e,
        hideAction: t
      } = this.$props;
      return e.indexOf("focus") !== -1 || t.indexOf("blur") !== -1;
    },
    forcePopupAlign() {
      var e;
      this.$data.sPopupVisible && ((e = this.popupRef) === null || e === void 0 || e.forceAlign());
    },
    fireEvents(e, t) {
      this.childOriginEvents[e] && this.childOriginEvents[e](t);
      const n = this.$props[e] || this.$attrs[e];
      n && n(t);
    },
    close() {
      this.setPopupVisible(!1);
    }
  },
  render() {
    const {
      $attrs: e
    } = this, t = mo(nS(this)), {
      alignPoint: n,
      getPopupContainer: o
    } = this.$props, l = t[0];
    this.childOriginEvents = EM(l);
    const r = {
      key: "trigger"
    };
    this.isContextmenuToShow() ? r.onContextmenu = this.onContextmenu : r.onContextmenu = this.createTwoChains("onContextmenu"), this.isClickToHide() || this.isClickToShow() ? (r.onClick = this.onClick, r.onMousedown = this.onMousedown, r[Ho ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart) : (r.onClick = this.createTwoChains("onClick"), r.onMousedown = this.createTwoChains("onMousedown"), r[Ho ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart")), this.isMouseEnterToShow() ? (r.onMouseenter = this.onMouseenter, n && (r.onMousemove = this.onMouseMove)) : r.onMouseenter = this.createTwoChains("onMouseenter"), this.isMouseLeaveToHide() ? r.onMouseleave = this.onMouseleave : r.onMouseleave = this.createTwoChains("onMouseleave"), this.isFocusToShow() || this.isBlurToHide() ? (r.onFocus = this.onFocus, r.onBlur = this.onBlur) : (r.onFocus = this.createTwoChains("onFocus"), r.onBlur = (c) => {
      c && (!c.relatedTarget || !Xs(c.target, c.relatedTarget)) && this.createTwoChains("onBlur")(c);
    });
    const a = ke(l && l.props && l.props.class, e.class);
    a && (r.class = a);
    const i = _n(l, _(_({}, r), {
      ref: "triggerRef"
    }), !0, !0), s = $(Eh, {
      key: "portal",
      getContainer: o && (() => o(this.getRootDomNode())),
      didUpdate: this.handlePortalUpdate,
      visible: this.$data.sPopupVisible
    }, {
      default: this.getComponent
    });
    return $(Ge, null, [i, s]);
  }
});
var Z3e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const Q3e = (e) => {
  const t = e === !0 ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    }
  };
}, eNe = /* @__PURE__ */ le({
  name: "SelectTrigger",
  inheritAttrs: !1,
  props: {
    dropdownAlign: Object,
    visible: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownStyle: de.object,
    placement: String,
    empty: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    popupClassName: String,
    animation: String,
    transitionName: String,
    getPopupContainer: Function,
    dropdownRender: Function,
    containerWidth: Number,
    dropdownMatchSelectWidth: de.oneOfType([Number, Boolean]).def(!0),
    popupElement: de.any,
    direction: String,
    getTriggerDOMNode: Function,
    onPopupVisibleChange: Function,
    onPopupMouseEnter: Function,
    onPopupFocusin: Function,
    onPopupFocusout: Function
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: l
    } = t;
    const r = O(() => {
      const {
        dropdownMatchSelectWidth: i
      } = e;
      return Q3e(i);
    }), a = /* @__PURE__ */ H();
    return l({
      getPopupElement: () => a.value
    }), () => {
      const i = _(_({}, e), o), {
        empty: s = !1
      } = i, c = Z3e(i, ["empty"]), {
        visible: u,
        dropdownAlign: d,
        prefixCls: f,
        popupElement: p,
        dropdownClassName: m,
        dropdownStyle: v,
        direction: h = "ltr",
        placement: g,
        dropdownMatchSelectWidth: y,
        containerWidth: b,
        dropdownRender: C,
        animation: w,
        transitionName: x,
        getPopupContainer: E,
        getTriggerDOMNode: I,
        onPopupVisibleChange: T,
        onPopupMouseEnter: P,
        onPopupFocusin: k,
        onPopupFocusout: N
      } = c, R = `${f}-dropdown`;
      let z = p;
      C && (z = C({
        menuNode: p,
        props: e
      }));
      const D = w ? `${R}-${w}` : x, F = _({
        minWidth: `${b}px`
      }, v);
      return typeof y == "number" ? F.width = `${y}px` : y && (F.width = `${b}px`), $(fd, Q(Q({}, e), {}, {
        showAction: T ? ["click"] : [],
        hideAction: T ? ["click"] : [],
        popupPlacement: g || (h === "rtl" ? "bottomRight" : "bottomLeft"),
        builtinPlacements: r.value,
        prefixCls: R,
        popupTransitionName: D,
        popupAlign: d,
        popupVisible: u,
        getPopupContainer: E,
        popupClassName: ke(m, {
          [`${R}-empty`]: s
        }),
        popupStyle: F,
        getTriggerDOMNode: I,
        onPopupVisibleChange: T
      }), {
        default: n.default,
        popup: () => $("div", {
          ref: a,
          onMouseenter: P,
          onFocusin: k,
          onFocusout: N
        }, [z])
      });
    };
  }
}), ot = {
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  /**
   * END
   */
  END: 35,
  /**
   * HOME
   */
  HOME: 36,
  /**
   * LEFT
   */
  LEFT: 37,
  /**
   * UP
   */
  UP: 38,
  /**
   * RIGHT
   */
  RIGHT: 39,
  /**
   * DOWN
   */
  DOWN: 40,
  /**
   * N
   */
  N: 78,
  /**
   * P
   */
  P: 80,
  /**
   * META
   */
  META: 91,
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  /**
   * EQUALS
   */
  EQUALS: 187,
  /**
   * WIN_KEY
   */
  WIN_KEY: 224
}, Ju = (e, t) => {
  let {
    slots: n
  } = t;
  var o;
  const {
    class: l,
    customizeIcon: r,
    customizeIconProps: a,
    onMousedown: i,
    onClick: s
  } = e;
  let c;
  return typeof r == "function" ? c = r(a) : c = dn(r) ? No(r) : r, $("span", {
    class: l,
    onMousedown: (u) => {
      u.preventDefault(), i && i(u);
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    unselectable: "on",
    onClick: s,
    "aria-hidden": !0
  }, [c !== void 0 ? c : $("span", {
    class: l.split(/\s+/).map((u) => `${u}-icon`)
  }, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)])]);
};
Ju.inheritAttrs = !1;
Ju.displayName = "TransBtn";
Ju.props = {
  class: String,
  customizeIcon: de.any,
  customizeIconProps: de.any,
  onMousedown: Function,
  onClick: Function
};
var tNe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const nNe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  // inheritAttrs: false,
  props: {
    disabled: de.looseBool,
    type: de.string,
    value: de.any,
    tag: {
      type: String,
      default: "input"
    },
    size: de.string,
    onChange: Function,
    onInput: Function,
    onBlur: Function,
    onFocus: Function,
    onKeydown: Function,
    onCompositionstart: Function,
    onCompositionend: Function,
    onKeyup: Function,
    onPaste: Function,
    onMousedown: Function
  },
  emits: ["change", "input", "blur", "keydown", "focus", "compositionstart", "compositionend", "keyup", "paste", "mousedown"],
  setup(e, t) {
    let {
      expose: n
    } = t;
    const o = /* @__PURE__ */ Ce(null);
    return n({
      focus: () => {
        o.value && o.value.focus();
      },
      blur: () => {
        o.value && o.value.blur();
      },
      input: o,
      setSelectionRange: (s, c, u) => {
        var d;
        (d = o.value) === null || d === void 0 || d.setSelectionRange(s, c, u);
      },
      select: () => {
        var s;
        (s = o.value) === null || s === void 0 || s.select();
      },
      getSelectionStart: () => {
        var s;
        return (s = o.value) === null || s === void 0 ? void 0 : s.selectionStart;
      },
      getSelectionEnd: () => {
        var s;
        return (s = o.value) === null || s === void 0 ? void 0 : s.selectionEnd;
      },
      getScrollTop: () => {
        var s;
        return (s = o.value) === null || s === void 0 ? void 0 : s.scrollTop;
      }
    }), () => {
      const {
        tag: s,
        value: c
      } = e, u = tNe(e, ["tag", "value"]);
      return $(s, Q(Q({}, u), {}, {
        ref: o,
        value: c
      }), null);
    };
  }
});
function oNe() {
  const e = document.documentElement.clientWidth, t = window.innerHeight || document.documentElement.clientHeight;
  return {
    width: e,
    height: t
  };
}
function cy(e) {
  const t = e.getBoundingClientRect(), n = document.documentElement;
  return {
    left: t.left + (window.scrollX || n.scrollLeft) - (n.clientLeft || document.body.clientLeft || 0),
    top: t.top + (window.scrollY || n.scrollTop) - (n.clientTop || document.body.clientTop || 0)
  };
}
function lNe(e) {
  return Array.prototype.slice.apply(e).map((n) => `${n}: ${e.getPropertyValue(n)};`).join("");
}
function rNe(e) {
  return Object.keys(e).reduce((t, n) => {
    const o = e[n];
    return typeof o == "undefined" || o === null || (t += `${n}: ${e[n]};`), t;
  }, "");
}
var aNe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const kp = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: {
    disabled: de.looseBool,
    type: de.string,
    value: de.any,
    lazy: de.bool.def(!0),
    tag: {
      type: String,
      default: "input"
    },
    size: de.string,
    style: de.oneOfType([String, Object]),
    class: de.string
  },
  emits: ["change", "input", "blur", "keydown", "focus", "compositionstart", "compositionend", "keyup", "paste", "mousedown"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      expose: l
    } = t;
    const r = /* @__PURE__ */ Ce(null), a = /* @__PURE__ */ H(), i = /* @__PURE__ */ H(!1);
    pe([() => e.value, i], () => {
      i.value || (a.value = e.value);
    }, {
      immediate: !0
    });
    const s = (E) => {
      n("change", E);
    }, c = (E) => {
      i.value = !0, E.target.composing = !0, n("compositionstart", E);
    }, u = (E) => {
      i.value = !1, E.target.composing = !1, n("compositionend", E);
      const I = document.createEvent("HTMLEvents");
      I.initEvent("input", !0, !0), E.target.dispatchEvent(I), s(E);
    }, d = (E) => {
      if (i.value && e.lazy) {
        a.value = E.target.value;
        return;
      }
      n("input", E);
    }, f = (E) => {
      n("blur", E);
    }, p = (E) => {
      n("focus", E);
    }, m = () => {
      r.value && r.value.focus();
    }, v = () => {
      r.value && r.value.blur();
    }, h = (E) => {
      n("keydown", E);
    }, g = (E) => {
      n("keyup", E);
    }, y = (E, I, T) => {
      var P;
      (P = r.value) === null || P === void 0 || P.setSelectionRange(E, I, T);
    }, b = () => {
      var E;
      (E = r.value) === null || E === void 0 || E.select();
    };
    l({
      focus: m,
      blur: v,
      input: O(() => {
        var E;
        return (E = r.value) === null || E === void 0 ? void 0 : E.input;
      }),
      setSelectionRange: y,
      select: b,
      getSelectionStart: () => {
        var E;
        return (E = r.value) === null || E === void 0 ? void 0 : E.getSelectionStart();
      },
      getSelectionEnd: () => {
        var E;
        return (E = r.value) === null || E === void 0 ? void 0 : E.getSelectionEnd();
      },
      getScrollTop: () => {
        var E;
        return (E = r.value) === null || E === void 0 ? void 0 : E.getScrollTop();
      }
    });
    const C = (E) => {
      n("mousedown", E);
    }, w = (E) => {
      n("paste", E);
    }, x = O(() => e.style && typeof e.style != "string" ? rNe(e.style) : e.style);
    return () => {
      const {
        style: E,
        lazy: I
      } = e, T = aNe(e, ["style", "lazy"]);
      return $(nNe, Q(Q(Q({}, T), o), {}, {
        style: x.value,
        onInput: d,
        onChange: s,
        onBlur: f,
        onFocus: p,
        ref: r,
        value: a.value,
        onCompositionstart: c,
        onCompositionend: u,
        onKeyup: g,
        onKeydown: h,
        onPaste: w,
        onMousedown: C
      }), null);
    };
  }
}), iNe = {
  inputRef: de.any,
  prefixCls: String,
  id: String,
  inputElement: de.VueNode,
  disabled: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  editable: {
    type: Boolean,
    default: void 0
  },
  activeDescendantId: String,
  value: String,
  open: {
    type: Boolean,
    default: void 0
  },
  tabindex: de.oneOfType([de.number, de.string]),
  /** Pass accessibility props to input */
  attrs: de.object,
  onKeydown: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onChange: {
    type: Function
  },
  onPaste: {
    type: Function
  },
  onCompositionstart: {
    type: Function
  },
  onCompositionend: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  }
}, bj = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "SelectInput",
  inheritAttrs: !1,
  props: iNe,
  setup(e) {
    let t = null;
    const n = ze("VCSelectContainerEvent");
    return () => {
      var o;
      const {
        prefixCls: l,
        id: r,
        inputElement: a,
        disabled: i,
        tabindex: s,
        autofocus: c,
        autocomplete: u,
        editable: d,
        activeDescendantId: f,
        value: p,
        onKeydown: m,
        onMousedown: v,
        onChange: h,
        onPaste: g,
        onCompositionstart: y,
        onCompositionend: b,
        onFocus: C,
        onBlur: w,
        open: x,
        inputRef: E,
        attrs: I
      } = e;
      let T = a || $(kp, null, null);
      const P = T.props || {}, {
        onKeydown: k,
        onInput: N,
        onFocus: R,
        onBlur: z,
        onMousedown: D,
        onCompositionstart: F,
        onCompositionend: M,
        style: A
      } = P;
      return T = _n(T, _(_(_(_(_({
        type: "search"
      }, P), {
        id: r,
        ref: E,
        disabled: i,
        tabindex: s,
        lazy: !1,
        autocomplete: u || "off",
        autofocus: c,
        class: ke(`${l}-selection-search-input`, (o = T == null ? void 0 : T.props) === null || o === void 0 ? void 0 : o.class),
        role: "combobox",
        "aria-expanded": x,
        "aria-haspopup": "listbox",
        "aria-owns": `${r}_list`,
        "aria-autocomplete": "list",
        "aria-controls": `${r}_list`,
        "aria-activedescendant": f
      }), I), {
        value: d ? p : "",
        readonly: !d,
        unselectable: d ? null : "on",
        style: _(_({}, A), {
          opacity: d ? null : 0
        }),
        onKeydown: (L) => {
          m(L), k && k(L);
        },
        onMousedown: (L) => {
          v(L), D && D(L);
        },
        onInput: (L) => {
          h(L), N && N(L);
        },
        onCompositionstart(L) {
          y(L), F && F(L);
        },
        onCompositionend(L) {
          b(L), M && M(L);
        },
        onPaste: g,
        onFocus: function() {
          clearTimeout(t), R && R(arguments.length <= 0 ? void 0 : arguments[0]), C && C(arguments.length <= 0 ? void 0 : arguments[0]), n == null || n.focus(arguments.length <= 0 ? void 0 : arguments[0]);
        },
        onBlur: function() {
          for (var L = arguments.length, B = new Array(L), V = 0; V < L; V++)
            B[V] = arguments[V];
          t = setTimeout(() => {
            z && z(B[0]), w && w(B[0]), n == null || n.blur(B[0]);
          }, 100);
        }
      }), T.type === "textarea" ? {} : {
        type: "search"
      }), !0, !0), T;
    };
  }
}), sNe = `accept acceptcharset accesskey action allowfullscreen allowtransparency
alt async autocomplete autofocus autoplay capture cellpadding cellspacing challenge
charset checked classid classname colspan cols content contenteditable contextmenu
controls coords crossorigin data datetime default defer dir disabled download draggable
enctype form formaction formenctype formmethod formnovalidate formtarget frameborder
headers height hidden high href hreflang htmlfor for httpequiv icon id inputmode integrity
is keyparams keytype kind label lang list loop low manifest marginheight marginwidth max maxlength media
mediagroup method min minlength multiple muted name novalidate nonce open
optimum pattern placeholder poster preload radiogroup readonly rel required
reversed role rowspan rows sandbox scope scoped scrolling seamless selected
shape size sizes span spellcheck src srcdoc srclang srcset start step style
summary tabindex target title type usemap value width wmode wrap`, cNe = `onCopy onCut onPaste onCompositionend onCompositionstart onCompositionupdate onKeydown
    onKeypress onKeyup onFocus onBlur onChange onInput onSubmit onClick onContextmenu onDoubleclick onDblclick
    onDrag onDragend onDragenter onDragexit onDragleave onDragover onDragstart onDrop onMousedown
    onMouseenter onMouseleave onMousemove onMouseout onMouseover onMouseup onSelect onTouchcancel
    onTouchend onTouchmove onTouchstart onTouchstartPassive onTouchmovePassive onScroll onWheel onAbort onCanplay onCanplaythrough
    onDurationchange onEmptied onEncrypted onEnded onError onLoadeddata onLoadedmetadata
    onLoadstart onPause onPlay onPlaying onProgress onRatechange onSeeked onSeeking onStalled onSuspend onTimeupdate onVolumechange onWaiting onLoad onError`, $8 = `${sNe} ${cNe}`.split(/[\s\n]+/), uNe = "aria-", dNe = "data-";
function x8(e, t) {
  return e.indexOf(t) === 0;
}
function Mc(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n;
  t === !1 ? n = {
    aria: !0,
    data: !0,
    attr: !0
  } : t === !0 ? n = {
    aria: !0
  } : n = _({}, t);
  const o = {};
  return Object.keys(e).forEach((l) => {
    // Aria
    (n.aria && (l === "role" || x8(l, uNe)) || // Data
    n.data && x8(l, dNe) || // Attr
    n.attr && ($8.includes(l) || $8.includes(l.toLowerCase()))) && (o[l] = e[l]);
  }), o;
}
const yj = Symbol("OverflowContextProviderKey"), x2 = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "OverflowContextProvider",
  inheritAttrs: !1,
  props: {
    value: {
      type: Object
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return at(yj, O(() => e.value)), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), fNe = () => ze(yj, O(() => null));
var pNe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const kd = void 0, Pb = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Item",
  props: {
    prefixCls: String,
    item: de.any,
    renderItem: Function,
    responsive: Boolean,
    itemKey: {
      type: [String, Number]
    },
    registerSize: Function,
    display: Boolean,
    order: Number,
    component: de.any,
    invalidate: Boolean
  },
  setup(e, t) {
    let {
      slots: n,
      expose: o
    } = t;
    const l = O(() => e.responsive && !e.display), r = /* @__PURE__ */ H();
    o({
      itemNodeRef: r
    });
    function a(i) {
      e.registerSize(e.itemKey, i);
    }
    return Uo(() => {
      a(null);
    }), () => {
      var i;
      const {
        prefixCls: s,
        invalidate: c,
        item: u,
        renderItem: d,
        responsive: f,
        registerSize: p,
        itemKey: m,
        display: v,
        order: h,
        component: g = "div"
      } = e, y = pNe(e, ["prefixCls", "invalidate", "item", "renderItem", "responsive", "registerSize", "itemKey", "display", "order", "component"]), b = (i = n.default) === null || i === void 0 ? void 0 : i.call(n), C = d && u !== kd ? d(u) : b;
      let w;
      c || (w = {
        opacity: l.value ? 0 : 1,
        height: l.value ? 0 : kd,
        overflowY: l.value ? "hidden" : kd,
        order: f ? h : kd,
        pointerEvents: l.value ? "none" : kd,
        position: l.value ? "absolute" : kd
      });
      const x = {};
      return l.value && (x["aria-hidden"] = !0), $(ca, {
        disabled: !f,
        onResize: (E) => {
          let {
            offsetWidth: I
          } = E;
          a(I);
        }
      }, {
        default: () => $(g, Q(Q(Q({
          class: ke(!c && s),
          style: w
        }, x), y), {}, {
          ref: r
        }), {
          default: () => [C]
        })
      });
    };
  }
});
var ww = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const vNe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "RawItem",
  inheritAttrs: !1,
  props: {
    component: de.any,
    title: de.any,
    id: String,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    role: String,
    tabindex: Number
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const l = fNe();
    return () => {
      var r;
      if (!l.value) {
        const {
          component: d = "div"
        } = e, f = ww(e, ["component"]);
        return $(d, Q(Q({}, f), o), {
          default: () => [(r = n.default) === null || r === void 0 ? void 0 : r.call(n)]
        });
      }
      const a = l.value, {
        className: i
      } = a, s = ww(a, ["className"]), {
        class: c
      } = o, u = ww(o, ["class"]);
      return $(x2, {
        value: null
      }, {
        default: () => [$(Pb, Q(Q(Q({
          class: ke(i, c)
        }, s), u), e), n)]
      });
    };
  }
});
var mNe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const Sj = "responsive", Cj = "invalidate";
function hNe(e) {
  return `+ ${e.length} ...`;
}
const gNe = () => ({
  id: String,
  prefixCls: String,
  data: Array,
  itemKey: [String, Number, Function],
  /** Used for `responsive`. It will limit render node to avoid perf issue */
  itemWidth: {
    type: Number,
    default: 10
  },
  renderItem: Function,
  /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
  renderRawItem: Function,
  maxCount: [Number, String],
  renderRest: Function,
  /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
  renderRawRest: Function,
  suffix: de.any,
  component: String,
  itemComponent: de.any,
  /** @private This API may be refactor since not well design */
  onVisibleChange: Function,
  /** When set to `full`, ssr will render full items by default and remove at client side */
  ssr: String,
  onMousedown: Function,
  role: String
}), ps = /* @__PURE__ */ le({
  name: "Overflow",
  inheritAttrs: !1,
  props: gNe(),
  emits: ["visibleChange"],
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      slots: l
    } = t;
    const r = O(() => e.ssr === "full"), a = /* @__PURE__ */ Ce(null), i = O(() => a.value || 0), s = /* @__PURE__ */ Ce(/* @__PURE__ */ new Map()), c = /* @__PURE__ */ Ce(0), u = /* @__PURE__ */ Ce(0), d = /* @__PURE__ */ Ce(0), f = /* @__PURE__ */ Ce(null), p = /* @__PURE__ */ Ce(null), m = O(() => p.value === null && r.value ? Number.MAX_SAFE_INTEGER : p.value || 0), v = /* @__PURE__ */ Ce(!1), h = O(() => `${e.prefixCls}-item`), g = O(() => Math.max(c.value, u.value)), y = O(() => !!(e.data.length && e.maxCount === Sj)), b = O(() => e.maxCount === Cj), C = O(() => y.value || typeof e.maxCount == "number" && e.data.length > e.maxCount), w = O(() => {
      let D = e.data;
      return y.value ? a.value === null && r.value ? D = e.data : D = e.data.slice(0, Math.min(e.data.length, i.value / e.itemWidth)) : typeof e.maxCount == "number" && (D = e.data.slice(0, e.maxCount)), D;
    }), x = O(() => y.value ? e.data.slice(m.value + 1) : e.data.slice(w.value.length)), E = (D, F) => {
      var M;
      return typeof e.itemKey == "function" ? e.itemKey(D) : (M = e.itemKey && (D == null ? void 0 : D[e.itemKey])) !== null && M !== void 0 ? M : F;
    }, I = O(() => e.renderItem || ((D) => D)), T = (D, F) => {
      p.value = D, F || (v.value = D < e.data.length - 1, o("visibleChange", D));
    }, P = (D, F) => {
      a.value = F.clientWidth;
    }, k = (D, F) => {
      const M = new Map(s.value);
      F === null ? M.delete(D) : M.set(D, F), s.value = M;
    }, N = (D, F) => {
      c.value = u.value, u.value = F;
    }, R = (D, F) => {
      d.value = F;
    }, z = (D) => s.value.get(E(w.value[D], D));
    return pe([i, s, u, d, () => e.itemKey, w], () => {
      if (i.value && g.value && w.value) {
        let D = d.value;
        const F = w.value.length, M = F - 1;
        if (!F) {
          T(0), f.value = null;
          return;
        }
        for (let A = 0; A < F; A += 1) {
          const L = z(A);
          if (L === void 0) {
            T(A - 1, !0);
            break;
          }
          if (D += L, // Only one means `totalWidth` is the final width
          M === 0 && D <= i.value || // Last two width will be the final width
          A === M - 1 && D + z(M) <= i.value) {
            T(M), f.value = null;
            break;
          } else if (D + g.value > i.value) {
            T(A - 1), f.value = D - L - d.value + u.value;
            break;
          }
        }
        e.suffix && z(0) + d.value > i.value && (f.value = null);
      }
    }), () => {
      const D = v.value && !!x.value.length, {
        itemComponent: F,
        renderRawItem: M,
        renderRawRest: A,
        renderRest: L,
        prefixCls: B = "rc-overflow",
        suffix: V,
        component: j = "div",
        id: W,
        onMousedown: Y
      } = e, {
        class: U,
        style: te
      } = n, J = mNe(n, ["class", "style"]);
      let re = {};
      f.value !== null && y.value && (re = {
        position: "absolute",
        left: `${f.value}px`,
        top: 0
      });
      const oe = {
        prefixCls: h.value,
        responsive: y.value,
        component: F,
        invalidate: b.value
      }, q = M ? (ee, fe) => {
        const me = E(ee, fe);
        return $(x2, {
          key: me,
          value: _(_({}, oe), {
            order: fe,
            item: ee,
            itemKey: me,
            registerSize: k,
            display: fe <= m.value
          })
        }, {
          default: () => [M(ee, fe)]
        });
      } : (ee, fe) => {
        const me = E(ee, fe);
        return $(Pb, Q(Q({}, oe), {}, {
          order: fe,
          key: me,
          item: ee,
          renderItem: I.value,
          itemKey: me,
          registerSize: k,
          display: fe <= m.value
        }), null);
      };
      let K = () => null;
      const se = {
        order: D ? m.value : Number.MAX_SAFE_INTEGER,
        className: `${h.value} ${h.value}-rest`,
        registerSize: N,
        display: D
      };
      if (A)
        A && (K = () => $(x2, {
          value: _(_({}, oe), se)
        }, {
          default: () => [A(x.value)]
        }));
      else {
        const ee = L || hNe;
        K = () => $(Pb, Q(Q({}, oe), se), {
          default: () => typeof ee == "function" ? ee(x.value) : ee
        });
      }
      const Z = () => {
        var ee;
        return $(j, Q({
          id: W,
          class: ke(!b.value && B, U),
          style: te,
          onMousedown: Y,
          role: e.role
        }, J), {
          default: () => [w.value.map(q), C.value ? K() : null, V && $(Pb, Q(Q({}, oe), {}, {
            order: m.value,
            class: `${h.value}-suffix`,
            registerSize: R,
            display: !0,
            style: re
          }), {
            default: () => V
          }), (ee = l.default) === null || ee === void 0 ? void 0 : ee.call(l)]
        });
      };
      return $(ca, {
        disabled: !y.value,
        onResize: P
      }, {
        default: Z
      });
    };
  }
});
ps.Item = vNe;
ps.RESPONSIVE = Sj;
ps.INVALIDATE = Cj;
const wj = Symbol("TreeSelectLegacyContextPropsKey");
function bNe(e) {
  return at(wj, e);
}
function mS() {
  return ze(wj, {});
}
const yNe = {
  id: String,
  prefixCls: String,
  values: de.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: de.any,
  placeholder: de.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: de.oneOfType([de.number, de.string]),
  compositionStatus: Boolean,
  removeIcon: de.any,
  choiceTransitionName: String,
  maxTagCount: de.oneOfType([de.number, de.string]),
  maxTagTextLength: Number,
  maxTagPlaceholder: de.any.def(() => (e) => `+ ${e.length} ...`),
  tagRender: Function,
  onToggleOpen: {
    type: Function
  },
  onRemove: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
}, E8 = (e) => {
  e.preventDefault(), e.stopPropagation();
}, SNe = /* @__PURE__ */ le({
  name: "MultipleSelectSelector",
  inheritAttrs: !1,
  props: yNe,
  setup(e) {
    const t = /* @__PURE__ */ Ce(), n = /* @__PURE__ */ Ce(0), o = /* @__PURE__ */ Ce(!1), l = mS(), r = O(() => `${e.prefixCls}-selection`), a = O(() => e.open || e.mode === "tags" ? e.searchValue : ""), i = O(() => e.mode === "tags" || e.showSearch && (e.open || o.value)), s = /* @__PURE__ */ H("");
    Ot(() => {
      s.value = a.value;
    }), nt(() => {
      pe(s, () => {
        n.value = t.value.scrollWidth;
      }, {
        flush: "post",
        immediate: !0
      });
    });
    function c(m, v, h, g, y) {
      return $("span", {
        class: ke(`${r.value}-item`, {
          [`${r.value}-item-disabled`]: h
        }),
        title: typeof m == "string" || typeof m == "number" ? m.toString() : void 0
      }, [$("span", {
        class: `${r.value}-item-content`
      }, [v]), g && $(Ju, {
        class: `${r.value}-item-remove`,
        onMousedown: E8,
        onClick: y,
        customizeIcon: e.removeIcon
      }, {
        default: () => [Ft("")]
      })]);
    }
    function u(m, v, h, g, y, b) {
      var C;
      const w = (E) => {
        E8(E), e.onToggleOpen(!open);
      };
      let x = b;
      return l.keyEntities && (x = ((C = l.keyEntities[m]) === null || C === void 0 ? void 0 : C.node) || {}), $("span", {
        key: m,
        onMousedown: w
      }, [e.tagRender({
        label: v,
        value: m,
        disabled: h,
        closable: g,
        onClose: y,
        option: x
      })]);
    }
    function d(m) {
      const {
        disabled: v,
        label: h,
        value: g,
        option: y
      } = m, b = !e.disabled && !v;
      let C = h;
      if (typeof e.maxTagTextLength == "number" && (typeof h == "string" || typeof h == "number")) {
        const x = String(C);
        x.length > e.maxTagTextLength && (C = `${x.slice(0, e.maxTagTextLength)}...`);
      }
      const w = (x) => {
        var E;
        x && x.stopPropagation(), (E = e.onRemove) === null || E === void 0 || E.call(e, m);
      };
      return typeof e.tagRender == "function" ? u(g, C, v, b, w, y) : c(h, C, v, b, w);
    }
    function f(m) {
      const {
        maxTagPlaceholder: v = (g) => `+ ${g.length} ...`
      } = e, h = typeof v == "function" ? v(m) : v;
      return c(h, h, !1);
    }
    const p = (m) => {
      const v = m.target.composing;
      s.value = m.target.value, v || e.onInputChange(m);
    };
    return () => {
      const {
        id: m,
        prefixCls: v,
        values: h,
        open: g,
        inputRef: y,
        placeholder: b,
        disabled: C,
        autofocus: w,
        autocomplete: x,
        activeDescendantId: E,
        tabindex: I,
        compositionStatus: T,
        onInputPaste: P,
        onInputKeyDown: k,
        onInputMouseDown: N,
        onInputCompositionStart: R,
        onInputCompositionEnd: z
      } = e, D = $("div", {
        class: `${r.value}-search`,
        style: {
          width: n.value + "px"
        },
        key: "input"
      }, [$(bj, {
        inputRef: y,
        open: g,
        prefixCls: v,
        id: m,
        inputElement: null,
        disabled: C,
        autofocus: w,
        autocomplete: x,
        editable: i.value,
        activeDescendantId: E,
        value: s.value,
        onKeydown: k,
        onMousedown: N,
        onChange: p,
        onPaste: P,
        onCompositionstart: R,
        onCompositionend: z,
        tabindex: I,
        attrs: Mc(e, !0),
        onFocus: () => o.value = !0,
        onBlur: () => o.value = !1
      }, null), $("span", {
        ref: t,
        class: `${r.value}-search-mirror`,
        "aria-hidden": !0
      }, [s.value, Ft("")])]), F = $(ps, {
        prefixCls: `${r.value}-overflow`,
        data: h,
        renderItem: d,
        renderRest: f,
        suffix: D,
        itemKey: "key",
        maxCount: e.maxTagCount,
        key: "overflow"
      }, null);
      return $(Ge, null, [F, !h.length && !a.value && !T && $("span", {
        class: `${r.value}-placeholder`
      }, [b])]);
    };
  }
}), CNe = {
  inputElement: de.any,
  id: String,
  prefixCls: String,
  values: de.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: de.any,
  placeholder: de.any,
  compositionStatus: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: de.oneOfType([de.number, de.string]),
  activeValue: String,
  backfill: {
    type: Boolean,
    default: void 0
  },
  optionLabelRender: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
}, OI = /* @__PURE__ */ le({
  name: "SingleSelector",
  setup(e) {
    const t = /* @__PURE__ */ Ce(!1), n = O(() => e.mode === "combobox"), o = O(() => n.value || e.showSearch), l = O(() => {
      let u = e.searchValue || "";
      return n.value && e.activeValue && !t.value && (u = e.activeValue), u;
    }), r = mS();
    pe([n, () => e.activeValue], () => {
      n.value && (t.value = !1);
    }, {
      immediate: !0
    });
    const a = O(() => e.mode !== "combobox" && !e.open && !e.showSearch ? !1 : !!l.value || e.compositionStatus), i = O(() => {
      const u = e.values[0];
      return u && (typeof u.label == "string" || typeof u.label == "number") ? u.label.toString() : void 0;
    }), s = () => {
      if (e.values[0])
        return null;
      const u = a.value ? {
        visibility: "hidden"
      } : void 0;
      return $("span", {
        class: `${e.prefixCls}-selection-placeholder`,
        style: u
      }, [e.placeholder]);
    }, c = (u) => {
      u.target.composing || (t.value = !0, e.onInputChange(u));
    };
    return () => {
      var u, d, f, p;
      const {
        inputElement: m,
        prefixCls: v,
        id: h,
        values: g,
        inputRef: y,
        disabled: b,
        autofocus: C,
        autocomplete: w,
        activeDescendantId: x,
        open: E,
        tabindex: I,
        optionLabelRender: T,
        onInputKeyDown: P,
        onInputMouseDown: k,
        onInputPaste: N,
        onInputCompositionStart: R,
        onInputCompositionEnd: z
      } = e, D = g[0];
      let F = null;
      if (D && r.customSlots) {
        const M = (u = D.key) !== null && u !== void 0 ? u : D.value, A = ((d = r.keyEntities[M]) === null || d === void 0 ? void 0 : d.node) || {};
        F = r.customSlots[(f = A.slots) === null || f === void 0 ? void 0 : f.title] || r.customSlots.title || D.label, typeof F == "function" && (F = F(A));
      } else
        F = T && D ? T(D.option) : D == null ? void 0 : D.label;
      return $(Ge, null, [$("span", {
        class: `${v}-selection-search`
      }, [$(bj, {
        inputRef: y,
        prefixCls: v,
        id: h,
        open: E,
        inputElement: m,
        disabled: b,
        autofocus: C,
        autocomplete: w,
        editable: o.value,
        activeDescendantId: x,
        value: l.value,
        onKeydown: P,
        onMousedown: k,
        onChange: c,
        onPaste: N,
        onCompositionstart: R,
        onCompositionend: z,
        tabindex: I,
        attrs: Mc(e, !0)
      }, null)]), !n.value && D && !a.value && $("span", {
        class: `${v}-selection-item`,
        title: i.value
      }, [$(Ge, {
        key: (p = D.key) !== null && p !== void 0 ? p : D.value
      }, [F])]), s()]);
    };
  }
});
OI.props = CNe;
OI.inheritAttrs = !1;
function wNe(e) {
  return ![
    // System function button
    ot.ESC,
    ot.SHIFT,
    ot.BACKSPACE,
    ot.TAB,
    ot.WIN_KEY,
    ot.ALT,
    ot.META,
    ot.WIN_KEY_RIGHT,
    ot.CTRL,
    ot.SEMICOLON,
    ot.EQUALS,
    ot.CAPS_LOCK,
    ot.CONTEXT_MENU,
    // F1-F12
    ot.F1,
    ot.F2,
    ot.F3,
    ot.F4,
    ot.F5,
    ot.F6,
    ot.F7,
    ot.F8,
    ot.F9,
    ot.F10,
    ot.F11,
    ot.F12
  ].includes(e);
}
function $j() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250, t = null, n;
  yt(() => {
    clearTimeout(n);
  });
  function o(l) {
    (l || t === null) && (t = l), clearTimeout(n), n = setTimeout(() => {
      t = null;
    }, e);
  }
  return [() => t, o];
}
function Am() {
  const e = (t) => {
    e.current = t;
  };
  return e;
}
const $Ne = /* @__PURE__ */ le({
  name: "Selector",
  inheritAttrs: !1,
  props: {
    id: String,
    prefixCls: String,
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    /** Display in the Selector value, it's not same as `value` prop */
    values: de.array,
    multiple: {
      type: Boolean,
      default: void 0
    },
    mode: String,
    searchValue: String,
    activeValue: String,
    inputElement: de.any,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    activeDescendantId: String,
    tabindex: de.oneOfType([de.number, de.string]),
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: de.any,
    removeIcon: de.any,
    // Tags
    maxTagCount: de.oneOfType([de.number, de.string]),
    maxTagTextLength: Number,
    maxTagPlaceholder: de.any,
    tagRender: Function,
    optionLabelRender: Function,
    /** Check if `tokenSeparators` contains `\n` or `\r\n` */
    tokenWithEnter: {
      type: Boolean,
      default: void 0
    },
    // Motion
    choiceTransitionName: String,
    onToggleOpen: {
      type: Function
    },
    /** `onSearch` returns go next step boolean to check if need do toggle open */
    onSearch: Function,
    onSearchSubmit: Function,
    onRemove: Function,
    onInputKeyDown: {
      type: Function
    },
    /**
     * @private get real dom for trigger align.
     * This may be removed after React provides replacement of `findDOMNode`
     */
    domRef: Function
  },
  setup(e, t) {
    let {
      expose: n
    } = t;
    const o = Am(), l = /* @__PURE__ */ H(!1), [r, a] = $j(0), i = (g) => {
      const {
        which: y
      } = g;
      (y === ot.UP || y === ot.DOWN) && g.preventDefault(), e.onInputKeyDown && e.onInputKeyDown(g), y === ot.ENTER && e.mode === "tags" && !l.value && !e.open && e.onSearchSubmit(g.target.value), wNe(y) && e.onToggleOpen(!0);
    }, s = () => {
      a(!0);
    };
    let c = null;
    const u = (g) => {
      e.onSearch(g, !0, l.value) !== !1 && e.onToggleOpen(!0);
    }, d = () => {
      l.value = !0;
    }, f = (g) => {
      l.value = !1, e.mode !== "combobox" && u(g.target.value);
    }, p = (g) => {
      let {
        target: {
          value: y
        }
      } = g;
      if (e.tokenWithEnter && c && /[\r\n]/.test(c)) {
        const b = c.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
        y = y.replace(b, c);
      }
      c = null, u(y);
    }, m = (g) => {
      const {
        clipboardData: y
      } = g;
      c = y.getData("text");
    }, v = (g) => {
      let {
        target: y
      } = g;
      y !== o.current && (document.body.style.msTouchAction !== void 0 ? setTimeout(() => {
        o.current.focus();
      }) : o.current.focus());
    }, h = (g) => {
      const y = r();
      g.target !== o.current && !y && g.preventDefault(), (e.mode !== "combobox" && (!e.showSearch || !y) || !e.open) && (e.open && e.onSearch("", !0, !1), e.onToggleOpen());
    };
    return n({
      focus: () => {
        o.current.focus();
      },
      blur: () => {
        o.current.blur();
      }
    }), () => {
      const {
        prefixCls: g,
        domRef: y,
        mode: b
      } = e, C = {
        inputRef: o,
        onInputKeyDown: i,
        onInputMouseDown: s,
        onInputChange: p,
        onInputPaste: m,
        compositionStatus: l.value,
        onInputCompositionStart: d,
        onInputCompositionEnd: f
      }, w = b === "multiple" || b === "tags" ? $(SNe, Q(Q({}, e), C), null) : $(OI, Q(Q({}, e), C), null);
      return $("div", {
        ref: y,
        class: `${g}-selector`,
        onClick: v,
        onMousedown: h
      }, [w]);
    };
  }
});
function xNe(e, t, n) {
  function o(l) {
    var r, a, i;
    let s = l.target;
    s.shadowRoot && l.composed && (s = l.composedPath()[0] || s);
    const c = [(r = e[0]) === null || r === void 0 ? void 0 : r.value, (i = (a = e[1]) === null || a === void 0 ? void 0 : a.value) === null || i === void 0 ? void 0 : i.getPopupElement()];
    t.value && c.every((u) => u && !u.contains(s) && u !== s) && n(!1);
  }
  nt(() => {
    window.addEventListener("mousedown", o);
  }), yt(() => {
    window.removeEventListener("mousedown", o);
  });
}
function ENe() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
  const t = /* @__PURE__ */ Ce(!1);
  let n;
  const o = () => {
    clearTimeout(n);
  };
  return nt(() => {
    o();
  }), [t, (r, a) => {
    o(), n = setTimeout(() => {
      t.value = r, a && a();
    }, e);
  }, o];
}
const xj = Symbol("BaseSelectContextKey");
function ONe(e) {
  return at(xj, e);
}
function Oh() {
  return ze(xj, {});
}
const _I = () => {
  if (typeof navigator == "undefined" || typeof window == "undefined")
    return !1;
  const e = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e == null ? void 0 : e.substring(0, 4));
};
function uy(e) {
  if (!/* @__PURE__ */ kn(e)) return /* @__PURE__ */ kt(e);
  const t = new Proxy({}, {
    get(n, o, l) {
      return Reflect.get(e.value, o, l);
    },
    set(n, o, l) {
      return e.value[o] = l, !0;
    },
    deleteProperty(n, o) {
      return Reflect.deleteProperty(e.value, o);
    },
    has(n, o) {
      return Reflect.has(e.value, o);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return /* @__PURE__ */ kt(t);
}
var _Ne = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const INe = ["value", "onChange", "removeIcon", "placeholder", "autofocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabindex", "OptionList", "notFoundContent"], TNe = () => ({
  prefixCls: String,
  id: String,
  omitDomProps: Array,
  // >>> Value
  displayValues: Array,
  onDisplayValuesChange: Function,
  // >>> Active
  /** Current dropdown list active item string value */
  activeValue: String,
  /** Link search input with target element */
  activeDescendantId: String,
  onActiveValueChange: Function,
  // >>> Search
  searchValue: String,
  /** Trigger onSearch, return false to prevent trigger open event */
  onSearch: Function,
  /** Trigger when search text match the `tokenSeparators`. Will provide split content */
  onSearchSplit: Function,
  maxLength: Number,
  OptionList: de.any,
  /** Tell if provided `options` is empty */
  emptyOptions: Boolean
}), hS = () => ({
  showSearch: {
    type: Boolean,
    default: void 0
  },
  tagRender: {
    type: Function
  },
  optionLabelRender: {
    type: Function
  },
  direction: {
    type: String
  },
  // MISC
  tabindex: Number,
  autofocus: Boolean,
  notFoundContent: de.any,
  placeholder: de.any,
  onClear: Function,
  choiceTransitionName: String,
  // >>> Mode
  mode: String,
  // >>> Status
  disabled: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  // >>> Open
  open: {
    type: Boolean,
    default: void 0
  },
  defaultOpen: {
    type: Boolean,
    default: void 0
  },
  onDropdownVisibleChange: {
    type: Function
  },
  // >>> Customize Input
  /** @private Internal usage. Do not use in your production. */
  getInputElement: {
    type: Function
  },
  /** @private Internal usage. Do not use in your production. */
  getRawInputElement: {
    type: Function
  },
  // >>> Selector
  maxTagTextLength: Number,
  maxTagCount: {
    type: [String, Number]
  },
  maxTagPlaceholder: de.any,
  // >>> Search
  tokenSeparators: {
    type: Array
  },
  // >>> Icons
  allowClear: {
    type: Boolean,
    default: void 0
  },
  showArrow: {
    type: Boolean,
    default: void 0
  },
  inputIcon: de.any,
  /** Clear all icon */
  clearIcon: de.any,
  /** Selector remove icon */
  removeIcon: de.any,
  // >>> Dropdown
  animation: String,
  transitionName: String,
  dropdownStyle: {
    type: Object
  },
  dropdownClassName: String,
  dropdownMatchSelectWidth: {
    type: [Boolean, Number],
    default: void 0
  },
  dropdownRender: {
    type: Function
  },
  dropdownAlign: Object,
  placement: {
    type: String
  },
  getPopupContainer: {
    type: Function
  },
  // >>> Focus
  showAction: {
    type: Array
  },
  onBlur: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  // >>> Rest Events
  onKeyup: Function,
  onKeydown: Function,
  onMousedown: Function,
  onPopupScroll: Function,
  onInputKeyDown: Function,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function
}), PNe = () => _(_({}, TNe()), hS());
function II(e) {
  return e === "tags" || e === "multiple";
}
const TI = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "BaseSelect",
  inheritAttrs: !1,
  props: sn(PNe(), {
    showAction: [],
    notFoundContent: "Not Found"
  }),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: l
    } = t;
    const r = O(() => II(e.mode)), a = O(() => e.showSearch !== void 0 ? e.showSearch : r.value || e.mode === "combobox"), i = /* @__PURE__ */ Ce(!1);
    nt(() => {
      i.value = _I();
    });
    const s = mS(), c = /* @__PURE__ */ Ce(null), u = Am(), d = /* @__PURE__ */ Ce(null), f = /* @__PURE__ */ Ce(null), p = /* @__PURE__ */ Ce(null), m = /* @__PURE__ */ H(!1), [v, h, g] = ENe();
    o({
      focus: () => {
        var q;
        (q = f.value) === null || q === void 0 || q.focus();
      },
      blur: () => {
        var q;
        (q = f.value) === null || q === void 0 || q.blur();
      },
      scrollTo: (q) => {
        var K;
        return (K = p.value) === null || K === void 0 ? void 0 : K.scrollTo(q);
      }
    });
    const C = O(() => {
      var q;
      if (e.mode !== "combobox")
        return e.searchValue;
      const K = (q = e.displayValues[0]) === null || q === void 0 ? void 0 : q.value;
      return typeof K == "string" || typeof K == "number" ? String(K) : "";
    }), w = e.open !== void 0 ? e.open : e.defaultOpen, x = /* @__PURE__ */ Ce(w), E = /* @__PURE__ */ Ce(w), I = (q) => {
      x.value = e.open !== void 0 ? e.open : q, E.value = x.value;
    };
    pe(() => e.open, () => {
      I(e.open);
    });
    const T = O(() => !e.notFoundContent && e.emptyOptions);
    Ot(() => {
      E.value = x.value, (e.disabled || T.value && E.value && e.mode === "combobox") && (E.value = !1);
    });
    const P = O(() => T.value ? !1 : E.value), k = (q) => {
      const K = q !== void 0 ? q : !E.value;
      E.value !== K && !e.disabled && (I(K), e.onDropdownVisibleChange && e.onDropdownVisibleChange(K), !K && j.value && (j.value = !1, h(!1, () => {
        B.value = !1, m.value = !1;
      })));
    }, N = O(() => (e.tokenSeparators || []).some((q) => [`
`, `\r
`].includes(q))), R = (q, K, se) => {
      var Z, ee;
      let fe = !0, me = q;
      (Z = e.onActiveValueChange) === null || Z === void 0 || Z.call(e, null);
      const ge = se ? null : Q4e(q, e.tokenSeparators);
      return e.mode !== "combobox" && ge && (me = "", (ee = e.onSearchSplit) === null || ee === void 0 || ee.call(e, ge), k(!1), fe = !1), e.onSearch && C.value !== me && e.onSearch(me, {
        source: K ? "typing" : "effect"
      }), fe;
    }, z = (q) => {
      var K;
      !q || !q.trim() || (K = e.onSearch) === null || K === void 0 || K.call(e, q, {
        source: "submit"
      });
    };
    pe(E, () => {
      !E.value && !r.value && e.mode !== "combobox" && R("", !1, !1);
    }, {
      immediate: !0,
      flush: "post"
    }), pe(() => e.disabled, () => {
      x.value && e.disabled && I(!1), e.disabled && !m.value && h(!1);
    }, {
      immediate: !0
    });
    const [D, F] = $j(), M = function(q) {
      var K;
      const se = D(), {
        which: Z
      } = q;
      if (Z === ot.ENTER && (e.mode !== "combobox" && q.preventDefault(), E.value || k(!0)), F(!!C.value), Z === ot.BACKSPACE && !se && r.value && !C.value && e.displayValues.length) {
        const ge = [...e.displayValues];
        let he = null;
        for (let $e = ge.length - 1; $e >= 0; $e -= 1) {
          const ne = ge[$e];
          if (!ne.disabled) {
            ge.splice($e, 1), he = ne;
            break;
          }
        }
        he && e.onDisplayValuesChange(ge, {
          type: "remove",
          values: [he]
        });
      }
      for (var ee = arguments.length, fe = new Array(ee > 1 ? ee - 1 : 0), me = 1; me < ee; me++)
        fe[me - 1] = arguments[me];
      E.value && p.value && p.value.onKeydown(q, ...fe), (K = e.onKeydown) === null || K === void 0 || K.call(e, q, ...fe);
    }, A = function(q) {
      for (var K = arguments.length, se = new Array(K > 1 ? K - 1 : 0), Z = 1; Z < K; Z++)
        se[Z - 1] = arguments[Z];
      E.value && p.value && p.value.onKeyup(q, ...se), e.onKeyup && e.onKeyup(q, ...se);
    }, L = (q) => {
      const K = e.displayValues.filter((se) => se !== q);
      e.onDisplayValuesChange(K, {
        type: "remove",
        values: [q]
      });
    }, B = /* @__PURE__ */ Ce(!1), V = function() {
      h(!0), e.disabled || (e.onFocus && !B.value && e.onFocus(...arguments), e.showAction && e.showAction.includes("focus") && k(!0)), B.value = !0;
    }, j = /* @__PURE__ */ H(!1), W = function() {
      if (j.value || (m.value = !0, h(!1, () => {
        B.value = !1, m.value = !1, k(!1);
      }), e.disabled))
        return;
      const q = C.value;
      q && (e.mode === "tags" ? e.onSearch(q, {
        source: "submit"
      }) : e.mode === "multiple" && e.onSearch("", {
        source: "blur"
      })), e.onBlur && e.onBlur(...arguments);
    }, Y = () => {
      j.value = !0;
    }, U = () => {
      j.value = !1;
    };
    at("VCSelectContainerEvent", {
      focus: V,
      blur: W
    });
    const te = [];
    nt(() => {
      te.forEach((q) => clearTimeout(q)), te.splice(0, te.length);
    }), yt(() => {
      te.forEach((q) => clearTimeout(q)), te.splice(0, te.length);
    });
    const J = function(q) {
      var K, se;
      const {
        target: Z
      } = q, ee = (K = d.value) === null || K === void 0 ? void 0 : K.getPopupElement();
      if (ee && ee.contains(Z)) {
        const he = setTimeout(() => {
          var $e;
          const ne = te.indexOf(he);
          ne !== -1 && te.splice(ne, 1), g(), !i.value && !ee.contains(document.activeElement) && (($e = f.value) === null || $e === void 0 || $e.focus());
        });
        te.push(he);
      }
      for (var fe = arguments.length, me = new Array(fe > 1 ? fe - 1 : 0), ge = 1; ge < fe; ge++)
        me[ge - 1] = arguments[ge];
      (se = e.onMousedown) === null || se === void 0 || se.call(e, q, ...me);
    }, re = /* @__PURE__ */ Ce(null), oe = () => {
    };
    return nt(() => {
      pe(P, () => {
        var q;
        if (P.value) {
          const K = Math.ceil((q = c.value) === null || q === void 0 ? void 0 : q.offsetWidth);
          re.value !== K && !Number.isNaN(K) && (re.value = K);
        }
      }, {
        immediate: !0,
        flush: "post"
      });
    }), xNe([c, d], P, k), ONe(uy(_(_({}, /* @__PURE__ */ to(e)), {
      open: E,
      triggerOpen: P,
      showSearch: a,
      multiple: r,
      toggleOpen: k
    }))), () => {
      const q = _(_({}, e), n), {
        prefixCls: K,
        id: se,
        open: Z,
        defaultOpen: ee,
        mode: fe,
        // Search related
        showSearch: me,
        searchValue: ge,
        onSearch: he,
        // Icons
        allowClear: $e,
        clearIcon: ne,
        showArrow: ae,
        inputIcon: ce,
        // Others
        disabled: xe,
        loading: Te,
        getInputElement: Se,
        getPopupContainer: be,
        placement: ie,
        // Dropdown
        animation: we,
        transitionName: Ne,
        dropdownStyle: tt,
        dropdownClassName: Pe,
        dropdownMatchSelectWidth: Re,
        dropdownRender: Le,
        dropdownAlign: Ue,
        showAction: Ae,
        direction: De,
        // Tags
        tokenSeparators: _e,
        tagRender: Ze,
        optionLabelRender: dt,
        // Events
        onPopupScroll: Tt,
        onDropdownVisibleChange: jt,
        onFocus: Qt,
        onBlur: je,
        onKeyup: lt,
        onKeydown: Ct,
        onMousedown: vn,
        onClear: tn,
        omitDomProps: ct,
        getRawInputElement: pt,
        displayValues: Lt,
        onDisplayValuesChange: Gn,
        emptyOptions: To,
        activeDescendantId: st,
        activeValue: Yt,
        OptionList: Kt
      } = q, Ln = _Ne(q, ["prefixCls", "id", "open", "defaultOpen", "mode", "showSearch", "searchValue", "onSearch", "allowClear", "clearIcon", "showArrow", "inputIcon", "disabled", "loading", "getInputElement", "getPopupContainer", "placement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "showAction", "direction", "tokenSeparators", "tagRender", "optionLabelRender", "onPopupScroll", "onDropdownVisibleChange", "onFocus", "onBlur", "onKeyup", "onKeydown", "onMousedown", "onClear", "omitDomProps", "getRawInputElement", "displayValues", "onDisplayValuesChange", "emptyOptions", "activeDescendantId", "activeValue", "OptionList"]), Zn = fe === "combobox" && Se && Se() || null, ho = typeof pt == "function" && pt(), ul = _({}, Ln);
      let zo;
      ho && (zo = (so) => {
        k(so);
      }), INe.forEach((so) => {
        delete ul[so];
      }), ct == null || ct.forEach((so) => {
        delete ul[so];
      });
      const ir = ae !== void 0 ? ae : Te || !r.value && fe !== "combobox";
      let hl;
      ir && (hl = $(Ju, {
        class: ke(`${K}-arrow`, {
          [`${K}-arrow-loading`]: Te
        }),
        customizeIcon: ce,
        customizeIconProps: {
          loading: Te,
          searchValue: C.value,
          open: E.value,
          focused: v.value,
          showSearch: a.value
        }
      }, null));
      let Go;
      const He = () => {
        tn == null || tn(), Gn([], {
          type: "clear",
          values: Lt
        }), R("", !1, !1);
      };
      !xe && $e && (Lt.length || C.value) && (Go = $(Ju, {
        class: `${K}-clear`,
        onMousedown: He,
        customizeIcon: ne
      }, {
        default: () => [Ft("")]
      }));
      const St = $(Kt, {
        ref: p
      }, _(_({}, s.customSlots), {
        option: l.option
      })), Xt = ke(K, n.class, {
        [`${K}-focused`]: v.value,
        [`${K}-multiple`]: r.value,
        [`${K}-single`]: !r.value,
        [`${K}-allow-clear`]: $e,
        [`${K}-show-arrow`]: ir,
        [`${K}-disabled`]: xe,
        [`${K}-loading`]: Te,
        [`${K}-open`]: E.value,
        [`${K}-customize-input`]: Zn,
        [`${K}-show-search`]: a.value
      }), Mn = $(eNe, {
        ref: d,
        disabled: xe,
        prefixCls: K,
        visible: P.value,
        popupElement: St,
        containerWidth: re.value,
        animation: we,
        transitionName: Ne,
        dropdownStyle: tt,
        dropdownClassName: Pe,
        direction: De,
        dropdownMatchSelectWidth: Re,
        dropdownRender: Le,
        dropdownAlign: Ue,
        placement: ie,
        getPopupContainer: be,
        empty: To,
        getTriggerDOMNode: () => u.current,
        onPopupVisibleChange: zo,
        onPopupMouseEnter: oe,
        onPopupFocusin: Y,
        onPopupFocusout: U
      }, {
        default: () => ho ? Io(ho) && _n(ho, {
          ref: u
        }, !1, !0) : $($Ne, Q(Q({}, e), {}, {
          domRef: u,
          prefixCls: K,
          inputElement: Zn,
          ref: f,
          id: se,
          showSearch: a.value,
          mode: fe,
          activeDescendantId: st,
          tagRender: Ze,
          optionLabelRender: dt,
          values: Lt,
          open: E.value,
          onToggleOpen: k,
          activeValue: Yt,
          searchValue: C.value,
          onSearch: R,
          onSearchSubmit: z,
          onRemove: L,
          tokenWithEnter: N.value
        }), null)
      });
      let jn;
      return ho ? jn = Mn : jn = $("div", Q(Q({}, ul), {}, {
        class: Xt,
        ref: c,
        onMousedown: J,
        onKeydown: M,
        onKeyup: A
      }), [v.value && !E.value && $("span", {
        style: {
          width: 0,
          height: 0,
          position: "absolute",
          overflow: "hidden",
          opacity: 0
        },
        "aria-live": "polite"
      }, [`${Lt.map((so) => {
        let {
          label: xo,
          value: Ao
        } = so;
        return ["number", "string"].includes(typeof xo) ? xo : Ao;
      }).join(", ")}`]), Mn, hl, Go]), jn;
    };
  }
}), gS = (e, t) => {
  let {
    height: n,
    offset: o,
    prefixCls: l,
    onInnerResize: r
  } = e, {
    slots: a
  } = t;
  var i;
  let s = {}, c = {
    display: "flex",
    flexDirection: "column"
  };
  return o !== void 0 && (s = {
    height: `${n}px`,
    position: "relative",
    overflow: "hidden"
  }, c = _(_({}, c), {
    transform: `translateY(${o}px)`,
    position: "absolute",
    left: 0,
    right: 0,
    top: 0
  })), $("div", {
    style: s
  }, [$(ca, {
    onResize: (u) => {
      let {
        offsetHeight: d
      } = u;
      d && r && r();
    }
  }, {
    default: () => [$("div", {
      style: c,
      class: ke({
        [`${l}-holder-inner`]: l
      })
    }, [(i = a.default) === null || i === void 0 ? void 0 : i.call(a)])]
  })]);
};
gS.displayName = "Filter";
gS.inheritAttrs = !1;
gS.props = {
  prefixCls: String,
  /** Virtual filler height. Should be `count * itemMinHeight` */
  height: Number,
  /** Set offset of visible items. Should be the top of start item position */
  offset: Number,
  onInnerResize: Function
};
const Ej = (e, t) => {
  let {
    setRef: n
  } = e, {
    slots: o
  } = t;
  var l;
  const r = Fn((l = o.default) === null || l === void 0 ? void 0 : l.call(o));
  return r && r.length ? No(r[0], {
    ref: n
  }) : r;
};
Ej.props = {
  setRef: {
    type: Function,
    default: () => {
    }
  }
};
const kNe = 20;
function O8(e) {
  return "touches" in e ? e.touches[0].pageY : e.pageY;
}
const NNe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ScrollBar",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    scrollTop: Number,
    scrollHeight: Number,
    height: Number,
    count: Number,
    onScroll: {
      type: Function
    },
    onStartMove: {
      type: Function
    },
    onStopMove: {
      type: Function
    }
  },
  setup() {
    return {
      moveRaf: null,
      scrollbarRef: Am(),
      thumbRef: Am(),
      visibleTimeout: null,
      state: /* @__PURE__ */ kt({
        dragging: !1,
        pageY: null,
        startTop: null,
        visible: !1
      })
    };
  },
  watch: {
    scrollTop: {
      handler() {
        this.delayHidden();
      },
      flush: "post"
    }
  },
  mounted() {
    var e, t;
    (e = this.scrollbarRef.current) === null || e === void 0 || e.addEventListener("touchstart", this.onScrollbarTouchStart, Ho ? {
      passive: !1
    } : !1), (t = this.thumbRef.current) === null || t === void 0 || t.addEventListener("touchstart", this.onMouseDown, Ho ? {
      passive: !1
    } : !1);
  },
  beforeUnmount() {
    this.removeEvents(), clearTimeout(this.visibleTimeout);
  },
  methods: {
    delayHidden() {
      clearTimeout(this.visibleTimeout), this.state.visible = !0, this.visibleTimeout = setTimeout(() => {
        this.state.visible = !1;
      }, 2e3);
    },
    onScrollbarTouchStart(e) {
      e.preventDefault();
    },
    onContainerMouseDown(e) {
      e.stopPropagation(), e.preventDefault();
    },
    // ======================= Clean =======================
    patchEvents() {
      window.addEventListener("mousemove", this.onMouseMove), window.addEventListener("mouseup", this.onMouseUp), this.thumbRef.current.addEventListener("touchmove", this.onMouseMove, Ho ? {
        passive: !1
      } : !1), this.thumbRef.current.addEventListener("touchend", this.onMouseUp);
    },
    removeEvents() {
      window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("mouseup", this.onMouseUp), this.scrollbarRef.current.removeEventListener("touchstart", this.onScrollbarTouchStart, Ho ? {
        passive: !1
      } : !1), this.thumbRef.current && (this.thumbRef.current.removeEventListener("touchstart", this.onMouseDown, Ho ? {
        passive: !1
      } : !1), this.thumbRef.current.removeEventListener("touchmove", this.onMouseMove, Ho ? {
        passive: !1
      } : !1), this.thumbRef.current.removeEventListener("touchend", this.onMouseUp)), rn.cancel(this.moveRaf);
    },
    // ======================= Thumb =======================
    onMouseDown(e) {
      const {
        onStartMove: t
      } = this.$props;
      _(this.state, {
        dragging: !0,
        pageY: O8(e),
        startTop: this.getTop()
      }), t(), this.patchEvents(), e.stopPropagation(), e.preventDefault();
    },
    onMouseMove(e) {
      const {
        dragging: t,
        pageY: n,
        startTop: o
      } = this.state, {
        onScroll: l
      } = this.$props;
      if (rn.cancel(this.moveRaf), t) {
        const r = O8(e) - n, a = o + r, i = this.getEnableScrollRange(), s = this.getEnableHeightRange(), c = s ? a / s : 0, u = Math.ceil(c * i);
        this.moveRaf = rn(() => {
          l(u);
        });
      }
    },
    onMouseUp() {
      const {
        onStopMove: e
      } = this.$props;
      this.state.dragging = !1, e(), this.removeEvents();
    },
    // ===================== Calculate =====================
    getSpinHeight() {
      const {
        height: e,
        scrollHeight: t
      } = this.$props;
      let n = e / t * 100;
      return n = Math.max(n, kNe), n = Math.min(n, e / 2), Math.floor(n);
    },
    getEnableScrollRange() {
      const {
        scrollHeight: e,
        height: t
      } = this.$props;
      return e - t || 0;
    },
    getEnableHeightRange() {
      const {
        height: e
      } = this.$props, t = this.getSpinHeight();
      return e - t || 0;
    },
    getTop() {
      const {
        scrollTop: e
      } = this.$props, t = this.getEnableScrollRange(), n = this.getEnableHeightRange();
      return e === 0 || t === 0 ? 0 : e / t * n;
    },
    // Not show scrollbar when height is large than scrollHeight
    showScroll() {
      const {
        height: e,
        scrollHeight: t
      } = this.$props;
      return t > e;
    }
  },
  render() {
    const {
      dragging: e,
      visible: t
    } = this.state, {
      prefixCls: n
    } = this.$props, o = this.getSpinHeight() + "px", l = this.getTop() + "px", r = this.showScroll(), a = r && t;
    return $("div", {
      ref: this.scrollbarRef,
      class: ke(`${n}-scrollbar`, {
        [`${n}-scrollbar-show`]: r
      }),
      style: {
        width: "8px",
        top: 0,
        bottom: 0,
        right: 0,
        position: "absolute",
        display: a ? void 0 : "none"
      },
      onMousedown: this.onContainerMouseDown,
      onMousemove: this.delayHidden
    }, [$("div", {
      ref: this.thumbRef,
      class: ke(`${n}-scrollbar-thumb`, {
        [`${n}-scrollbar-thumb-moving`]: e
      }),
      style: {
        width: "100%",
        height: o,
        top: l,
        left: 0,
        position: "absolute",
        background: "rgba(0, 0, 0, 0.5)",
        borderRadius: "99px",
        cursor: "pointer",
        userSelect: "none"
      },
      onMousedown: this.onMouseDown
    }, null)]);
  }
});
function MNe(e, t, n, o) {
  const l = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ H(Symbol("update"));
  pe(e, () => {
    a.value = Symbol("update");
  });
  let i;
  function s() {
    rn.cancel(i);
  }
  function c() {
    s(), i = rn(() => {
      l.forEach((d, f) => {
        if (d && d.offsetParent) {
          const {
            offsetHeight: p
          } = d;
          r.get(f) !== p && (a.value = Symbol("update"), r.set(f, d.offsetHeight));
        }
      });
    });
  }
  function u(d, f) {
    const p = t(d);
    l.get(p), f ? (l.set(p, f.$el || f), c()) : l.delete(p);
  }
  return Uo(() => {
    s();
  }), [u, c, r, a];
}
function ANe(e, t, n, o, l, r, a, i) {
  let s;
  return (c) => {
    if (c == null) {
      i();
      return;
    }
    rn.cancel(s);
    const u = t.value, d = o.itemHeight;
    if (typeof c == "number")
      a(c);
    else if (c && typeof c == "object") {
      let f;
      const {
        align: p
      } = c;
      "index" in c ? {
        index: f
      } = c : f = u.findIndex((h) => l(h) === c.key);
      const {
        offset: m = 0
      } = c, v = (h, g) => {
        if (h < 0 || !e.value) return;
        const y = e.value.clientHeight;
        let b = !1, C = g;
        if (y) {
          const w = g || p;
          let x = 0, E = 0, I = 0;
          const T = Math.min(u.length, f);
          for (let N = 0; N <= T; N += 1) {
            const R = l(u[N]);
            E = x;
            const z = n.get(R);
            I = E + (z === void 0 ? d : z), x = I, N === f && z === void 0 && (b = !0);
          }
          const P = e.value.scrollTop;
          let k = null;
          switch (w) {
            case "top":
              k = E - m;
              break;
            case "bottom":
              k = I - y + m;
              break;
            default: {
              const N = P + y;
              E < P ? C = "top" : I > N && (C = "bottom");
            }
          }
          k !== null && k !== P && a(k);
        }
        s = rn(() => {
          b && r(), v(h - 1, C);
        }, 2);
      };
      v(5);
    }
  };
}
const RNe = typeof navigator == "object" && /Firefox/i.test(navigator.userAgent), Oj = (e, t) => {
  let n = !1, o = null;
  function l() {
    clearTimeout(o), n = !0, o = setTimeout(() => {
      n = !1;
    }, 50);
  }
  return function(r) {
    let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const i = (
      // Pass origin wheel when on the top
      r < 0 && e.value || // Pass origin wheel when on the bottom
      r > 0 && t.value
    );
    return a && i ? (clearTimeout(o), n = !1) : (!i || n) && l(), !n && i;
  };
};
function DNe(e, t, n, o) {
  let l = 0, r = null, a = null, i = !1;
  const s = Oj(t, n);
  function c(d) {
    if (!e.value) return;
    rn.cancel(r);
    const {
      deltaY: f
    } = d;
    l += f, a = f, !s(f) && (RNe || d.preventDefault(), r = rn(() => {
      o(l * (i ? 10 : 1)), l = 0;
    }));
  }
  function u(d) {
    e.value && (i = d.detail === a);
  }
  return [c, u];
}
const LNe = 14 / 15;
function BNe(e, t, n) {
  let o = !1, l = 0, r = null, a = null;
  const i = () => {
    r && (r.removeEventListener("touchmove", s), r.removeEventListener("touchend", c));
  }, s = (f) => {
    if (o) {
      const p = Math.ceil(f.touches[0].pageY);
      let m = l - p;
      l = p, n(m) && f.preventDefault(), clearInterval(a), a = setInterval(() => {
        m *= LNe, (!n(m, !0) || Math.abs(m) <= 0.1) && clearInterval(a);
      }, 16);
    }
  }, c = () => {
    o = !1, i();
  }, u = (f) => {
    i(), f.touches.length === 1 && !o && (o = !0, l = Math.ceil(f.touches[0].pageY), r = f.target, r.addEventListener("touchmove", s, {
      passive: !1
    }), r.addEventListener("touchend", c));
  }, d = () => {
  };
  nt(() => {
    document.addEventListener("touchmove", d, {
      passive: !1
    }), pe(e, (f) => {
      t.value.removeEventListener("touchstart", u), i(), clearInterval(a), f && t.value.addEventListener("touchstart", u, {
        passive: !1
      });
    }, {
      immediate: !0
    });
  }), yt(() => {
    document.removeEventListener("touchmove", d);
  });
}
var FNe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const VNe = [], zNe = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function HNe(e, t, n, o, l, r) {
  let {
    getKey: a
  } = r;
  return e.slice(t, n + 1).map((i, s) => {
    const c = t + s, u = l(i, c, {
      // style: status === 'MEASURE_START' ? { visibility: 'hidden' } : {},
    }), d = a(i);
    return $(Ej, {
      key: d,
      setRef: (f) => o(i, f)
    }, {
      default: () => [u]
    });
  });
}
const _j = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "List",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    data: de.array,
    height: Number,
    itemHeight: Number,
    /** If not match virtual scroll condition, Set List still use height of container. */
    fullHeight: {
      type: Boolean,
      default: void 0
    },
    itemKey: {
      type: [String, Number, Function],
      required: !0
    },
    component: {
      type: [String, Object]
    },
    /** Set `false` will always use real scroll instead of virtual one */
    virtual: {
      type: Boolean,
      default: void 0
    },
    children: Function,
    onScroll: Function,
    onMousedown: Function,
    onMouseenter: Function,
    onVisibleChange: Function
  },
  setup(e, t) {
    let {
      expose: n
    } = t;
    const o = O(() => {
      const {
        height: L,
        itemHeight: B,
        virtual: V
      } = e;
      return !!(V !== !1 && L && B);
    }), l = O(() => {
      const {
        height: L,
        itemHeight: B,
        data: V
      } = e;
      return o.value && V && B * V.length > L;
    }), r = /* @__PURE__ */ kt({
      scrollTop: 0,
      scrollMoving: !1
    }), a = O(() => e.data || VNe), i = /* @__PURE__ */ Ce([]);
    pe(a, () => {
      i.value = (/* @__PURE__ */ Wt(a.value)).slice();
    }, {
      immediate: !0
    });
    const s = /* @__PURE__ */ Ce((L) => {
    });
    pe(() => e.itemKey, (L) => {
      typeof L == "function" ? s.value = L : s.value = (B) => B == null ? void 0 : B[L];
    }, {
      immediate: !0
    });
    const c = /* @__PURE__ */ Ce(), u = /* @__PURE__ */ Ce(), d = /* @__PURE__ */ Ce(), f = (L) => s.value(L), p = {
      getKey: f
    };
    function m(L) {
      let B;
      typeof L == "function" ? B = L(r.scrollTop) : B = L;
      const V = x(B);
      c.value && (c.value.scrollTop = V), r.scrollTop = V;
    }
    const [v, h, g, y] = MNe(i, f), b = /* @__PURE__ */ kt({
      scrollHeight: void 0,
      start: 0,
      end: 0,
      offset: void 0
    }), C = /* @__PURE__ */ Ce(0);
    nt(() => {
      Ke(() => {
        var L;
        C.value = ((L = u.value) === null || L === void 0 ? void 0 : L.offsetHeight) || 0;
      });
    }), $o(() => {
      Ke(() => {
        var L;
        C.value = ((L = u.value) === null || L === void 0 ? void 0 : L.offsetHeight) || 0;
      });
    }), pe([o, i], () => {
      o.value || _(b, {
        scrollHeight: void 0,
        start: 0,
        end: i.value.length - 1,
        offset: void 0
      });
    }, {
      immediate: !0
    }), pe([o, i, C, l], () => {
      o.value && !l.value && _(b, {
        scrollHeight: C.value,
        start: 0,
        end: i.value.length - 1,
        offset: void 0
      }), c.value && (r.scrollTop = c.value.scrollTop);
    }, {
      immediate: !0
    }), pe([l, o, () => r.scrollTop, i, y, () => e.height, C], () => {
      if (!o.value || !l.value)
        return;
      let L = 0, B, V, j;
      const W = i.value.length, Y = i.value, U = r.scrollTop, {
        itemHeight: te,
        height: J
      } = e, re = U + J;
      for (let oe = 0; oe < W; oe += 1) {
        const q = Y[oe], K = f(q);
        let se = g.get(K);
        se === void 0 && (se = te);
        const Z = L + se;
        B === void 0 && Z >= U && (B = oe, V = L), j === void 0 && Z > re && (j = oe), L = Z;
      }
      B === void 0 && (B = 0, V = 0, j = Math.ceil(J / te)), j === void 0 && (j = W - 1), j = Math.min(j + 1, W), _(b, {
        scrollHeight: L,
        start: B,
        end: j,
        offset: V
      });
    }, {
      immediate: !0
    });
    const w = O(() => b.scrollHeight - e.height);
    function x(L) {
      let B = L;
      return Number.isNaN(w.value) || (B = Math.min(B, w.value)), B = Math.max(B, 0), B;
    }
    const E = O(() => r.scrollTop <= 0), I = O(() => r.scrollTop >= w.value), T = Oj(E, I);
    function P(L) {
      m(L);
    }
    function k(L) {
      var B;
      const {
        scrollTop: V
      } = L.currentTarget;
      V !== r.scrollTop && m(V), (B = e.onScroll) === null || B === void 0 || B.call(e, L);
    }
    const [N, R] = DNe(o, E, I, (L) => {
      m((B) => B + L);
    });
    BNe(o, c, (L, B) => T(L, B) ? !1 : (N({
      preventDefault() {
      },
      deltaY: L
    }), !0));
    function z(L) {
      o.value && L.preventDefault();
    }
    const D = () => {
      c.value && (c.value.removeEventListener("wheel", N, Ho ? {
        passive: !1
      } : !1), c.value.removeEventListener("DOMMouseScroll", R), c.value.removeEventListener("MozMousePixelScroll", z));
    };
    Ot(() => {
      Ke(() => {
        c.value && (D(), c.value.addEventListener("wheel", N, Ho ? {
          passive: !1
        } : !1), c.value.addEventListener("DOMMouseScroll", R), c.value.addEventListener("MozMousePixelScroll", z));
      });
    }), yt(() => {
      D();
    });
    const F = ANe(c, i, g, e, f, h, m, () => {
      var L;
      (L = d.value) === null || L === void 0 || L.delayHidden();
    });
    n({
      scrollTo: F
    });
    const M = O(() => {
      let L = null;
      return e.height && (L = _({
        [e.fullHeight ? "height" : "maxHeight"]: e.height + "px"
      }, zNe), o.value && (L.overflowY = "hidden", r.scrollMoving && (L.pointerEvents = "none"))), L;
    });
    return pe([() => b.start, () => b.end, i], () => {
      if (e.onVisibleChange) {
        const L = i.value.slice(b.start, b.end + 1);
        e.onVisibleChange(L, i.value);
      }
    }, {
      flush: "post"
    }), {
      state: r,
      mergedData: i,
      componentStyle: M,
      onFallbackScroll: k,
      onScrollBar: P,
      componentRef: c,
      useVirtual: o,
      calRes: b,
      collectHeight: h,
      setInstance: v,
      sharedConfig: p,
      scrollBarRef: d,
      fillerInnerRef: u,
      delayHideScrollBar: () => {
        var L;
        (L = d.value) === null || L === void 0 || L.delayHidden();
      }
    };
  },
  render() {
    const e = _(_({}, this.$props), this.$attrs), {
      prefixCls: t = "rc-virtual-list",
      height: n,
      itemHeight: o,
      // eslint-disable-next-line no-unused-vars
      fullHeight: l,
      data: r,
      itemKey: a,
      virtual: i,
      component: s = "div",
      onScroll: c,
      children: u = this.$slots.default,
      style: d,
      class: f
    } = e, p = FNe(e, ["prefixCls", "height", "itemHeight", "fullHeight", "data", "itemKey", "virtual", "component", "onScroll", "children", "style", "class"]), m = ke(t, f), {
      scrollTop: v
    } = this.state, {
      scrollHeight: h,
      offset: g,
      start: y,
      end: b
    } = this.calRes, {
      componentStyle: C,
      onFallbackScroll: w,
      onScrollBar: x,
      useVirtual: E,
      collectHeight: I,
      sharedConfig: T,
      setInstance: P,
      mergedData: k,
      delayHideScrollBar: N
    } = this;
    return $("div", Q({
      style: _(_({}, d), {
        position: "relative"
      }),
      class: m
    }, p), [$(s, {
      class: `${t}-holder`,
      style: C,
      ref: "componentRef",
      onScroll: w,
      onMouseenter: N
    }, {
      default: () => [$(gS, {
        prefixCls: t,
        height: h,
        offset: g,
        onInnerResize: I,
        ref: "fillerInnerRef"
      }, {
        default: () => HNe(k, y, b, P, u, T)
      })]
    }), E && $(NNe, {
      ref: "scrollBarRef",
      prefixCls: t,
      scrollTop: v,
      height: n,
      scrollHeight: h,
      count: k.length,
      onScroll: x,
      onStartMove: () => {
        this.state.scrollMoving = !0;
      },
      onStopMove: () => {
        this.state.scrollMoving = !1;
      }
    }, null)]);
  }
});
function PI(e, t, n) {
  const o = /* @__PURE__ */ H(e());
  return pe(t, (l, r) => {
    n ? n(l, r) && (o.value = e()) : o.value = e();
  }), o;
}
function jNe() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
const Ij = Symbol("SelectContextKey");
function WNe(e) {
  return at(Ij, e);
}
function KNe() {
  return ze(Ij, {});
}
var UNe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function _8(e) {
  return typeof e == "string" || typeof e == "number";
}
const GNe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: !1,
  setup(e, t) {
    let {
      expose: n,
      slots: o
    } = t;
    const l = Oh(), r = KNe(), a = O(() => `${l.prefixCls}-item`), i = PI(() => r.flattenOptions, [() => l.open, () => r.flattenOptions], (w) => w[0]), s = Am(), c = (w) => {
      w.preventDefault();
    }, u = (w) => {
      s.current && s.current.scrollTo(typeof w == "number" ? {
        index: w
      } : w);
    }, d = function(w) {
      let x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      const E = i.value.length;
      for (let I = 0; I < E; I += 1) {
        const T = (w + I * x + E) % E, {
          group: P,
          data: k
        } = i.value[T];
        if (!P && !k.disabled)
          return T;
      }
      return -1;
    }, f = /* @__PURE__ */ kt({
      activeIndex: d(0)
    }), p = function(w) {
      let x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      f.activeIndex = w;
      const E = {
        source: x ? "keyboard" : "mouse"
      }, I = i.value[w];
      if (!I) {
        r.onActiveValue(null, -1, E);
        return;
      }
      r.onActiveValue(I.value, w, E);
    };
    pe([() => i.value.length, () => l.searchValue], () => {
      p(r.defaultActiveFirstOption !== !1 ? d(0) : -1);
    }, {
      immediate: !0
    });
    const m = (w) => r.rawValues.has(w) && l.mode !== "combobox";
    pe([() => l.open, () => l.searchValue], () => {
      if (!l.multiple && l.open && r.rawValues.size === 1) {
        const w = Array.from(r.rawValues)[0], x = (/* @__PURE__ */ Wt(i.value)).findIndex((E) => {
          let {
            data: I
          } = E;
          return I[r.fieldNames.value] === w;
        });
        x !== -1 && (p(x), Ke(() => {
          u(x);
        }));
      }
      l.open && Ke(() => {
        var w;
        (w = s.current) === null || w === void 0 || w.scrollTo(void 0);
      });
    }, {
      immediate: !0,
      flush: "post"
    });
    const v = (w) => {
      w !== void 0 && r.onSelect(w, {
        selected: !r.rawValues.has(w)
      }), l.multiple || l.toggleOpen(!1);
    }, h = (w) => typeof w.label == "function" ? w.label() : w.label;
    function g(w) {
      const x = i.value[w];
      if (!x) return null;
      const E = x.data || {}, {
        value: I
      } = E, {
        group: T
      } = x, P = Mc(E, !0), k = h(x);
      return x ? $("div", Q(Q({
        "aria-label": typeof k == "string" && !T ? k : null
      }, P), {}, {
        key: w,
        role: T ? "presentation" : "option",
        id: `${l.id}_list_${w}`,
        "aria-selected": m(I)
      }), [I]) : null;
    }
    return n({
      onKeydown: (w) => {
        const {
          which: x,
          ctrlKey: E
        } = w;
        switch (x) {
          case ot.N:
          case ot.P:
          case ot.UP:
          case ot.DOWN: {
            let I = 0;
            if (x === ot.UP ? I = -1 : x === ot.DOWN ? I = 1 : jNe() && E && (x === ot.N ? I = 1 : x === ot.P && (I = -1)), I !== 0) {
              const T = d(f.activeIndex + I, I);
              u(T), p(T, !0);
            }
            break;
          }
          case ot.ENTER: {
            const I = i.value[f.activeIndex];
            I && !I.data.disabled ? v(I.value) : v(void 0), l.open && w.preventDefault();
            break;
          }
          case ot.ESC:
            l.toggleOpen(!1), l.open && w.stopPropagation();
        }
      },
      onKeyup: () => {
      },
      scrollTo: (w) => {
        u(w);
      }
    }), () => {
      const {
        id: w,
        notFoundContent: x,
        onPopupScroll: E
      } = l, {
        menuItemSelectedIcon: I,
        fieldNames: T,
        virtual: P,
        listHeight: k,
        listItemHeight: N
      } = r, R = o.option, {
        activeIndex: z
      } = f, D = Object.keys(T).map((F) => T[F]);
      return i.value.length === 0 ? $("div", {
        role: "listbox",
        id: `${w}_list`,
        class: `${a.value}-empty`,
        onMousedown: c
      }, [x]) : $(Ge, null, [$("div", {
        role: "listbox",
        id: `${w}_list`,
        style: {
          height: 0,
          width: 0,
          overflow: "hidden"
        }
      }, [g(z - 1), g(z), g(z + 1)]), $(_j, {
        itemKey: "key",
        ref: s,
        data: i.value,
        height: k,
        itemHeight: N,
        fullHeight: !1,
        onMousedown: c,
        onScroll: E,
        virtual: P
      }, {
        default: (F, M) => {
          var A;
          const {
            group: L,
            groupOption: B,
            data: V,
            value: j
          } = F, {
            key: W
          } = V, Y = typeof F.label == "function" ? F.label() : F.label;
          if (L) {
            const ne = (A = V.title) !== null && A !== void 0 ? A : _8(Y) && Y;
            return $("div", {
              class: ke(a.value, `${a.value}-group`),
              title: ne
            }, [R ? R(V) : Y !== void 0 ? Y : W]);
          }
          const {
            disabled: U,
            title: te,
            children: J,
            style: re,
            class: oe,
            className: q
          } = V, K = UNe(V, ["disabled", "title", "children", "style", "class", "className"]), se = pn(K, D), Z = m(j), ee = `${a.value}-option`, fe = ke(a.value, ee, oe, q, {
            [`${ee}-grouped`]: B,
            [`${ee}-active`]: z === M && !U,
            [`${ee}-disabled`]: U,
            [`${ee}-selected`]: Z
          }), me = h(F), ge = !I || typeof I == "function" || Z, he = typeof me == "number" ? me : me || j;
          let $e = _8(he) ? he.toString() : void 0;
          return te !== void 0 && ($e = te), $("div", Q(Q({}, se), {}, {
            "aria-selected": Z,
            class: fe,
            title: $e,
            onMousemove: (ne) => {
              K.onMousemove && K.onMousemove(ne), !(z === M || U) && p(M);
            },
            onClick: (ne) => {
              U || v(j), K.onClick && K.onClick(ne);
            },
            style: re
          }), [$("div", {
            class: `${ee}-content`
          }, [R ? R(V) : he]), Io(I) || Z, ge && $(Ju, {
            class: `${a.value}-option-state`,
            customizeIcon: I,
            customizeIconProps: {
              isSelected: Z
            }
          }, {
            default: () => [Z ? "" : null]
          })]);
        }
      })]);
    };
  }
});
var YNe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function XNe(e) {
  const t = e, {
    key: n,
    children: o
  } = t, l = t.props, {
    value: r,
    disabled: a
  } = l, i = YNe(l, ["value", "disabled"]), s = o == null ? void 0 : o.default;
  return _({
    key: n,
    value: r !== void 0 ? r : n,
    children: s,
    disabled: a || a === ""
  }, i);
}
function kI(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return Fn(e).map((o, l) => {
    var r;
    if (!Io(o) || !o.type)
      return null;
    const {
      type: {
        isSelectOptGroup: a
      },
      key: i,
      children: s,
      props: c
    } = o;
    if (t || !a)
      return XNe(o);
    const u = s && s.default ? s.default() : void 0, d = (c == null ? void 0 : c.label) || ((r = s.label) === null || r === void 0 ? void 0 : r.call(s)) || i;
    return _(_({
      key: `__RC_SELECT_GRP__${i === null ? l : String(i)}__`
    }, c), {
      label: d,
      options: kI(u || [])
    });
  }).filter((o) => o);
}
function qNe(e, t, n) {
  const o = /* @__PURE__ */ Ce(), l = /* @__PURE__ */ Ce(), r = /* @__PURE__ */ Ce(), a = /* @__PURE__ */ Ce([]);
  return pe([e, t], () => {
    e.value ? a.value = (/* @__PURE__ */ Wt(e.value)).slice() : a.value = kI(t.value);
  }, {
    immediate: !0,
    deep: !0
  }), Ot(() => {
    const i = a.value, s = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map(), u = n.value;
    function d(f) {
      let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      for (let m = 0; m < f.length; m += 1) {
        const v = f[m];
        !v[u.options] || p ? (s.set(v[u.value], v), c.set(v[u.label], v)) : d(v[u.options], !0);
      }
    }
    d(i), o.value = i, l.value = s, r.value = c;
  }), {
    options: o,
    valueOptions: l,
    labelOptions: r
  };
}
let I8 = 0;
const JNe = process.env.NODE_ENV !== "test" && Fl();
function ZNe() {
  let e;
  return JNe ? (e = I8, I8 += 1) : e = "TEST_OR_SSR", e;
}
function NI() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ H("");
  const t = `rc_select_${ZNe()}`;
  return e.value || t;
}
function MI(e) {
  return Array.isArray(e) ? e : e !== void 0 ? [e] : [];
}
const QNe = typeof window != "undefined" && window.document && window.document.documentElement;
process.env.NODE_ENV;
function eMe(e) {
  const {
    mode: t,
    options: n,
    children: o,
    backfill: l,
    allowClear: r,
    placeholder: a,
    getInputElement: i,
    showSearch: s,
    onSearch: c,
    defaultOpen: u,
    autofocus: d,
    labelInValue: f,
    value: p,
    inputValue: m,
    optionLabelProp: v
  } = e, h = II(t), g = s !== void 0 ? s : h || t === "combobox", y = n || kI(o);
  if (pr(t !== "tags" || y.every((b) => !b.disabled), "Please avoid setting option to disabled in tags mode since user can always type text as tag."), pr(t !== "combobox" || !v, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly."), pr(t === "combobox" || !l, "`backfill` only works with `combobox` mode."), pr(t === "combobox" || !i, "`getInputElement` only work with `combobox` mode."), u2(t !== "combobox" || !i || !r || !a, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`."), c && !g && t !== "combobox" && t !== "tags" && pr(!1, "`onSearch` should work with `showSearch` instead of use alone."), u2(!u || d, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autofocus` if needed."), p != null) {
    const b = MI(p);
    pr(!f || b.every((C) => typeof C == "object" && ("key" in C || "value" in C)), "`value` should in shape of `{ value: string | number, label?: any }` when you set `labelInValue` to `true`"), pr(!h || Array.isArray(p), "`value` should be array when `mode` is `multiple` or `tags`");
  }
  if (o) {
    let b = null;
    o.some((C) => {
      var w;
      if (!Io(C) || !C.type)
        return !1;
      const {
        type: x
      } = C;
      return x.isSelectOption ? !1 : x.isSelectOptGroup ? !(((w = C.children) === null || w === void 0 ? void 0 : w.default()) || []).every((T) => !Io(T) || !C.type || T.type.isSelectOption ? !0 : (b = T.type, !1)) : (b = x, !0);
    }), b && pr(!1, `\`children\` should be \`Select.Option\` or \`Select.OptGroup\` instead of \`${b.displayName || b.name || b}\`.`), pr(m === void 0, "`inputValue` is deprecated, please use `searchValue` instead.");
  }
}
function $w(e, t) {
  return MI(e).join("").toUpperCase().includes(t);
}
const tMe = (e, t, n, o, l) => O(() => {
  const r = n.value, a = l == null ? void 0 : l.value, i = o == null ? void 0 : o.value;
  if (!r || i === !1)
    return e.value;
  const {
    options: s,
    label: c,
    value: u
  } = t.value, d = [], f = typeof i == "function", p = r.toUpperCase(), m = f ? i : (h, g) => a ? $w(g[a], p) : g[s] ? $w(g[c !== "children" ? c : "label"], p) : $w(g[u], p), v = f ? (h) => y2(h) : (h) => h;
  return e.value.forEach((h) => {
    if (h[s]) {
      if (m(r, v(h)))
        d.push(h);
      else {
        const y = h[s].filter((b) => m(r, v(b)));
        y.length && d.push(_(_({}, h), {
          [s]: y
        }));
      }
      return;
    }
    m(r, v(h)) && d.push(h);
  }), d;
}), nMe = (e, t) => {
  const n = /* @__PURE__ */ Ce({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  return [O(() => {
    const {
      values: r,
      options: a
    } = n.value, i = e.value.map((u) => {
      var d;
      return u.label === void 0 ? _(_({}, u), {
        label: (d = r.get(u.value)) === null || d === void 0 ? void 0 : d.label
      }) : u;
    }), s = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
    return i.forEach((u) => {
      s.set(u.value, u), c.set(u.value, t.value.get(u.value) || a.get(u.value));
    }), n.value.values = s, n.value.options = c, i;
  }), (r) => t.value.get(r) || n.value.options.get(r)];
};
function ro(e, t) {
  const {
    defaultValue: n,
    value: o = /* @__PURE__ */ H()
  } = t || {};
  let l = typeof e == "function" ? e() : e;
  o.value !== void 0 && (l = S(o)), n !== void 0 && (l = typeof n == "function" ? n() : n);
  const r = /* @__PURE__ */ H(l), a = /* @__PURE__ */ H(l);
  Ot(() => {
    let s = o.value !== void 0 ? o.value : r.value;
    t.postState && (s = t.postState(s)), a.value = s;
  });
  function i(s) {
    const c = a.value;
    r.value = s, /* @__PURE__ */ Wt(a.value) !== s && t.onChange && t.onChange(s, c);
  }
  return pe(o, () => {
    r.value = o.value;
  }), [a, i];
}
function Bn(e) {
  const t = typeof e == "function" ? e() : e, n = /* @__PURE__ */ H(t);
  function o(l) {
    n.value = l;
  }
  return [n, o];
}
const oMe = ["inputValue"];
function Tj() {
  return _(_({}, hS()), {
    prefixCls: String,
    id: String,
    backfill: {
      type: Boolean,
      default: void 0
    },
    // >>> Field Names
    fieldNames: Object,
    // >>> Search
    /** @deprecated Use `searchValue` instead */
    inputValue: String,
    searchValue: String,
    onSearch: Function,
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    // >>> Select
    onSelect: Function,
    onDeselect: Function,
    // >>> Options
    /**
     * In Select, `false` means do nothing.
     * In TreeSelect, `false` will highlight match item.
     * It's by design.
     */
    filterOption: {
      type: [Boolean, Function],
      default: void 0
    },
    filterSort: Function,
    optionFilterProp: String,
    optionLabelProp: String,
    options: Array,
    defaultActiveFirstOption: {
      type: Boolean,
      default: void 0
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    // >>> Icon
    menuItemSelectedIcon: de.any,
    mode: String,
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    value: de.any,
    defaultValue: de.any,
    onChange: Function,
    children: Array
  });
}
function lMe(e) {
  return !e || typeof e != "object";
}
const rMe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "VcSelect",
  inheritAttrs: !1,
  props: sn(Tj(), {
    prefixCls: "vc-select",
    autoClearSearchValue: !0,
    listHeight: 200,
    listItemHeight: 20,
    dropdownMatchSelectWidth: !0
  }),
  setup(e, t) {
    let {
      expose: n,
      attrs: o,
      slots: l
    } = t;
    const r = NI(/* @__PURE__ */ ft(e, "id")), a = O(() => II(e.mode)), i = O(() => !!(!e.options && e.children)), s = O(() => e.filterOption === void 0 && e.mode === "combobox" ? !1 : e.filterOption), c = O(() => oj(e.fieldNames, i.value)), [u, d] = ro("", {
      value: O(() => e.searchValue !== void 0 ? e.searchValue : e.inputValue),
      postState: (oe) => oe || ""
    }), f = qNe(/* @__PURE__ */ ft(e, "options"), /* @__PURE__ */ ft(e, "children"), c), {
      valueOptions: p,
      labelOptions: m,
      options: v
    } = f, h = (oe) => MI(oe).map((K) => {
      var se, Z;
      let ee, fe, me, ge;
      lMe(K) ? ee = K : (me = K.key, fe = K.label, ee = (se = K.value) !== null && se !== void 0 ? se : me);
      const he = p.value.get(ee);
      return he && (fe === void 0 && (fe = he == null ? void 0 : he[e.optionLabelProp || c.value.label]), me === void 0 && (me = (Z = he == null ? void 0 : he.key) !== null && Z !== void 0 ? Z : ee), ge = he == null ? void 0 : he.disabled), {
        label: fe,
        value: ee,
        key: me,
        disabled: ge,
        option: he
      };
    }), [g, y] = ro(e.defaultValue, {
      value: /* @__PURE__ */ ft(e, "value")
    }), b = O(() => {
      var oe;
      const q = h(g.value);
      return e.mode === "combobox" && !(!((oe = q[0]) === null || oe === void 0) && oe.value) ? [] : q;
    }), [C, w] = nMe(b, p), x = O(() => {
      if (!e.mode && C.value.length === 1) {
        const oe = C.value[0];
        if (oe.value === null && (oe.label === null || oe.label === void 0))
          return [];
      }
      return C.value.map((oe) => {
        var q;
        return _(_({}, oe), {
          label: (q = typeof oe.label == "function" ? oe.label() : oe.label) !== null && q !== void 0 ? q : oe.value
        });
      });
    }), E = O(() => new Set(C.value.map((oe) => oe.value)));
    Ot(() => {
      var oe;
      if (e.mode === "combobox") {
        const q = (oe = C.value[0]) === null || oe === void 0 ? void 0 : oe.value;
        q != null && d(String(q));
      }
    }, {
      flush: "post"
    });
    const I = (oe, q) => {
      const K = q != null ? q : oe;
      return {
        [c.value.value]: oe,
        [c.value.label]: K
      };
    }, T = /* @__PURE__ */ Ce();
    Ot(() => {
      if (e.mode !== "tags") {
        T.value = v.value;
        return;
      }
      const oe = v.value.slice(), q = (K) => p.value.has(K);
      [...C.value].sort((K, se) => K.value < se.value ? -1 : 1).forEach((K) => {
        const se = K.value;
        q(se) || oe.push(I(se, K.label));
      }), T.value = oe;
    });
    const P = tMe(T, c, u, s, /* @__PURE__ */ ft(e, "optionFilterProp")), k = O(() => e.mode !== "tags" || !u.value || P.value.some((oe) => oe[e.optionFilterProp || "value"] === u.value) ? P.value : [I(u.value), ...P.value]), N = O(() => e.filterSort ? [...k.value].sort((oe, q) => e.filterSort(oe, q)) : k.value), R = O(() => Z4e(N.value, {
      fieldNames: c.value,
      childrenAsData: i.value
    })), z = (oe) => {
      const q = h(oe);
      if (y(q), e.onChange && // Trigger event only when value changed
      (q.length !== C.value.length || q.some((K, se) => {
        var Z;
        return ((Z = C.value[se]) === null || Z === void 0 ? void 0 : Z.value) !== (K == null ? void 0 : K.value);
      }))) {
        const K = e.labelInValue ? q.map((Z) => _(_({}, Z), {
          originLabel: Z.label,
          label: typeof Z.label == "function" ? Z.label() : Z.label
        })) : q.map((Z) => Z.value), se = q.map((Z) => y2(w(Z.value)));
        e.onChange(
          // Value
          a.value ? K : K[0],
          // Option
          a.value ? se : se[0]
        );
      }
    }, [D, F] = Bn(null), [M, A] = Bn(0), L = O(() => e.defaultActiveFirstOption !== void 0 ? e.defaultActiveFirstOption : e.mode !== "combobox"), B = function(oe, q) {
      let {
        source: K = "keyboard"
      } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      A(q), e.backfill && e.mode === "combobox" && oe !== null && K === "keyboard" && F(String(oe));
    }, V = (oe, q) => {
      const K = () => {
        var se;
        const Z = w(oe), ee = Z == null ? void 0 : Z[c.value.label];
        return [e.labelInValue ? {
          label: typeof ee == "function" ? ee() : ee,
          originLabel: ee,
          value: oe,
          key: (se = Z == null ? void 0 : Z.key) !== null && se !== void 0 ? se : oe
        } : oe, y2(Z)];
      };
      if (q && e.onSelect) {
        const [se, Z] = K();
        e.onSelect(se, Z);
      } else if (!q && e.onDeselect) {
        const [se, Z] = K();
        e.onDeselect(se, Z);
      }
    }, j = (oe, q) => {
      let K;
      const se = a.value ? q.selected : !0;
      se ? K = a.value ? [...C.value, oe] : [oe] : K = C.value.filter((Z) => Z.value !== oe), z(K), V(oe, se), e.mode === "combobox" ? F("") : (!a.value || e.autoClearSearchValue) && (d(""), F(""));
    }, W = (oe, q) => {
      z(oe), (q.type === "remove" || q.type === "clear") && q.values.forEach((K) => {
        V(K.value, !1);
      });
    }, Y = (oe, q) => {
      var K;
      if (d(oe), F(null), q.source === "submit") {
        const se = (oe || "").trim();
        if (se) {
          const Z = Array.from(/* @__PURE__ */ new Set([...E.value, se]));
          z(Z), V(se, !0), d("");
        }
        return;
      }
      q.source !== "blur" && (e.mode === "combobox" && z(oe), (K = e.onSearch) === null || K === void 0 || K.call(e, oe));
    }, U = (oe) => {
      let q = oe;
      e.mode !== "tags" && (q = oe.map((se) => {
        const Z = m.value.get(se);
        return Z == null ? void 0 : Z.value;
      }).filter((se) => se !== void 0));
      const K = Array.from(/* @__PURE__ */ new Set([...E.value, ...q]));
      z(K), K.forEach((se) => {
        V(se, !0);
      });
    }, te = O(() => e.virtual !== !1 && e.dropdownMatchSelectWidth !== !1);
    WNe(uy(_(_({}, f), {
      flattenOptions: R,
      onActiveValue: B,
      defaultActiveFirstOption: L,
      onSelect: j,
      menuItemSelectedIcon: /* @__PURE__ */ ft(e, "menuItemSelectedIcon"),
      rawValues: E,
      fieldNames: c,
      virtual: te,
      listHeight: /* @__PURE__ */ ft(e, "listHeight"),
      listItemHeight: /* @__PURE__ */ ft(e, "listItemHeight"),
      childrenAsData: i
    }))), process.env.NODE_ENV !== "production" && Ot(() => {
      eMe(e);
    }, {
      flush: "post"
    });
    const J = /* @__PURE__ */ H();
    n({
      focus() {
        var oe;
        (oe = J.value) === null || oe === void 0 || oe.focus();
      },
      blur() {
        var oe;
        (oe = J.value) === null || oe === void 0 || oe.blur();
      },
      scrollTo(oe) {
        var q;
        (q = J.value) === null || q === void 0 || q.scrollTo(oe);
      }
    });
    const re = O(() => pn(e, [
      "id",
      "mode",
      "prefixCls",
      "backfill",
      "fieldNames",
      // Search
      "inputValue",
      "searchValue",
      "onSearch",
      "autoClearSearchValue",
      // Select
      "onSelect",
      "onDeselect",
      "dropdownMatchSelectWidth",
      // Options
      "filterOption",
      "filterSort",
      "optionFilterProp",
      "optionLabelProp",
      "options",
      "children",
      "defaultActiveFirstOption",
      "menuItemSelectedIcon",
      "virtual",
      "listHeight",
      "listItemHeight",
      // Value
      "value",
      "defaultValue",
      "labelInValue",
      "onChange"
    ]));
    return () => $(TI, Q(Q(Q({}, re.value), o), {}, {
      id: r,
      prefixCls: e.prefixCls,
      ref: J,
      omitDomProps: oMe,
      mode: e.mode,
      displayValues: x.value,
      onDisplayValuesChange: W,
      searchValue: u.value,
      onSearch: Y,
      onSearchSplit: U,
      dropdownMatchSelectWidth: e.dropdownMatchSelectWidth,
      OptionList: GNe,
      emptyOptions: !R.value.length,
      activeValue: D.value,
      activeDescendantId: `${r}_list_${M.value}`
    }), l);
  }
}), AI = () => null;
AI.isSelectOption = !0;
AI.displayName = "ASelectOption";
const RI = () => null;
RI.isSelectOptGroup = !0;
RI.displayName = "ASelectOptGroup";
var aMe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, name: "down", theme: "outlined" }, iMe = Symbol("iconContext"), Pj = function() {
  return ze(iMe, {
    prefixCls: /* @__PURE__ */ H("anticon"),
    rootClassName: /* @__PURE__ */ H(""),
    csp: /* @__PURE__ */ H()
  });
};
function DI() {
  return !!(typeof window != "undefined" && window.document && window.document.createElement);
}
function sMe(e, t) {
  return e && e.contains ? e.contains(t) : !1;
}
var T8 = "data-vc-order", cMe = "vc-icon-key", E2 = /* @__PURE__ */ new Map();
function kj() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.mark;
  return t ? t.startsWith("data-") ? t : "data-".concat(t) : cMe;
}
function LI(e) {
  if (e.attachTo)
    return e.attachTo;
  var t = document.querySelector("head");
  return t || document.body;
}
function uMe(e) {
  return e === "queue" ? "prependQueue" : e ? "prepend" : "append";
}
function Nj(e) {
  return Array.from((E2.get(e) || e).children).filter(function(t) {
    return t.tagName === "STYLE";
  });
}
function Mj(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!DI())
    return null;
  var n = t.csp, o = t.prepend, l = document.createElement("style");
  l.setAttribute(T8, uMe(o)), n && n.nonce && (l.nonce = n.nonce), l.innerHTML = e;
  var r = LI(t), a = r.firstChild;
  if (o) {
    if (o === "queue") {
      var i = Nj(r).filter(function(s) {
        return ["prepend", "prependQueue"].includes(s.getAttribute(T8));
      });
      if (i.length)
        return r.insertBefore(l, i[i.length - 1].nextSibling), l;
    }
    r.insertBefore(l, a);
  } else
    r.appendChild(l);
  return l;
}
function dMe(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = LI(t);
  return Nj(n).find(function(o) {
    return o.getAttribute(kj(t)) === e;
  });
}
function fMe(e, t) {
  var n = E2.get(e);
  if (!n || !sMe(document, n)) {
    var o = Mj("", t), l = o.parentNode;
    E2.set(e, l), e.removeChild(o);
  }
}
function pMe(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = LI(n);
  fMe(o, n);
  var l = dMe(t, n);
  if (l)
    return n.csp && n.csp.nonce && l.nonce !== n.csp.nonce && (l.nonce = n.csp.nonce), l.innerHTML !== e && (l.innerHTML = e), l;
  var r = Mj(e, n);
  return r.setAttribute(kj(n), t), r;
}
function P8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      vMe(e, l, n[l]);
    });
  }
  return e;
}
function vMe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function mMe(e, t) {
  process.env.NODE_ENV !== "production" && !e && console !== void 0 && console.error("Warning: ".concat(t));
}
function hMe(e, t) {
  mMe(e, "[@ant-design/icons-vue] ".concat(t));
}
function k8(e) {
  return typeof e == "object" && typeof e.name == "string" && typeof e.theme == "string" && (typeof e.icon == "object" || typeof e.icon == "function");
}
function O2(e, t, n) {
  return n ? ht(e.tag, P8({
    key: t
  }, n, e.attrs), (e.children || []).map(function(o, l) {
    return O2(o, "".concat(t, "-").concat(e.tag, "-").concat(l));
  })) : ht(e.tag, P8({
    key: t
  }, e.attrs), (e.children || []).map(function(o, l) {
    return O2(o, "".concat(t, "-").concat(e.tag, "-").concat(l));
  }));
}
function Aj(e) {
  return Xu(e)[0];
}
function Rj(e) {
  return e ? Array.isArray(e) ? e : [e] : [];
}
var gMe = `
.anticon {
  display: inline-block;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`;
function Dj(e) {
  return e && e.getRootNode && e.getRootNode();
}
function bMe(e) {
  return DI() ? Dj(e) instanceof ShadowRoot : !1;
}
function yMe(e) {
  return bMe(e) ? Dj(e) : null;
}
var SMe = function() {
  var t = Pj(), n = t.prefixCls, o = t.csp, l = xt(), r = gMe;
  n && (r = r.replace(/anticon/g, n.value)), Ke(function() {
    if (DI()) {
      var a = l.vnode.el, i = yMe(a);
      pMe(r, "@ant-design-vue-icons", {
        prepend: !0,
        csp: o.value,
        attachTo: i
      });
    }
  });
}, CMe = ["icon", "primaryColor", "secondaryColor"];
function wMe(e, t) {
  if (e == null) return {};
  var n = $Me(e, t), o, l;
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    for (l = 0; l < r.length; l++)
      o = r[l], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
function $Me(e, t) {
  if (e == null) return {};
  var n = {}, o = Object.keys(e), l, r;
  for (r = 0; r < o.length; r++)
    l = o[r], !(t.indexOf(l) >= 0) && (n[l] = e[l]);
  return n;
}
function kb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      xMe(e, l, n[l]);
    });
  }
  return e;
}
function xMe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Dv = /* @__PURE__ */ kt({
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: !1
});
function EMe(e) {
  var t = e.primaryColor, n = e.secondaryColor;
  Dv.primaryColor = t, Dv.secondaryColor = n || Aj(t), Dv.calculated = !!n;
}
function OMe() {
  return kb({}, Dv);
}
var Ac = function(t, n) {
  var o = kb({}, t, n.attrs), l = o.icon, r = o.primaryColor, a = o.secondaryColor, i = wMe(o, CMe), s = Dv;
  if (r && (s = {
    primaryColor: r,
    secondaryColor: a || Aj(r)
  }), hMe(k8(l), "icon should be icon definiton, but got ".concat(l)), !k8(l))
    return null;
  var c = l;
  return c && typeof c.icon == "function" && (c = kb({}, c, {
    icon: c.icon(s.primaryColor, s.secondaryColor)
  })), O2(c.icon, "svg-".concat(c.name), kb({}, i, {
    "data-icon": c.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }));
};
Ac.props = {
  icon: Object,
  primaryColor: String,
  secondaryColor: String,
  focusable: String
};
Ac.inheritAttrs = !1;
Ac.displayName = "IconBase";
Ac.getTwoToneColors = OMe;
Ac.setTwoToneColors = EMe;
function _Me(e, t) {
  return kMe(e) || PMe(e, t) || TMe(e, t) || IMe();
}
function IMe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function TMe(e, t) {
  if (e) {
    if (typeof e == "string") return N8(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return N8(e, t);
  }
}
function N8(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, o = new Array(t); n < t; n++)
    o[n] = e[n];
  return o;
}
function PMe(e, t) {
  var n = e == null ? null : typeof Symbol != "undefined" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var o = [], l = !0, r = !1, a, i;
    try {
      for (n = n.call(e); !(l = (a = n.next()).done) && (o.push(a.value), !(t && o.length === t)); l = !0)
        ;
    } catch (s) {
      r = !0, i = s;
    } finally {
      try {
        !l && n.return != null && n.return();
      } finally {
        if (r) throw i;
      }
    }
    return o;
  }
}
function kMe(e) {
  if (Array.isArray(e)) return e;
}
function Lj(e) {
  var t = Rj(e), n = _Me(t, 2), o = n[0], l = n[1];
  return Ac.setTwoToneColors({
    primaryColor: o,
    secondaryColor: l
  });
}
function NMe() {
  var e = Ac.getTwoToneColors();
  return e.calculated ? [e.primaryColor, e.secondaryColor] : e.primaryColor;
}
var MMe = /* @__PURE__ */ le({
  name: "InsertStyles",
  setup: function() {
    return SMe(), function() {
      return null;
    };
  }
}), AMe = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];
function RMe(e, t) {
  return FMe(e) || BMe(e, t) || LMe(e, t) || DMe();
}
function DMe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function LMe(e, t) {
  if (e) {
    if (typeof e == "string") return M8(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return M8(e, t);
  }
}
function M8(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, o = new Array(t); n < t; n++)
    o[n] = e[n];
  return o;
}
function BMe(e, t) {
  var n = e == null ? null : typeof Symbol != "undefined" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var o = [], l = !0, r = !1, a, i;
    try {
      for (n = n.call(e); !(l = (a = n.next()).done) && (o.push(a.value), !(t && o.length === t)); l = !0)
        ;
    } catch (s) {
      r = !0, i = s;
    } finally {
      try {
        !l && n.return != null && n.return();
      } finally {
        if (r) throw i;
      }
    }
    return o;
  }
}
function FMe(e) {
  if (Array.isArray(e)) return e;
}
function A8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      bv(e, l, n[l]);
    });
  }
  return e;
}
function bv(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function VMe(e, t) {
  if (e == null) return {};
  var n = zMe(e, t), o, l;
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    for (l = 0; l < r.length; l++)
      o = r[l], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
function zMe(e, t) {
  if (e == null) return {};
  var n = {}, o = Object.keys(e), l, r;
  for (r = 0; r < o.length; r++)
    l = o[r], !(t.indexOf(l) >= 0) && (n[l] = e[l]);
  return n;
}
Lj(Kke.primary);
var cn = function(t, n) {
  var o, l = A8({}, t, n.attrs), r = l.class, a = l.icon, i = l.spin, s = l.rotate, c = l.tabindex, u = l.twoToneColor, d = l.onClick, f = VMe(l, AMe), p = Pj(), m = p.prefixCls, v = p.rootClassName, h = (o = {}, bv(o, v.value, !!v.value), bv(o, m.value, !0), bv(o, "".concat(m.value, "-").concat(a.name), !!a.name), bv(o, "".concat(m.value, "-spin"), !!i || a.name === "loading"), o), g = c;
  g === void 0 && d && (g = -1);
  var y = s ? {
    msTransform: "rotate(".concat(s, "deg)"),
    transform: "rotate(".concat(s, "deg)")
  } : void 0, b = Rj(u), C = RMe(b, 2), w = C[0], x = C[1];
  return $("span", A8({
    role: "img",
    "aria-label": a.name
  }, f, {
    onClick: d,
    class: [h, r],
    tabindex: g
  }), [$(Ac, {
    icon: a,
    primaryColor: w,
    secondaryColor: x,
    style: y
  }, null), $(MMe, null, null)]);
};
cn.props = {
  spin: Boolean,
  rotate: Number,
  icon: Object,
  twoToneColor: [String, Array]
};
cn.displayName = "AntdIcon";
cn.inheritAttrs = !1;
cn.getTwoToneColor = NMe;
cn.setTwoToneColor = Lj;
function R8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      HMe(e, l, n[l]);
    });
  }
  return e;
}
function HMe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var pd = function(t, n) {
  var o = R8({}, t, n.attrs);
  return $(cn, R8({}, o, {
    icon: aMe
  }), null);
};
pd.displayName = "DownOutlined";
pd.inheritAttrs = !1;
var jMe = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" };
function D8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      WMe(e, l, n[l]);
    });
  }
  return e;
}
function WMe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var ar = function(t, n) {
  var o = D8({}, t, n.attrs);
  return $(cn, D8({}, o, {
    icon: jMe
  }), null);
};
ar.displayName = "LoadingOutlined";
ar.inheritAttrs = !1;
var KMe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, name: "check", theme: "outlined" };
function L8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      UMe(e, l, n[l]);
    });
  }
  return e;
}
function UMe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Np = function(t, n) {
  var o = L8({}, t, n.attrs);
  return $(cn, L8({}, o, {
    icon: KMe
  }), null);
};
Np.displayName = "CheckOutlined";
Np.inheritAttrs = !1;
var GMe = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, name: "close", theme: "outlined" };
function B8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      YMe(e, l, n[l]);
    });
  }
  return e;
}
function YMe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Hl = function(t, n) {
  var o = B8({}, t, n.attrs);
  return $(cn, B8({}, o, {
    icon: GMe
  }), null);
};
Hl.displayName = "CloseOutlined";
Hl.inheritAttrs = !1;
var XMe = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, name: "close-circle", theme: "filled" };
function F8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      qMe(e, l, n[l]);
    });
  }
  return e;
}
function qMe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var jl = function(t, n) {
  var o = F8({}, t, n.attrs);
  return $(cn, F8({}, o, {
    icon: XMe
  }), null);
};
jl.displayName = "CloseCircleFilled";
jl.inheritAttrs = !1;
var JMe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, name: "search", theme: "outlined" };
function V8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      ZMe(e, l, n[l]);
    });
  }
  return e;
}
function ZMe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Mp = function(t, n) {
  var o = V8({}, t, n.attrs);
  return $(cn, V8({}, o, {
    icon: JMe
  }), null);
};
Mp.displayName = "SearchOutlined";
Mp.inheritAttrs = !1;
function BI(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    loading: n,
    multiple: o,
    prefixCls: l,
    hasFeedback: r,
    feedbackIcon: a,
    showArrow: i
  } = e, s = e.suffixIcon || t.suffixIcon && t.suffixIcon(), c = e.clearIcon || t.clearIcon && t.clearIcon(), u = e.menuItemSelectedIcon || t.menuItemSelectedIcon && t.menuItemSelectedIcon(), d = e.removeIcon || t.removeIcon && t.removeIcon(), f = c != null ? c : $(jl, null, null), p = (g) => $(Ge, null, [i !== !1 && g, r && a]);
  let m = null;
  if (s !== void 0)
    m = p(s);
  else if (n)
    m = p($(ar, {
      spin: !0
    }, null));
  else {
    const g = `${l}-suffix`;
    m = (y) => {
      let {
        open: b,
        showSearch: C
      } = y;
      return p(b && C ? $(Mp, {
        class: g
      }, null) : $(pd, {
        class: g
      }, null));
    };
  }
  let v = null;
  u !== void 0 ? v = u : o ? v = $(Np, null, null) : v = null;
  let h = null;
  return d !== void 0 ? h = d : h = $(Hl, null, null), {
    clearIcon: f,
    suffixIcon: m,
    itemIcon: v,
    removeIcon: h
  };
}
function FI(e) {
  const t = Symbol("contextKey");
  return {
    useProvide: (l, r) => {
      const a = /* @__PURE__ */ kt({});
      return at(t, a), Ot(() => {
        _(a, l, r || {});
      }), a;
    },
    useInject: () => ze(t, e) || {}
  };
}
const dy = Symbol("ContextProps"), fy = Symbol("InternalContextProps"), QMe = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : O(() => !0);
  const n = /* @__PURE__ */ H(/* @__PURE__ */ new Map()), o = (a, i) => {
    n.value.set(a, i), n.value = new Map(n.value);
  }, l = (a) => {
    n.value.delete(a), n.value = new Map(n.value);
  }, r = xt();
  pe([t, n], () => {
    if (process.env.NODE_ENV !== "production" && t.value && n.value.size > 1) {
      un(!1, "Form.Item", `FormItem can only collect one field item, you haved set ${[...n.value.values()].map((i) => `\`${i.name}\``).join(", ")} ${n.value.size} field items.
        You can set not need to be collected fields into \`a-form-item-rest\``);
      let a = r;
      for (; a.parent; )
        console.warn("at", a.type), a = a.parent;
    }
  }), at(dy, e), at(fy, {
    addFormItemField: o,
    removeFormItemField: l
  });
}, _2 = {
  id: O(() => {
  }),
  onFieldBlur: () => {
  },
  onFieldChange: () => {
  },
  clearValidate: () => {
  }
}, I2 = {
  addFormItemField: () => {
  },
  removeFormItemField: () => {
  }
}, Ko = () => {
  const e = ze(fy, I2), t = Symbol("FormItemFieldKey"), n = xt();
  return e.addFormItemField(t, n.type), yt(() => {
    e.removeFormItemField(t);
  }), at(fy, I2), at(dy, _2), ze(dy, _2);
}, py = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AFormItemRest",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return at(fy, I2), at(dy, _2), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), sl = FI({}), vy = /* @__PURE__ */ le({
  name: "NoFormStatus",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return sl.useProvide({}), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
});
function Ll(e, t, n) {
  return ke({
    [`${e}-status-success`]: t === "success",
    [`${e}-status-warning`]: t === "warning",
    [`${e}-status-error`]: t === "error",
    [`${e}-status-validating`]: t === "validating",
    [`${e}-has-feedback`]: n
  });
}
const Ja = (e, t) => t || e, e8e = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      display: "inline-flex",
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      }
    }
  };
}, t8e = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${t}-item`]: {
        "&:empty": {
          display: "none"
        }
      }
    }
  };
}, Bj = Zt("Space", (e) => [t8e(e), e8e(e)]), n8e = () => ({
  compactSize: String,
  compactDirection: de.oneOf($l("horizontal", "vertical")).def("horizontal"),
  isFirstItem: Qe(),
  isLastItem: Qe()
}), bS = FI(null), Rc = (e, t) => {
  const n = bS.useInject(), o = O(() => {
    if (!n || e7(n)) return "";
    const {
      compactDirection: l,
      isFirstItem: r,
      isLastItem: a
    } = n, i = l === "vertical" ? "-vertical-" : "-";
    return ke({
      [`${e.value}-compact${i}item`]: !0,
      [`${e.value}-compact${i}first-item`]: r,
      [`${e.value}-compact${i}last-item`]: a,
      [`${e.value}-compact${i}item-rtl`]: t.value === "rtl"
    });
  });
  return {
    compactSize: O(() => n == null ? void 0 : n.compactSize),
    compactDirection: O(() => n == null ? void 0 : n.compactDirection),
    compactItemClassnames: o
  };
}, Rm = /* @__PURE__ */ le({
  name: "NoCompactStyle",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return bS.useProvide(null), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), o8e = () => ({
  prefixCls: String,
  size: {
    type: String
  },
  direction: de.oneOf($l("horizontal", "vertical")).def("horizontal"),
  align: de.oneOf($l("start", "end", "center", "baseline")),
  block: {
    type: Boolean,
    default: void 0
  }
}), l8e = /* @__PURE__ */ le({
  name: "CompactItem",
  props: n8e(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return bS.useProvide(e), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), my = /* @__PURE__ */ le({
  name: "ASpaceCompact",
  inheritAttrs: !1,
  props: o8e(),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("space-compact", e), a = bS.useInject(), [i, s] = Bj(l), c = O(() => ke(l.value, s.value, {
      [`${l.value}-rtl`]: r.value === "rtl",
      [`${l.value}-block`]: e.block,
      [`${l.value}-vertical`]: e.direction === "vertical"
    }));
    return () => {
      var u;
      const d = Fn(((u = o.default) === null || u === void 0 ? void 0 : u.call(o)) || []);
      return d.length === 0 ? null : i($("div", Q(Q({}, n), {}, {
        class: [c.value, n.class]
      }), [d.map((f, p) => {
        var m;
        const v = f && f.key || `${l.value}-item-${p}`, h = !a || e7(a);
        return $(l8e, {
          key: v,
          compactSize: (m = e.size) !== null && m !== void 0 ? m : "middle",
          compactDirection: e.direction,
          isFirstItem: p === 0 && (h || (a == null ? void 0 : a.isFirstItem)),
          isLastItem: p === d.length - 1 && (h || (a == null ? void 0 : a.isLastItem))
        }, {
          default: () => [f]
        });
      })]));
    };
  }
}), r8e = (e) => ({
  animationDuration: e,
  animationFillMode: "both"
}), a8e = (e) => ({
  animationDuration: e,
  animationFillMode: "both"
}), _h = function(e, t, n, o) {
  const r = (arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1) ? "&" : "";
  return {
    [`
      ${r}${e}-enter,
      ${r}${e}-appear
    `]: _(_({}, r8e(o)), {
      animationPlayState: "paused"
    }),
    [`${r}${e}-leave`]: _(_({}, a8e(o)), {
      animationPlayState: "paused"
    }),
    [`
      ${r}${e}-enter${e}-enter-active,
      ${r}${e}-appear${e}-appear-active
    `]: {
      animationName: t,
      animationPlayState: "running"
    },
    [`${r}${e}-leave${e}-leave-active`]: {
      animationName: n,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
}, i8e = new mn("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
}), s8e = new mn("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
}), VI = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const {
    antCls: n
  } = e, o = `${n}-fade`, l = t ? "&" : "";
  return [_h(o, i8e, s8e, e.motionDurationMid, t), {
    [`
        ${l}${o}-enter,
        ${l}${o}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${l}${o}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
}, c8e = new mn("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), u8e = new mn("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), d8e = new mn("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), f8e = new mn("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), p8e = new mn("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), v8e = new mn("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), m8e = new mn("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), h8e = new mn("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), g8e = {
  "move-up": {
    inKeyframes: m8e,
    outKeyframes: h8e
  },
  "move-down": {
    inKeyframes: c8e,
    outKeyframes: u8e
  },
  "move-left": {
    inKeyframes: d8e,
    outKeyframes: f8e
  },
  "move-right": {
    inKeyframes: p8e,
    outKeyframes: v8e
  }
}, cp = (e, t) => {
  const {
    antCls: n
  } = e, o = `${n}-${t}`, {
    inKeyframes: l,
    outKeyframes: r
  } = g8e[t];
  return [_h(o, l, r, e.motionDurationMid), {
    [`
        ${o}-enter,
        ${o}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: e.motionEaseOutCirc
    },
    [`${o}-leave`]: {
      animationTimingFunction: e.motionEaseInOutCirc
    }
  }];
}, yS = new mn("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), SS = new mn("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), CS = new mn("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
}), wS = new mn("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
}), b8e = new mn("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), y8e = new mn("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), S8e = new mn("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
}), C8e = new mn("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
}), w8e = {
  "slide-up": {
    inKeyframes: yS,
    outKeyframes: SS
  },
  "slide-down": {
    inKeyframes: CS,
    outKeyframes: wS
  },
  "slide-left": {
    inKeyframes: b8e,
    outKeyframes: y8e
  },
  "slide-right": {
    inKeyframes: S8e,
    outKeyframes: C8e
  }
}, _i = (e, t) => {
  const {
    antCls: n
  } = e, o = `${n}-${t}`, {
    inKeyframes: l,
    outKeyframes: r
  } = w8e[t];
  return [_h(o, l, r, e.motionDurationMid), {
    [`
      ${o}-enter,
      ${o}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: e.motionEaseOutQuint
    },
    [`${o}-leave`]: {
      animationTimingFunction: e.motionEaseInQuint
    }
  }];
}, zI = new mn("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), $8e = new mn("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
}), z8 = new mn("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), H8 = new mn("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
}), x8e = new mn("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
}), E8e = new mn("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
}), O8e = new mn("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
}), _8e = new mn("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
}), I8e = new mn("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
}), T8e = new mn("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
}), P8e = new mn("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
}), k8e = new mn("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
}), N8e = {
  zoom: {
    inKeyframes: zI,
    outKeyframes: $8e
  },
  "zoom-big": {
    inKeyframes: z8,
    outKeyframes: H8
  },
  "zoom-big-fast": {
    inKeyframes: z8,
    outKeyframes: H8
  },
  "zoom-left": {
    inKeyframes: O8e,
    outKeyframes: _8e
  },
  "zoom-right": {
    inKeyframes: I8e,
    outKeyframes: T8e
  },
  "zoom-up": {
    inKeyframes: x8e,
    outKeyframes: E8e
  },
  "zoom-down": {
    inKeyframes: P8e,
    outKeyframes: k8e
  }
}, Ap = (e, t) => {
  const {
    antCls: n
  } = e, o = `${n}-${t}`, {
    inKeyframes: l,
    outKeyframes: r
  } = N8e[t];
  return [_h(o, l, r, t === "zoom-big-fast" ? e.motionDurationFast : e.motionDurationMid), {
    [`
        ${o}-enter,
        ${o}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: e.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${o}-leave`]: {
      animationTimingFunction: e.motionEaseInOutCirc
    }
  }];
}, Ih = (e) => ({
  [e.componentCls]: {
    // For common/openAnimation
    [`${e.antCls}-motion-collapse-legacy`]: {
      overflow: "hidden",
      "&-active": {
        transition: `height ${e.motionDurationMid} ${e.motionEaseInOut},
        opacity ${e.motionDurationMid} ${e.motionEaseInOut} !important`
      }
    },
    [`${e.antCls}-motion-collapse`]: {
      overflow: "hidden",
      transition: `height ${e.motionDurationMid} ${e.motionEaseInOut},
        opacity ${e.motionDurationMid} ${e.motionEaseInOut} !important`
    }
  }
}), j8 = (e) => {
  const {
    controlPaddingHorizontal: t
  } = e;
  return {
    position: "relative",
    display: "block",
    minHeight: e.controlHeight,
    padding: `${(e.controlHeight - e.fontSize * e.lineHeight) / 2}px ${t}px`,
    color: e.colorText,
    fontWeight: "normal",
    fontSize: e.fontSize,
    lineHeight: e.lineHeight,
    boxSizing: "border-box"
  };
}, M8e = (e) => {
  const {
    antCls: t,
    componentCls: n
  } = e, o = `${n}-item`;
  return [
    {
      [`${n}-dropdown`]: _(_({}, nn(e)), {
        position: "absolute",
        top: -9999,
        zIndex: e.zIndexPopup,
        boxSizing: "border-box",
        padding: e.paddingXXS,
        overflow: "hidden",
        fontSize: e.fontSize,
        // Fix select render lag of long text in chrome
        // https://github.com/ant-design/ant-design/issues/11456
        // https://github.com/ant-design/ant-design/issues/11843
        fontVariant: "initial",
        backgroundColor: e.colorBgElevated,
        borderRadius: e.borderRadiusLG,
        outline: "none",
        boxShadow: e.boxShadowSecondary,
        [`
            &${t}-slide-up-enter${t}-slide-up-enter-active${n}-dropdown-placement-bottomLeft,
            &${t}-slide-up-appear${t}-slide-up-appear-active${n}-dropdown-placement-bottomLeft
          `]: {
          animationName: yS
        },
        [`
            &${t}-slide-up-enter${t}-slide-up-enter-active${n}-dropdown-placement-topLeft,
            &${t}-slide-up-appear${t}-slide-up-appear-active${n}-dropdown-placement-topLeft
          `]: {
          animationName: CS
        },
        [`&${t}-slide-up-leave${t}-slide-up-leave-active${n}-dropdown-placement-bottomLeft`]: {
          animationName: SS
        },
        [`&${t}-slide-up-leave${t}-slide-up-leave-active${n}-dropdown-placement-topLeft`]: {
          animationName: wS
        },
        "&-hidden": {
          display: "none"
        },
        "&-empty": {
          color: e.colorTextDisabled
        },
        // ========================= Options =========================
        [`${o}-empty`]: _(_({}, j8(e)), {
          color: e.colorTextDisabled
        }),
        [`${o}`]: _(_({}, j8(e)), {
          cursor: "pointer",
          transition: `background ${e.motionDurationSlow} ease`,
          borderRadius: e.borderRadiusSM,
          // =========== Group ============
          "&-group": {
            color: e.colorTextDescription,
            fontSize: e.fontSizeSM,
            cursor: "default"
          },
          // =========== Option ===========
          "&-option": {
            display: "flex",
            "&-content": _({
              flex: "auto"
            }, Fo),
            "&-state": {
              flex: "none"
            },
            [`&-active:not(${o}-option-disabled)`]: {
              backgroundColor: e.controlItemBgHover
            },
            [`&-selected:not(${o}-option-disabled)`]: {
              color: e.colorText,
              fontWeight: e.fontWeightStrong,
              backgroundColor: e.controlItemBgActive,
              [`${o}-option-state`]: {
                color: e.colorPrimary
              }
            },
            "&-disabled": {
              [`&${o}-option-selected`]: {
                backgroundColor: e.colorBgContainerDisabled
              },
              color: e.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: e.controlPaddingHorizontal * 2
            }
          }
        }),
        // =========================== RTL ===========================
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Follow code may reuse in other components
    _i(e, "slide-up"),
    _i(e, "slide-down"),
    cp(e, "move-up"),
    cp(e, "move-down")
  ];
}, Nd = 2;
function Fj(e) {
  let {
    controlHeightSM: t,
    controlHeight: n,
    lineWidth: o
  } = e;
  const l = (n - t) / 2 - o, r = Math.ceil(l / 2);
  return [l, r];
}
function xw(e, t) {
  const {
    componentCls: n,
    iconCls: o
  } = e, l = `${n}-selection-overflow`, r = e.controlHeightSM, [a] = Fj(e), i = t ? `${n}-${t}` : "";
  return {
    [`${n}-multiple${i}`]: {
      fontSize: e.fontSize,
      /**
       * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
       * may update to redesign with its align logic.
       */
      // =========================== Overflow ===========================
      [l]: {
        position: "relative",
        display: "flex",
        flex: "auto",
        flexWrap: "wrap",
        maxWidth: "100%",
        "&-item": {
          flex: "none",
          alignSelf: "center",
          maxWidth: "100%",
          display: "inline-flex"
        }
      },
      // ========================= Selector =========================
      [`${n}-selector`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        // Multiple is little different that horizontal is follow the vertical
        padding: `${a - Nd}px ${Nd * 2}px`,
        borderRadius: e.borderRadius,
        [`${n}-show-search&`]: {
          cursor: "text"
        },
        [`${n}-disabled&`]: {
          background: e.colorBgContainerDisabled,
          cursor: "not-allowed"
        },
        "&:after": {
          display: "inline-block",
          width: 0,
          margin: `${Nd}px 0`,
          lineHeight: `${r}px`,
          content: '"\\a0"'
        }
      },
      [`
        &${n}-show-arrow ${n}-selector,
        &${n}-allow-clear ${n}-selector
      `]: {
        paddingInlineEnd: e.fontSizeIcon + e.controlPaddingHorizontal
      },
      // ======================== Selections ========================
      [`${n}-selection-item`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        height: r,
        marginTop: Nd,
        marginBottom: Nd,
        lineHeight: `${r - e.lineWidth * 2}px`,
        background: e.colorFillSecondary,
        border: `${e.lineWidth}px solid ${e.colorSplit}`,
        borderRadius: e.borderRadiusSM,
        cursor: "default",
        transition: `font-size ${e.motionDurationSlow}, line-height ${e.motionDurationSlow}, height ${e.motionDurationSlow}`,
        userSelect: "none",
        marginInlineEnd: Nd * 2,
        paddingInlineStart: e.paddingXS,
        paddingInlineEnd: e.paddingXS / 2,
        [`${n}-disabled&`]: {
          color: e.colorTextDisabled,
          borderColor: e.colorBorder,
          cursor: "not-allowed"
        },
        // It's ok not to do this, but 24px makes bottom narrow in view should adjust
        "&-content": {
          display: "inline-block",
          marginInlineEnd: e.paddingXS / 2,
          overflow: "hidden",
          whiteSpace: "pre",
          textOverflow: "ellipsis"
        },
        "&-remove": _(_({}, cd()), {
          display: "inline-block",
          color: e.colorIcon,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${o}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: e.colorIconHover
          }
        })
      },
      // ========================== Input ==========================
      [`${l}-item + ${l}-item`]: {
        [`${n}-selection-search`]: {
          marginInlineStart: 0
        }
      },
      [`${n}-selection-search`]: {
        display: "inline-flex",
        position: "relative",
        maxWidth: "100%",
        marginInlineStart: e.inputPaddingHorizontalBase - a,
        "\n          &-input,\n          &-mirror\n        ": {
          height: r,
          fontFamily: e.fontFamily,
          lineHeight: `${r}px`,
          transition: `all ${e.motionDurationSlow}`
        },
        "&-input": {
          width: "100%",
          minWidth: 4.1
          // fix search cursor missing
        },
        "&-mirror": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          insetInlineEnd: "auto",
          zIndex: 999,
          whiteSpace: "pre",
          visibility: "hidden"
        }
      },
      // ======================= Placeholder =======================
      [`${n}-selection-placeholder `]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: e.inputPaddingHorizontalBase,
        insetInlineEnd: e.inputPaddingHorizontalBase,
        transform: "translateY(-50%)",
        transition: `all ${e.motionDurationSlow}`
      }
    }
  };
}
function A8e(e) {
  const {
    componentCls: t
  } = e, n = Vt(e, {
    controlHeight: e.controlHeightSM,
    controlHeightSM: e.controlHeightXS,
    borderRadius: e.borderRadiusSM,
    borderRadiusSM: e.borderRadiusXS
  }), [, o] = Fj(e);
  return [
    xw(e),
    // ======================== Small ========================
    // Shared
    xw(n, "sm"),
    // Padding
    {
      [`${t}-multiple${t}-sm`]: {
        [`${t}-selection-placeholder`]: {
          insetInlineStart: e.controlPaddingHorizontalSM - e.lineWidth,
          insetInlineEnd: "auto"
        },
        // https://github.com/ant-design/ant-design/issues/29559
        [`${t}-selection-search`]: {
          marginInlineStart: o
        }
      }
    },
    // ======================== Large ========================
    // Shared
    xw(Vt(e, {
      fontSize: e.fontSizeLG,
      controlHeight: e.controlHeightLG,
      controlHeightSM: e.controlHeight,
      borderRadius: e.borderRadiusLG,
      borderRadiusSM: e.borderRadius
    }), "lg")
  ];
}
function Ew(e, t) {
  const {
    componentCls: n,
    inputPaddingHorizontalBase: o,
    borderRadius: l
  } = e, r = e.controlHeight - e.lineWidth * 2, a = Math.ceil(e.fontSize * 1.25), i = t ? `${n}-${t}` : "";
  return {
    [`${n}-single${i}`]: {
      fontSize: e.fontSize,
      // ========================= Selector =========================
      [`${n}-selector`]: _(_({}, nn(e)), {
        display: "flex",
        borderRadius: l,
        [`${n}-selection-search`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: o,
          insetInlineEnd: o,
          bottom: 0,
          "&-input": {
            width: "100%"
          }
        },
        [`
          ${n}-selection-item,
          ${n}-selection-placeholder
        `]: {
          padding: 0,
          lineHeight: `${r}px`,
          transition: `all ${e.motionDurationSlow}`,
          // Firefox inline-block position calculation is not same as Chrome & Safari. Patch this:
          "@supports (-moz-appearance: meterbar)": {
            lineHeight: `${r}px`
          }
        },
        [`${n}-selection-item`]: {
          position: "relative",
          userSelect: "none"
        },
        [`${n}-selection-placeholder`]: {
          transition: "none",
          pointerEvents: "none"
        },
        // For common baseline align
        [[
          "&:after",
          /* For '' value baseline align */
          `${n}-selection-item:after`,
          /* For undefined value baseline align */
          `${n}-selection-placeholder:after`
        ].join(",")]: {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        }
      }),
      [`
        &${n}-show-arrow ${n}-selection-item,
        &${n}-show-arrow ${n}-selection-placeholder
      `]: {
        paddingInlineEnd: a
      },
      // Opacity selection if open
      [`&${n}-open ${n}-selection-item`]: {
        color: e.colorTextPlaceholder
      },
      // ========================== Input ==========================
      // We only change the style of non-customize input which is only support by `combobox` mode.
      // Not customize
      [`&:not(${n}-customize-input)`]: {
        [`${n}-selector`]: {
          width: "100%",
          height: e.controlHeight,
          padding: `0 ${o}px`,
          [`${n}-selection-search-input`]: {
            height: r
          },
          "&:after": {
            lineHeight: `${r}px`
          }
        }
      },
      [`&${n}-customize-input`]: {
        [`${n}-selector`]: {
          "&:after": {
            display: "none"
          },
          [`${n}-selection-search`]: {
            position: "static",
            width: "100%"
          },
          [`${n}-selection-placeholder`]: {
            position: "absolute",
            insetInlineStart: 0,
            insetInlineEnd: 0,
            padding: `0 ${o}px`,
            "&:after": {
              display: "none"
            }
          }
        }
      }
    }
  };
}
function R8e(e) {
  const {
    componentCls: t
  } = e, n = e.controlPaddingHorizontalSM - e.lineWidth;
  return [
    Ew(e),
    // ======================== Small ========================
    // Shared
    Ew(Vt(e, {
      controlHeight: e.controlHeightSM,
      borderRadius: e.borderRadiusSM
    }), "sm"),
    // padding
    {
      [`${t}-single${t}-sm`]: {
        [`&:not(${t}-customize-input)`]: {
          [`${t}-selection-search`]: {
            insetInlineStart: n,
            insetInlineEnd: n
          },
          [`${t}-selector`]: {
            padding: `0 ${n}px`
          },
          // With arrow should provides `padding-right` to show the arrow
          [`&${t}-show-arrow ${t}-selection-search`]: {
            insetInlineEnd: n + e.fontSize * 1.5
          },
          [`
            &${t}-show-arrow ${t}-selection-item,
            &${t}-show-arrow ${t}-selection-placeholder
          `]: {
            paddingInlineEnd: e.fontSize * 1.5
          }
        }
      }
    },
    // ======================== Large ========================
    // Shared
    Ew(Vt(e, {
      controlHeight: e.controlHeightLG,
      fontSize: e.fontSizeLG,
      borderRadius: e.borderRadiusLG
    }), "lg")
  ];
}
function D8e(e, t, n) {
  const {
    focusElCls: o,
    focus: l,
    borderElCls: r
  } = n, a = r ? "> *" : "", i = ["hover", l ? "focus" : null, "active"].filter(Boolean).map((s) => `&:${s} ${a}`).join(",");
  return {
    [`&-item:not(${t}-last-item)`]: {
      marginInlineEnd: -e.lineWidth
    },
    "&-item": _(_({
      [i]: {
        zIndex: 2
      }
    }, o ? {
      [`&${o}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${a}`]: {
        zIndex: 0
      }
    })
  };
}
function L8e(e, t, n) {
  const {
    borderElCls: o
  } = n, l = o ? `> ${o}` : "";
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item) ${l}`]: {
      borderRadius: 0
    },
    [`&-item:not(${t}-last-item)${t}-first-item`]: {
      [`& ${l}, &${e}-sm ${l}, &${e}-lg ${l}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${t}-first-item)${t}-last-item`]: {
      [`& ${l}, &${e}-sm ${l}, &${e}-lg ${l}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function Rp(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: !0
  };
  const {
    componentCls: n
  } = e, o = `${n}-compact`;
  return {
    [o]: _(_({}, D8e(e, o, t)), L8e(n, o, t))
  };
}
const B8e = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    position: "relative",
    backgroundColor: e.colorBgContainer,
    border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
    transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
    input: {
      cursor: "pointer"
    },
    [`${t}-show-search&`]: {
      cursor: "text",
      input: {
        cursor: "auto",
        color: "inherit"
      }
    },
    [`${t}-disabled&`]: {
      color: e.colorTextDisabled,
      background: e.colorBgContainerDisabled,
      cursor: "not-allowed",
      [`${t}-multiple&`]: {
        background: e.colorBgContainerDisabled
      },
      input: {
        cursor: "not-allowed"
      }
    }
  };
}, Ow = function(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  const {
    componentCls: o,
    borderHoverColor: l,
    outlineColor: r,
    antCls: a
  } = t, i = n ? {
    [`${o}-selector`]: {
      borderColor: l
    }
  } : {};
  return {
    [e]: {
      [`&:not(${o}-disabled):not(${o}-customize-input):not(${a}-pagination-size-changer)`]: _(_({}, i), {
        [`${o}-focused& ${o}-selector`]: {
          borderColor: l,
          boxShadow: `0 0 0 ${t.controlOutlineWidth}px ${r}`,
          borderInlineEndWidth: `${t.controlLineWidth}px !important`,
          outline: 0
        },
        [`&:hover ${o}-selector`]: {
          borderColor: l,
          borderInlineEndWidth: `${t.controlLineWidth}px !important`
        }
      })
    }
  };
}, F8e = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-selection-search-input`]: {
      margin: 0,
      padding: 0,
      background: "transparent",
      border: "none",
      outline: "none",
      appearance: "none",
      "&::-webkit-search-cancel-button": {
        display: "none",
        "-webkit-appearance": "none"
      }
    }
  };
}, V8e = (e) => {
  const {
    componentCls: t,
    inputPaddingHorizontalBase: n,
    iconCls: o
  } = e;
  return {
    [t]: _(_({}, nn(e)), {
      position: "relative",
      display: "inline-block",
      cursor: "pointer",
      [`&:not(${t}-customize-input) ${t}-selector`]: _(_({}, B8e(e)), F8e(e)),
      // [`&:not(&-disabled):hover ${selectCls}-selector`]: {
      //   ...genHoverStyle(token),
      // },
      // ======================== Selection ========================
      [`${t}-selection-item`]: _({
        flex: 1,
        fontWeight: "normal"
      }, Fo),
      // ======================= Placeholder =======================
      [`${t}-selection-placeholder`]: _(_({}, Fo), {
        flex: 1,
        color: e.colorTextPlaceholder,
        pointerEvents: "none"
      }),
      // ========================== Arrow ==========================
      [`${t}-arrow`]: _(_({}, cd()), {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: n,
        height: e.fontSizeIcon,
        marginTop: -e.fontSizeIcon / 2,
        color: e.colorTextQuaternary,
        fontSize: e.fontSizeIcon,
        lineHeight: 1,
        textAlign: "center",
        pointerEvents: "none",
        display: "flex",
        alignItems: "center",
        [o]: {
          verticalAlign: "top",
          transition: `transform ${e.motionDurationSlow}`,
          "> svg": {
            verticalAlign: "top"
          },
          [`&:not(${t}-suffix)`]: {
            pointerEvents: "auto"
          }
        },
        [`${t}-disabled &`]: {
          cursor: "not-allowed"
        },
        "> *:not(:last-child)": {
          marginInlineEnd: 8
          // FIXME: magic
        }
      }),
      // ========================== Clear ==========================
      [`${t}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: n,
        zIndex: 1,
        display: "inline-block",
        width: e.fontSizeIcon,
        height: e.fontSizeIcon,
        marginTop: -e.fontSizeIcon / 2,
        color: e.colorTextQuaternary,
        fontSize: e.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        background: e.colorBgContainer,
        cursor: "pointer",
        opacity: 0,
        transition: `color ${e.motionDurationMid} ease, opacity ${e.motionDurationSlow} ease`,
        textRendering: "auto",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: e.colorTextTertiary
        }
      },
      "&:hover": {
        [`${t}-clear`]: {
          opacity: 1
        }
      }
    }),
    // ========================= Feedback ==========================
    [`${t}-has-feedback`]: {
      [`${t}-clear`]: {
        insetInlineEnd: n + e.fontSize + e.paddingXXS
      }
    }
  };
}, z8e = (e) => {
  const {
    componentCls: t
  } = e;
  return [
    {
      [t]: {
        // ==================== BorderLess ====================
        [`&-borderless ${t}-selector`]: {
          backgroundColor: "transparent !important",
          borderColor: "transparent !important",
          boxShadow: "none !important"
        },
        // ==================== In Form ====================
        [`&${t}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    // =====================================================
    // ==                       LTR                       ==
    // =====================================================
    // Base
    V8e(e),
    // Single
    R8e(e),
    // Multiple
    A8e(e),
    // Dropdown
    M8e(e),
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${t}-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==                     Status                      ==
    // =====================================================
    Ow(t, Vt(e, {
      borderHoverColor: e.colorPrimaryHover,
      outlineColor: e.controlOutline
    })),
    Ow(`${t}-status-error`, Vt(e, {
      borderHoverColor: e.colorErrorHover,
      outlineColor: e.colorErrorOutline
    }), !0),
    Ow(`${t}-status-warning`, Vt(e, {
      borderHoverColor: e.colorWarningHover,
      outlineColor: e.colorWarningOutline
    }), !0),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    Rp(e, {
      borderElCls: `${t}-selector`,
      focusElCls: `${t}-focused`
    })
  ];
}, HI = Zt("Select", (e, t) => {
  let {
    rootPrefixCls: n
  } = t;
  const o = Vt(e, {
    rootPrefixCls: n,
    inputPaddingHorizontalBase: e.paddingSM - 1
  });
  return [z8e(o)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 50
})), $S = () => _(_({}, pn(Tj(), ["inputIcon", "mode", "getInputElement", "getRawInputElement", "backfill"])), {
  value: zt([Array, Object, String, Number]),
  defaultValue: zt([Array, Object, String, Number]),
  notFoundContent: de.any,
  suffixIcon: de.any,
  itemIcon: de.any,
  size: At(),
  mode: At(),
  bordered: Qe(!0),
  transitionName: String,
  choiceTransitionName: At(""),
  popupClassName: String,
  /** @deprecated Please use `popupClassName` instead */
  dropdownClassName: String,
  placement: At(),
  status: At(),
  "onUpdate:value": Fe()
}), W8 = "SECRET_COMBOBOX_MODE_DO_NOT_USE", pl = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ASelect",
  Option: AI,
  OptGroup: RI,
  inheritAttrs: !1,
  props: sn($S(), {
    listHeight: 256,
    listItemHeight: 24
  }),
  SECRET_COMBOBOX_MODE_DO_NOT_USE: W8,
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      slots: l,
      expose: r
    } = t;
    const a = /* @__PURE__ */ H(), i = Ko(), s = sl.useInject(), c = O(() => Ja(s.status, e.status)), u = () => {
      var V;
      (V = a.value) === null || V === void 0 || V.focus();
    }, d = () => {
      var V;
      (V = a.value) === null || V === void 0 || V.blur();
    }, f = (V) => {
      var j;
      (j = a.value) === null || j === void 0 || j.scrollTo(V);
    }, p = O(() => {
      const {
        mode: V
      } = e;
      if (V !== "combobox")
        return V === W8 ? "combobox" : V;
    });
    process.env.NODE_ENV !== "production" && un(!e.dropdownClassName, "Select", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
    const {
      prefixCls: m,
      direction: v,
      renderEmpty: h,
      size: g,
      getPrefixCls: y,
      getPopupContainer: b,
      disabled: C,
      select: w
    } = bt("select", e), {
      compactSize: x,
      compactItemClassnames: E
    } = Rc(m, v), I = O(() => x.value || g.value), T = Cr(), P = O(() => {
      var V;
      return (V = C.value) !== null && V !== void 0 ? V : T.value;
    }), [k, N] = HI(m), R = O(() => y()), z = O(() => e.placement !== void 0 ? e.placement : v.value === "rtl" ? "bottomRight" : "bottomLeft"), D = O(() => Vl(R.value, xI(z.value), e.transitionName)), F = O(() => ke({
      [`${m.value}-lg`]: I.value === "large",
      [`${m.value}-sm`]: I.value === "small",
      [`${m.value}-rtl`]: v.value === "rtl",
      [`${m.value}-borderless`]: !e.bordered,
      [`${m.value}-in-form-item`]: s.isFormItemInput
    }, Ll(m.value, c.value, s.hasFeedback), E.value, N.value)), M = function() {
      for (var V = arguments.length, j = new Array(V), W = 0; W < V; W++)
        j[W] = arguments[W];
      o("update:value", j[0]), o("change", ...j), i.onFieldChange();
    }, A = (V) => {
      o("blur", V), i.onFieldBlur();
    };
    r({
      blur: d,
      focus: u,
      scrollTo: f
    });
    const L = O(() => p.value === "multiple" || p.value === "tags"), B = O(() => e.showArrow !== void 0 ? e.showArrow : e.loading || !(L.value || p.value === "combobox"));
    return () => {
      var V, j, W, Y;
      const {
        notFoundContent: U,
        listHeight: te = 256,
        listItemHeight: J = 24,
        popupClassName: re,
        dropdownClassName: oe,
        virtual: q,
        dropdownMatchSelectWidth: K,
        id: se = i.id.value,
        placeholder: Z = (V = l.placeholder) === null || V === void 0 ? void 0 : V.call(l),
        showArrow: ee
      } = e, {
        hasFeedback: fe,
        feedbackIcon: me
      } = s;
      let ge;
      U !== void 0 ? ge = U : l.notFoundContent ? ge = l.notFoundContent() : p.value === "combobox" ? ge = null : ge = (h == null ? void 0 : h("Select")) || $(fI, {
        componentName: "Select"
      }, null);
      const {
        suffixIcon: he,
        itemIcon: $e,
        removeIcon: ne,
        clearIcon: ae
      } = BI(_(_({}, e), {
        multiple: L.value,
        prefixCls: m.value,
        hasFeedback: fe,
        feedbackIcon: me,
        showArrow: B.value
      }), l), ce = pn(e, ["prefixCls", "suffixIcon", "itemIcon", "removeIcon", "clearIcon", "size", "bordered", "status"]), xe = ke(re || oe, {
        [`${m.value}-dropdown-${v.value}`]: v.value === "rtl"
      }, N.value);
      return k($(rMe, Q(Q(Q({
        ref: a,
        virtual: q,
        dropdownMatchSelectWidth: K
      }, ce), n), {}, {
        showSearch: (j = e.showSearch) !== null && j !== void 0 ? j : (W = w == null ? void 0 : w.value) === null || W === void 0 ? void 0 : W.showSearch,
        placeholder: Z,
        listHeight: te,
        listItemHeight: J,
        mode: p.value,
        prefixCls: m.value,
        direction: v.value,
        inputIcon: he,
        menuItemSelectedIcon: $e,
        removeIcon: ne,
        clearIcon: ae,
        notFoundContent: ge,
        class: [F.value, n.class],
        getPopupContainer: b == null ? void 0 : b.value,
        dropdownClassName: xe,
        onChange: M,
        onBlur: A,
        id: se,
        dropdownRender: ce.dropdownRender || l.dropdownRender,
        transitionName: D.value,
        children: (Y = l.default) === null || Y === void 0 ? void 0 : Y.call(l),
        tagRender: e.tagRender || l.tagRender,
        optionLabelRender: l.optionLabel,
        maxTagPlaceholder: e.maxTagPlaceholder || l.maxTagPlaceholder,
        showArrow: fe || ee,
        disabled: P.value
      }), {
        option: l.option
      }));
    };
  }
});
pl.install = function(e) {
  return e.component(pl.name, pl), e.component(pl.Option.displayName, pl.Option), e.component(pl.OptGroup.displayName, pl.OptGroup), e;
};
const H8e = pl.Option, j8e = pl.OptGroup, uc = () => null;
uc.isSelectOption = !0;
uc.displayName = "AAutoCompleteOption";
const wf = () => null;
wf.isSelectOptGroup = !0;
wf.displayName = "AAutoCompleteOptGroup";
function W8e(e) {
  var t, n;
  return ((t = e == null ? void 0 : e.type) === null || t === void 0 ? void 0 : t.isSelectOption) || ((n = e == null ? void 0 : e.type) === null || n === void 0 ? void 0 : n.isSelectOptGroup);
}
const K8e = () => _(_({}, pn($S(), ["loading", "mode", "optionLabelProp", "labelInValue"])), {
  dataSource: Array,
  dropdownMenuStyle: {
    type: Object,
    default: void 0
  },
  // optionLabelProp: String,
  dropdownMatchSelectWidth: {
    type: [Number, Boolean],
    default: !0
  },
  prefixCls: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  transitionName: String,
  choiceTransitionName: {
    type: String,
    default: "zoom"
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  backfill: {
    type: Boolean,
    default: void 0
  },
  // optionLabelProp: PropTypes.string.def('children'),
  filterOption: {
    type: [Boolean, Function],
    default: !1
  },
  defaultActiveFirstOption: {
    type: Boolean,
    default: !0
  },
  status: String
}), U8e = uc, G8e = wf, _w = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AAutoComplete",
  inheritAttrs: !1,
  props: K8e(),
  // emits: ['change', 'select', 'focus', 'blur'],
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: l
    } = t;
    Hn(!("dataSource" in n), "AutoComplete", "`dataSource` slot is deprecated, please use props `options` instead."), Hn(!("options" in n), "AutoComplete", "`options` slot is deprecated, please use props `options` instead."), Hn(!e.dropdownClassName, "AutoComplete", "`dropdownClassName` is deprecated, please use `popupClassName` instead.");
    const r = /* @__PURE__ */ H(), a = () => {
      var u;
      const d = Fn((u = n.default) === null || u === void 0 ? void 0 : u.call(n));
      return d.length ? d[0] : void 0;
    };
    l({
      focus: () => {
        var u;
        (u = r.value) === null || u === void 0 || u.focus();
      },
      blur: () => {
        var u;
        (u = r.value) === null || u === void 0 || u.blur();
      }
    });
    const {
      prefixCls: c
    } = bt("select", e);
    return () => {
      var u, d, f;
      const {
        size: p,
        dataSource: m,
        notFoundContent: v = (u = n.notFoundContent) === null || u === void 0 ? void 0 : u.call(n)
      } = e;
      let h;
      const {
        class: g
      } = o, y = {
        [g]: !!g,
        [`${c.value}-lg`]: p === "large",
        [`${c.value}-sm`]: p === "small",
        [`${c.value}-show-search`]: !0,
        [`${c.value}-auto-complete`]: !0
      };
      if (e.options === void 0) {
        const C = ((d = n.dataSource) === null || d === void 0 ? void 0 : d.call(n)) || ((f = n.options) === null || f === void 0 ? void 0 : f.call(n)) || [];
        C.length && W8e(C[0]) ? h = C : h = m ? m.map((w) => {
          if (Io(w))
            return w;
          switch (typeof w) {
            case "string":
              return $(uc, {
                key: w,
                value: w
              }, {
                default: () => [w]
              });
            case "object":
              return $(uc, {
                key: w.value,
                value: w.value
              }, {
                default: () => [w.text]
              });
            default:
              throw new Error("AutoComplete[dataSource] only supports type `string[] | Object[]`.");
          }
        }) : [];
      }
      const b = pn(_(_(_({}, e), o), {
        mode: pl.SECRET_COMBOBOX_MODE_DO_NOT_USE,
        // optionLabelProp,
        getInputElement: a,
        notFoundContent: v,
        // placeholder: '',
        class: y,
        popupClassName: e.popupClassName || e.dropdownClassName,
        ref: r
      }), ["dataSource", "loading"]);
      return $(pl, b, Q({
        default: () => [h]
      }, pn(n, ["default", "dataSource", "options"])));
    };
  }
}), Y8e = _(_w, {
  Option: uc,
  OptGroup: wf,
  install(e) {
    return e.component(_w.name, _w), e.component(uc.displayName, uc), e.component(wf.displayName, wf), e;
  }
});
var X8e = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z" } }, { tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, name: "check-circle", theme: "outlined" };
function K8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      q8e(e, l, n[l]);
    });
  }
  return e;
}
function q8e(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var xS = function(t, n) {
  var o = K8({}, t, n.attrs);
  return $(cn, K8({}, o, {
    icon: X8e
  }), null);
};
xS.displayName = "CheckCircleOutlined";
xS.inheritAttrs = !1;
var J8e = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, name: "exclamation-circle", theme: "outlined" };
function U8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      Z8e(e, l, n[l]);
    });
  }
  return e;
}
function Z8e(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var ES = function(t, n) {
  var o = U8({}, t, n.attrs);
  return $(cn, U8({}, o, {
    icon: J8e
  }), null);
};
ES.displayName = "ExclamationCircleOutlined";
ES.inheritAttrs = !1;
var Q8e = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z" } }] }, name: "info-circle", theme: "outlined" };
function G8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      e6e(e, l, n[l]);
    });
  }
  return e;
}
function e6e(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var OS = function(t, n) {
  var o = G8({}, t, n.attrs);
  return $(cn, G8({}, o, {
    icon: Q8e
  }), null);
};
OS.displayName = "InfoCircleOutlined";
OS.inheritAttrs = !1;
var t6e = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm0 76c-205.4 0-372 166.6-372 372s166.6 372 372 372 372-166.6 372-372-166.6-372-372-372zm128.01 198.83c.03 0 .05.01.09.06l45.02 45.01a.2.2 0 01.05.09.12.12 0 010 .07c0 .02-.01.04-.05.08L557.25 512l127.87 127.86a.27.27 0 01.05.06v.02a.12.12 0 010 .07c0 .03-.01.05-.05.09l-45.02 45.02a.2.2 0 01-.09.05.12.12 0 01-.07 0c-.02 0-.04-.01-.08-.05L512 557.25 384.14 685.12c-.04.04-.06.05-.08.05a.12.12 0 01-.07 0c-.03 0-.05-.01-.09-.05l-45.02-45.02a.2.2 0 01-.05-.09.12.12 0 010-.07c0-.02.01-.04.06-.08L466.75 512 338.88 384.14a.27.27 0 01-.05-.06l-.01-.02a.12.12 0 010-.07c0-.03.01-.05.05-.09l45.02-45.02a.2.2 0 01.09-.05.12.12 0 01.07 0c.02 0 .04.01.08.06L512 466.75l127.86-127.86c.04-.05.06-.06.08-.06a.12.12 0 01.07 0z" } }] }, name: "close-circle", theme: "outlined" };
function Y8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      n6e(e, l, n[l]);
    });
  }
  return e;
}
function n6e(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var _S = function(t, n) {
  var o = Y8({}, t, n.attrs);
  return $(cn, Y8({}, o, {
    icon: t6e
  }), null);
};
_S.displayName = "CloseCircleOutlined";
_S.inheritAttrs = !1;
var o6e = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, name: "check-circle", theme: "filled" };
function X8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      l6e(e, l, n[l]);
    });
  }
  return e;
}
function l6e(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Za = function(t, n) {
  var o = X8({}, t, n.attrs);
  return $(cn, X8({}, o, {
    icon: o6e
  }), null);
};
Za.displayName = "CheckCircleFilled";
Za.inheritAttrs = !1;
var r6e = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "exclamation-circle", theme: "filled" };
function q8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      a6e(e, l, n[l]);
    });
  }
  return e;
}
function a6e(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Qa = function(t, n) {
  var o = q8({}, t, n.attrs);
  return $(cn, q8({}, o, {
    icon: r6e
  }), null);
};
Qa.displayName = "ExclamationCircleFilled";
Qa.inheritAttrs = !1;
var i6e = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "info-circle", theme: "filled" };
function J8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      s6e(e, l, n[l]);
    });
  }
  return e;
}
function s6e(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Dc = function(t, n) {
  var o = J8({}, t, n.attrs);
  return $(cn, J8({}, o, {
    icon: i6e
  }), null);
};
Dc.displayName = "InfoCircleFilled";
Dc.inheritAttrs = !1;
const kg = (e, t, n, o, l) => ({
  backgroundColor: e,
  border: `${o.lineWidth}px ${o.lineType} ${t}`,
  [`${l}-icon`]: {
    color: n
  }
}), c6e = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    marginXS: o,
    marginSM: l,
    fontSize: r,
    fontSizeLG: a,
    lineHeight: i,
    borderRadiusLG: s,
    motionEaseInOutCirc: c,
    alertIconSizeLG: u,
    colorText: d,
    paddingContentVerticalSM: f,
    alertPaddingHorizontal: p,
    paddingMD: m,
    paddingContentHorizontalLG: v
  } = e;
  return {
    [t]: _(_({}, nn(e)), {
      position: "relative",
      display: "flex",
      alignItems: "center",
      padding: `${f}px ${p}px`,
      wordWrap: "break-word",
      borderRadius: s,
      [`&${t}-rtl`]: {
        direction: "rtl"
      },
      [`${t}-content`]: {
        flex: 1,
        minWidth: 0
      },
      [`${t}-icon`]: {
        marginInlineEnd: o,
        lineHeight: 0
      },
      "&-description": {
        display: "none",
        fontSize: r,
        lineHeight: i
      },
      "&-message": {
        color: d
      },
      [`&${t}-motion-leave`]: {
        overflow: "hidden",
        opacity: 1,
        transition: `max-height ${n} ${c}, opacity ${n} ${c},
        padding-top ${n} ${c}, padding-bottom ${n} ${c},
        margin-bottom ${n} ${c}`
      },
      [`&${t}-motion-leave-active`]: {
        maxHeight: 0,
        marginBottom: "0 !important",
        paddingTop: 0,
        paddingBottom: 0,
        opacity: 0
      }
    }),
    [`${t}-with-description`]: {
      alignItems: "flex-start",
      paddingInline: v,
      paddingBlock: m,
      [`${t}-icon`]: {
        marginInlineEnd: l,
        fontSize: u,
        lineHeight: 0
      },
      [`${t}-message`]: {
        display: "block",
        marginBottom: o,
        color: d,
        fontSize: a
      },
      [`${t}-description`]: {
        display: "block"
      }
    },
    [`${t}-banner`]: {
      marginBottom: 0,
      border: "0 !important",
      borderRadius: 0
    }
  };
}, u6e = (e) => {
  const {
    componentCls: t,
    colorSuccess: n,
    colorSuccessBorder: o,
    colorSuccessBg: l,
    colorWarning: r,
    colorWarningBorder: a,
    colorWarningBg: i,
    colorError: s,
    colorErrorBorder: c,
    colorErrorBg: u,
    colorInfo: d,
    colorInfoBorder: f,
    colorInfoBg: p
  } = e;
  return {
    [t]: {
      "&-success": kg(l, o, n, e, t),
      "&-info": kg(p, f, d, e, t),
      "&-warning": kg(i, a, r, e, t),
      "&-error": _(_({}, kg(u, c, s, e, t)), {
        [`${t}-description > pre`]: {
          margin: 0,
          padding: 0
        }
      })
    }
  };
}, d6e = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    motionDurationMid: o,
    marginXS: l,
    fontSizeIcon: r,
    colorIcon: a,
    colorIconHover: i
  } = e;
  return {
    [t]: {
      "&-action": {
        marginInlineStart: l
      },
      [`${t}-close-icon`]: {
        marginInlineStart: l,
        padding: 0,
        overflow: "hidden",
        fontSize: r,
        lineHeight: `${r}px`,
        backgroundColor: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        [`${n}-close`]: {
          color: a,
          transition: `color ${o}`,
          "&:hover": {
            color: i
          }
        }
      },
      "&-close-text": {
        color: a,
        transition: `color ${o}`,
        "&:hover": {
          color: i
        }
      }
    }
  };
}, f6e = (e) => [c6e(e), u6e(e), d6e(e)], p6e = Zt("Alert", (e) => {
  const {
    fontSizeHeading3: t
  } = e, n = Vt(e, {
    alertIconSizeLG: t,
    alertPaddingHorizontal: 12
    // Fixed value here.
  });
  return [f6e(n)];
}), v6e = {
  success: Za,
  info: Dc,
  error: jl,
  warning: Qa
}, m6e = {
  success: xS,
  info: OS,
  error: _S,
  warning: ES
}, h6e = $l("success", "info", "warning", "error"), g6e = () => ({
  /**
   * Type of Alert styles, options: `success`, `info`, `warning`, `error`
   */
  type: de.oneOf(h6e),
  /** Whether Alert can be closed */
  closable: {
    type: Boolean,
    default: void 0
  },
  /** Close text to show */
  closeText: de.any,
  /** Content of Alert */
  message: de.any,
  /** Additional content of Alert */
  description: de.any,
  /** Trigger when animation ending of Alert */
  afterClose: Function,
  /** Whether to show icon */
  showIcon: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  banner: {
    type: Boolean,
    default: void 0
  },
  icon: de.any,
  closeIcon: de.any,
  onClose: Function
}), b6e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AAlert",
  inheritAttrs: !1,
  props: g6e(),
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: l,
      expose: r
    } = t;
    const {
      prefixCls: a,
      direction: i
    } = bt("alert", e), [s, c] = p6e(a), u = /* @__PURE__ */ Ce(!1), d = /* @__PURE__ */ Ce(!1), f = /* @__PURE__ */ Ce(), p = (g) => {
      g.preventDefault();
      const y = f.value;
      y.style.height = `${y.offsetHeight}px`, y.style.height = `${y.offsetHeight}px`, u.value = !0, o("close", g);
    }, m = () => {
      var g;
      u.value = !1, d.value = !0, (g = e.afterClose) === null || g === void 0 || g.call(e);
    }, v = O(() => {
      const {
        type: g
      } = e;
      return g !== void 0 ? g : e.banner ? "warning" : "info";
    });
    r({
      animationEnd: m
    });
    const h = /* @__PURE__ */ Ce({});
    return () => {
      var g, y, b, C, w, x, E, I, T, P;
      const {
        banner: k,
        closeIcon: N = (g = n.closeIcon) === null || g === void 0 ? void 0 : g.call(n)
      } = e;
      let {
        closable: R,
        showIcon: z
      } = e;
      const D = (y = e.closeText) !== null && y !== void 0 ? y : (b = n.closeText) === null || b === void 0 ? void 0 : b.call(n), F = (C = e.description) !== null && C !== void 0 ? C : (w = n.description) === null || w === void 0 ? void 0 : w.call(n), M = (x = e.message) !== null && x !== void 0 ? x : (E = n.message) === null || E === void 0 ? void 0 : E.call(n), A = (I = e.icon) !== null && I !== void 0 ? I : (T = n.icon) === null || T === void 0 ? void 0 : T.call(n), L = (P = n.action) === null || P === void 0 ? void 0 : P.call(n);
      z = k && z === void 0 ? !0 : z;
      const B = (F ? m6e : v6e)[v.value] || null;
      D && (R = !0);
      const V = a.value, j = ke(V, {
        [`${V}-${v.value}`]: !0,
        [`${V}-closing`]: u.value,
        [`${V}-with-description`]: !!F,
        [`${V}-no-icon`]: !z,
        [`${V}-banner`]: !!k,
        [`${V}-closable`]: R,
        [`${V}-rtl`]: i.value === "rtl",
        [c.value]: !0
      }), W = R ? $("button", {
        type: "button",
        onClick: p,
        class: `${V}-close-icon`,
        tabindex: 0
      }, [D ? $("span", {
        class: `${V}-close-text`
      }, [D]) : N === void 0 ? $(Hl, null, null) : N]) : null, Y = A && (Io(A) ? _n(A, {
        class: `${V}-icon`
      }) : $("span", {
        class: `${V}-icon`
      }, [A])) || $(B, {
        class: `${V}-icon`
      }, null), U = da(`${V}-motion`, {
        appear: !1,
        css: !0,
        onAfterLeave: m,
        onBeforeLeave: (te) => {
          te.style.maxHeight = `${te.offsetHeight}px`;
        },
        onLeave: (te) => {
          te.style.maxHeight = "0px";
        }
      });
      return s(d.value ? null : $(Vn, U, {
        default: () => [_t($("div", Q(Q({
          role: "alert"
        }, l), {}, {
          style: [l.style, h.value],
          class: [l.class, j],
          "data-show": !u.value,
          ref: f
        }), [z ? Y : null, $("div", {
          class: `${V}-content`
        }, [M ? $("div", {
          class: `${V}-message`
        }, [M]) : null, F ? $("div", {
          class: `${V}-description`
        }, [F]) : null]), L ? $("div", {
          class: `${V}-action`
        }, [L]) : null, W]), [[Jt, !u.value]])]
      }));
    };
  }
}), y6e = po(b6e), rs = ["xxxl", "xxl", "xl", "lg", "md", "sm", "xs"], S6e = (e) => ({
  xs: `(max-width: ${e.screenXSMax}px)`,
  sm: `(min-width: ${e.screenSM}px)`,
  md: `(min-width: ${e.screenMD}px)`,
  lg: `(min-width: ${e.screenLG}px)`,
  xl: `(min-width: ${e.screenXL}px)`,
  xxl: `(min-width: ${e.screenXXL}px)`,
  xxxl: `{min-width: ${e.screenXXXL}px}`
});
function jI() {
  const [, e] = _s();
  return O(() => {
    const t = S6e(e.value), n = /* @__PURE__ */ new Map();
    let o = -1, l = {};
    return {
      matchHandlers: {},
      dispatch(r) {
        return l = r, n.forEach((a) => a(l)), n.size >= 1;
      },
      subscribe(r) {
        return n.size || this.register(), o += 1, n.set(o, r), r(l), o;
      },
      unsubscribe(r) {
        n.delete(r), n.size || this.unregister();
      },
      unregister() {
        Object.keys(t).forEach((r) => {
          const a = t[r], i = this.matchHandlers[a];
          i == null || i.mql.removeListener(i == null ? void 0 : i.listener);
        }), n.clear();
      },
      register() {
        Object.keys(t).forEach((r) => {
          const a = t[r], i = (c) => {
            let {
              matches: u
            } = c;
            this.dispatch(_(_({}, l), {
              [r]: u
            }));
          }, s = window.matchMedia(a);
          s.addListener(i), this.matchHandlers[a] = {
            mql: s,
            listener: i
          }, i(s);
        });
      },
      responsiveMap: t
    };
  });
}
function Dp() {
  const e = /* @__PURE__ */ Ce({});
  let t = null;
  const n = jI();
  return nt(() => {
    t = n.value.subscribe((o) => {
      e.value = o;
    });
  }), Uo(() => {
    n.value.unsubscribe(t);
  }), e;
}
function _r(e) {
  const t = /* @__PURE__ */ Ce();
  return Ot(() => {
    t.value = e();
  }, {
    flush: "sync"
    // needed so updates are immediate.
  }), t;
}
const C6e = (e) => {
  const {
    antCls: t,
    componentCls: n,
    iconCls: o,
    avatarBg: l,
    avatarColor: r,
    containerSize: a,
    containerSizeLG: i,
    containerSizeSM: s,
    textFontSize: c,
    textFontSizeLG: u,
    textFontSizeSM: d,
    borderRadius: f,
    borderRadiusLG: p,
    borderRadiusSM: m,
    lineWidth: v,
    lineType: h
  } = e, g = (y, b, C) => ({
    width: y,
    height: y,
    lineHeight: `${y - v * 2}px`,
    borderRadius: "50%",
    [`&${n}-square`]: {
      borderRadius: C
    },
    [`${n}-string`]: {
      position: "absolute",
      left: {
        _skip_check_: !0,
        value: "50%"
      },
      transformOrigin: "0 center"
    },
    [`&${n}-icon`]: {
      fontSize: b,
      [`> ${o}`]: {
        margin: 0
      }
    }
  });
  return {
    [n]: _(_(_(_({}, nn(e)), {
      position: "relative",
      display: "inline-block",
      overflow: "hidden",
      color: r,
      whiteSpace: "nowrap",
      textAlign: "center",
      verticalAlign: "middle",
      background: l,
      border: `${v}px ${h} transparent`,
      "&-image": {
        background: "transparent"
      },
      [`${t}-image-img`]: {
        display: "block"
      }
    }), g(a, c, f)), {
      "&-lg": _({}, g(i, u, p)),
      "&-sm": _({}, g(s, d, m)),
      "> img": {
        display: "block",
        width: "100%",
        height: "100%",
        objectFit: "cover"
      }
    })
  };
}, w6e = (e) => {
  const {
    componentCls: t,
    groupBorderColor: n,
    groupOverlapping: o,
    groupSpace: l
  } = e;
  return {
    [`${t}-group`]: {
      display: "inline-flex",
      [`${t}`]: {
        borderColor: n
      },
      "> *:not(:first-child)": {
        marginInlineStart: o
      }
    },
    [`${t}-group-popover`]: {
      [`${t} + ${t}`]: {
        marginInlineStart: l
      }
    }
  };
}, Vj = Zt("Avatar", (e) => {
  const {
    colorTextLightSolid: t,
    colorTextPlaceholder: n
  } = e, o = Vt(e, {
    avatarBg: n,
    avatarColor: t
  });
  return [C6e(o), w6e(o)];
}, (e) => {
  const {
    controlHeight: t,
    controlHeightLG: n,
    controlHeightSM: o,
    fontSize: l,
    fontSizeLG: r,
    fontSizeXL: a,
    fontSizeHeading3: i,
    marginXS: s,
    marginXXS: c,
    colorBorderBg: u
  } = e;
  return {
    containerSize: t,
    containerSizeLG: n,
    containerSizeSM: o,
    textFontSize: Math.round((r + a) / 2),
    textFontSizeLG: i,
    textFontSizeSM: l,
    groupSpace: c,
    groupOverlapping: -s,
    groupBorderColor: u
  };
}), zj = Symbol("AvatarContextKey"), $6e = () => ze(zj, {}), x6e = (e) => at(zj, e), E6e = () => ({
  prefixCls: String,
  shape: {
    type: String,
    default: "circle"
  },
  size: {
    type: [Number, String, Object],
    default: () => "default"
  },
  src: String,
  /** Srcset of image avatar */
  srcset: String,
  icon: de.any,
  alt: String,
  gap: Number,
  draggable: {
    type: Boolean,
    default: void 0
  },
  crossOrigin: String,
  loadError: {
    type: Function
  }
}), Pu = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AAvatar",
  inheritAttrs: !1,
  props: E6e(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const l = /* @__PURE__ */ Ce(!0), r = /* @__PURE__ */ Ce(!1), a = /* @__PURE__ */ Ce(1), i = /* @__PURE__ */ Ce(null), s = /* @__PURE__ */ Ce(null), {
      prefixCls: c
    } = bt("avatar", e), [u, d] = Vj(c), f = $6e(), p = O(() => e.size === "default" ? f.size : e.size), m = Dp(), v = _r(() => {
      if (typeof e.size != "object")
        return;
      const b = rs.find((w) => m.value[w]);
      return e.size[b];
    }), h = (b) => v.value ? {
      width: `${v.value}px`,
      height: `${v.value}px`,
      lineHeight: `${v.value}px`,
      fontSize: `${b ? v.value / 2 : 18}px`
    } : {}, g = () => {
      if (!i.value || !s.value)
        return;
      const b = i.value.offsetWidth, C = s.value.offsetWidth;
      if (b !== 0 && C !== 0) {
        const {
          gap: w = 4
        } = e;
        w * 2 < C && (a.value = C - w * 2 < b ? (C - w * 2) / b : 1);
      }
    }, y = () => {
      const {
        loadError: b
      } = e;
      (b == null ? void 0 : b()) !== !1 && (l.value = !1);
    };
    return pe(() => e.src, () => {
      Ke(() => {
        l.value = !0, a.value = 1;
      });
    }), pe(() => e.gap, () => {
      Ke(() => {
        g();
      });
    }), nt(() => {
      Ke(() => {
        g(), r.value = !0;
      });
    }), () => {
      var b, C;
      const {
        shape: w,
        src: x,
        alt: E,
        srcset: I,
        draggable: T,
        crossOrigin: P
      } = e, k = (b = f.shape) !== null && b !== void 0 ? b : w, N = Wo(n, e, "icon"), R = c.value, z = {
        [`${o.class}`]: !!o.class,
        [R]: !0,
        [`${R}-lg`]: p.value === "large",
        [`${R}-sm`]: p.value === "small",
        [`${R}-${k}`]: !0,
        [`${R}-image`]: x && l.value,
        [`${R}-icon`]: N,
        [d.value]: !0
      }, D = typeof p.value == "number" ? {
        width: `${p.value}px`,
        height: `${p.value}px`,
        lineHeight: `${p.value}px`,
        fontSize: N ? `${p.value / 2}px` : "18px"
      } : {}, F = (C = n.default) === null || C === void 0 ? void 0 : C.call(n);
      let M;
      if (x && l.value)
        M = $("img", {
          draggable: T,
          src: x,
          srcset: I,
          onError: y,
          alt: E,
          crossorigin: P
        }, null);
      else if (N)
        M = N;
      else if (r.value || a.value !== 1) {
        const A = `scale(${a.value}) translateX(-50%)`, L = {
          msTransform: A,
          WebkitTransform: A,
          transform: A
        }, B = typeof p.value == "number" ? {
          lineHeight: `${p.value}px`
        } : {};
        M = $(ca, {
          onResize: g
        }, {
          default: () => [$("span", {
            class: `${R}-string`,
            ref: i,
            style: _(_({}, B), L)
          }, [F])]
        });
      } else
        M = $("span", {
          class: `${R}-string`,
          ref: i,
          style: {
            opacity: 0
          }
        }, [F]);
      return u($("span", Q(Q({}, o), {}, {
        ref: s,
        class: z,
        style: [D, h(!!N), o.style]
      }), [M]));
    };
  }
}), Wr = {
  adjustX: 1,
  adjustY: 1
}, Kr = [0, 0], Hj = {
  left: {
    points: ["cr", "cl"],
    overflow: Wr,
    offset: [-4, 0],
    targetOffset: Kr
  },
  right: {
    points: ["cl", "cr"],
    overflow: Wr,
    offset: [4, 0],
    targetOffset: Kr
  },
  top: {
    points: ["bc", "tc"],
    overflow: Wr,
    offset: [0, -4],
    targetOffset: Kr
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: Wr,
    offset: [0, 4],
    targetOffset: Kr
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: Wr,
    offset: [0, -4],
    targetOffset: Kr
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: Wr,
    offset: [-4, 0],
    targetOffset: Kr
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Wr,
    offset: [0, -4],
    targetOffset: Kr
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: Wr,
    offset: [4, 0],
    targetOffset: Kr
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Wr,
    offset: [0, 4],
    targetOffset: Kr
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: Wr,
    offset: [4, 0],
    targetOffset: Kr
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Wr,
    offset: [0, 4],
    targetOffset: Kr
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: Wr,
    offset: [-4, 0],
    targetOffset: Kr
  }
}, O6e = {
  prefixCls: String,
  id: String,
  overlayInnerStyle: de.any
}, _6e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "TooltipContent",
  props: O6e,
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      var o;
      return $("div", {
        class: `${e.prefixCls}-inner`,
        id: e.id,
        role: "tooltip",
        style: e.overlayInnerStyle
      }, [(o = n.overlay) === null || o === void 0 ? void 0 : o.call(n)]);
    };
  }
});
var I6e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function Z8() {
}
const T6e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Tooltip",
  inheritAttrs: !1,
  props: {
    trigger: de.any.def(["hover"]),
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    placement: de.string.def("right"),
    transitionName: String,
    animation: de.any,
    afterVisibleChange: de.func.def(() => {
    }),
    overlayStyle: {
      type: Object,
      default: void 0
    },
    overlayClassName: String,
    prefixCls: de.string.def("rc-tooltip"),
    mouseEnterDelay: de.number.def(0.1),
    mouseLeaveDelay: de.number.def(0.1),
    getPopupContainer: Function,
    destroyTooltipOnHide: {
      type: Boolean,
      default: !1
    },
    align: de.object.def(() => ({})),
    arrowContent: de.any.def(null),
    tipId: String,
    builtinPlacements: de.object,
    overlayInnerStyle: {
      type: Object,
      default: void 0
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    onVisibleChange: Function,
    onPopupAlign: Function,
    arrow: {
      type: Boolean,
      default: !0
    }
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: l
    } = t;
    const r = /* @__PURE__ */ Ce(), a = () => {
      const {
        prefixCls: u,
        tipId: d,
        overlayInnerStyle: f
      } = e;
      return [e.arrow ? $("div", {
        class: `${u}-arrow`,
        key: "arrow"
      }, [Wo(n, e, "arrowContent")]) : null, $(_6e, {
        key: "content",
        prefixCls: u,
        id: d,
        overlayInnerStyle: f
      }, {
        overlay: n.overlay
      })];
    };
    l({
      getPopupDomNode: () => r.value.getPopupDomNode(),
      triggerDOM: r,
      forcePopupAlign: () => {
        var u;
        return (u = r.value) === null || u === void 0 ? void 0 : u.forcePopupAlign();
      }
    });
    const s = /* @__PURE__ */ Ce(!1), c = /* @__PURE__ */ Ce(!1);
    return Ot(() => {
      const {
        destroyTooltipOnHide: u
      } = e;
      if (typeof u == "boolean")
        s.value = u;
      else if (u && typeof u == "object") {
        const {
          keepParent: d
        } = u;
        s.value = d === !0, c.value = d === !1;
      }
    }), () => {
      const {
        overlayClassName: u,
        trigger: d,
        mouseEnterDelay: f,
        mouseLeaveDelay: p,
        overlayStyle: m,
        prefixCls: v,
        afterVisibleChange: h,
        transitionName: g,
        animation: y,
        placement: b,
        align: C,
        destroyTooltipOnHide: w,
        defaultVisible: x
      } = e, E = I6e(e, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible"]), I = _({}, E);
      e.visible !== void 0 && (I.popupVisible = e.visible);
      const T = _(_(_({
        popupClassName: u,
        prefixCls: v,
        action: d,
        builtinPlacements: Hj,
        popupPlacement: b,
        popupAlign: C,
        afterPopupVisibleChange: h,
        popupTransitionName: g,
        popupAnimation: y,
        defaultPopupVisible: x,
        destroyPopupOnHide: s.value,
        autoDestroy: c.value,
        mouseLeaveDelay: p,
        popupStyle: m,
        mouseEnterDelay: f
      }, I), o), {
        onPopupVisibleChange: e.onVisibleChange || Z8,
        onPopupAlign: e.onPopupAlign || Z8,
        ref: r,
        arrow: !!e.arrow,
        popup: a()
      });
      return $(fd, T, {
        default: n.default
      });
    };
  }
}), WI = () => ({
  trigger: [String, Array],
  open: {
    type: Boolean,
    default: void 0
  },
  /** @deprecated Please use `open` instead. */
  visible: {
    type: Boolean,
    default: void 0
  },
  placement: String,
  color: String,
  transitionName: String,
  overlayStyle: Nt(),
  overlayInnerStyle: Nt(),
  overlayClassName: String,
  openClassName: String,
  prefixCls: String,
  mouseEnterDelay: Number,
  mouseLeaveDelay: Number,
  getPopupContainer: Function,
  /**@deprecated Please use `arrow={{ pointAtCenter: true }}` instead. */
  arrowPointAtCenter: {
    type: Boolean,
    default: void 0
  },
  arrow: {
    type: [Boolean, Object],
    default: !0
  },
  autoAdjustOverflow: {
    type: [Boolean, Object],
    default: void 0
  },
  destroyTooltipOnHide: {
    type: Boolean,
    default: void 0
  },
  align: Nt(),
  builtinPlacements: Nt(),
  children: Array,
  /** @deprecated Please use `onOpenChange` instead. */
  onVisibleChange: Function,
  /** @deprecated Please use `onUpdate:open` instead. */
  "onUpdate:visible": Function,
  onOpenChange: Function,
  "onUpdate:open": Function
}), P6e = {
  adjustX: 1,
  adjustY: 1
}, Q8 = {
  adjustX: 0,
  adjustY: 0
}, k6e = [0, 0];
function e6(e) {
  return typeof e == "boolean" ? e ? P6e : Q8 : _(_({}, Q8), e);
}
function KI(e) {
  const {
    arrowWidth: t = 4,
    horizontalArrowShift: n = 16,
    verticalArrowShift: o = 8,
    autoAdjustOverflow: l,
    arrowPointAtCenter: r
  } = e, a = {
    left: {
      points: ["cr", "cl"],
      offset: [-4, 0]
    },
    right: {
      points: ["cl", "cr"],
      offset: [4, 0]
    },
    top: {
      points: ["bc", "tc"],
      offset: [0, -4]
    },
    bottom: {
      points: ["tc", "bc"],
      offset: [0, 4]
    },
    topLeft: {
      points: ["bl", "tc"],
      offset: [-(n + t), -4]
    },
    leftTop: {
      points: ["tr", "cl"],
      offset: [-4, -(o + t)]
    },
    topRight: {
      points: ["br", "tc"],
      offset: [n + t, -4]
    },
    rightTop: {
      points: ["tl", "cr"],
      offset: [4, -(o + t)]
    },
    bottomRight: {
      points: ["tr", "bc"],
      offset: [n + t, 4]
    },
    rightBottom: {
      points: ["bl", "cr"],
      offset: [4, o + t]
    },
    bottomLeft: {
      points: ["tl", "bc"],
      offset: [-(n + t), 4]
    },
    leftBottom: {
      points: ["br", "cl"],
      offset: [-4, o + t]
    }
  };
  return Object.keys(a).forEach((i) => {
    a[i] = r ? _(_({}, a[i]), {
      overflow: e6(l),
      targetOffset: k6e
    }) : _(_({}, Hj[i]), {
      overflow: e6(l)
    }), a[i].ignoreShake = !0;
  }), a;
}
function hy() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  for (let t = 0, n = e.length; t < n; t++)
    if (e[t] !== void 0)
      return e[t];
}
const N6e = km.map((e) => `${e}-inverse`), M6e = ["success", "processing", "error", "default", "warning"];
function IS(e) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? [...N6e, ...km].includes(e) : km.includes(e);
}
function A6e(e) {
  return M6e.includes(e);
}
function R6e(e, t) {
  const n = IS(t), o = ke({
    [`${e}-${t}`]: t && n
  }), l = {}, r = {};
  return t && !n && (l.background = t, r["--antd-arrow-background-color"] = t), {
    className: o,
    overlayStyle: l,
    arrowStyle: r
  };
}
function Ng(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return e.map((n) => `${t}${n}`).join(",");
}
const UI = 8;
function jj(e) {
  const t = UI, {
    sizePopupArrow: n,
    contentRadius: o,
    borderRadiusOuter: l,
    limitVerticalRadius: r
  } = e, a = n / 2 - Math.ceil(l * (Math.sqrt(2) - 1)), i = (o > 12 ? o + 2 : 12) - a, s = r ? t - a : i;
  return {
    dropdownArrowOffset: i,
    dropdownArrowOffsetVertical: s
  };
}
function GI(e, t) {
  const {
    componentCls: n,
    sizePopupArrow: o,
    marginXXS: l,
    borderRadiusXS: r,
    borderRadiusOuter: a,
    boxShadowPopoverArrow: i
  } = e, {
    colorBg: s,
    showArrowCls: c,
    contentRadius: u = e.borderRadiusLG,
    limitVerticalRadius: d
  } = t, {
    dropdownArrowOffsetVertical: f,
    dropdownArrowOffset: p
  } = jj({
    sizePopupArrow: o,
    contentRadius: u,
    borderRadiusOuter: a,
    limitVerticalRadius: d
  }), m = o / 2 + l;
  return {
    [n]: {
      // ============================ Basic ============================
      [`${n}-arrow`]: [_(_({
        position: "absolute",
        zIndex: 1,
        display: "block"
      }, cI(o, r, a, s, i)), {
        "&:before": {
          background: s
        }
      })],
      // ========================== Placement ==========================
      // Here handle the arrow position and rotate stuff
      // >>>>> Top
      [[`&-placement-top ${n}-arrow`, `&-placement-topLeft ${n}-arrow`, `&-placement-topRight ${n}-arrow`].join(",")]: {
        bottom: 0,
        transform: "translateY(100%) rotate(180deg)"
      },
      [`&-placement-top ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
      },
      [`&-placement-topLeft ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: p
        }
      },
      [`&-placement-topRight ${n}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: p
        }
      },
      // >>>>> Bottom
      [[`&-placement-bottom ${n}-arrow`, `&-placement-bottomLeft ${n}-arrow`, `&-placement-bottomRight ${n}-arrow`].join(",")]: {
        top: 0,
        transform: "translateY(-100%)"
      },
      [`&-placement-bottom ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(-100%)"
      },
      [`&-placement-bottomLeft ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: p
        }
      },
      [`&-placement-bottomRight ${n}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: p
        }
      },
      // >>>>> Left
      [[`&-placement-left ${n}-arrow`, `&-placement-leftTop ${n}-arrow`, `&-placement-leftBottom ${n}-arrow`].join(",")]: {
        right: {
          _skip_check_: !0,
          value: 0
        },
        transform: "translateX(100%) rotate(90deg)"
      },
      [`&-placement-left ${n}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
      },
      [`&-placement-leftTop ${n}-arrow`]: {
        top: f
      },
      [`&-placement-leftBottom ${n}-arrow`]: {
        bottom: f
      },
      // >>>>> Right
      [[`&-placement-right ${n}-arrow`, `&-placement-rightTop ${n}-arrow`, `&-placement-rightBottom ${n}-arrow`].join(",")]: {
        left: {
          _skip_check_: !0,
          value: 0
        },
        transform: "translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-right ${n}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-rightTop ${n}-arrow`]: {
        top: f
      },
      [`&-placement-rightBottom ${n}-arrow`]: {
        bottom: f
      },
      // =========================== Offset ============================
      // Offset the popover to account for the dropdown arrow
      // >>>>> Top
      [Ng(["&-placement-topLeft", "&-placement-top", "&-placement-topRight"].map((v) => v += ":not(&-arrow-hidden)"), c)]: {
        paddingBottom: m
      },
      // >>>>> Bottom
      [Ng(["&-placement-bottomLeft", "&-placement-bottom", "&-placement-bottomRight"].map((v) => v += ":not(&-arrow-hidden)"), c)]: {
        paddingTop: m
      },
      // >>>>> Left
      [Ng(["&-placement-leftTop", "&-placement-left", "&-placement-leftBottom"].map((v) => v += ":not(&-arrow-hidden)"), c)]: {
        paddingRight: {
          _skip_check_: !0,
          value: m
        }
      },
      // >>>>> Right
      [Ng(["&-placement-rightTop", "&-placement-right", "&-placement-rightBottom"].map((v) => v += ":not(&-arrow-hidden)"), c)]: {
        paddingLeft: {
          _skip_check_: !0,
          value: m
        }
      }
    }
  };
}
const D6e = (e) => {
  const {
    componentCls: t,
    // ant-tooltip
    tooltipMaxWidth: n,
    tooltipColor: o,
    tooltipBg: l,
    tooltipBorderRadius: r,
    zIndexPopup: a,
    controlHeight: i,
    boxShadowSecondary: s,
    paddingSM: c,
    paddingXS: u,
    tooltipRadiusOuter: d
  } = e;
  return [
    {
      [t]: _(_(_(_({}, nn(e)), {
        position: "absolute",
        zIndex: a,
        display: "block",
        "&": [{
          width: "max-content"
        }, {
          width: "intrinsic"
        }],
        maxWidth: n,
        visibility: "visible",
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": l,
        // Wrapper for the tooltip content
        [`${t}-inner`]: {
          minWidth: i,
          minHeight: i,
          padding: `${c / 2}px ${u}px`,
          color: o,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: l,
          borderRadius: r,
          boxShadow: s
        },
        // Limit left and right placement radius
        [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
          [`${t}-inner`]: {
            borderRadius: Math.min(r, UI)
          }
        },
        [`${t}-content`]: {
          position: "relative"
        }
      }), ry(e, (f, p) => {
        let {
          darkColor: m
        } = p;
        return {
          [`&${t}-${f}`]: {
            [`${t}-inner`]: {
              backgroundColor: m
            },
            [`${t}-arrow`]: {
              "--antd-arrow-background-color": m
            }
          }
        };
      })), {
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Arrow Style
    GI(Vt(e, {
      borderRadiusOuter: d
    }), {
      colorBg: "var(--antd-arrow-background-color)",
      showArrowCls: "",
      contentRadius: r,
      limitVerticalRadius: !0
    }),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none"
      }
    }
  ];
}, L6e = (e, t) => Zt("Tooltip", (o) => {
  if ((t == null ? void 0 : t.value) === !1)
    return [];
  const {
    borderRadius: l,
    colorTextLightSolid: r,
    colorBgDefault: a,
    borderRadiusOuter: i
  } = o, s = Vt(o, {
    // default variables
    tooltipMaxWidth: 250,
    tooltipColor: r,
    tooltipBorderRadius: l,
    tooltipBg: a,
    tooltipRadiusOuter: i > 4 ? 4 : i
  });
  return [D6e(s), Ap(o, "zoom-big-fast")];
}, (o) => {
  let {
    zIndexPopupBase: l,
    colorBgSpotlight: r
  } = o;
  return {
    zIndexPopup: l + 70,
    colorBgDefault: r
  };
})(e), B6e = (e, t) => {
  const n = {}, o = _({}, e);
  return t.forEach((l) => {
    e && l in e && (n[l] = e[l], delete o[l]);
  }), {
    picked: n,
    omitted: o
  };
}, Wj = () => _(_({}, WI()), {
  title: de.any
}), Kj = () => ({
  trigger: "hover",
  align: {},
  placement: "top",
  mouseEnterDelay: 0.1,
  mouseLeaveDelay: 0.1,
  arrowPointAtCenter: !1,
  autoAdjustOverflow: !0
}), F6e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ATooltip",
  inheritAttrs: !1,
  props: sn(Wj(), {
    trigger: "hover",
    align: {},
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: !1,
    autoAdjustOverflow: !0
  }),
  slots: Object,
  // emits: ['update:visible', 'visibleChange'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: l,
      expose: r
    } = t;
    process.env.NODE_ENV !== "production" && [["visible", "open"], ["onVisibleChange", "onOpenChange"]].forEach((P) => {
      let [k, N] = P;
      Hn(e[k] === void 0, "Tooltip", `\`${k}\` is deprecated, please use \`${N}\` instead.`);
    });
    const {
      prefixCls: a,
      getPopupContainer: i,
      direction: s,
      rootPrefixCls: c
    } = bt("tooltip", e), u = O(() => {
      var P;
      return (P = e.open) !== null && P !== void 0 ? P : e.visible;
    }), d = /* @__PURE__ */ H(hy([e.open, e.visible])), f = /* @__PURE__ */ H();
    let p;
    pe(u, (P) => {
      rn.cancel(p), p = rn(() => {
        d.value = !!P;
      });
    });
    const m = () => {
      var P;
      const k = (P = e.title) !== null && P !== void 0 ? P : n.title;
      return !k && k !== 0;
    }, v = (P) => {
      const k = m();
      u.value === void 0 && (d.value = k ? !1 : P), k || (o("update:visible", P), o("visibleChange", P), o("update:open", P), o("openChange", P));
    };
    r({
      getPopupDomNode: () => f.value.getPopupDomNode(),
      open: d,
      forcePopupAlign: () => {
        var P;
        return (P = f.value) === null || P === void 0 ? void 0 : P.forcePopupAlign();
      }
    });
    const g = O(() => {
      var P;
      const {
        builtinPlacements: k,
        autoAdjustOverflow: N,
        arrow: R,
        arrowPointAtCenter: z
      } = e;
      let D = z;
      return typeof R == "object" && (D = (P = R.pointAtCenter) !== null && P !== void 0 ? P : z), k || KI({
        arrowPointAtCenter: D,
        autoAdjustOverflow: N
      });
    }), y = (P) => P || P === "", b = (P) => {
      const k = P.type;
      if (typeof k == "object" && P.props && ((k.__ANT_BUTTON === !0 || k === "button") && y(P.props.disabled) || k.__ANT_SWITCH === !0 && (y(P.props.disabled) || y(P.props.loading)) || k.__ANT_RADIO === !0 && y(P.props.disabled))) {
        const {
          picked: N,
          omitted: R
        } = B6e(Zz(P), ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]), z = _(_({
          display: "inline-block"
        }, N), {
          cursor: "not-allowed",
          lineHeight: 1,
          width: P.props && P.props.block ? "100%" : void 0
        }), D = _(_({}, R), {
          pointerEvents: "none"
        }), F = _n(P, {
          style: D
        }, !0);
        return $("span", {
          style: z,
          class: `${a.value}-disabled-compatible-wrapper`
        }, [F]);
      }
      return P;
    }, C = () => {
      var P, k;
      return (P = e.title) !== null && P !== void 0 ? P : (k = n.title) === null || k === void 0 ? void 0 : k.call(n);
    }, w = (P, k) => {
      const N = g.value, R = Object.keys(N).find((z) => {
        var D, F;
        return N[z].points[0] === ((D = k.points) === null || D === void 0 ? void 0 : D[0]) && N[z].points[1] === ((F = k.points) === null || F === void 0 ? void 0 : F[1]);
      });
      if (R) {
        const z = P.getBoundingClientRect(), D = {
          top: "50%",
          left: "50%"
        };
        R.indexOf("top") >= 0 || R.indexOf("Bottom") >= 0 ? D.top = `${z.height - k.offset[1]}px` : (R.indexOf("Top") >= 0 || R.indexOf("bottom") >= 0) && (D.top = `${-k.offset[1]}px`), R.indexOf("left") >= 0 || R.indexOf("Right") >= 0 ? D.left = `${z.width - k.offset[0]}px` : (R.indexOf("right") >= 0 || R.indexOf("Left") >= 0) && (D.left = `${-k.offset[0]}px`), P.style.transformOrigin = `${D.left} ${D.top}`;
      }
    }, x = O(() => R6e(a.value, e.color)), E = O(() => l["data-popover-inject"]), [I, T] = L6e(a, O(() => !E.value));
    return () => {
      var P, k;
      const {
        openClassName: N,
        overlayClassName: R,
        overlayStyle: z,
        overlayInnerStyle: D
      } = e;
      let F = (k = mo((P = n.default) === null || P === void 0 ? void 0 : P.call(n))) !== null && k !== void 0 ? k : null;
      F = F.length === 1 ? F[0] : F;
      let M = d.value;
      if (u.value === void 0 && m() && (M = !1), !F)
        return null;
      const A = b(Io(F) && !TPe(F) ? F : $("span", null, [F])), L = ke({
        [N || `${a.value}-open`]: !0,
        [A.props && A.props.class]: A.props && A.props.class
      }), B = ke(R, {
        [`${a.value}-rtl`]: s.value === "rtl"
      }, x.value.className, T.value), V = _(_({}, x.value.overlayStyle), D), j = x.value.arrowStyle, W = _(_(_({}, l), e), {
        prefixCls: a.value,
        arrow: !!e.arrow,
        getPopupContainer: i == null ? void 0 : i.value,
        builtinPlacements: g.value,
        visible: M,
        ref: f,
        overlayClassName: B,
        overlayStyle: _(_({}, j), z),
        overlayInnerStyle: V,
        onVisibleChange: v,
        onPopupAlign: w,
        transitionName: Vl(c.value, "zoom-big-fast", e.transitionName)
      });
      return I($(T6e, W, {
        default: () => [d.value ? _n(A, {
          class: L
        }) : A],
        arrowContent: () => $("span", {
          class: `${a.value}-arrow-content`
        }, null),
        overlay: C
      }));
    };
  }
}), Sr = po(F6e), V6e = (e) => {
  const {
    componentCls: t,
    popoverBg: n,
    popoverColor: o,
    width: l,
    fontWeightStrong: r,
    popoverPadding: a,
    boxShadowSecondary: i,
    colorTextHeading: s,
    borderRadiusLG: c,
    zIndexPopup: u,
    marginXS: d,
    colorBgElevated: f
  } = e;
  return [
    {
      [t]: _(_({}, nn(e)), {
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: !0,
          value: 0
        },
        zIndex: u,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        "--antd-arrow-background-color": f,
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${t}-content`]: {
          position: "relative"
        },
        [`${t}-inner`]: {
          backgroundColor: n,
          backgroundClip: "padding-box",
          borderRadius: c,
          boxShadow: i,
          padding: a
        },
        [`${t}-title`]: {
          minWidth: l,
          marginBottom: d,
          color: s,
          fontWeight: r
        },
        [`${t}-inner-content`]: {
          color: o
        }
      })
    },
    // Arrow Style
    GI(e, {
      colorBg: "var(--antd-arrow-background-color)"
    }),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none",
        [`${t}-content`]: {
          display: "inline-block"
        }
      }
    }
  ];
}, z6e = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: km.map((n) => {
      const o = e[`${n}-6`];
      return {
        [`&${t}-${n}`]: {
          "--antd-arrow-background-color": o,
          [`${t}-inner`]: {
            backgroundColor: o
          },
          [`${t}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
}, H6e = (e) => {
  const {
    componentCls: t,
    lineWidth: n,
    lineType: o,
    colorSplit: l,
    paddingSM: r,
    controlHeight: a,
    fontSize: i,
    lineHeight: s,
    padding: c
  } = e, u = a - Math.round(i * s), d = u / 2, f = u / 2 - n, p = c;
  return {
    [t]: {
      [`${t}-inner`]: {
        padding: 0
      },
      [`${t}-title`]: {
        margin: 0,
        padding: `${d}px ${p}px ${f}px`,
        borderBottom: `${n}px ${o} ${l}`
      },
      [`${t}-inner-content`]: {
        padding: `${r}px ${p}px`
      }
    }
  };
}, j6e = Zt("Popover", (e) => {
  const {
    colorBgElevated: t,
    colorText: n,
    wireframe: o
  } = e, l = Vt(e, {
    popoverBg: t,
    popoverColor: n,
    popoverPadding: 12
    // Fixed Value
  });
  return [V6e(l), z6e(l), o && H6e(l), Ap(l, "zoom-big")];
}, (e) => {
  let {
    zIndexPopupBase: t
  } = e;
  return {
    zIndexPopup: t + 30,
    width: 177
  };
}), W6e = () => _(_({}, WI()), {
  content: Wn(),
  title: Wn()
}), K6e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "APopover",
  inheritAttrs: !1,
  props: sn(W6e(), _(_({}, Kj()), {
    trigger: "hover",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1
  })),
  setup(e, t) {
    let {
      expose: n,
      slots: o,
      attrs: l
    } = t;
    const r = /* @__PURE__ */ H();
    Hn(e.visible === void 0, "popover", "`visible` will be removed in next major version, please use `open` instead."), n({
      getPopupDomNode: () => {
        var f, p;
        return (p = (f = r.value) === null || f === void 0 ? void 0 : f.getPopupDomNode) === null || p === void 0 ? void 0 : p.call(f);
      }
    });
    const {
      prefixCls: a,
      configProvider: i
    } = bt("popover", e), [s, c] = j6e(a), u = O(() => i.getPrefixCls()), d = () => {
      var f, p;
      const {
        title: m = mo((f = o.title) === null || f === void 0 ? void 0 : f.call(o)),
        content: v = mo((p = o.content) === null || p === void 0 ? void 0 : p.call(o))
      } = e, h = !!(Array.isArray(m) ? m.length : m), g = !!(Array.isArray(v) ? v.length : m);
      return !h && !g ? null : $(Ge, null, [h && $("div", {
        class: `${a.value}-title`
      }, [m]), $("div", {
        class: `${a.value}-inner-content`
      }, [v])]);
    };
    return () => {
      const f = ke(e.overlayClassName, c.value);
      return s($(Sr, Q(Q(Q({}, pn(e, ["title", "content"])), l), {}, {
        prefixCls: a.value,
        ref: r,
        overlayClassName: f,
        transitionName: Vl(u.value, "zoom-big", e.transitionName),
        "data-popover-inject": !0
      }), {
        title: d,
        default: o.default
      }));
    };
  }
}), YI = po(K6e), U6e = () => ({
  prefixCls: String,
  maxCount: Number,
  maxStyle: {
    type: Object,
    default: void 0
  },
  maxPopoverPlacement: {
    type: String,
    default: "top"
  },
  maxPopoverTrigger: String,
  /*
   * Size of avatar, options: `large`, `small`, `default`
   * or a custom number size
   * */
  size: {
    type: [Number, String, Object],
    default: "default"
  },
  shape: {
    type: String,
    default: "circle"
  }
}), gy = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AAvatarGroup",
  inheritAttrs: !1,
  props: U6e(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("avatar", e), a = O(() => `${l.value}-group`), [i, s] = Vj(l);
    return Ot(() => {
      const c = {
        size: e.size,
        shape: e.shape
      };
      x6e(c);
    }), () => {
      const {
        maxPopoverPlacement: c = "top",
        maxCount: u,
        maxStyle: d,
        maxPopoverTrigger: f = "hover",
        shape: p
      } = e, m = {
        [a.value]: !0,
        [`${a.value}-rtl`]: r.value === "rtl",
        [`${o.class}`]: !!o.class,
        [s.value]: !0
      }, v = Wo(n, e), h = Fn(v).map((y, b) => _n(y, {
        key: `avatar-key-${b}`
      })), g = h.length;
      if (u && u < g) {
        const y = h.slice(0, u), b = h.slice(u, g);
        return y.push($(YI, {
          key: "avatar-popover-key",
          content: b,
          trigger: f,
          placement: c,
          overlayClassName: `${a.value}-popover`
        }, {
          default: () => [$(Pu, {
            style: d,
            shape: p
          }, {
            default: () => [`+${g - u}`]
          })]
        })), i($("div", Q(Q({}, o), {}, {
          class: m,
          style: o.style
        }), [y]));
      }
      return i($("div", Q(Q({}, o), {}, {
        class: m,
        style: o.style
      }), [h]));
    };
  }
});
Pu.Group = gy;
Pu.install = function(e) {
  return e.component(Pu.name, Pu), e.component(gy.name, gy), e;
};
function t6(e) {
  let {
    prefixCls: t,
    value: n,
    current: o,
    offset: l = 0
  } = e, r;
  return l && (r = {
    position: "absolute",
    top: `${l}00%`,
    left: 0
  }), $("p", {
    style: r,
    class: ke(`${t}-only-unit`, {
      current: o
    })
  }, [n]);
}
function G6e(e, t, n) {
  let o = e, l = 0;
  for (; (o + 10) % 10 !== t; )
    o += n, l += n;
  return l;
}
const Y6e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "SingleNumber",
  props: {
    prefixCls: String,
    value: String,
    count: Number
  },
  setup(e) {
    const t = O(() => Number(e.value)), n = O(() => Math.abs(e.count)), o = /* @__PURE__ */ kt({
      prevValue: t.value,
      prevCount: n.value
    }), l = () => {
      o.prevValue = t.value, o.prevCount = n.value;
    }, r = /* @__PURE__ */ H();
    return pe(t, () => {
      clearTimeout(r.value), r.value = setTimeout(() => {
        l();
      }, 1e3);
    }, {
      flush: "post"
    }), Uo(() => {
      clearTimeout(r.value);
    }), () => {
      let a, i = {};
      const s = t.value;
      if (o.prevValue === s || Number.isNaN(s) || Number.isNaN(o.prevValue))
        a = [t6(_(_({}, e), {
          current: !0
        }))], i = {
          transition: "none"
        };
      else {
        a = [];
        const c = s + 10, u = [];
        for (let p = s; p <= c; p += 1)
          u.push(p);
        const d = u.findIndex((p) => p % 10 === o.prevValue);
        a = u.map((p, m) => {
          const v = p % 10;
          return t6(_(_({}, e), {
            value: v,
            offset: m - d,
            current: m === d
          }));
        });
        const f = o.prevCount < n.value ? 1 : -1;
        i = {
          transform: `translateY(${-G6e(o.prevValue, s, f)}00%)`
        };
      }
      return $("span", {
        class: `${e.prefixCls}-only`,
        style: i,
        onTransitionend: () => l()
      }, [a]);
    };
  }
});
var X6e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const q6e = {
  prefixCls: String,
  count: de.any,
  component: String,
  title: de.any,
  show: Boolean
}, J6e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ScrollNumber",
  inheritAttrs: !1,
  props: q6e,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: l
    } = bt("scroll-number", e);
    return () => {
      var r;
      const a = _(_({}, e), n), {
        prefixCls: i,
        count: s,
        title: c,
        show: u,
        component: d = "sup",
        class: f,
        style: p
      } = a, m = X6e(a, ["prefixCls", "count", "title", "show", "component", "class", "style"]), v = _(_({}, m), {
        style: p,
        "data-show": e.show,
        class: ke(l.value, f),
        title: c
      });
      let h = s;
      if (s && Number(s) % 1 === 0) {
        const y = String(s).split("");
        h = y.map((b, C) => $(Y6e, {
          prefixCls: l.value,
          count: Number(s),
          value: b,
          key: y.length - C
        }, null));
      }
      p && p.borderColor && (v.style = _(_({}, p), {
        boxShadow: `0 0 0 1px ${p.borderColor} inset`
      }));
      const g = mo((r = o.default) === null || r === void 0 ? void 0 : r.call(o));
      return g && g.length ? _n(g, {
        class: ke(`${l.value}-custom-component`)
      }, !1) : $(d, v, {
        default: () => [h]
      });
    };
  }
}), Z6e = new mn("antStatusProcessing", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(2.4)",
    opacity: 0
  }
}), Q6e = new mn("antZoomBadgeIn", {
  "0%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1) translate(50%, -50%)"
  }
}), eAe = new mn("antZoomBadgeOut", {
  "0%": {
    transform: "scale(1) translate(50%, -50%)"
  },
  "100%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  }
}), tAe = new mn("antNoWrapperZoomBadgeIn", {
  "0%": {
    transform: "scale(0)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)"
  }
}), nAe = new mn("antNoWrapperZoomBadgeOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0)",
    opacity: 0
  }
}), oAe = new mn("antBadgeLoadingCircle", {
  "0%": {
    transformOrigin: "50%"
  },
  "100%": {
    transform: "translate(50%, -50%) rotate(360deg)",
    transformOrigin: "50%"
  }
}), lAe = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    antCls: o,
    badgeFontHeight: l,
    badgeShadowSize: r,
    badgeHeightSm: a,
    motionDurationSlow: i,
    badgeStatusSize: s,
    marginXS: c,
    badgeRibbonOffset: u
  } = e, d = `${o}-scroll-number`, f = `${o}-ribbon`, p = `${o}-ribbon-wrapper`, m = ry(e, (h, g) => {
    let {
      darkColor: y
    } = g;
    return {
      [`&${t} ${t}-color-${h}`]: {
        background: y,
        [`&:not(${t}-count)`]: {
          color: y
        }
      }
    };
  }), v = ry(e, (h, g) => {
    let {
      darkColor: y
    } = g;
    return {
      [`&${f}-color-${h}`]: {
        background: y,
        color: y
      }
    };
  });
  return {
    [t]: _(_(_(_({}, nn(e)), {
      position: "relative",
      display: "inline-block",
      width: "fit-content",
      lineHeight: 1,
      [`${t}-count`]: {
        zIndex: e.badgeZIndex,
        minWidth: e.badgeHeight,
        height: e.badgeHeight,
        color: e.badgeTextColor,
        fontWeight: e.badgeFontWeight,
        fontSize: e.badgeFontSize,
        lineHeight: `${e.badgeHeight}px`,
        whiteSpace: "nowrap",
        textAlign: "center",
        background: e.badgeColor,
        borderRadius: e.badgeHeight / 2,
        boxShadow: `0 0 0 ${r}px ${e.badgeShadowColor}`,
        transition: `background ${e.motionDurationMid}`,
        a: {
          color: e.badgeTextColor
        },
        "a:hover": {
          color: e.badgeTextColor
        },
        "a:hover &": {
          background: e.badgeColorHover
        }
      },
      [`${t}-count-sm`]: {
        minWidth: a,
        height: a,
        fontSize: e.badgeFontSizeSm,
        lineHeight: `${a}px`,
        borderRadius: a / 2
      },
      [`${t}-multiple-words`]: {
        padding: `0 ${e.paddingXS}px`
      },
      [`${t}-dot`]: {
        zIndex: e.badgeZIndex,
        width: e.badgeDotSize,
        minWidth: e.badgeDotSize,
        height: e.badgeDotSize,
        background: e.badgeColor,
        borderRadius: "100%",
        boxShadow: `0 0 0 ${r}px ${e.badgeShadowColor}`
      },
      [`${t}-dot${d}`]: {
        transition: `background ${i}`
      },
      [`${t}-count, ${t}-dot, ${d}-custom-component`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        transform: "translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&${n}-spin`]: {
          animationName: oAe,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        }
      },
      [`&${t}-status`]: {
        lineHeight: "inherit",
        verticalAlign: "baseline",
        [`${t}-status-dot`]: {
          position: "relative",
          top: -1,
          display: "inline-block",
          width: s,
          height: s,
          verticalAlign: "middle",
          borderRadius: "50%"
        },
        [`${t}-status-success`]: {
          backgroundColor: e.colorSuccess
        },
        [`${t}-status-processing`]: {
          overflow: "visible",
          color: e.colorPrimary,
          backgroundColor: e.colorPrimary,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            borderWidth: r,
            borderStyle: "solid",
            borderColor: "inherit",
            borderRadius: "50%",
            animationName: Z6e,
            animationDuration: e.badgeProcessingDuration,
            animationIterationCount: "infinite",
            animationTimingFunction: "ease-in-out",
            content: '""'
          }
        },
        [`${t}-status-default`]: {
          backgroundColor: e.colorTextPlaceholder
        },
        [`${t}-status-error`]: {
          backgroundColor: e.colorError
        },
        [`${t}-status-warning`]: {
          backgroundColor: e.colorWarning
        },
        [`${t}-status-text`]: {
          marginInlineStart: c,
          color: e.colorText,
          fontSize: e.fontSize
        }
      }
    }), m), {
      [`${t}-zoom-appear, ${t}-zoom-enter`]: {
        animationName: Q6e,
        animationDuration: e.motionDurationSlow,
        animationTimingFunction: e.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`${t}-zoom-leave`]: {
        animationName: eAe,
        animationDuration: e.motionDurationSlow,
        animationTimingFunction: e.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`&${t}-not-a-wrapper`]: {
        [`${t}-zoom-appear, ${t}-zoom-enter`]: {
          animationName: tAe,
          animationDuration: e.motionDurationSlow,
          animationTimingFunction: e.motionEaseOutBack
        },
        [`${t}-zoom-leave`]: {
          animationName: nAe,
          animationDuration: e.motionDurationSlow,
          animationTimingFunction: e.motionEaseOutBack
        },
        [`&:not(${t}-status)`]: {
          verticalAlign: "middle"
        },
        [`${d}-custom-component, ${t}-count`]: {
          transform: "none"
        },
        [`${d}-custom-component, ${d}`]: {
          position: "relative",
          top: "auto",
          display: "block",
          transformOrigin: "50% 50%"
        }
      },
      [`${d}`]: {
        overflow: "hidden",
        [`${d}-only`]: {
          position: "relative",
          display: "inline-block",
          height: e.badgeHeight,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseOutBack}`,
          WebkitTransformStyle: "preserve-3d",
          WebkitBackfaceVisibility: "hidden",
          [`> p${d}-only-unit`]: {
            height: e.badgeHeight,
            margin: 0,
            WebkitTransformStyle: "preserve-3d",
            WebkitBackfaceVisibility: "hidden"
          }
        },
        [`${d}-symbol`]: {
          verticalAlign: "top"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl",
        [`${t}-count, ${t}-dot, ${d}-custom-component`]: {
          transform: "translate(-50%, -50%)"
        }
      }
    }),
    [`${p}`]: {
      position: "relative"
    },
    [`${f}`]: _(_(_(_({}, nn(e)), {
      position: "absolute",
      top: c,
      padding: `0 ${e.paddingXS}px`,
      color: e.colorPrimary,
      lineHeight: `${l}px`,
      whiteSpace: "nowrap",
      backgroundColor: e.colorPrimary,
      borderRadius: e.borderRadiusSM,
      [`${f}-text`]: {
        color: e.colorTextLightSolid
      },
      [`${f}-corner`]: {
        position: "absolute",
        top: "100%",
        width: u,
        height: u,
        color: "currentcolor",
        border: `${u / 2}px solid`,
        transform: e.badgeRibbonCornerTransform,
        transformOrigin: "top",
        filter: e.badgeRibbonCornerFilter
      }
    }), v), {
      [`&${f}-placement-end`]: {
        insetInlineEnd: -u,
        borderEndEndRadius: 0,
        [`${f}-corner`]: {
          insetInlineEnd: 0,
          borderInlineEndColor: "transparent",
          borderBlockEndColor: "transparent"
        }
      },
      [`&${f}-placement-start`]: {
        insetInlineStart: -u,
        borderEndStartRadius: 0,
        [`${f}-corner`]: {
          insetInlineStart: 0,
          borderBlockEndColor: "transparent",
          borderInlineStartColor: "transparent"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
}, Uj = Zt("Badge", (e) => {
  const {
    fontSize: t,
    lineHeight: n,
    fontSizeSM: o,
    lineWidth: l,
    marginXS: r,
    colorBorderBg: a
  } = e, i = Math.round(t * n), s = l, c = "auto", u = i - 2 * s, d = e.colorBgContainer, f = "normal", p = o, m = e.colorError, v = e.colorErrorHover, h = t, g = o / 2, y = o, b = o / 2, C = Vt(e, {
    badgeFontHeight: i,
    badgeShadowSize: s,
    badgeZIndex: c,
    badgeHeight: u,
    badgeTextColor: d,
    badgeFontWeight: f,
    badgeFontSize: p,
    badgeColor: m,
    badgeColorHover: v,
    badgeShadowColor: a,
    badgeHeightSm: h,
    badgeDotSize: g,
    badgeFontSizeSm: y,
    badgeStatusSize: b,
    badgeProcessingDuration: "1.2s",
    badgeRibbonOffset: r,
    // Follow token just by Design. Not related with token
    badgeRibbonCornerTransform: "scaleY(0.75)",
    badgeRibbonCornerFilter: "brightness(75%)"
  });
  return [lAe(C)];
});
var rAe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const aAe = () => ({
  prefix: String,
  color: {
    type: String
  },
  text: de.any,
  placement: {
    type: String,
    default: "end"
  }
}), by = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ABadgeRibbon",
  inheritAttrs: !1,
  props: aAe(),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("ribbon", e), [a, i] = Uj(l), s = O(() => IS(e.color, !1)), c = O(() => [l.value, `${l.value}-placement-${e.placement}`, {
      [`${l.value}-rtl`]: r.value === "rtl",
      [`${l.value}-color-${e.color}`]: s.value
    }]);
    return () => {
      var u, d;
      const {
        class: f,
        style: p
      } = n, m = rAe(n, ["class", "style"]), v = {}, h = {};
      return e.color && !s.value && (v.background = e.color, h.color = e.color), a($("div", Q({
        class: `${l.value}-wrapper ${i.value}`
      }, m), [(u = o.default) === null || u === void 0 ? void 0 : u.call(o), $("div", {
        class: [c.value, f, i.value],
        style: _(_({}, v), p)
      }, [$("span", {
        class: `${l.value}-text`
      }, [e.text || ((d = o.text) === null || d === void 0 ? void 0 : d.call(o))]), $("div", {
        class: `${l.value}-corner`,
        style: h
      }, null)])]));
    };
  }
}), yy = (e) => !isNaN(parseFloat(e)) && isFinite(e), iAe = () => ({
  /** Number to show in badge */
  count: de.any.def(null),
  showZero: {
    type: Boolean,
    default: void 0
  },
  /** Max count to show */
  overflowCount: {
    type: Number,
    default: 99
  },
  /** whether to show red dot without number */
  dot: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  scrollNumberPrefixCls: String,
  status: {
    type: String
  },
  size: {
    type: String,
    default: "default"
  },
  color: String,
  text: de.any,
  offset: Array,
  numberStyle: {
    type: Object,
    default: void 0
  },
  title: String
}), Lv = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ABadge",
  Ribbon: by,
  inheritAttrs: !1,
  props: iAe(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("badge", e), [a, i] = Uj(l), s = O(() => e.count > e.overflowCount ? `${e.overflowCount}+` : e.count), c = O(() => s.value === "0" || s.value === 0), u = O(() => e.count === null || c.value && !e.showZero), d = O(() => (e.status !== null && e.status !== void 0 || e.color !== null && e.color !== void 0) && u.value), f = O(() => e.dot && !c.value), p = O(() => f.value ? "" : s.value), m = O(() => (p.value === null || p.value === void 0 || p.value === "" || c.value && !e.showZero) && !f.value), v = /* @__PURE__ */ H(e.count), h = /* @__PURE__ */ H(p.value), g = /* @__PURE__ */ H(f.value);
    pe([() => e.count, p, f], () => {
      m.value || (v.value = e.count, h.value = p.value, g.value = f.value);
    }, {
      immediate: !0
    });
    const y = O(() => IS(e.color, !1)), b = O(() => ({
      [`${l.value}-status-dot`]: d.value,
      [`${l.value}-status-${e.status}`]: !!e.status,
      [`${l.value}-color-${e.color}`]: y.value
    })), C = O(() => e.color && !y.value ? {
      background: e.color,
      color: e.color
    } : {}), w = O(() => ({
      [`${l.value}-dot`]: g.value,
      [`${l.value}-count`]: !g.value,
      [`${l.value}-count-sm`]: e.size === "small",
      [`${l.value}-multiple-words`]: !g.value && h.value && h.value.toString().length > 1,
      [`${l.value}-status-${e.status}`]: !!e.status,
      [`${l.value}-color-${e.color}`]: y.value
    }));
    return () => {
      var x, E;
      const {
        offset: I,
        title: T,
        color: P
      } = e, k = o.style, N = Wo(n, e, "text"), R = l.value, z = v.value;
      let D = Fn((x = n.default) === null || x === void 0 ? void 0 : x.call(n));
      D = D.length ? D : null;
      const F = !!(!m.value || n.count), M = (() => {
        if (!I)
          return _({}, k);
        const Y = {
          marginTop: yy(I[1]) ? `${I[1]}px` : I[1]
        };
        return r.value === "rtl" ? Y.left = `${parseInt(I[0], 10)}px` : Y.right = `${-parseInt(I[0], 10)}px`, _(_({}, Y), k);
      })(), A = T != null ? T : typeof z == "string" || typeof z == "number" ? z : void 0, L = F || !N ? null : $("span", {
        class: `${R}-status-text`
      }, [N]), B = typeof z == "object" || z === void 0 && n.count ? _n(z != null ? z : (E = n.count) === null || E === void 0 ? void 0 : E.call(n), {
        style: M
      }, !1) : null, V = ke(R, {
        [`${R}-status`]: d.value,
        [`${R}-not-a-wrapper`]: !D,
        [`${R}-rtl`]: r.value === "rtl"
      }, o.class, i.value);
      if (!D && d.value) {
        const Y = M.color;
        return a($("span", Q(Q({}, o), {}, {
          class: V,
          style: M
        }), [$("span", {
          class: b.value,
          style: C.value
        }, null), $("span", {
          style: {
            color: Y
          },
          class: `${R}-status-text`
        }, [N])]));
      }
      const j = da(D ? `${R}-zoom` : "", {
        appear: !1
      });
      let W = _(_({}, M), e.numberStyle);
      return P && !y.value && (W = W || {}, W.background = P), a($("span", Q(Q({}, o), {}, {
        class: V
      }), [D, $(Vn, j, {
        default: () => [_t($(J6e, {
          prefixCls: e.scrollNumberPrefixCls,
          show: F,
          class: w.value,
          count: h.value,
          title: A,
          style: W,
          key: "scrollNumber"
        }, {
          default: () => [B]
        }), [[Jt, F]])]
      }), L]));
    };
  }
});
Lv.install = function(e) {
  return e.component(Lv.name, Lv), e.component(by.name, by), e;
};
const Md = {
  adjustX: 1,
  adjustY: 1
}, Ad = [0, 0], sAe = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: Md,
    offset: [0, -4],
    targetOffset: Ad
  },
  topCenter: {
    points: ["bc", "tc"],
    overflow: Md,
    offset: [0, -4],
    targetOffset: Ad
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Md,
    offset: [0, -4],
    targetOffset: Ad
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Md,
    offset: [0, 4],
    targetOffset: Ad
  },
  bottomCenter: {
    points: ["tc", "bc"],
    overflow: Md,
    offset: [0, 4],
    targetOffset: Ad
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Md,
    offset: [0, 4],
    targetOffset: Ad
  }
};
var cAe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const Gj = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  props: {
    minOverlayWidthMatchTrigger: {
      type: Boolean,
      default: void 0
    },
    arrow: {
      type: Boolean,
      default: !1
    },
    prefixCls: de.string.def("rc-dropdown"),
    transitionName: String,
    overlayClassName: de.string.def(""),
    openClassName: String,
    animation: de.any,
    align: de.object,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    placement: de.string.def("bottomLeft"),
    overlay: de.any,
    trigger: de.oneOfType([de.string, de.arrayOf(de.string)]).def("hover"),
    alignPoint: {
      type: Boolean,
      default: void 0
    },
    showAction: de.array,
    hideAction: de.array,
    getPopupContainer: Function,
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: !1
    },
    mouseEnterDelay: de.number.def(0.15),
    mouseLeaveDelay: de.number.def(0.1)
  },
  emits: ["visibleChange", "overlayClick"],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      expose: l
    } = t;
    const r = /* @__PURE__ */ H(!!e.visible);
    pe(() => e.visible, (p) => {
      p !== void 0 && (r.value = p);
    });
    const a = /* @__PURE__ */ H();
    l({
      triggerRef: a
    });
    const i = (p) => {
      e.visible === void 0 && (r.value = !1), o("overlayClick", p);
    }, s = (p) => {
      e.visible === void 0 && (r.value = p), o("visibleChange", p);
    }, c = () => {
      var p;
      const m = (p = n.overlay) === null || p === void 0 ? void 0 : p.call(n), v = {
        prefixCls: `${e.prefixCls}-menu`,
        onClick: i
      };
      return $(Ge, {
        key: Xz
      }, [e.arrow && $("div", {
        class: `${e.prefixCls}-arrow`
      }, null), _n(m, v, !1)]);
    }, u = O(() => {
      const {
        minOverlayWidthMatchTrigger: p = !e.alignPoint
      } = e;
      return p;
    }), d = () => {
      var p;
      const m = (p = n.default) === null || p === void 0 ? void 0 : p.call(n);
      return r.value && m ? _n(m[0], {
        class: e.openClassName || `${e.prefixCls}-open`
      }, !1) : m;
    }, f = O(() => !e.hideAction && e.trigger.indexOf("contextmenu") !== -1 ? ["click"] : e.hideAction);
    return () => {
      const {
        prefixCls: p,
        arrow: m,
        showAction: v,
        overlayStyle: h,
        trigger: g,
        placement: y,
        align: b,
        getPopupContainer: C,
        transitionName: w,
        animation: x,
        overlayClassName: E
      } = e, I = cAe(e, ["prefixCls", "arrow", "showAction", "overlayStyle", "trigger", "placement", "align", "getPopupContainer", "transitionName", "animation", "overlayClassName"]);
      return $(fd, Q(Q({}, I), {}, {
        prefixCls: p,
        ref: a,
        popupClassName: ke(E, {
          [`${p}-show-arrow`]: m
        }),
        popupStyle: h,
        builtinPlacements: sAe,
        action: g,
        showAction: v,
        hideAction: f.value || [],
        popupPlacement: y,
        popupAlign: b,
        popupTransitionName: w,
        popupAnimation: x,
        popupVisible: r.value,
        stretch: u.value ? "minWidth" : "",
        onPopupVisibleChange: s,
        getPopupContainer: C
      }), {
        popup: c,
        default: d
      });
    };
  }
}), uAe = (e) => {
  const {
    componentCls: t,
    colorPrimary: n
  } = e;
  return {
    [t]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${n})`,
      boxShadow: "0 0 0 0 currentcolor",
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${e.motionEaseOutCirc}`, `opacity 2s ${e.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: "0 0 0 6px currentcolor",
          opacity: 0
        }
      }
    }
  };
}, dAe = Zt("Wave", (e) => [uAe(e)]);
function fAe(e) {
  const t = (e || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  return t && t[1] && t[2] && t[3] ? !(t[1] === t[2] && t[2] === t[3]) : !0;
}
function Iw(e) {
  return e && e !== "#fff" && e !== "#ffffff" && e !== "rgb(255, 255, 255)" && e !== "rgba(255, 255, 255, 1)" && fAe(e) && !/rgba\((?:\d*, ){3}0\)/.test(e) && // any transparent rgba color
  e !== "transparent";
}
function pAe(e) {
  const {
    borderTopColor: t,
    borderColor: n,
    backgroundColor: o
  } = getComputedStyle(e);
  return Iw(t) ? t : Iw(n) ? n : Iw(o) ? o : null;
}
function Tw(e) {
  return Number.isNaN(e) ? 0 : e;
}
const vAe = /* @__PURE__ */ le({
  props: {
    target: Nt(),
    className: String
  },
  setup(e) {
    const t = /* @__PURE__ */ Ce(null), [n, o] = Bn(null), [l, r] = Bn([]), [a, i] = Bn(0), [s, c] = Bn(0), [u, d] = Bn(0), [f, p] = Bn(0), [m, v] = Bn(!1);
    function h() {
      const {
        target: E
      } = e, I = getComputedStyle(E);
      o(pAe(E));
      const T = I.position === "static", {
        borderLeftWidth: P,
        borderTopWidth: k
      } = I;
      i(T ? E.offsetLeft : Tw(-parseFloat(P))), c(T ? E.offsetTop : Tw(-parseFloat(k))), d(E.offsetWidth), p(E.offsetHeight);
      const {
        borderTopLeftRadius: N,
        borderTopRightRadius: R,
        borderBottomLeftRadius: z,
        borderBottomRightRadius: D
      } = I;
      r([N, R, D, z].map((F) => Tw(parseFloat(F))));
    }
    let g, y, b;
    const C = () => {
      clearTimeout(b), rn.cancel(y), g == null || g.disconnect();
    }, w = () => {
      var E;
      const I = (E = t.value) === null || E === void 0 ? void 0 : E.parentElement;
      I && (Bl(null, I), I.parentElement && I.parentElement.removeChild(I));
    };
    nt(() => {
      C(), b = setTimeout(() => {
        w();
      }, 5e3);
      const {
        target: E
      } = e;
      E && (y = rn(() => {
        h(), v(!0);
      }), typeof ResizeObserver != "undefined" && (g = new ResizeObserver(h), g.observe(E)));
    }), yt(() => {
      C();
    });
    const x = (E) => {
      E.propertyName === "opacity" && w();
    };
    return () => {
      if (!m.value)
        return null;
      const E = {
        left: `${a.value}px`,
        top: `${s.value}px`,
        width: `${u.value}px`,
        height: `${f.value}px`,
        borderRadius: l.value.map((I) => `${I}px`).join(" ")
      };
      return n && (E["--wave-color"] = n.value), $(Vn, {
        appear: !0,
        name: "wave-motion",
        appearFromClass: "wave-motion-appear",
        appearActiveClass: "wave-motion-appear",
        appearToClass: "wave-motion-appear wave-motion-appear-active"
      }, {
        default: () => [$("div", {
          ref: t,
          class: e.className,
          style: E,
          onTransitionend: x
        }, null)]
      });
    };
  }
});
function mAe(e, t) {
  const n = document.createElement("div");
  return n.style.position = "absolute", n.style.left = "0px", n.style.top = "0px", e == null || e.insertBefore(n, e == null ? void 0 : e.firstChild), Bl($(vAe, {
    target: e,
    className: t
  }, null), n), () => {
    Bl(null, n), n.parentElement && n.parentElement.removeChild(n);
  };
}
function hAe(e, t) {
  const n = xt();
  let o;
  function l() {
    var r;
    const a = nr(n);
    o == null || o(), !(!((r = t == null ? void 0 : t.value) === null || r === void 0) && r.disabled || !a) && (o = mAe(a, e.value));
  }
  return yt(() => {
    o == null || o();
  }), l;
}
const XI = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Wave",
  props: {
    disabled: Boolean
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = xt(), {
      prefixCls: l,
      wave: r
    } = bt("wave", e), [, a] = dAe(l), i = hAe(O(() => ke(l.value, a.value)), r);
    let s;
    const c = () => {
      nr(o).removeEventListener("click", s, !0);
    };
    return nt(() => {
      pe(() => e.disabled, () => {
        c(), Ke(() => {
          const u = nr(o);
          u == null || u.removeEventListener("click", s, !0), !(!u || u.nodeType !== 1 || e.disabled) && (s = (d) => {
            d.target.tagName === "INPUT" || !pS(d.target) || // No need wave
            !u.getAttribute || u.getAttribute("disabled") || u.disabled || u.className.includes("disabled") || u.className.includes("-leave") || i();
          }, u.addEventListener("click", s, !0));
        });
      }, {
        immediate: !0,
        flush: "post"
      });
    }), yt(() => {
      c();
    }), () => {
      var u;
      return (u = n.default) === null || u === void 0 ? void 0 : u.call(n)[0];
    };
  }
});
function Sy(e) {
  return e === "danger" ? {
    danger: !0
  } : {
    type: e
  };
}
const Yj = () => ({
  prefixCls: String,
  type: String,
  htmlType: {
    type: String,
    default: "button"
  },
  shape: {
    type: String
  },
  size: {
    type: String
  },
  loading: {
    type: [Boolean, Object],
    default: () => !1
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  ghost: {
    type: Boolean,
    default: void 0
  },
  block: {
    type: Boolean,
    default: void 0
  },
  danger: {
    type: Boolean,
    default: void 0
  },
  icon: de.any,
  href: String,
  target: String,
  title: String,
  onClick: Yu(),
  onMousedown: Yu()
}), n6 = (e) => {
  e && (e.style.width = "0px", e.style.opacity = "0", e.style.transform = "scale(0)");
}, o6 = (e) => {
  Ke(() => {
    e && (e.style.width = `${e.scrollWidth}px`, e.style.opacity = "1", e.style.transform = "scale(1)");
  });
}, l6 = (e) => {
  e && e.style && (e.style.width = null, e.style.opacity = null, e.style.transform = null);
}, gAe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "LoadingIcon",
  props: {
    prefixCls: String,
    loading: [Boolean, Object],
    existIcon: Boolean
  },
  setup(e) {
    return () => {
      const {
        existIcon: t,
        prefixCls: n,
        loading: o
      } = e;
      if (t)
        return $("span", {
          class: `${n}-loading-icon`
        }, [$(ar, null, null)]);
      const l = !!o;
      return $(Vn, {
        name: `${n}-loading-icon-motion`,
        onBeforeEnter: n6,
        onEnter: o6,
        onAfterEnter: l6,
        onBeforeLeave: o6,
        onLeave: (r) => {
          setTimeout(() => {
            n6(r);
          });
        },
        onAfterLeave: l6
      }, {
        default: () => [l ? $("span", {
          class: `${n}-loading-icon`
        }, [$(ar, null, null)]) : null]
      });
    };
  }
}), r6 = (e, t) => ({
  // Border
  [`> span, > ${e}`]: {
    "&:not(:last-child)": {
      [`&, & > ${e}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: t
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${e}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: t
        }
      }
    }
  }
}), bAe = (e) => {
  const {
    componentCls: t,
    fontSize: n,
    lineWidth: o,
    colorPrimaryHover: l,
    colorErrorHover: r
  } = e;
  return {
    [`${t}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${t}`]: {
          "&:not(:last-child)": {
            [`&, & > ${t}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: -o,
            [`&, & > ${t}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [t]: {
          position: "relative",
          zIndex: 1,
          "&:hover,\n          &:focus,\n          &:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${t}-icon-only`]: {
          fontSize: n
        }
      },
      // Border Color
      r6(`${t}-primary`, l),
      r6(`${t}-danger`, r)
    ]
  };
};
function yAe(e, t) {
  return {
    // border collapse
    [`&-item:not(${t}-last-item)`]: {
      marginBottom: -e.lineWidth
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function SAe(e, t) {
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${t}-first-item:not(${t}-last-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${t}-last-item:not(${t}-first-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function CAe(e) {
  const t = `${e.componentCls}-compact-vertical`;
  return {
    [t]: _(_({}, yAe(e, t)), SAe(e.componentCls, t))
  };
}
const wAe = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: {
      outline: "none",
      position: "relative",
      display: "inline-block",
      fontWeight: 400,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      backgroundColor: "transparent",
      border: `${e.lineWidth}px ${e.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      lineHeight: e.lineHeight,
      color: e.colorText,
      "> span": {
        display: "inline-block"
      },
      // Leave a space between icon and text.
      [`> ${n} + span, > span + ${n}`]: {
        marginInlineStart: e.marginXS
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": _({}, ys(e)),
      // make `btn-icon-only` not too narrow
      [`&-icon-only${t}-compact-item`]: {
        flex: "none"
      },
      // Special styles for Primary Button
      [`&-compact-item${t}-primary`]: {
        [`&:not([disabled]) + ${t}-compact-item${t}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: -e.lineWidth,
            insetInlineStart: -e.lineWidth,
            display: "inline-block",
            width: e.lineWidth,
            height: `calc(100% + ${e.lineWidth * 2}px)`,
            backgroundColor: e.colorPrimaryHover,
            content: '""'
          }
        }
      },
      // Special styles for Primary Button
      "&-compact-vertical-item": {
        [`&${t}-primary`]: {
          [`&:not([disabled]) + ${t}-compact-vertical-item${t}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: -e.lineWidth,
              insetInlineStart: -e.lineWidth,
              display: "inline-block",
              width: `calc(100% + ${e.lineWidth * 2}px)`,
              height: e.lineWidth,
              backgroundColor: e.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
}, Ss = (e, t) => ({
  "&:not(:disabled)": {
    "&:hover": e,
    "&:active": t
  }
}), $Ae = (e) => ({
  minWidth: e.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
}), xAe = (e) => ({
  borderRadius: e.controlHeight,
  paddingInlineStart: e.controlHeight / 2,
  paddingInlineEnd: e.controlHeight / 2
}), T2 = (e) => ({
  cursor: "not-allowed",
  borderColor: e.colorBorder,
  color: e.colorTextDisabled,
  backgroundColor: e.colorBgContainerDisabled,
  boxShadow: "none"
}), Cy = (e, t, n, o, l, r, a) => ({
  [`&${e}-background-ghost`]: _(_({
    color: t || void 0,
    backgroundColor: "transparent",
    borderColor: n || void 0,
    boxShadow: "none"
  }, Ss(_({
    backgroundColor: "transparent"
  }, r), _({
    backgroundColor: "transparent"
  }, a))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: o || void 0,
      borderColor: l || void 0
    }
  })
}), qI = (e) => ({
  "&:disabled": _({}, T2(e))
}), Xj = (e) => _({}, qI(e)), wy = (e) => ({
  "&:disabled": {
    cursor: "not-allowed",
    color: e.colorTextDisabled
  }
}), qj = (e) => _(_(_(_(_({}, Xj(e)), {
  backgroundColor: e.colorBgContainer,
  borderColor: e.colorBorder,
  boxShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlTmpOutline}`
}), Ss({
  color: e.colorPrimaryHover,
  borderColor: e.colorPrimaryHover
}, {
  color: e.colorPrimaryActive,
  borderColor: e.colorPrimaryActive
})), Cy(e.componentCls, e.colorBgContainer, e.colorBgContainer, e.colorTextDisabled, e.colorBorder)), {
  [`&${e.componentCls}-dangerous`]: _(_(_({
    color: e.colorError,
    borderColor: e.colorError
  }, Ss({
    color: e.colorErrorHover,
    borderColor: e.colorErrorBorderHover
  }, {
    color: e.colorErrorActive,
    borderColor: e.colorErrorActive
  })), Cy(e.componentCls, e.colorError, e.colorError, e.colorTextDisabled, e.colorBorder)), qI(e))
}), EAe = (e) => _(_(_(_(_({}, Xj(e)), {
  color: e.colorTextLightSolid,
  backgroundColor: e.colorPrimary,
  boxShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlOutline}`
}), Ss({
  color: e.colorTextLightSolid,
  backgroundColor: e.colorPrimaryHover
}, {
  color: e.colorTextLightSolid,
  backgroundColor: e.colorPrimaryActive
})), Cy(e.componentCls, e.colorPrimary, e.colorPrimary, e.colorTextDisabled, e.colorBorder, {
  color: e.colorPrimaryHover,
  borderColor: e.colorPrimaryHover
}, {
  color: e.colorPrimaryActive,
  borderColor: e.colorPrimaryActive
})), {
  [`&${e.componentCls}-dangerous`]: _(_(_({
    backgroundColor: e.colorError,
    boxShadow: `0 ${e.controlOutlineWidth}px 0 ${e.colorErrorOutline}`
  }, Ss({
    backgroundColor: e.colorErrorHover
  }, {
    backgroundColor: e.colorErrorActive
  })), Cy(e.componentCls, e.colorError, e.colorError, e.colorTextDisabled, e.colorBorder, {
    color: e.colorErrorHover,
    borderColor: e.colorErrorHover
  }, {
    color: e.colorErrorActive,
    borderColor: e.colorErrorActive
  })), qI(e))
}), OAe = (e) => _(_({}, qj(e)), {
  borderStyle: "dashed"
}), _Ae = (e) => _(_(_({
  color: e.colorLink
}, Ss({
  color: e.colorLinkHover
}, {
  color: e.colorLinkActive
})), wy(e)), {
  [`&${e.componentCls}-dangerous`]: _(_({
    color: e.colorError
  }, Ss({
    color: e.colorErrorHover
  }, {
    color: e.colorErrorActive
  })), wy(e))
}), IAe = (e) => _(_(_({}, Ss({
  color: e.colorText,
  backgroundColor: e.colorBgTextHover
}, {
  color: e.colorText,
  backgroundColor: e.colorBgTextActive
})), wy(e)), {
  [`&${e.componentCls}-dangerous`]: _(_({
    color: e.colorError
  }, wy(e)), Ss({
    color: e.colorErrorHover,
    backgroundColor: e.colorErrorBg
  }, {
    color: e.colorErrorHover,
    backgroundColor: e.colorErrorBg
  }))
}), TAe = (e) => _(_({}, T2(e)), {
  [`&${e.componentCls}:hover`]: _({}, T2(e))
}), PAe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-default`]: qj(e),
    [`${t}-primary`]: EAe(e),
    [`${t}-dashed`]: OAe(e),
    [`${t}-link`]: _Ae(e),
    [`${t}-text`]: IAe(e),
    [`${t}-disabled`]: TAe(e)
  };
}, JI = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls: n,
    iconCls: o,
    controlHeight: l,
    fontSize: r,
    lineHeight: a,
    lineWidth: i,
    borderRadius: s,
    buttonPaddingHorizontal: c
  } = e, u = Math.max(0, (l - r * a) / 2 - i), d = c - i, f = `${n}-icon-only`;
  return [
    // Size
    {
      [`${n}${t}`]: {
        fontSize: r,
        height: l,
        padding: `${u}px ${d}px`,
        borderRadius: s,
        [`&${f}`]: {
          width: l,
          paddingInlineStart: 0,
          paddingInlineEnd: 0,
          [`&${n}-round`]: {
            width: "auto"
          },
          "> span": {
            transform: "scale(1.143)"
            // 14px -> 16px
          }
        },
        // Loading
        [`&${n}-loading`]: {
          opacity: e.opacityLoading,
          cursor: "default"
        },
        [`${n}-loading-icon`]: {
          transition: `width ${e.motionDurationSlow} ${e.motionEaseInOut}, opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`
        },
        [`&:not(${f}) ${n}-loading-icon > ${o}`]: {
          marginInlineEnd: e.marginXS
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${n}${n}-circle${t}`]: $Ae(e)
    },
    {
      [`${n}${n}-round${t}`]: xAe(e)
    }
  ];
}, kAe = (e) => JI(e), NAe = (e) => {
  const t = Vt(e, {
    controlHeight: e.controlHeightSM,
    padding: e.paddingXS,
    buttonPaddingHorizontal: 8,
    borderRadius: e.borderRadiusSM
  });
  return JI(t, `${e.componentCls}-sm`);
}, MAe = (e) => {
  const t = Vt(e, {
    controlHeight: e.controlHeightLG,
    fontSize: e.fontSizeLG,
    borderRadius: e.borderRadiusLG
  });
  return JI(t, `${e.componentCls}-lg`);
}, AAe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`&${t}-block`]: {
        width: "100%"
      }
    }
  };
}, RAe = Zt("Button", (e) => {
  const {
    controlTmpOutline: t,
    paddingContentHorizontal: n
  } = e, o = Vt(e, {
    colorOutlineDefault: t,
    buttonPaddingHorizontal: n
  });
  return [
    // Shared
    wAe(o),
    // Size
    NAe(o),
    kAe(o),
    MAe(o),
    // Block
    AAe(o),
    // Group (type, ghost, danger, disabled, loading)
    PAe(o),
    // Button Group
    bAe(o),
    // Space Compact
    Rp(e, {
      focus: !1
    }),
    CAe(e)
  ];
}), DAe = () => ({
  prefixCls: String,
  size: {
    type: String
  }
}), Jj = FI(), $y = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AButtonGroup",
  props: DAe(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o,
      direction: l
    } = bt("btn-group", e), [, , r] = _s();
    Jj.useProvide(/* @__PURE__ */ kt({
      size: O(() => e.size)
    }));
    const a = O(() => {
      const {
        size: i
      } = e;
      let s = "";
      switch (i) {
        case "large":
          s = "lg";
          break;
        case "small":
          s = "sm";
          break;
        case "middle":
        case void 0:
          break;
        default:
          un(!i, "Button.Group", "Invalid prop `size`.");
      }
      return {
        [`${o.value}`]: !0,
        [`${o.value}-${s}`]: s,
        [`${o.value}-rtl`]: l.value === "rtl",
        [r.value]: !0
      };
    });
    return () => {
      var i;
      return $("div", {
        class: a.value
      }, [Fn((i = n.default) === null || i === void 0 ? void 0 : i.call(n))]);
    };
  }
}), a6 = /^[\u4e00-\u9fa5]{2}$/, i6 = a6.test.bind(a6);
function Mg(e) {
  return e === "text" || e === "link";
}
const ko = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AButton",
  inheritAttrs: !1,
  __ANT_BUTTON: !0,
  props: sn(Yj(), {
    type: "default"
  }),
  slots: Object,
  // emits: ['click', 'mousedown'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: l,
      expose: r
    } = t;
    const {
      prefixCls: a,
      autoInsertSpaceInButton: i,
      direction: s,
      size: c
    } = bt("btn", e), [u, d] = RAe(a), f = Jj.useInject(), p = Cr(), m = O(() => {
      var D;
      return (D = e.disabled) !== null && D !== void 0 ? D : p.value;
    }), v = /* @__PURE__ */ Ce(null), h = /* @__PURE__ */ Ce(void 0);
    let g = !1;
    const y = /* @__PURE__ */ Ce(!1), b = /* @__PURE__ */ Ce(!1), C = O(() => i.value !== !1), {
      compactSize: w,
      compactItemClassnames: x
    } = Rc(a, s), E = O(() => typeof e.loading == "object" && e.loading.delay ? e.loading.delay || !0 : !!e.loading);
    pe(E, (D) => {
      clearTimeout(h.value), typeof E.value == "number" ? h.value = setTimeout(() => {
        y.value = D;
      }, E.value) : y.value = D;
    }, {
      immediate: !0
    });
    const I = O(() => {
      const {
        type: D,
        shape: F = "default",
        ghost: M,
        block: A,
        danger: L
      } = e, B = a.value, V = {
        large: "lg",
        small: "sm",
        middle: void 0
      }, j = w.value || (f == null ? void 0 : f.size) || c.value, W = j && V[j] || "";
      return [x.value, {
        [d.value]: !0,
        [`${B}`]: !0,
        [`${B}-${F}`]: F !== "default" && F,
        [`${B}-${D}`]: D,
        [`${B}-${W}`]: W,
        [`${B}-loading`]: y.value,
        [`${B}-background-ghost`]: M && !Mg(D),
        [`${B}-two-chinese-chars`]: b.value && C.value,
        [`${B}-block`]: A,
        [`${B}-dangerous`]: !!L,
        [`${B}-rtl`]: s.value === "rtl"
      }];
    }), T = () => {
      const D = v.value;
      if (!D || i.value === !1)
        return;
      const F = D.textContent;
      g && i6(F) ? b.value || (b.value = !0) : b.value && (b.value = !1);
    }, P = (D) => {
      if (y.value || m.value) {
        D.preventDefault();
        return;
      }
      l("click", D);
    }, k = (D) => {
      l("mousedown", D);
    }, N = (D, F) => {
      const M = F ? " " : "";
      if (D.type === Vr) {
        let A = D.children.trim();
        return i6(A) && (A = A.split("").join(M)), $("span", null, [A]);
      }
      return D;
    };
    return Ot(() => {
      un(!(e.ghost && Mg(e.type)), "Button", "`link` or `text` button can't be a `ghost` button.");
    }), nt(T), $o(T), yt(() => {
      h.value && clearTimeout(h.value);
    }), r({
      focus: () => {
        var D;
        (D = v.value) === null || D === void 0 || D.focus();
      },
      blur: () => {
        var D;
        (D = v.value) === null || D === void 0 || D.blur();
      }
    }), () => {
      var D, F;
      const {
        icon: M = (D = n.icon) === null || D === void 0 ? void 0 : D.call(n)
      } = e, A = Fn((F = n.default) === null || F === void 0 ? void 0 : F.call(n));
      g = A.length === 1 && !M && !Mg(e.type);
      const {
        type: L,
        htmlType: B,
        href: V,
        title: j,
        target: W
      } = e, Y = y.value ? "loading" : M, U = _(_({}, o), {
        title: j,
        disabled: m.value,
        class: [I.value, o.class, {
          [`${a.value}-icon-only`]: A.length === 0 && !!Y
        }],
        onClick: P,
        onMousedown: k
      });
      m.value || delete U.disabled;
      const te = M && !y.value ? M : $(gAe, {
        existIcon: !!M,
        prefixCls: a.value,
        loading: !!y.value
      }, null), J = A.map((oe) => N(oe, g && C.value));
      if (V !== void 0)
        return u($("a", Q(Q({}, U), {}, {
          href: V,
          target: W,
          ref: v
        }), [te, J]));
      let re = $("button", Q(Q({}, U), {}, {
        ref: v,
        type: B
      }), [te, J]);
      if (!Mg(L)) {
        const oe = /* @__PURE__ */ function() {
          return re;
        }();
        re = $(XI, {
          ref: "wave",
          disabled: !!y.value
        }, {
          default: () => [oe]
        });
      }
      return u(re);
    };
  }
});
ko.Group = $y;
ko.install = function(e) {
  return e.component(ko.name, ko), e.component($y.name, $y), e;
};
const Zj = () => ({
  arrow: zt([Boolean, Object]),
  trigger: {
    type: [Array, String]
  },
  menu: Nt(),
  overlay: de.any,
  /** @deprecated Please use `open` instead */
  visible: Qe(),
  open: Qe(),
  disabled: Qe(),
  danger: Qe(),
  autofocus: Qe(),
  align: Nt(),
  getPopupContainer: Function,
  prefixCls: String,
  transitionName: String,
  placement: String,
  overlayClassName: String,
  overlayStyle: Nt(),
  forceRender: Qe(),
  mouseEnterDelay: Number,
  mouseLeaveDelay: Number,
  openClassName: String,
  minOverlayWidthMatchTrigger: Qe(),
  destroyPopupOnHide: Qe(),
  /** @deprecated Please use `onOpenChange` instead */
  onVisibleChange: {
    type: Function
  },
  /** @deprecated Please use `onUpdate:open` instead */
  "onUpdate:visible": {
    type: Function
  },
  onOpenChange: {
    type: Function
  },
  "onUpdate:open": {
    type: Function
  }
}), Pw = Yj(), LAe = () => _(_({}, Zj()), {
  type: Pw.type,
  size: String,
  htmlType: Pw.htmlType,
  href: String,
  disabled: Qe(),
  prefixCls: String,
  icon: de.any,
  title: String,
  loading: Pw.loading,
  onClick: Yu()
});
var BAe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "ellipsis", theme: "outlined" };
function s6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      FAe(e, l, n[l]);
    });
  }
  return e;
}
function FAe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Th = function(t, n) {
  var o = s6({}, t, n.attrs);
  return $(cn, s6({}, o, {
    icon: BAe
  }), null);
};
Th.displayName = "EllipsisOutlined";
Th.inheritAttrs = !1;
const VAe = (e) => {
  const {
    componentCls: t,
    antCls: n,
    paddingXS: o,
    opacityLoading: l
  } = e;
  return {
    [`${t}-button`]: {
      whiteSpace: "nowrap",
      [`&${n}-btn-group > ${n}-btn`]: {
        [`&-loading, &-loading + ${n}-btn`]: {
          cursor: "default",
          pointerEvents: "none",
          opacity: l
        },
        [`&:last-child:not(:first-child):not(${n}-btn-icon-only)`]: {
          paddingInline: o
        }
      }
    }
  };
}, zAe = (e) => {
  const {
    componentCls: t,
    menuCls: n,
    colorError: o,
    colorTextLightSolid: l
  } = e, r = `${n}-item`;
  return {
    [`${t}, ${t}-menu-submenu`]: {
      [`${n} ${r}`]: {
        [`&${r}-danger:not(${r}-disabled)`]: {
          color: o,
          "&:hover": {
            color: l,
            backgroundColor: o
          }
        }
      }
    }
  };
}, HAe = (e) => {
  const {
    componentCls: t,
    menuCls: n,
    zIndexPopup: o,
    dropdownArrowDistance: l,
    dropdownArrowOffset: r,
    sizePopupArrow: a,
    antCls: i,
    iconCls: s,
    motionDurationMid: c,
    dropdownPaddingVertical: u,
    fontSize: d,
    dropdownEdgeChildPadding: f,
    colorTextDisabled: p,
    fontSizeIcon: m,
    controlPaddingHorizontal: v,
    colorBgElevated: h,
    boxShadowPopoverArrow: g
  } = e;
  return [
    {
      [t]: _(_({}, nn(e)), {
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: !0,
          value: -9999
        },
        zIndex: o,
        display: "block",
        // A placeholder out of dropdown visible range to avoid close when user moving
        "&::before": {
          position: "absolute",
          insetBlock: -l + a / 2,
          // insetInlineStart: -7, // FIXME: Seems not work for hidden element
          zIndex: -9999,
          opacity: 1e-4,
          content: '""'
        },
        [`${t}-wrap`]: {
          position: "relative",
          [`${i}-btn > ${s}-down`]: {
            fontSize: m
          },
          [`${s}-down::before`]: {
            transition: `transform ${c}`
          }
        },
        [`${t}-wrap-open`]: {
          [`${s}-down::before`]: {
            transform: "rotate(180deg)"
          }
        },
        "\n        &-hidden,\n        &-menu-hidden,\n        &-menu-submenu-hidden\n      ": {
          display: "none"
        },
        // =============================================================
        // ==                          Arrow                          ==
        // =============================================================
        // Offset the popover to account for the dropdown arrow
        [`
        &-show-arrow${t}-placement-topLeft,
        &-show-arrow${t}-placement-top,
        &-show-arrow${t}-placement-topRight
      `]: {
          paddingBottom: l
        },
        [`
        &-show-arrow${t}-placement-bottomLeft,
        &-show-arrow${t}-placement-bottom,
        &-show-arrow${t}-placement-bottomRight
      `]: {
          paddingTop: l
        },
        // Note: .popover-arrow is outer, .popover-arrow:after is inner
        [`${t}-arrow`]: _({
          position: "absolute",
          zIndex: 1,
          display: "block"
        }, cI(a, e.borderRadiusXS, e.borderRadiusOuter, h, g)),
        [`
        &-placement-top > ${t}-arrow,
        &-placement-topLeft > ${t}-arrow,
        &-placement-topRight > ${t}-arrow
      `]: {
          bottom: l,
          transform: "translateY(100%) rotate(180deg)"
        },
        [`&-placement-top > ${t}-arrow`]: {
          left: {
            _skip_check_: !0,
            value: "50%"
          },
          transform: "translateX(-50%) translateY(100%) rotate(180deg)"
        },
        [`&-placement-topLeft > ${t}-arrow`]: {
          left: {
            _skip_check_: !0,
            value: r
          }
        },
        [`&-placement-topRight > ${t}-arrow`]: {
          right: {
            _skip_check_: !0,
            value: r
          }
        },
        [`
          &-placement-bottom > ${t}-arrow,
          &-placement-bottomLeft > ${t}-arrow,
          &-placement-bottomRight > ${t}-arrow
        `]: {
          top: l,
          transform: "translateY(-100%)"
        },
        [`&-placement-bottom > ${t}-arrow`]: {
          left: {
            _skip_check_: !0,
            value: "50%"
          },
          transform: "translateY(-100%) translateX(-50%)"
        },
        [`&-placement-bottomLeft > ${t}-arrow`]: {
          left: {
            _skip_check_: !0,
            value: r
          }
        },
        [`&-placement-bottomRight > ${t}-arrow`]: {
          right: {
            _skip_check_: !0,
            value: r
          }
        },
        // =============================================================
        // ==                         Motion                          ==
        // =============================================================
        // When position is not enough for dropdown, the placement will revert.
        // We will handle this with revert motion name.
        [`&${i}-slide-down-enter${i}-slide-down-enter-active${t}-placement-bottomLeft,
          &${i}-slide-down-appear${i}-slide-down-appear-active${t}-placement-bottomLeft,
          &${i}-slide-down-enter${i}-slide-down-enter-active${t}-placement-bottom,
          &${i}-slide-down-appear${i}-slide-down-appear-active${t}-placement-bottom,
          &${i}-slide-down-enter${i}-slide-down-enter-active${t}-placement-bottomRight,
          &${i}-slide-down-appear${i}-slide-down-appear-active${t}-placement-bottomRight`]: {
          animationName: yS
        },
        [`&${i}-slide-up-enter${i}-slide-up-enter-active${t}-placement-topLeft,
          &${i}-slide-up-appear${i}-slide-up-appear-active${t}-placement-topLeft,
          &${i}-slide-up-enter${i}-slide-up-enter-active${t}-placement-top,
          &${i}-slide-up-appear${i}-slide-up-appear-active${t}-placement-top,
          &${i}-slide-up-enter${i}-slide-up-enter-active${t}-placement-topRight,
          &${i}-slide-up-appear${i}-slide-up-appear-active${t}-placement-topRight`]: {
          animationName: CS
        },
        [`&${i}-slide-down-leave${i}-slide-down-leave-active${t}-placement-bottomLeft,
          &${i}-slide-down-leave${i}-slide-down-leave-active${t}-placement-bottom,
          &${i}-slide-down-leave${i}-slide-down-leave-active${t}-placement-bottomRight`]: {
          animationName: SS
        },
        [`&${i}-slide-up-leave${i}-slide-up-leave-active${t}-placement-topLeft,
          &${i}-slide-up-leave${i}-slide-up-leave-active${t}-placement-top,
          &${i}-slide-up-leave${i}-slide-up-leave-active${t}-placement-topRight`]: {
          animationName: wS
        }
      })
    },
    {
      // =============================================================
      // ==                          Menu                           ==
      // =============================================================
      [`${t} ${n}`]: {
        position: "relative",
        margin: 0
      },
      [`${n}-submenu-popup`]: {
        position: "absolute",
        zIndex: o,
        background: "transparent",
        boxShadow: "none",
        transformOrigin: "0 0",
        "ul,li": {
          listStyle: "none"
        },
        ul: {
          marginInline: "0.3em"
        }
      },
      [`${t}, ${t}-menu-submenu`]: {
        [n]: _(_({
          padding: f,
          listStyleType: "none",
          backgroundColor: h,
          backgroundClip: "padding-box",
          borderRadius: e.borderRadiusLG,
          outline: "none",
          boxShadow: e.boxShadowSecondary
        }, ys(e)), {
          [`${n}-item-group-title`]: {
            padding: `${u}px ${v}px`,
            color: e.colorTextDescription,
            transition: `all ${c}`
          },
          // ======================= Item Content =======================
          [`${n}-item`]: {
            position: "relative",
            display: "flex",
            alignItems: "center",
            borderRadius: e.borderRadiusSM
          },
          [`${n}-item-icon`]: {
            minWidth: d,
            marginInlineEnd: e.marginXS,
            fontSize: e.fontSizeSM
          },
          [`${n}-title-content`]: {
            flex: "auto",
            "> a": {
              color: "inherit",
              transition: `all ${c}`,
              "&:hover": {
                color: "inherit"
              },
              "&::after": {
                position: "absolute",
                inset: 0,
                content: '""'
              }
            }
          },
          // =========================== Item ===========================
          [`${n}-item, ${n}-submenu-title`]: _(_({
            clear: "both",
            margin: 0,
            padding: `${u}px ${v}px`,
            color: e.colorText,
            fontWeight: "normal",
            fontSize: d,
            lineHeight: e.lineHeight,
            cursor: "pointer",
            transition: `all ${c}`,
            "&:hover, &-active": {
              backgroundColor: e.controlItemBgHover
            }
          }, ys(e)), {
            "&-selected": {
              color: e.colorPrimary,
              backgroundColor: e.controlItemBgActive,
              "&:hover, &-active": {
                backgroundColor: e.controlItemBgActiveHover
              }
            },
            "&-disabled": {
              color: p,
              cursor: "not-allowed",
              "&:hover": {
                color: p,
                backgroundColor: h,
                cursor: "not-allowed"
              },
              a: {
                pointerEvents: "none"
              }
            },
            "&-divider": {
              height: 1,
              margin: `${e.marginXXS}px 0`,
              overflow: "hidden",
              lineHeight: 0,
              backgroundColor: e.colorSplit
            },
            [`${t}-menu-submenu-expand-icon`]: {
              position: "absolute",
              insetInlineEnd: e.paddingXS,
              [`${t}-menu-submenu-arrow-icon`]: {
                marginInlineEnd: "0 !important",
                color: e.colorTextDescription,
                fontSize: m,
                fontStyle: "normal"
              }
            }
          }),
          [`${n}-item-group-list`]: {
            margin: `0 ${e.marginXS}px`,
            padding: 0,
            listStyle: "none"
          },
          [`${n}-submenu-title`]: {
            paddingInlineEnd: v + e.fontSizeSM
          },
          [`${n}-submenu-vertical`]: {
            position: "relative"
          },
          [`${n}-submenu${n}-submenu-disabled ${t}-menu-submenu-title`]: {
            [`&, ${t}-menu-submenu-arrow-icon`]: {
              color: p,
              backgroundColor: h,
              cursor: "not-allowed"
            }
          },
          // https://github.com/ant-design/ant-design/issues/19264
          [`${n}-submenu-selected ${t}-menu-submenu-title`]: {
            color: e.colorPrimary
          }
        })
      }
    },
    // Follow code may reuse in other components
    [_i(e, "slide-up"), _i(e, "slide-down"), cp(e, "move-up"), cp(e, "move-down"), Ap(e, "zoom-big")]
  ];
}, Qj = Zt("Dropdown", (e, t) => {
  let {
    rootPrefixCls: n
  } = t;
  const {
    marginXXS: o,
    sizePopupArrow: l,
    controlHeight: r,
    fontSize: a,
    lineHeight: i,
    paddingXXS: s,
    componentCls: c,
    borderRadiusOuter: u,
    borderRadiusLG: d
  } = e, f = (r - a * i) / 2, {
    dropdownArrowOffset: p
  } = jj({
    sizePopupArrow: l,
    contentRadius: d,
    borderRadiusOuter: u
  }), m = Vt(e, {
    menuCls: `${c}-menu`,
    rootPrefixCls: n,
    dropdownArrowDistance: l / 2 + o,
    dropdownArrowOffset: p,
    dropdownPaddingVertical: f,
    dropdownEdgeChildPadding: s
  });
  return [HAe(m), VAe(m), zAe(m)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 50
}));
var jAe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const WAe = ko.Group, Dm = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ADropdownButton",
  inheritAttrs: !1,
  __ANT_BUTTON: !0,
  props: sn(LAe(), {
    trigger: "hover",
    placement: "bottomRight",
    type: "default"
  }),
  // emits: ['click', 'visibleChange', 'update:visible'],s
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: l
    } = t;
    const r = (f) => {
      l("update:visible", f), l("visibleChange", f), l("update:open", f), l("openChange", f);
    }, {
      prefixCls: a,
      direction: i,
      getPopupContainer: s
    } = bt("dropdown", e), c = O(() => `${a.value}-button`), [u, d] = Qj(a);
    return () => {
      var f, p;
      const m = _(_({}, e), o), {
        type: v = "default",
        disabled: h,
        danger: g,
        loading: y,
        htmlType: b,
        class: C = "",
        overlay: w = (f = n.overlay) === null || f === void 0 ? void 0 : f.call(n),
        trigger: x,
        align: E,
        open: I,
        visible: T,
        onVisibleChange: P,
        placement: k = i.value === "rtl" ? "bottomLeft" : "bottomRight",
        href: N,
        title: R,
        icon: z = ((p = n.icon) === null || p === void 0 ? void 0 : p.call(n)) || $(Th, null, null),
        mouseEnterDelay: D,
        mouseLeaveDelay: F,
        overlayClassName: M,
        overlayStyle: A,
        destroyPopupOnHide: L,
        onClick: B,
        "onUpdate:open": V
      } = m, j = jAe(m, ["type", "disabled", "danger", "loading", "htmlType", "class", "overlay", "trigger", "align", "open", "visible", "onVisibleChange", "placement", "href", "title", "icon", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "onClick", "onUpdate:open"]), W = {
        align: E,
        disabled: h,
        trigger: h ? [] : x,
        placement: k,
        getPopupContainer: s == null ? void 0 : s.value,
        onOpenChange: r,
        mouseEnterDelay: D,
        mouseLeaveDelay: F,
        open: I != null ? I : T,
        overlayClassName: M,
        overlayStyle: A,
        destroyPopupOnHide: L
      }, Y = $(ko, {
        danger: g,
        type: v,
        disabled: h,
        loading: y,
        onClick: B,
        htmlType: b,
        href: N,
        title: R
      }, {
        default: n.default
      }), U = $(ko, {
        danger: g,
        type: v,
        icon: z
      }, null);
      return u($(WAe, Q(Q({}, j), {}, {
        class: ke(c.value, C, d.value)
      }), {
        default: () => [n.leftButton ? n.leftButton({
          button: Y
        }) : Y, $(Ia, W, {
          default: () => [n.rightButton ? n.rightButton({
            button: U
          }) : U],
          overlay: () => w
        })]
      }));
    };
  }
});
var KAe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, name: "right", theme: "outlined" };
function c6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      UAe(e, l, n[l]);
    });
  }
  return e;
}
function UAe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Br = function(t, n) {
  var o = c6({}, t, n.attrs);
  return $(cn, c6({}, o, {
    icon: KAe
  }), null);
};
Br.displayName = "RightOutlined";
Br.inheritAttrs = !1;
const eW = Symbol("OverrideContextKey"), tW = () => ze(eW, void 0), ZI = (e) => {
  var t, n, o;
  const {
    prefixCls: l,
    mode: r,
    selectable: a,
    validator: i,
    onClick: s,
    expandIcon: c
  } = tW() || {};
  at(eW, {
    prefixCls: O(() => {
      var u, d;
      return (d = (u = e.prefixCls) === null || u === void 0 ? void 0 : u.value) !== null && d !== void 0 ? d : l == null ? void 0 : l.value;
    }),
    mode: O(() => {
      var u, d;
      return (d = (u = e.mode) === null || u === void 0 ? void 0 : u.value) !== null && d !== void 0 ? d : r == null ? void 0 : r.value;
    }),
    selectable: O(() => {
      var u, d;
      return (d = (u = e.selectable) === null || u === void 0 ? void 0 : u.value) !== null && d !== void 0 ? d : a == null ? void 0 : a.value;
    }),
    validator: (t = e.validator) !== null && t !== void 0 ? t : i,
    onClick: (n = e.onClick) !== null && n !== void 0 ? n : s,
    expandIcon: (o = e.expandIcon) !== null && o !== void 0 ? o : c == null ? void 0 : c.value
  });
}, Ia = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ADropdown",
  inheritAttrs: !1,
  props: sn(Zj(), {
    mouseEnterDelay: 0.15,
    mouseLeaveDelay: 0.1,
    placement: "bottomLeft",
    trigger: "hover"
  }),
  // emits: ['visibleChange', 'update:visible'],
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: l
    } = t;
    const {
      prefixCls: r,
      rootPrefixCls: a,
      direction: i,
      getPopupContainer: s
    } = bt("dropdown", e), [c, u] = Qj(r);
    process.env.NODE_ENV !== "production" && [["visible", "open"], ["onVisibleChange", "onOpenChange"], ["onUpdate:visible", "onUpdate:open"]].forEach((h) => {
      let [g, y] = h;
      Hn(e[g] === void 0, "Dropdown", `\`${g}\` is deprecated which will be removed in next major version, please use \`${y}\` instead.`);
    });
    const d = O(() => {
      const {
        placement: h = "",
        transitionName: g
      } = e;
      return g !== void 0 ? g : h.includes("top") ? `${a.value}-slide-down` : `${a.value}-slide-up`;
    });
    ZI({
      prefixCls: O(() => `${r.value}-menu`),
      expandIcon: O(() => $("span", {
        class: `${r.value}-menu-submenu-arrow`
      }, [$(Br, {
        class: `${r.value}-menu-submenu-arrow-icon`
      }, null)])),
      mode: O(() => "vertical"),
      selectable: O(() => !1),
      onClick: () => {
      },
      validator: (h) => {
        let {
          mode: g
        } = h;
        Hn(!g || g === "vertical", "Dropdown", `mode="${g}" is not supported for Dropdown's Menu.`);
      }
    });
    const f = () => {
      var h, g, y;
      const b = e.overlay || ((h = n.overlay) === null || h === void 0 ? void 0 : h.call(n)), C = Array.isArray(b) ? b[0] : b;
      if (!C) return null;
      const w = C.props || {};
      un(!w.mode || w.mode === "vertical", "Dropdown", `mode="${w.mode}" is not supported for Dropdown's Menu.`);
      const {
        selectable: x = !1,
        expandIcon: E = (y = (g = C.children) === null || g === void 0 ? void 0 : g.expandIcon) === null || y === void 0 ? void 0 : y.call(g)
      } = w, I = typeof E != "undefined" && Io(E) ? E : $("span", {
        class: `${r.value}-menu-submenu-arrow`
      }, [$(Br, {
        class: `${r.value}-menu-submenu-arrow-icon`
      }, null)]);
      return Io(C) ? _n(C, {
        mode: "vertical",
        selectable: x,
        expandIcon: () => I
      }) : C;
    }, p = O(() => {
      const h = e.placement;
      if (!h)
        return i.value === "rtl" ? "bottomRight" : "bottomLeft";
      if (h.includes("Center")) {
        const g = h.slice(0, h.indexOf("Center"));
        return un(!h.includes("Center"), "Dropdown", `You are using '${h}' placement in Dropdown, which is deprecated. Try to use '${g}' instead.`), g;
      }
      return h;
    }), m = O(() => typeof e.visible == "boolean" ? e.visible : e.open), v = (h) => {
      l("update:visible", h), l("visibleChange", h), l("update:open", h), l("openChange", h);
    };
    return () => {
      var h, g;
      const {
        arrow: y,
        trigger: b,
        disabled: C,
        overlayClassName: w
      } = e, x = (h = n.default) === null || h === void 0 ? void 0 : h.call(n)[0], E = _n(x, _({
        class: ke((g = x == null ? void 0 : x.props) === null || g === void 0 ? void 0 : g.class, {
          [`${r.value}-rtl`]: i.value === "rtl"
        }, `${r.value}-trigger`)
      }, C ? {
        disabled: C
      } : {})), I = ke(w, u.value, {
        [`${r.value}-rtl`]: i.value === "rtl"
      }), T = C ? [] : b;
      let P;
      T && T.includes("contextmenu") && (P = !0);
      const k = KI({
        arrowPointAtCenter: typeof y == "object" && y.pointAtCenter,
        autoAdjustOverflow: !0
      }), N = pn(_(_(_({}, e), o), {
        visible: m.value,
        builtinPlacements: k,
        overlayClassName: I,
        arrow: !!y,
        alignPoint: P,
        prefixCls: r.value,
        getPopupContainer: s == null ? void 0 : s.value,
        transitionName: d.value,
        trigger: T,
        onVisibleChange: v,
        placement: p.value
      }), ["overlay", "onUpdate:visible"]);
      return c($(Gj, N, {
        default: () => [E],
        overlay: f
      }));
    };
  }
});
Ia.Button = Dm;
var GAe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const YAe = () => ({
  prefixCls: String,
  href: String,
  separator: de.any,
  dropdownProps: Nt(),
  overlay: de.any,
  onClick: Yu()
}), Lm = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumbItem",
  inheritAttrs: !1,
  __ANT_BREADCRUMB_ITEM: !0,
  props: YAe(),
  // emits: ['click'],
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: l
    } = t;
    const {
      prefixCls: r
    } = bt("breadcrumb", e), a = (s, c) => {
      const u = Wo(n, e, "overlay");
      return u ? $(Ia, Q(Q({}, e.dropdownProps), {}, {
        overlay: u,
        placement: "bottom"
      }), {
        default: () => [$("span", {
          class: `${c}-overlay-link`
        }, [s, $(pd, null, null)])]
      }) : s;
    }, i = (s) => {
      l("click", s);
    };
    return () => {
      var s;
      const c = (s = Wo(n, e, "separator")) !== null && s !== void 0 ? s : "/", u = Wo(n, e), {
        class: d,
        style: f
      } = o, p = GAe(o, ["class", "style"]);
      let m;
      return e.href !== void 0 ? m = $("a", Q({
        class: `${r.value}-link`,
        onClick: i
      }, p), [u]) : m = $("span", Q({
        class: `${r.value}-link`,
        onClick: i
      }, p), [u]), m = a(m, r.value), u != null ? $("li", {
        class: d,
        style: f
      }, [m, c && $("span", {
        class: `${r.value}-separator`
      }, [c])]) : null;
    };
  }
});
function XAe(e, t, n, o) {
  let l;
  if (l !== void 0)
    return !!l;
  if (e === t)
    return !0;
  if (typeof e != "object" || !e || typeof t != "object" || !t)
    return !1;
  const r = Object.keys(e), a = Object.keys(t);
  if (r.length !== a.length)
    return !1;
  const i = Object.prototype.hasOwnProperty.bind(t);
  for (let s = 0; s < r.length; s++) {
    const c = r[s];
    if (!i(c))
      return !1;
    const u = e[c], d = t[c];
    if (l = void 0, l === !1 || l === void 0 && u !== d)
      return !1;
  }
  return !0;
}
function Wd(e, t) {
  return XAe(/* @__PURE__ */ Wt(e), /* @__PURE__ */ Wt(t));
}
const nW = Symbol("menuContextKey"), oW = (e) => {
  at(nW, e);
}, Is = () => ze(nW), lW = Symbol("ForceRenderKey"), qAe = (e) => {
  at(lW, e);
}, rW = () => ze(lW, !1), aW = Symbol("menuFirstLevelContextKey"), iW = (e) => {
  at(aW, e);
}, JAe = () => ze(aW, !0), xy = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "MenuContextProvider",
  inheritAttrs: !1,
  props: {
    mode: {
      type: String,
      default: void 0
    },
    overflowDisabled: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Is(), l = _({}, o);
    return e.mode !== void 0 && (l.mode = /* @__PURE__ */ ft(e, "mode")), e.overflowDisabled !== void 0 && (l.overflowDisabled = /* @__PURE__ */ ft(e, "overflowDisabled")), oW(l), () => {
      var r;
      return (r = n.default) === null || r === void 0 ? void 0 : r.call(n);
    };
  }
}), sW = Symbol("siderCollapsed"), cW = Symbol("siderHookProvider"), Ag = "$$__vc-menu-more__key", uW = Symbol("KeyPathContext"), QI = () => ze(uW, {
  parentEventKeys: O(() => []),
  parentKeys: O(() => []),
  parentInfo: {}
}), ZAe = (e, t, n) => {
  const {
    parentEventKeys: o,
    parentKeys: l
  } = QI(), r = O(() => [...o.value, e]), a = O(() => [...l.value, t]);
  return at(uW, {
    parentEventKeys: r,
    parentKeys: a,
    parentInfo: n
  }), a;
}, dW = Symbol("measure"), u6 = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return at(dW, !0), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), eT = () => ze(dW, !1);
function fW(e) {
  const {
    mode: t,
    rtl: n,
    inlineIndent: o
  } = Is();
  return O(() => t.value !== "inline" ? null : n.value ? {
    paddingRight: `${e.value * o.value}px`
  } : {
    paddingLeft: `${e.value * o.value}px`
  });
}
let QAe = 0;
const eRe = () => ({
  id: String,
  role: String,
  disabled: Boolean,
  danger: Boolean,
  title: {
    type: [String, Boolean],
    default: void 0
  },
  icon: de.any,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function,
  onKeydown: Function,
  onFocus: Function,
  // Internal user prop
  originItemValue: Nt()
}), bi = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuItem",
  inheritAttrs: !1,
  props: eRe(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: l
    } = t;
    const r = xt(), a = eT(), i = typeof r.vnode.key == "symbol" ? String(r.vnode.key) : r.vnode.key;
    un(typeof r.vnode.key != "symbol", "MenuItem", `MenuItem \`:key="${String(i)}"\` not support Symbol type`);
    const s = `menu_item_${++QAe}_$$_${i}`, {
      parentEventKeys: c,
      parentKeys: u
    } = QI(), {
      prefixCls: d,
      activeKeys: f,
      disabled: p,
      changeActiveKeys: m,
      rtl: v,
      inlineCollapsed: h,
      siderCollapsed: g,
      onItemClick: y,
      selectedKeys: b,
      registerMenuInfo: C,
      unRegisterMenuInfo: w
    } = Is(), x = JAe(), E = /* @__PURE__ */ Ce(!1), I = O(() => [...u.value, i]);
    C(s, {
      eventKey: s,
      key: i,
      parentEventKeys: c,
      parentKeys: u,
      isLeaf: !0
    }), yt(() => {
      w(s);
    }), pe(f, () => {
      E.value = !!f.value.find((V) => V === i);
    }, {
      immediate: !0
    });
    const P = O(() => p.value || e.disabled), k = O(() => b.value.includes(i)), N = O(() => {
      const V = `${d.value}-item`;
      return {
        [`${V}`]: !0,
        [`${V}-danger`]: e.danger,
        [`${V}-active`]: E.value,
        [`${V}-selected`]: k.value,
        [`${V}-disabled`]: P.value
      };
    }), R = (V) => ({
      key: i,
      eventKey: s,
      keyPath: I.value,
      eventKeyPath: [...c.value, s],
      domEvent: V,
      item: _(_({}, e), l)
    }), z = (V) => {
      if (P.value)
        return;
      const j = R(V);
      o("click", V), y(j);
    }, D = (V) => {
      P.value || (m(I.value), o("mouseenter", V));
    }, F = (V) => {
      P.value || (m([]), o("mouseleave", V));
    }, M = (V) => {
      if (o("keydown", V), V.which === ot.ENTER) {
        const j = R(V);
        o("click", V), y(j);
      }
    }, A = (V) => {
      m(I.value), o("focus", V);
    }, L = (V, j) => {
      const W = $("span", {
        class: `${d.value}-title-content`
      }, [j]);
      return (!V || Io(j) && j.type === "span") && j && h.value && x && typeof j == "string" ? $("div", {
        class: `${d.value}-inline-collapsed-noicon`
      }, [j.charAt(0)]) : W;
    }, B = fW(O(() => I.value.length));
    return () => {
      var V, j, W, Y, U;
      if (a) return null;
      const te = (V = e.title) !== null && V !== void 0 ? V : (j = n.title) === null || j === void 0 ? void 0 : j.call(n), J = Fn((W = n.default) === null || W === void 0 ? void 0 : W.call(n)), re = J.length;
      let oe = te;
      typeof te == "undefined" ? oe = x && re ? J : "" : te === !1 && (oe = "");
      const q = {
        title: oe
      };
      !g.value && !h.value && (q.title = null, q.open = !1);
      const K = {};
      e.role === "option" && (K["aria-selected"] = k.value);
      const se = (Y = e.icon) !== null && Y !== void 0 ? Y : (U = n.icon) === null || U === void 0 ? void 0 : U.call(n, e);
      return $(Sr, Q(Q({}, q), {}, {
        placement: v.value ? "left" : "right",
        overlayClassName: `${d.value}-inline-collapsed-tooltip`
      }), {
        default: () => [$(ps.Item, Q(Q(Q({
          component: "li"
        }, l), {}, {
          id: e.id,
          style: _(_({}, l.style || {}), B.value),
          class: [N.value, {
            [`${l.class}`]: !!l.class,
            [`${d.value}-item-only-child`]: (se ? re + 1 : re) === 1
          }],
          role: e.role || "menuitem",
          tabindex: e.disabled ? null : -1,
          "data-menu-id": i,
          "aria-disabled": e.disabled
        }, K), {}, {
          onMouseenter: D,
          onMouseleave: F,
          onClick: z,
          onKeydown: M,
          onFocus: A,
          title: typeof te == "string" ? te : void 0
        }), {
          default: () => [_n(typeof se == "function" ? se(e.originItemValue) : se, {
            class: `${d.value}-item-icon`
          }, !1), L(se, J)]
        })]
      });
    };
  }
}), lc = {
  adjustX: 1,
  adjustY: 1
}, tRe = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: lc,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: lc,
    offset: [0, 7]
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: lc,
    offset: [-4, 0]
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: lc,
    offset: [4, 0]
  }
}, nRe = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: lc,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: lc,
    offset: [0, 7]
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: lc,
    offset: [-4, 0]
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: lc,
    offset: [4, 0]
  }
}, oRe = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
}, d6 = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "PopupTrigger",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    mode: String,
    visible: Boolean,
    // popup: React.ReactNode;
    popupClassName: String,
    popupOffset: Array,
    disabled: Boolean,
    onVisibleChange: Function
  },
  slots: Object,
  emits: ["visibleChange"],
  setup(e, t) {
    let {
      slots: n,
      emit: o
    } = t;
    const l = /* @__PURE__ */ Ce(!1), {
      getPopupContainer: r,
      rtl: a,
      subMenuOpenDelay: i,
      subMenuCloseDelay: s,
      builtinPlacements: c,
      triggerSubMenuAction: u,
      forceSubMenuRender: d,
      motion: f,
      defaultMotions: p,
      rootClassName: m
    } = Is(), v = rW(), h = O(() => a.value ? _(_({}, nRe), c.value) : _(_({}, tRe), c.value)), g = O(() => oRe[e.mode]), y = /* @__PURE__ */ Ce();
    pe(() => e.visible, (w) => {
      rn.cancel(y.value), y.value = rn(() => {
        l.value = w;
      });
    }, {
      immediate: !0
    }), yt(() => {
      rn.cancel(y.value);
    });
    const b = (w) => {
      o("visibleChange", w);
    }, C = O(() => {
      var w, x;
      const E = f.value || ((w = p.value) === null || w === void 0 ? void 0 : w[e.mode]) || ((x = p.value) === null || x === void 0 ? void 0 : x.other), I = typeof E == "function" ? E() : E;
      return I ? da(I.name, {
        css: !0
      }) : void 0;
    });
    return () => {
      const {
        prefixCls: w,
        popupClassName: x,
        mode: E,
        popupOffset: I,
        disabled: T
      } = e;
      return $(fd, {
        prefixCls: w,
        popupClassName: ke(`${w}-popup`, {
          [`${w}-rtl`]: a.value
        }, x, m.value),
        stretch: E === "horizontal" ? "minWidth" : null,
        getPopupContainer: r.value,
        builtinPlacements: h.value,
        popupPlacement: g.value,
        popupVisible: l.value,
        popupAlign: I && {
          offset: I
        },
        action: T ? [] : [u.value],
        mouseEnterDelay: i.value,
        mouseLeaveDelay: s.value,
        onPopupVisibleChange: b,
        forceRender: v || d.value,
        popupAnimation: C.value
      }, {
        popup: n.popup,
        default: n.default
      });
    };
  }
}), tT = (e, t) => {
  let {
    slots: n,
    attrs: o
  } = t;
  var l;
  const {
    prefixCls: r,
    mode: a
  } = Is();
  return $("ul", Q(Q({}, o), {}, {
    class: ke(r.value, `${r.value}-sub`, `${r.value}-${a.value === "inline" ? "inline" : "vertical"}`),
    "data-menu-list": !0
  }), [(l = n.default) === null || l === void 0 ? void 0 : l.call(n)]);
};
tT.displayName = "SubMenuList";
const lRe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "InlineSubMenuList",
  inheritAttrs: !1,
  props: {
    id: String,
    open: Boolean,
    keyPath: Array
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = O(() => "inline"), {
      motion: l,
      mode: r,
      defaultMotions: a
    } = Is(), i = O(() => r.value === o.value), s = /* @__PURE__ */ H(!i.value), c = O(() => i.value ? e.open : !1);
    pe(r, () => {
      i.value && (s.value = !1);
    }, {
      flush: "post"
    });
    const u = O(() => {
      var d, f;
      const p = l.value || ((d = a.value) === null || d === void 0 ? void 0 : d[o.value]) || ((f = a.value) === null || f === void 0 ? void 0 : f.other), m = typeof p == "function" ? p() : p;
      return _(_({}, m), {
        appear: e.keyPath.length <= 1
      });
    });
    return () => {
      var d;
      return s.value ? null : $(xy, {
        mode: o.value
      }, {
        default: () => [$(Vn, u.value, {
          default: () => [_t($(tT, {
            id: e.id
          }, {
            default: () => [(d = n.default) === null || d === void 0 ? void 0 : d.call(n)]
          }), [[Jt, c.value]])]
        })]
      });
    };
  }
});
let f6 = 0;
const rRe = () => ({
  icon: de.any,
  title: de.any,
  disabled: Boolean,
  level: Number,
  popupClassName: String,
  popupOffset: Array,
  internalPopupClose: Boolean,
  eventKey: String,
  expandIcon: Function,
  theme: String,
  onMouseenter: Function,
  onMouseleave: Function,
  onTitleClick: Function,
  // Internal user prop
  originItemValue: Nt()
}), Zu = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ASubMenu",
  inheritAttrs: !1,
  props: rRe(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: l
    } = t;
    var r, a;
    iW(!1);
    const i = eT(), s = xt(), c = typeof s.vnode.key == "symbol" ? String(s.vnode.key) : s.vnode.key;
    un(typeof s.vnode.key != "symbol", "SubMenu", `SubMenu \`:key="${String(c)}"\` not support Symbol type`);
    const u = r2(c) ? c : `sub_menu_${++f6}_$$_not_set_key`, d = (r = e.eventKey) !== null && r !== void 0 ? r : r2(c) ? `sub_menu_${++f6}_$$_${c}` : u, {
      parentEventKeys: f,
      parentInfo: p,
      parentKeys: m
    } = QI(), v = O(() => [...m.value, u]), g = {
      eventKey: d,
      key: u,
      parentEventKeys: f,
      childrenEventKeys: /* @__PURE__ */ Ce([]),
      parentKeys: m
    };
    (a = p.childrenEventKeys) === null || a === void 0 || a.value.push(d), yt(() => {
      var $e;
      p.childrenEventKeys && (p.childrenEventKeys.value = ($e = p.childrenEventKeys) === null || $e === void 0 ? void 0 : $e.value.filter((ne) => ne != d));
    }), ZAe(d, u, g);
    const {
      prefixCls: y,
      activeKeys: b,
      disabled: C,
      changeActiveKeys: w,
      mode: x,
      inlineCollapsed: E,
      openKeys: I,
      overflowDisabled: T,
      onOpenChange: P,
      registerMenuInfo: k,
      unRegisterMenuInfo: N,
      selectedSubMenuKeys: R,
      expandIcon: z,
      theme: D
    } = Is(), F = c != null, M = !i && (rW() || !F);
    qAe(M), (i && F || !i && !F || M) && (k(d, g), yt(() => {
      N(d);
    }));
    const A = O(() => `${y.value}-submenu`), L = O(() => C.value || e.disabled), B = /* @__PURE__ */ Ce(), V = /* @__PURE__ */ Ce(), j = O(() => I.value.includes(u)), W = O(() => !T.value && j.value), Y = O(() => R.value.includes(u)), U = /* @__PURE__ */ Ce(!1);
    pe(b, () => {
      U.value = !!b.value.find(($e) => $e === u);
    }, {
      immediate: !0
    });
    const te = ($e) => {
      L.value || (l("titleClick", $e, u), x.value === "inline" && P(u, !j.value));
    }, J = ($e) => {
      L.value || (w(v.value), l("mouseenter", $e));
    }, re = ($e) => {
      L.value || (w([]), l("mouseleave", $e));
    }, oe = fW(O(() => v.value.length)), q = ($e) => {
      x.value !== "inline" && P(u, $e);
    }, K = () => {
      w(v.value);
    }, se = d && `${d}-popup`, Z = O(() => ke(y.value, `${y.value}-${e.theme || D.value}`, e.popupClassName)), ee = ($e, ne) => {
      if (!ne)
        return E.value && !m.value.length && $e && typeof $e == "string" ? $("div", {
          class: `${y.value}-inline-collapsed-noicon`
        }, [$e.charAt(0)]) : $("span", {
          class: `${y.value}-title-content`
        }, [$e]);
      const ae = Io($e) && $e.type === "span";
      return $(Ge, null, [_n(typeof ne == "function" ? ne(e.originItemValue) : ne, {
        class: `${y.value}-item-icon`
      }, !1), ae ? $e : $("span", {
        class: `${y.value}-title-content`
      }, [$e])]);
    }, fe = O(() => x.value !== "inline" && v.value.length > 1 ? "vertical" : x.value), me = O(() => x.value === "horizontal" ? "vertical" : x.value), ge = O(() => fe.value === "horizontal" ? "vertical" : fe.value), he = () => {
      var $e, ne;
      const ae = A.value, ce = ($e = e.icon) !== null && $e !== void 0 ? $e : (ne = n.icon) === null || ne === void 0 ? void 0 : ne.call(n, e), xe = e.expandIcon || n.expandIcon || z.value, Te = ee(Wo(n, e, "title"), ce);
      return $("div", {
        style: oe.value,
        class: `${ae}-title`,
        tabindex: L.value ? null : -1,
        ref: B,
        title: typeof Te == "string" ? Te : null,
        "data-menu-id": u,
        "aria-expanded": W.value,
        "aria-haspopup": !0,
        "aria-controls": se,
        "aria-disabled": L.value,
        onClick: te,
        onFocus: K
      }, [Te, x.value !== "horizontal" && xe ? xe(_(_({}, e), {
        isOpen: W.value
      })) : $("i", {
        class: `${ae}-arrow`
      }, null)]);
    };
    return () => {
      var $e;
      if (i)
        return F ? ($e = n.default) === null || $e === void 0 ? void 0 : $e.call(n) : null;
      const ne = A.value;
      let ae = () => null;
      if (!T.value && x.value !== "inline") {
        const ce = x.value === "horizontal" ? [0, 8] : [10, 0];
        ae = () => $(d6, {
          mode: fe.value,
          prefixCls: ne,
          visible: !e.internalPopupClose && W.value,
          popupClassName: Z.value,
          popupOffset: e.popupOffset || ce,
          disabled: L.value,
          onVisibleChange: q
        }, {
          default: () => [he()],
          popup: () => $(xy, {
            mode: ge.value
          }, {
            default: () => [$(tT, {
              id: se,
              ref: V
            }, {
              default: n.default
            })]
          })
        });
      } else
        ae = () => $(d6, null, {
          default: he
        });
      return $(xy, {
        mode: me.value
      }, {
        default: () => [$(ps.Item, Q(Q({
          component: "li"
        }, o), {}, {
          role: "none",
          class: ke(ne, `${ne}-${x.value}`, o.class, {
            [`${ne}-open`]: W.value,
            [`${ne}-active`]: U.value,
            [`${ne}-selected`]: Y.value,
            [`${ne}-disabled`]: L.value
          }),
          onMouseenter: J,
          onMouseleave: re,
          "data-submenu-id": u
        }), {
          default: () => $(Ge, null, [ae(), !T.value && $(lRe, {
            id: se,
            open: W.value,
            keyPath: v.value
          }, {
            default: n.default
          })])
        })]
      });
    };
  }
});
function pW(e, t) {
  return e.classList ? e.classList.contains(t) : ` ${e.className} `.indexOf(` ${t} `) > -1;
}
function Ey(e, t) {
  e.classList ? e.classList.add(t) : pW(e, t) || (e.className = `${e.className} ${t}`);
}
function Oy(e, t) {
  if (e.classList)
    e.classList.remove(t);
  else if (pW(e, t)) {
    const n = e.className;
    e.className = ` ${n} `.replace(` ${t} `, " ");
  }
}
const Ph = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant-motion-collapse", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return {
    name: e,
    appear: t,
    css: !0,
    onBeforeEnter: (n) => {
      n.style.height = "0px", n.style.opacity = "0", Ey(n, e);
    },
    onEnter: (n) => {
      Ke(() => {
        n.style.height = `${n.scrollHeight}px`, n.style.opacity = "1";
      });
    },
    onAfterEnter: (n) => {
      n && (Oy(n, e), n.style.height = null, n.style.opacity = null);
    },
    onBeforeLeave: (n) => {
      Ey(n, e), n.style.height = `${n.offsetHeight}px`, n.style.opacity = null;
    },
    onLeave: (n) => {
      setTimeout(() => {
        n.style.height = "0px", n.style.opacity = "0";
      });
    },
    onAfterLeave: (n) => {
      n && (Oy(n, e), n.style && (n.style.height = null, n.style.opacity = null));
    }
  };
}, aRe = () => ({
  title: de.any,
  // Internal user prop
  originItemValue: Nt()
}), Bm = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuItemGroup",
  inheritAttrs: !1,
  props: aRe(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l
    } = Is(), r = O(() => `${l.value}-item-group`), a = eT();
    return () => {
      var i, s;
      return a ? (i = n.default) === null || i === void 0 ? void 0 : i.call(n) : $("li", Q(Q({}, o), {}, {
        onClick: (c) => c.stopPropagation(),
        class: r.value
      }), [$("div", {
        title: typeof e.title == "string" ? e.title : void 0,
        class: `${r.value}-title`
      }, [Wo(n, e, "title")]), $("ul", {
        class: `${r.value}-list`
      }, [(s = n.default) === null || s === void 0 ? void 0 : s.call(n)])]);
    };
  }
}), iRe = () => ({
  prefixCls: String,
  dashed: Boolean
}), Fm = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuDivider",
  props: iRe(),
  setup(e) {
    const {
      prefixCls: t
    } = Is(), n = O(() => ({
      [`${t.value}-item-divider`]: !0,
      [`${t.value}-item-divider-dashed`]: !!e.dashed
    }));
    return () => $("li", {
      class: n.value
    }, null);
  }
});
var sRe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function P2(e, t, n) {
  return (e || []).map((o, l) => {
    if (o && typeof o == "object") {
      const r = o, {
        label: a,
        children: i,
        key: s,
        type: c
      } = r, u = sRe(r, ["label", "children", "key", "type"]), d = s != null ? s : `tmp-${l}`, f = n ? n.parentKeys.slice() : [], p = [], m = {
        eventKey: d,
        key: d,
        parentEventKeys: /* @__PURE__ */ H(f),
        parentKeys: /* @__PURE__ */ H(f),
        childrenEventKeys: /* @__PURE__ */ H(p),
        isLeaf: !1
      };
      if (i || c === "group") {
        if (c === "group") {
          const h = P2(i, t, n);
          return $(Bm, Q(Q({
            key: d
          }, u), {}, {
            title: a,
            originItemValue: o
          }), {
            default: () => [h]
          });
        }
        t.set(d, m), n && n.childrenEventKeys.push(d);
        const v = P2(i, t, {
          childrenEventKeys: p,
          parentKeys: [].concat(f, d)
        });
        return $(Zu, Q(Q({
          key: d
        }, u), {}, {
          title: a,
          originItemValue: o
        }), {
          default: () => [v]
        });
      }
      return c === "divider" ? $(Fm, Q({
        key: d
      }, u), null) : (m.isLeaf = !0, t.set(d, m), $(bi, Q(Q({
        key: d
      }, u), {}, {
        originItemValue: o
      }), {
        default: () => [a]
      }));
    }
    return null;
  }).filter((o) => o);
}
function cRe(e) {
  const t = /* @__PURE__ */ Ce([]), n = /* @__PURE__ */ Ce(!1), o = /* @__PURE__ */ Ce(/* @__PURE__ */ new Map());
  return pe(() => e.items, () => {
    const l = /* @__PURE__ */ new Map();
    n.value = !1, e.items ? (n.value = !0, t.value = P2(e.items, l)) : t.value = void 0, o.value = l;
  }, {
    immediate: !0,
    deep: !0
  }), {
    itemsNodes: t,
    store: o,
    hasItmes: n
  };
}
const uRe = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    menuHorizontalHeight: o,
    colorSplit: l,
    lineWidth: r,
    lineType: a,
    menuItemPaddingInline: i
  } = e;
  return {
    [`${t}-horizontal`]: {
      lineHeight: `${o}px`,
      border: 0,
      borderBottom: `${r}px ${a} ${l}`,
      boxShadow: "none",
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        content: '"\\20"'
      },
      // ======================= Item =======================
      [`${t}-item, ${t}-submenu`]: {
        position: "relative",
        display: "inline-block",
        verticalAlign: "bottom",
        paddingInline: i
      },
      [`> ${t}-item:hover,
        > ${t}-item-active,
        > ${t}-submenu ${t}-submenu-title:hover`]: {
        backgroundColor: "transparent"
      },
      [`${t}-item, ${t}-submenu-title`]: {
        transition: [`border-color ${n}`, `background ${n}`].join(",")
      },
      // ===================== Sub Menu =====================
      [`${t}-submenu-arrow`]: {
        display: "none"
      }
    }
  };
}, dRe = (e) => {
  let {
    componentCls: t,
    menuArrowOffset: n
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl"
    },
    [`${t}-submenu-rtl`]: {
      transformOrigin: "100% 0"
    },
    // Vertical Arrow
    [`${t}-rtl${t}-vertical,
    ${t}-submenu-rtl ${t}-vertical`]: {
      [`${t}-submenu-arrow`]: {
        "&::before": {
          transform: `rotate(-45deg) translateY(-${n})`
        },
        "&::after": {
          transform: `rotate(45deg) translateY(${n})`
        }
      }
    }
  };
}, p6 = (e) => _({}, bs(e)), v6 = (e, t) => {
  const {
    componentCls: n,
    colorItemText: o,
    colorItemTextSelected: l,
    colorGroupTitle: r,
    colorItemBg: a,
    colorSubItemBg: i,
    colorItemBgSelected: s,
    colorActiveBarHeight: c,
    colorActiveBarWidth: u,
    colorActiveBarBorderSize: d,
    motionDurationSlow: f,
    motionEaseInOut: p,
    motionEaseOut: m,
    menuItemPaddingInline: v,
    motionDurationMid: h,
    colorItemTextHover: g,
    lineType: y,
    colorSplit: b,
    // Disabled
    colorItemTextDisabled: C,
    // Danger
    colorDangerItemText: w,
    colorDangerItemTextHover: x,
    colorDangerItemTextSelected: E,
    colorDangerItemBgActive: I,
    colorDangerItemBgSelected: T,
    colorItemBgHover: P,
    menuSubMenuBg: k,
    // Horizontal
    colorItemTextSelectedHorizontal: N,
    colorItemBgSelectedHorizontal: R
  } = e;
  return {
    [`${n}-${t}`]: {
      color: o,
      background: a,
      [`&${n}-root:focus-visible`]: _({}, p6(e)),
      // ======================== Item ========================
      [`${n}-item-group-title`]: {
        color: r
      },
      [`${n}-submenu-selected`]: {
        [`> ${n}-submenu-title`]: {
          color: l
        }
      },
      // Disabled
      [`${n}-item-disabled, ${n}-submenu-disabled`]: {
        color: `${C} !important`
      },
      // Hover
      [`${n}-item:hover, ${n}-submenu-title:hover`]: {
        [`&:not(${n}-item-selected):not(${n}-submenu-selected)`]: {
          color: g
        }
      },
      [`&:not(${n}-horizontal)`]: {
        [`${n}-item:not(${n}-item-selected)`]: {
          "&:hover": {
            backgroundColor: P
          },
          "&:active": {
            backgroundColor: s
          }
        },
        [`${n}-submenu-title`]: {
          "&:hover": {
            backgroundColor: P
          },
          "&:active": {
            backgroundColor: s
          }
        }
      },
      // Danger - only Item has
      [`${n}-item-danger`]: {
        color: w,
        [`&${n}-item:hover`]: {
          [`&:not(${n}-item-selected):not(${n}-submenu-selected)`]: {
            color: x
          }
        },
        [`&${n}-item:active`]: {
          background: I
        }
      },
      [`${n}-item a`]: {
        "&, &:hover": {
          color: "inherit"
        }
      },
      [`${n}-item-selected`]: {
        color: l,
        // Danger
        [`&${n}-item-danger`]: {
          color: E
        },
        "a, a:hover": {
          color: "inherit"
        }
      },
      [`& ${n}-item-selected`]: {
        backgroundColor: s,
        // Danger
        [`&${n}-item-danger`]: {
          backgroundColor: T
        }
      },
      [`${n}-item, ${n}-submenu-title`]: {
        [`&:not(${n}-item-disabled):focus-visible`]: _({}, p6(e))
      },
      [`&${n}-submenu > ${n}`]: {
        backgroundColor: k
      },
      [`&${n}-popup > ${n}`]: {
        backgroundColor: a
      },
      // ====================== Horizontal ======================
      [`&${n}-horizontal`]: _(_({}, t === "dark" ? {
        borderBottom: 0
      } : {}), {
        [`> ${n}-item, > ${n}-submenu`]: {
          top: d,
          marginTop: -d,
          marginBottom: 0,
          borderRadius: 0,
          "&::after": {
            position: "absolute",
            insetInline: v,
            bottom: 0,
            borderBottom: `${c}px solid transparent`,
            transition: `border-color ${f} ${p}`,
            content: '""'
          },
          "&:hover, &-active, &-open": {
            "&::after": {
              borderBottomWidth: c,
              borderBottomColor: N
            }
          },
          "&-selected": {
            color: N,
            backgroundColor: R,
            "&::after": {
              borderBottomWidth: c,
              borderBottomColor: N
            }
          }
        }
      }),
      // ================== Inline & Vertical ===================
      //
      [`&${n}-root`]: {
        [`&${n}-inline, &${n}-vertical`]: {
          borderInlineEnd: `${d}px ${y} ${b}`
        }
      },
      // ======================== Inline ========================
      [`&${n}-inline`]: {
        // Sub
        [`${n}-sub${n}-inline`]: {
          background: i
        },
        // Item
        [`${n}-item, ${n}-submenu-title`]: d && u ? {
          width: `calc(100% + ${d}px)`
        } : {},
        [`${n}-item`]: {
          position: "relative",
          "&::after": {
            position: "absolute",
            insetBlock: 0,
            insetInlineEnd: 0,
            borderInlineEnd: `${u}px solid ${l}`,
            transform: "scaleY(0.0001)",
            opacity: 0,
            transition: [`transform ${h} ${m}`, `opacity ${h} ${m}`].join(","),
            content: '""'
          },
          // Danger
          [`&${n}-item-danger`]: {
            "&::after": {
              borderInlineEndColor: E
            }
          }
        },
        [`${n}-selected, ${n}-item-selected`]: {
          "&::after": {
            transform: "scaleY(1)",
            opacity: 1,
            transition: [`transform ${h} ${p}`, `opacity ${h} ${p}`].join(",")
          }
        }
      }
    }
  };
}, m6 = (e) => {
  const {
    componentCls: t,
    menuItemHeight: n,
    itemMarginInline: o,
    padding: l,
    menuArrowSize: r,
    marginXS: a,
    marginXXS: i
  } = e, s = l + r + a;
  return {
    [`${t}-item`]: {
      position: "relative"
    },
    [`${t}-item, ${t}-submenu-title`]: {
      height: n,
      lineHeight: `${n}px`,
      paddingInline: l,
      overflow: "hidden",
      textOverflow: "ellipsis",
      marginInline: o,
      marginBlock: i,
      width: `calc(100% - ${o * 2}px)`
    },
    // disable margin collapsed
    [`${t}-submenu`]: {
      paddingBottom: 0.02
    },
    [`> ${t}-item,
            > ${t}-submenu > ${t}-submenu-title`]: {
      height: n,
      lineHeight: `${n}px`
    },
    [`${t}-item-group-list ${t}-submenu-title,
            ${t}-submenu-title`]: {
      paddingInlineEnd: s
    }
  };
}, fRe = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    menuItemHeight: o,
    colorTextLightSolid: l,
    dropdownWidth: r,
    controlHeightLG: a,
    motionDurationMid: i,
    motionEaseOut: s,
    paddingXL: c,
    fontSizeSM: u,
    fontSizeLG: d,
    motionDurationSlow: f,
    paddingXS: p,
    boxShadowSecondary: m
  } = e, v = {
    height: o,
    lineHeight: `${o}px`,
    listStylePosition: "inside",
    listStyleType: "disc"
  };
  return [
    {
      [t]: {
        "&-inline, &-vertical": _({
          [`&${t}-root`]: {
            boxShadow: "none"
          }
        }, m6(e))
      },
      [`${t}-submenu-popup`]: {
        [`${t}-vertical`]: _(_({}, m6(e)), {
          boxShadow: m
        })
      }
    },
    // Vertical only
    {
      [`${t}-submenu-popup ${t}-vertical${t}-sub`]: {
        minWidth: r,
        maxHeight: `calc(100vh - ${a * 2.5}px)`,
        padding: "0",
        overflow: "hidden",
        borderInlineEnd: 0,
        // https://github.com/ant-design/ant-design/issues/22244
        // https://github.com/ant-design/ant-design/issues/26812
        "&:not([class*='-active'])": {
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    },
    // Inline Only
    {
      [`${t}-inline`]: {
        width: "100%",
        // Motion enhance for first level
        [`&${t}-root`]: {
          [`${t}-item, ${t}-submenu-title`]: {
            display: "flex",
            alignItems: "center",
            transition: [`border-color ${f}`, `background ${f}`, `padding ${i} ${s}`].join(","),
            [`> ${t}-title-content`]: {
              flex: "auto",
              minWidth: 0,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            "> *": {
              flex: "none"
            }
          }
        },
        // >>>>> Sub
        [`${t}-sub${t}-inline`]: {
          padding: 0,
          border: 0,
          borderRadius: 0,
          boxShadow: "none",
          [`& > ${t}-submenu > ${t}-submenu-title`]: v,
          [`& ${t}-item-group-title`]: {
            paddingInlineStart: c
          }
        },
        // >>>>> Item
        [`${t}-item`]: v
      }
    },
    // Inline Collapse Only
    {
      [`${t}-inline-collapsed`]: {
        width: o * 2,
        [`&${t}-root`]: {
          [`${t}-item, ${t}-submenu ${t}-submenu-title`]: {
            [`> ${t}-inline-collapsed-noicon`]: {
              fontSize: d,
              textAlign: "center"
            }
          }
        },
        [`> ${t}-item,
          > ${t}-item-group > ${t}-item-group-list > ${t}-item,
          > ${t}-item-group > ${t}-item-group-list > ${t}-submenu > ${t}-submenu-title,
          > ${t}-submenu > ${t}-submenu-title`]: {
          insetInlineStart: 0,
          paddingInline: `calc(50% - ${u}px)`,
          textOverflow: "clip",
          [`
            ${t}-submenu-arrow,
            ${t}-submenu-expand-icon
          `]: {
            opacity: 0
          },
          [`${t}-item-icon, ${n}`]: {
            margin: 0,
            fontSize: d,
            lineHeight: `${o}px`,
            "+ span": {
              display: "inline-block",
              opacity: 0
            }
          }
        },
        [`${t}-item-icon, ${n}`]: {
          display: "inline-block"
        },
        "&-tooltip": {
          pointerEvents: "none",
          [`${t}-item-icon, ${n}`]: {
            display: "none"
          },
          "a, a:hover": {
            color: l
          }
        },
        [`${t}-item-group-title`]: _(_({}, Fo), {
          paddingInline: p
        })
      }
    }
  ];
}, h6 = (e) => {
  const {
    componentCls: t,
    fontSize: n,
    motionDurationSlow: o,
    motionDurationMid: l,
    motionEaseInOut: r,
    motionEaseOut: a,
    iconCls: i,
    controlHeightSM: s
  } = e;
  return {
    // >>>>> Item
    [`${t}-item, ${t}-submenu-title`]: {
      position: "relative",
      display: "block",
      margin: 0,
      whiteSpace: "nowrap",
      cursor: "pointer",
      transition: [`border-color ${o}`, `background ${o}`, `padding ${o} ${r}`].join(","),
      [`${t}-item-icon, ${i}`]: {
        minWidth: n,
        fontSize: n,
        transition: [`font-size ${l} ${a}`, `margin ${o} ${r}`, `color ${o}`].join(","),
        "+ span": {
          marginInlineStart: s - n,
          opacity: 1,
          transition: [`opacity ${o} ${r}`, `margin ${o}`, `color ${o}`].join(",")
        }
      },
      [`${t}-item-icon`]: _({}, cd()),
      [`&${t}-item-only-child`]: {
        [`> ${i}, > ${t}-item-icon`]: {
          marginInlineEnd: 0
        }
      }
    },
    // Disabled state sets text to gray and nukes hover/tab effects
    [`${t}-item-disabled, ${t}-submenu-disabled`]: {
      background: "none !important",
      cursor: "not-allowed",
      "&::after": {
        borderColor: "transparent !important"
      },
      a: {
        color: "inherit !important"
      },
      [`> ${t}-submenu-title`]: {
        color: "inherit !important",
        cursor: "not-allowed"
      }
    }
  };
}, g6 = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    motionEaseInOut: o,
    borderRadius: l,
    menuArrowSize: r,
    menuArrowOffset: a
  } = e;
  return {
    [`${t}-submenu`]: {
      "&-expand-icon, &-arrow": {
        position: "absolute",
        top: "50%",
        insetInlineEnd: e.margin,
        width: r,
        color: "currentcolor",
        transform: "translateY(-50%)",
        transition: `transform ${n} ${o}, opacity ${n}`
      },
      "&-arrow": {
        // 
        "&::before, &::after": {
          position: "absolute",
          width: r * 0.6,
          height: r * 0.15,
          backgroundColor: "currentcolor",
          borderRadius: l,
          transition: [`background ${n} ${o}`, `transform ${n} ${o}`, `top ${n} ${o}`, `color ${n} ${o}`].join(","),
          content: '""'
        },
        "&::before": {
          transform: `rotate(45deg) translateY(-${a})`
        },
        "&::after": {
          transform: `rotate(-45deg) translateY(${a})`
        }
      }
    }
  };
}, pRe = (e) => {
  const {
    antCls: t,
    componentCls: n,
    fontSize: o,
    motionDurationSlow: l,
    motionDurationMid: r,
    motionEaseInOut: a,
    lineHeight: i,
    paddingXS: s,
    padding: c,
    colorSplit: u,
    lineWidth: d,
    zIndexPopup: f,
    borderRadiusLG: p,
    radiusSubMenuItem: m,
    menuArrowSize: v,
    menuArrowOffset: h,
    lineType: g,
    menuPanelMaskInset: y
  } = e;
  return [
    // Misc
    {
      "": {
        [`${n}`]: _(_({}, ja()), {
          // Hidden
          "&-hidden": {
            display: "none"
          }
        })
      },
      [`${n}-submenu-hidden`]: {
        display: "none"
      }
    },
    {
      [n]: _(_(_(_(_(_(_({}, nn(e)), ja()), {
        marginBottom: 0,
        paddingInlineStart: 0,
        // Override default ul/ol
        fontSize: o,
        lineHeight: 0,
        listStyle: "none",
        outline: "none",
        transition: `width ${l} cubic-bezier(0.2, 0, 0, 1) 0s`,
        "ul, ol": {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        // Overflow ellipsis
        "&-overflow": {
          display: "flex",
          [`${n}-item`]: {
            flex: "none"
          }
        },
        [`${n}-item, ${n}-submenu, ${n}-submenu-title`]: {
          borderRadius: e.radiusItem
        },
        [`${n}-item-group-title`]: {
          padding: `${s}px ${c}px`,
          fontSize: o,
          lineHeight: i,
          transition: `all ${l}`
        },
        [`&-horizontal ${n}-submenu`]: {
          transition: [`border-color ${l} ${a}`, `background ${l} ${a}`].join(",")
        },
        [`${n}-submenu, ${n}-submenu-inline`]: {
          transition: [`border-color ${l} ${a}`, `background ${l} ${a}`, `padding ${r} ${a}`].join(",")
        },
        [`${n}-submenu ${n}-sub`]: {
          cursor: "initial",
          transition: [`background ${l} ${a}`, `padding ${l} ${a}`].join(",")
        },
        [`${n}-title-content`]: {
          transition: `color ${l}`
        },
        [`${n}-item a`]: {
          "&::before": {
            position: "absolute",
            inset: 0,
            backgroundColor: "transparent",
            content: '""'
          }
        },
        // Removed a Badge related style seems it's safe
        // https://github.com/ant-design/ant-design/issues/19809
        // >>>>> Divider
        [`${n}-item-divider`]: {
          overflow: "hidden",
          lineHeight: 0,
          borderColor: u,
          borderStyle: g,
          borderWidth: 0,
          borderTopWidth: d,
          marginBlock: d,
          padding: 0,
          "&-dashed": {
            borderStyle: "dashed"
          }
        }
      }), h6(e)), {
        [`${n}-item-group`]: {
          [`${n}-item-group-list`]: {
            margin: 0,
            padding: 0,
            [`${n}-item, ${n}-submenu-title`]: {
              paddingInline: `${o * 2}px ${c}px`
            }
          }
        },
        // ======================= Sub Menu =======================
        "&-submenu": {
          "&-popup": {
            position: "absolute",
            zIndex: f,
            background: "transparent",
            borderRadius: p,
            boxShadow: "none",
            transformOrigin: "0 0",
            // https://github.com/ant-design/ant-design/issues/13955
            "&::before": {
              position: "absolute",
              inset: `${y}px 0 0`,
              zIndex: -1,
              width: "100%",
              height: "100%",
              opacity: 0,
              content: '""'
            }
          },
          // https://github.com/ant-design/ant-design/issues/13955
          "&-placement-rightTop::before": {
            top: 0,
            insetInlineStart: y
          },
          [`> ${n}`]: _(_(_({
            borderRadius: p
          }, h6(e)), g6(e)), {
            [`${n}-item, ${n}-submenu > ${n}-submenu-title`]: {
              borderRadius: m
            },
            [`${n}-submenu-title::after`]: {
              transition: `transform ${l} ${a}`
            }
          })
        }
      }), g6(e)), {
        [`&-inline-collapsed ${n}-submenu-arrow,
        &-inline ${n}-submenu-arrow`]: {
          // 
          "&::before": {
            transform: `rotate(-45deg) translateX(${h})`
          },
          "&::after": {
            transform: `rotate(45deg) translateX(-${h})`
          }
        },
        [`${n}-submenu-open${n}-submenu-inline > ${n}-submenu-title > ${n}-submenu-arrow`]: {
          // 
          transform: `translateY(-${v * 0.2}px)`,
          "&::after": {
            transform: `rotate(-45deg) translateX(-${h})`
          },
          "&::before": {
            transform: `rotate(45deg) translateX(${h})`
          }
        }
      })
    },
    // Integration with header element so menu items have the same height
    {
      [`${t}-layout-header`]: {
        [n]: {
          lineHeight: "inherit"
        }
      }
    }
  ];
}, vRe = (e, t) => Zt("Menu", (o, l) => {
  let {
    overrideComponentToken: r
  } = l;
  if ((t == null ? void 0 : t.value) === !1)
    return [];
  const {
    colorBgElevated: a,
    colorPrimary: i,
    colorError: s,
    colorErrorHover: c,
    colorTextLightSolid: u
  } = o, {
    controlHeightLG: d,
    fontSize: f
  } = o, p = f / 7 * 5, m = Vt(o, {
    menuItemHeight: d,
    menuItemPaddingInline: o.margin,
    menuArrowSize: p,
    menuHorizontalHeight: d * 1.15,
    menuArrowOffset: `${p * 0.25}px`,
    menuPanelMaskInset: -7,
    menuSubMenuBg: a
  }), v = new xn(u).setAlpha(0.65).toRgbString(), h = Vt(m, {
    colorItemText: v,
    colorItemTextHover: u,
    colorGroupTitle: v,
    colorItemTextSelected: u,
    colorItemBg: "#001529",
    colorSubItemBg: "#000c17",
    colorItemBgActive: "transparent",
    colorItemBgSelected: i,
    colorActiveBarWidth: 0,
    colorActiveBarHeight: 0,
    colorActiveBarBorderSize: 0,
    // Disabled
    colorItemTextDisabled: new xn(u).setAlpha(0.25).toRgbString(),
    // Danger
    colorDangerItemText: s,
    colorDangerItemTextHover: c,
    colorDangerItemTextSelected: u,
    colorDangerItemBgActive: s,
    colorDangerItemBgSelected: s,
    menuSubMenuBg: "#001529",
    // Horizontal
    colorItemTextSelectedHorizontal: u,
    colorItemBgSelectedHorizontal: i
  }, _({}, r));
  return [
    // Basic
    pRe(m),
    // Horizontal
    uRe(m),
    // Vertical
    fRe(m),
    // Theme
    v6(m, "light"),
    v6(h, "dark"),
    // RTL
    dRe(m),
    // Motion
    Ih(m),
    _i(m, "slide-up"),
    _i(m, "slide-down"),
    Ap(m, "zoom-big")
  ];
}, (o) => {
  const {
    colorPrimary: l,
    colorError: r,
    colorTextDisabled: a,
    colorErrorBg: i,
    colorText: s,
    colorTextDescription: c,
    colorBgContainer: u,
    colorFillAlter: d,
    colorFillContent: f,
    lineWidth: p,
    lineWidthBold: m,
    controlItemBgActive: v,
    colorBgTextHover: h
  } = o;
  return {
    dropdownWidth: 160,
    zIndexPopup: o.zIndexPopupBase + 50,
    radiusItem: o.borderRadiusLG,
    radiusSubMenuItem: o.borderRadiusSM,
    colorItemText: s,
    colorItemTextHover: s,
    colorItemTextHoverHorizontal: l,
    colorGroupTitle: c,
    colorItemTextSelected: l,
    colorItemTextSelectedHorizontal: l,
    colorItemBg: u,
    colorItemBgHover: h,
    colorItemBgActive: f,
    colorSubItemBg: d,
    colorItemBgSelected: v,
    colorItemBgSelectedHorizontal: "transparent",
    colorActiveBarWidth: 0,
    colorActiveBarHeight: m,
    colorActiveBarBorderSize: p,
    // Disabled
    colorItemTextDisabled: a,
    // Danger
    colorDangerItemText: r,
    colorDangerItemTextHover: r,
    colorDangerItemTextSelected: r,
    colorDangerItemBgActive: i,
    colorDangerItemBgSelected: i,
    itemMarginInline: o.marginXXS
  };
})(e), mRe = () => ({
  id: String,
  prefixCls: String,
  // donot use items, now only support inner use
  items: Array,
  disabled: Boolean,
  inlineCollapsed: Boolean,
  disabledOverflow: Boolean,
  forceSubMenuRender: Boolean,
  openKeys: Array,
  selectedKeys: Array,
  activeKey: String,
  selectable: {
    type: Boolean,
    default: !0
  },
  multiple: {
    type: Boolean,
    default: !1
  },
  tabindex: {
    type: [Number, String]
  },
  motion: Object,
  role: String,
  theme: {
    type: String,
    default: "light"
  },
  mode: {
    type: String,
    default: "vertical"
  },
  inlineIndent: {
    type: Number,
    default: 24
  },
  subMenuOpenDelay: {
    type: Number,
    default: 0
  },
  subMenuCloseDelay: {
    type: Number,
    default: 0.1
  },
  builtinPlacements: {
    type: Object
  },
  triggerSubMenuAction: {
    type: String,
    default: "hover"
  },
  getPopupContainer: Function,
  expandIcon: Function,
  onOpenChange: Function,
  onSelect: Function,
  onDeselect: Function,
  onClick: [Function, Array],
  onFocus: Function,
  onBlur: Function,
  onMousedown: Function,
  "onUpdate:openKeys": Function,
  "onUpdate:selectedKeys": Function,
  "onUpdate:activeKey": Function
}), b6 = [], Do = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AMenu",
  inheritAttrs: !1,
  props: mRe(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: l
    } = t;
    const {
      direction: r,
      getPrefixCls: a
    } = bt("menu", e), i = tW(), s = O(() => {
      var J;
      return a("menu", e.prefixCls || ((J = i == null ? void 0 : i.prefixCls) === null || J === void 0 ? void 0 : J.value));
    }), [c, u] = vRe(s, O(() => !i)), d = /* @__PURE__ */ Ce(/* @__PURE__ */ new Map()), f = ze(sW, /* @__PURE__ */ H(void 0)), p = O(() => f.value !== void 0 ? f.value : e.inlineCollapsed), {
      itemsNodes: m
    } = cRe(e), v = /* @__PURE__ */ Ce(!1);
    nt(() => {
      v.value = !0;
    }), Ot(() => {
      un(!(e.inlineCollapsed === !0 && e.mode !== "inline"), "Menu", "`inlineCollapsed` should only be used when `mode` is inline."), un(!(f.value !== void 0 && e.inlineCollapsed === !0), "Menu", "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead.");
    });
    const h = /* @__PURE__ */ H([]), g = /* @__PURE__ */ H([]), y = /* @__PURE__ */ H({});
    pe(d, () => {
      const J = {};
      for (const re of d.value.values())
        J[re.key] = re;
      y.value = J;
    }, {
      flush: "post"
    }), Ot(() => {
      if (e.activeKey !== void 0) {
        let J = [];
        const re = e.activeKey ? y.value[e.activeKey] : void 0;
        re && e.activeKey !== void 0 ? J = DC([].concat(S(re.parentKeys), e.activeKey)) : J = [], Wd(h.value, J) || (h.value = J);
      }
    }), pe(() => e.selectedKeys, (J) => {
      J && (g.value = J.slice());
    }, {
      immediate: !0,
      deep: !0
    });
    const b = /* @__PURE__ */ H([]);
    pe([y, g], () => {
      let J = [];
      g.value.forEach((re) => {
        const oe = y.value[re];
        oe && (J = J.concat(S(oe.parentKeys)));
      }), J = DC(J), Wd(b.value, J) || (b.value = J);
    }, {
      immediate: !0
    });
    const C = (J) => {
      if (e.selectable) {
        const {
          key: re
        } = J, oe = g.value.includes(re);
        let q;
        e.multiple ? oe ? q = g.value.filter((se) => se !== re) : q = [...g.value, re] : q = [re];
        const K = _(_({}, J), {
          selectedKeys: q
        });
        Wd(q, g.value) || (e.selectedKeys === void 0 && (g.value = q), o("update:selectedKeys", q), oe && e.multiple ? o("deselect", K) : o("select", K));
      }
      P.value !== "inline" && !e.multiple && w.value.length && R(b6);
    }, w = /* @__PURE__ */ H([]);
    pe(() => e.openKeys, function() {
      let J = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : w.value;
      Wd(w.value, J) || (w.value = J.slice());
    }, {
      immediate: !0,
      deep: !0
    });
    let x;
    const E = (J) => {
      clearTimeout(x), x = setTimeout(() => {
        e.activeKey === void 0 && (h.value = J), o("update:activeKey", J[J.length - 1]);
      });
    }, I = O(() => !!e.disabled), T = O(() => r.value === "rtl"), P = /* @__PURE__ */ H("vertical"), k = /* @__PURE__ */ Ce(!1);
    Ot(() => {
      var J;
      (e.mode === "inline" || e.mode === "vertical") && p.value ? (P.value = "vertical", k.value = p.value) : (P.value = e.mode, k.value = !1), !((J = i == null ? void 0 : i.mode) === null || J === void 0) && J.value && (P.value = i.mode.value);
    });
    const N = O(() => P.value === "inline"), R = (J) => {
      w.value = J, o("update:openKeys", J), o("openChange", J);
    }, z = /* @__PURE__ */ H(w.value), D = /* @__PURE__ */ Ce(!1);
    pe(w, () => {
      N.value && (z.value = w.value);
    }, {
      immediate: !0
    }), pe(N, () => {
      if (!D.value) {
        D.value = !0;
        return;
      }
      N.value ? w.value = z.value : R(b6);
    }, {
      immediate: !0
    });
    const F = O(() => ({
      [`${s.value}`]: !0,
      [`${s.value}-root`]: !0,
      [`${s.value}-${P.value}`]: !0,
      [`${s.value}-inline-collapsed`]: k.value,
      [`${s.value}-rtl`]: T.value,
      [`${s.value}-${e.theme}`]: !0
    })), M = O(() => a()), A = O(() => ({
      horizontal: {
        name: `${M.value}-slide-up`
      },
      inline: Ph(`${M.value}-motion-collapse`),
      other: {
        name: `${M.value}-zoom-big`
      }
    }));
    iW(!0);
    const L = function() {
      let J = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      const re = [], oe = d.value;
      return J.forEach((q) => {
        const {
          key: K,
          childrenEventKeys: se
        } = oe.get(q);
        re.push(K, ...L(S(se)));
      }), re;
    }, B = (J) => {
      var re;
      o("click", J), C(J), (re = i == null ? void 0 : i.onClick) === null || re === void 0 || re.call(i);
    }, V = (J, re) => {
      var oe;
      const q = ((oe = y.value[J]) === null || oe === void 0 ? void 0 : oe.childrenEventKeys) || [];
      let K = w.value.filter((se) => se !== J);
      if (re)
        K.push(J);
      else if (P.value !== "inline") {
        const se = L(S(q));
        K = DC(K.filter((Z) => !se.includes(Z)));
      }
      Wd(w, K) || R(K);
    }, j = (J, re) => {
      d.value.set(J, re), d.value = new Map(d.value);
    }, W = (J) => {
      d.value.delete(J), d.value = new Map(d.value);
    }, Y = /* @__PURE__ */ H(0), U = O(() => {
      var J;
      return e.expandIcon || n.expandIcon || !((J = i == null ? void 0 : i.expandIcon) === null || J === void 0) && J.value ? (re) => {
        let oe = e.expandIcon || n.expandIcon;
        return oe = typeof oe == "function" ? oe(re) : oe, _n(oe, {
          class: `${s.value}-submenu-expand-icon`
        }, !1);
      } : null;
    });
    oW({
      prefixCls: s,
      activeKeys: h,
      openKeys: w,
      selectedKeys: g,
      changeActiveKeys: E,
      disabled: I,
      rtl: T,
      mode: P,
      inlineIndent: O(() => e.inlineIndent),
      subMenuCloseDelay: O(() => e.subMenuCloseDelay),
      subMenuOpenDelay: O(() => e.subMenuOpenDelay),
      builtinPlacements: O(() => e.builtinPlacements),
      triggerSubMenuAction: O(() => e.triggerSubMenuAction),
      getPopupContainer: O(() => e.getPopupContainer),
      inlineCollapsed: k,
      theme: O(() => e.theme),
      siderCollapsed: f,
      defaultMotions: O(() => v.value ? A.value : null),
      motion: O(() => v.value ? e.motion : null),
      overflowDisabled: /* @__PURE__ */ Ce(void 0),
      onOpenChange: V,
      onItemClick: B,
      registerMenuInfo: j,
      unRegisterMenuInfo: W,
      selectedSubMenuKeys: b,
      expandIcon: U,
      forceSubMenuRender: O(() => e.forceSubMenuRender),
      rootClassName: u
    });
    const te = () => {
      var J;
      return m.value || Fn((J = n.default) === null || J === void 0 ? void 0 : J.call(n));
    };
    return () => {
      var J;
      const re = te(), oe = Y.value >= re.length - 1 || P.value !== "horizontal" || e.disabledOverflow, q = (se) => P.value !== "horizontal" || e.disabledOverflow ? se : (
        // Need wrap for overflow dropdown that do not response for open
        se.map((Z, ee) => (
          // Always wrap provider to avoid sub node re-mount
          $(xy, {
            key: Z.key,
            overflowDisabled: ee > Y.value
          }, {
            default: () => Z
          })
        ))
      ), K = ((J = n.overflowedIndicator) === null || J === void 0 ? void 0 : J.call(n)) || $(Th, null, null);
      return c($(ps, Q(Q({}, l), {}, {
        onMousedown: e.onMousedown,
        prefixCls: `${s.value}-overflow`,
        component: "ul",
        itemComponent: bi,
        class: [F.value, l.class, u.value],
        role: "menu",
        id: e.id,
        data: q(re),
        renderRawItem: (se) => se,
        renderRawRest: (se) => {
          const Z = se.length, ee = Z ? re.slice(-Z) : null;
          return $(Ge, null, [$(Zu, {
            eventKey: Ag,
            key: Ag,
            title: K,
            disabled: oe,
            internalPopupClose: Z === 0
          }, {
            default: () => ee
          }), $(u6, null, {
            default: () => [$(Zu, {
              eventKey: Ag,
              key: Ag,
              title: K,
              disabled: oe,
              internalPopupClose: Z === 0
            }, {
              default: () => ee
            })]
          })]);
        },
        maxCount: P.value !== "horizontal" || e.disabledOverflow ? ps.INVALIDATE : ps.RESPONSIVE,
        ssr: "full",
        "data-menu-list": !0,
        onVisibleChange: (se) => {
          Y.value = se;
        }
      }), {
        default: () => [$(a1, {
          to: "body"
        }, {
          default: () => [$("div", {
            style: {
              display: "none"
            },
            "aria-hidden": !0
          }, [$(u6, null, {
            default: () => [q(te())]
          })])]
        })]
      }));
    };
  }
});
Do.install = function(e) {
  return e.component(Do.name, Do), e.component(bi.name, bi), e.component(Zu.name, Zu), e.component(Fm.name, Fm), e.component(Bm.name, Bm), e;
};
Do.Item = bi;
Do.Divider = Fm;
Do.SubMenu = Zu;
Do.ItemGroup = Bm;
const hRe = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: _(_({}, nn(e)), {
      color: e.breadcrumbBaseColor,
      fontSize: e.breadcrumbFontSize,
      [n]: {
        fontSize: e.breadcrumbIconFontSize
      },
      ol: {
        display: "flex",
        flexWrap: "wrap",
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      a: _({
        color: e.breadcrumbLinkColor,
        transition: `color ${e.motionDurationMid}`,
        padding: `0 ${e.paddingXXS}px`,
        borderRadius: e.borderRadiusSM,
        height: e.lineHeight * e.fontSize,
        display: "inline-block",
        marginInline: -e.marginXXS,
        "&:hover": {
          color: e.breadcrumbLinkColorHover,
          backgroundColor: e.colorBgTextHover
        }
      }, ys(e)),
      "li:last-child": {
        color: e.breadcrumbLastItemColor,
        [`& > ${t}-separator`]: {
          display: "none"
        }
      },
      [`${t}-separator`]: {
        marginInline: e.breadcrumbSeparatorMargin,
        color: e.breadcrumbSeparatorColor
      },
      [`${t}-link`]: {
        [`
          > ${n} + span,
          > ${n} + a
        `]: {
          marginInlineStart: e.marginXXS
        }
      },
      [`${t}-overlay-link`]: {
        borderRadius: e.borderRadiusSM,
        height: e.lineHeight * e.fontSize,
        display: "inline-block",
        padding: `0 ${e.paddingXXS}px`,
        marginInline: -e.marginXXS,
        [`> ${n}`]: {
          marginInlineStart: e.marginXXS,
          fontSize: e.fontSizeIcon
        },
        "&:hover": {
          color: e.breadcrumbLinkColorHover,
          backgroundColor: e.colorBgTextHover,
          a: {
            color: e.breadcrumbLinkColorHover
          }
        },
        a: {
          "&:hover": {
            backgroundColor: "transparent"
          }
        }
      },
      // rtl style
      [`&${e.componentCls}-rtl`]: {
        direction: "rtl"
      }
    })
  };
}, gRe = Zt("Breadcrumb", (e) => {
  const t = Vt(e, {
    breadcrumbBaseColor: e.colorTextDescription,
    breadcrumbFontSize: e.fontSize,
    breadcrumbIconFontSize: e.fontSize,
    breadcrumbLinkColor: e.colorTextDescription,
    breadcrumbLinkColorHover: e.colorText,
    breadcrumbLastItemColor: e.colorText,
    breadcrumbSeparatorMargin: e.marginXS,
    breadcrumbSeparatorColor: e.colorTextDescription
  });
  return [hRe(t)];
}), bRe = () => ({
  prefixCls: String,
  routes: {
    type: Array
  },
  params: de.any,
  separator: de.any,
  itemRender: {
    type: Function
  }
});
function yRe(e, t) {
  if (!e.breadcrumbName)
    return null;
  const n = Object.keys(t).join("|");
  return e.breadcrumbName.replace(new RegExp(`:(${n})`, "g"), (l, r) => t[r] || l);
}
function y6(e) {
  const {
    route: t,
    params: n,
    routes: o,
    paths: l
  } = e, r = o.indexOf(t) === o.length - 1, a = yRe(t, n);
  return r ? $("span", null, [a]) : $("a", {
    href: `#/${l.join("/")}`
  }, [a]);
}
const ku = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumb",
  inheritAttrs: !1,
  props: bRe(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("breadcrumb", e), [a, i] = gRe(l), s = (d, f) => (d = (d || "").replace(/^\//, ""), Object.keys(f).forEach((p) => {
      d = d.replace(`:${p}`, f[p]);
    }), d), c = (d, f, p) => {
      const m = [...d], v = s(f || "", p);
      return v && m.push(v), m;
    }, u = (d) => {
      let {
        routes: f = [],
        params: p = {},
        separator: m,
        itemRender: v = y6
      } = d;
      const h = [];
      return f.map((g) => {
        const y = s(g.path, p);
        y && h.push(y);
        const b = [...h];
        let C = null;
        g.children && g.children.length && (C = $(Do, {
          items: g.children.map((x) => ({
            key: x.path || x.breadcrumbName,
            label: v({
              route: x,
              params: p,
              routes: f,
              paths: c(b, x.path, p)
            })
          }))
        }, null));
        const w = {
          separator: m
        };
        return C && (w.overlay = C), $(Lm, Q(Q({}, w), {}, {
          key: y || g.breadcrumbName
        }), {
          default: () => [v({
            route: g,
            params: p,
            routes: f,
            paths: b
          })]
        });
      });
    };
    return () => {
      var d;
      let f;
      const {
        routes: p,
        params: m = {}
      } = e, v = Fn(Wo(n, e)), h = (d = Wo(n, e, "separator")) !== null && d !== void 0 ? d : "/", g = e.itemRender || n.itemRender || y6;
      p && p.length > 0 ? f = u({
        routes: p,
        params: m,
        separator: h,
        itemRender: g
      }) : v.length && (f = v.map((b, C) => (Hn(typeof b.type == "object" && (b.type.__ANT_BREADCRUMB_ITEM || b.type.__ANT_BREADCRUMB_SEPARATOR), "Breadcrumb", "Only accepts Breadcrumb.Item and Breadcrumb.Separator as it's children"), No(b, {
        separator: h,
        key: C
      }))));
      const y = {
        [l.value]: !0,
        [`${l.value}-rtl`]: r.value === "rtl",
        [`${o.class}`]: !!o.class,
        [i.value]: !0
      };
      return a($("nav", Q(Q({}, o), {}, {
        class: y
      }), [$("ol", null, [f])]));
    };
  }
});
var SRe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const CRe = () => ({
  prefixCls: String
}), _y = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumbSeparator",
  __ANT_BREADCRUMB_SEPARATOR: !0,
  inheritAttrs: !1,
  props: CRe(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l
    } = bt("breadcrumb", e);
    return () => {
      var r;
      const {
        separator: a,
        class: i
      } = o, s = SRe(o, ["separator", "class"]), c = Fn((r = n.default) === null || r === void 0 ? void 0 : r.call(n));
      return $("span", Q({
        class: [`${l.value}-separator`, i]
      }, s), [c.length > 0 ? c : "/"]);
    };
  }
});
ku.Item = Lm;
ku.Separator = _y;
ku.install = function(e) {
  return e.component(ku.name, ku), e.component(Lm.name, Lm), e.component(_y.name, _y), e;
};
var vW = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Ya, function() {
    return function(n, o) {
      o.prototype.weekday = function(l) {
        var r = this.$locale().weekStart || 0, a = this.$W, i = (a < r ? a + 7 : a) - r;
        return this.$utils().u(l) ? i : this.subtract(i, "day").add(l, "day");
      };
    };
  });
})(vW);
var wRe = vW.exports;
const $Re = /* @__PURE__ */ Xa(wRe);
var mW = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Ya, function() {
    var n = "month", o = "quarter";
    return function(l, r) {
      var a = r.prototype;
      a.quarter = function(c) {
        return this.$utils().u(c) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (c - 1));
      };
      var i = a.add;
      a.add = function(c, u) {
        return c = Number(c), this.$utils().p(u) === o ? this.add(3 * c, n) : i.bind(this)(c, u);
      };
      var s = a.startOf;
      a.startOf = function(c, u) {
        var d = this.$utils(), f = !!d.u(u) || u;
        if (d.p(c) === o) {
          var p = this.quarter() - 1;
          return f ? this.month(3 * p).startOf(n).startOf("day") : this.month(3 * p + 2).endOf(n).endOf("day");
        }
        return s.bind(this)(c, u);
      };
    };
  });
})(mW);
var xRe = mW.exports;
const ERe = /* @__PURE__ */ Xa(xRe);
wt.extend(W1);
wt.extend(m9);
wt.extend($Re);
wt.extend(JO);
wt.extend(g9);
wt.extend(y9);
wt.extend(ERe);
wt.extend((e, t) => {
  const n = t.prototype, o = n.format;
  n.format = function(r) {
    const a = (r || "").replace("Wo", "wo");
    return o.bind(this)(a);
  };
});
const ORe = {
  // ar_EG:
  // az_AZ:
  // bg_BG:
  bn_BD: "bn-bd",
  by_BY: "be",
  // ca_ES:
  // cs_CZ:
  // da_DK:
  // de_DE:
  // el_GR:
  en_GB: "en-gb",
  en_US: "en",
  // es_ES:
  // et_EE:
  // fa_IR:
  // fi_FI:
  fr_BE: "fr",
  fr_CA: "fr-ca",
  // fr_FR:
  // ga_IE:
  // gl_ES:
  // he_IL:
  // hi_IN:
  // hr_HR:
  // hu_HU:
  hy_AM: "hy-am",
  // id_ID:
  // is_IS:
  // it_IT:
  // ja_JP:
  // ka_GE:
  // kk_KZ:
  // km_KH:
  kmr_IQ: "ku",
  // kn_IN:
  // ko_KR:
  // ku_IQ: // previous ku in antd
  // lt_LT:
  // lv_LV:
  // mk_MK:
  // ml_IN:
  // mn_MN:
  // ms_MY:
  // nb_NO:
  // ne_NP:
  nl_BE: "nl-be",
  // nl_NL:
  // pl_PL:
  pt_BR: "pt-br",
  // pt_PT:
  // ro_RO:
  // ru_RU:
  // sk_SK:
  // sl_SI:
  // sr_RS:
  // sv_SE:
  // ta_IN:
  // th_TH:
  // tr_TR:
  // uk_UA:
  // ur_PK:
  // vi_VN:
  zh_CN: "zh-cn",
  zh_HK: "zh-hk",
  zh_TW: "zh-tw"
}, Gc = (e) => ORe[e] || e.split("_")[0], S6 = () => {
  u2(!1, "Not match any format. Please help to fire a issue about this.");
}, _Re = /\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|k{1,2}|S/g;
function C6(e, t, n) {
  const o = [...new Set(e.split(n))];
  let l = 0;
  for (let r = 0; r < o.length; r++) {
    const a = o[r];
    if (l += a.length, l > t)
      return a;
    l += n.length;
  }
}
const w6 = (e, t) => {
  if (!e) return null;
  if (wt.isDayjs(e))
    return e;
  const n = t.matchAll(_Re);
  let o = wt(e, t);
  if (n === null)
    return o;
  for (const l of n) {
    const r = l[0], a = l.index;
    if (r === "Q") {
      const i = e.slice(a - 1, a), s = C6(e, a, i).match(/\d+/)[0];
      o = o.quarter(parseInt(s));
    }
    if (r.toLowerCase() === "wo") {
      const i = e.slice(a - 1, a), s = C6(e, a, i).match(/\d+/)[0];
      o = o.week(parseInt(s));
    }
    r.toLowerCase() === "ww" && (o = o.week(parseInt(e.slice(a, a + r.length)))), r.toLowerCase() === "w" && (o = o.week(parseInt(e.slice(a, a + r.length + 1))));
  }
  return o;
}, nT = {
  // get
  getNow: () => wt(),
  getFixedDate: (e) => wt(e, ["YYYY-M-DD", "YYYY-MM-DD"]),
  getEndDate: (e) => e.endOf("month"),
  getWeekDay: (e) => {
    const t = e.locale("en");
    return t.weekday() + t.localeData().firstDayOfWeek();
  },
  getYear: (e) => e.year(),
  getMonth: (e) => e.month(),
  getDate: (e) => e.date(),
  getHour: (e) => e.hour(),
  getMinute: (e) => e.minute(),
  getSecond: (e) => e.second(),
  // set
  addYear: (e, t) => e.add(t, "year"),
  addMonth: (e, t) => e.add(t, "month"),
  addDate: (e, t) => e.add(t, "day"),
  setYear: (e, t) => e.year(t),
  setMonth: (e, t) => e.month(t),
  setDate: (e, t) => e.date(t),
  setHour: (e, t) => e.hour(t),
  setMinute: (e, t) => e.minute(t),
  setSecond: (e, t) => e.second(t),
  // Compare
  isAfter: (e, t) => e.isAfter(t),
  isValidate: (e) => e.isValid(),
  locale: {
    getWeekFirstDay: (e) => wt().locale(Gc(e)).localeData().firstDayOfWeek(),
    getWeekFirstDate: (e, t) => t.locale(Gc(e)).weekday(0),
    getWeek: (e, t) => t.locale(Gc(e)).week(),
    getShortWeekDays: (e) => wt().locale(Gc(e)).localeData().weekdaysMin(),
    getShortMonths: (e) => wt().locale(Gc(e)).localeData().monthsShort(),
    format: (e, t, n) => t.locale(Gc(e)).format(n),
    parse: (e, t, n) => {
      const o = Gc(e);
      for (let l = 0; l < n.length; l += 1) {
        const r = n[l], a = t;
        if (r.includes("wo") || r.includes("Wo")) {
          const s = a.split("-")[0], c = a.split("-")[1], u = wt(s, "YYYY").startOf("year").locale(o);
          for (let d = 0; d <= 52; d += 1) {
            const f = u.add(d, "week");
            if (f.format("Wo") === c)
              return f;
          }
          return S6(), null;
        }
        const i = wt(a, r, !0).locale(o);
        if (i.isValid())
          return i;
      }
      return t || S6(), null;
    }
  },
  toDate: (e, t) => Array.isArray(e) ? e.map((n) => w6(n, t)) : w6(e, t),
  toString: (e, t) => Array.isArray(e) ? e.map((n) => wt.isDayjs(n) ? n.format(t) : n) : wt.isDayjs(e) ? e.format(t) : e
};
function Vo(e) {
  const t = Ti();
  return _(_({}, e), t);
}
const hW = Symbol("PanelContextProps"), oT = (e) => {
  at(hW, e);
}, Ri = () => ze(hW, {}), Rg = {
  visibility: "hidden"
};
function Lc(e, t) {
  let {
    slots: n
  } = t;
  var o;
  const l = Vo(e), {
    prefixCls: r,
    prevIcon: a = "",
    nextIcon: i = "",
    superPrevIcon: s = "",
    superNextIcon: c = "",
    onSuperPrev: u,
    onSuperNext: d,
    onPrev: f,
    onNext: p
  } = l, {
    hideNextBtn: m,
    hidePrevBtn: v
  } = Ri();
  return $("div", {
    class: r
  }, [u && $("button", {
    type: "button",
    onClick: u,
    tabindex: -1,
    class: `${r}-super-prev-btn`,
    style: v.value ? Rg : {}
  }, [s]), f && $("button", {
    type: "button",
    onClick: f,
    tabindex: -1,
    class: `${r}-prev-btn`,
    style: v.value ? Rg : {}
  }, [a]), $("div", {
    class: `${r}-view`
  }, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)]), p && $("button", {
    type: "button",
    onClick: p,
    tabindex: -1,
    class: `${r}-next-btn`,
    style: m.value ? Rg : {}
  }, [i]), d && $("button", {
    type: "button",
    onClick: d,
    tabindex: -1,
    class: `${r}-super-next-btn`,
    style: m.value ? Rg : {}
  }, [c])]);
}
Lc.displayName = "Header";
Lc.inheritAttrs = !1;
function lT(e) {
  const t = Vo(e), {
    prefixCls: n,
    generateConfig: o,
    viewDate: l,
    onPrevDecades: r,
    onNextDecades: a
  } = t, {
    hideHeader: i
  } = Ri();
  if (i)
    return null;
  const s = `${n}-header`, c = o.getYear(l), u = Math.floor(c / as) * as, d = u + as - 1;
  return $(Lc, Q(Q({}, t), {}, {
    prefixCls: s,
    onSuperPrev: r,
    onSuperNext: a
  }), {
    default: () => [u, Ft("-"), d]
  });
}
lT.displayName = "DecadeHeader";
lT.inheritAttrs = !1;
function gW(e, t, n, o, l) {
  let r = e.setHour(t, n);
  return r = e.setMinute(r, o), r = e.setSecond(r, l), r;
}
function Nb(e, t, n) {
  if (!n)
    return t;
  let o = t;
  return o = e.setHour(o, e.getHour(n)), o = e.setMinute(o, e.getMinute(n)), o = e.setSecond(o, e.getSecond(n)), o;
}
function IRe(e, t, n, o, l, r) {
  const a = Math.floor(e / o) * o;
  if (a < e)
    return [a, 60 - l, 60 - r];
  const i = Math.floor(t / l) * l;
  if (i < t)
    return [a, i, 60 - r];
  const s = Math.floor(n / r) * r;
  return [a, i, s];
}
function TRe(e, t) {
  const n = e.getYear(t), o = e.getMonth(t) + 1, l = e.getEndDate(e.getFixedDate(`${n}-${o}-01`)), r = e.getDate(l), a = o < 10 ? `0${o}` : `${o}`;
  return `${n}-${a}-${r}`;
}
function vd(e) {
  const {
    prefixCls: t,
    disabledDate: n,
    onSelect: o,
    picker: l,
    rowNum: r,
    colNum: a,
    prefixColumn: i,
    rowClassName: s,
    baseDate: c,
    getCellClassName: u,
    getCellText: d,
    getCellNode: f,
    getCellDate: p,
    generateConfig: m,
    titleCell: v,
    headerCells: h
  } = Vo(e), {
    onDateMouseenter: g,
    onDateMouseleave: y,
    mode: b
  } = Ri(), C = `${t}-cell`, w = [];
  for (let x = 0; x < r; x += 1) {
    const E = [];
    let I;
    for (let T = 0; T < a; T += 1) {
      const P = x * a + T, k = p(c, P), N = A2({
        cellDate: k,
        mode: b.value,
        disabledDate: n,
        generateConfig: m
      });
      T === 0 && (I = k, i && E.push(i(I)));
      const R = v && v(k);
      E.push($("td", {
        key: T,
        title: R,
        class: ke(C, _({
          [`${C}-disabled`]: N,
          [`${C}-start`]: d(k) === 1 || l === "year" && Number(R) % 10 === 0,
          [`${C}-end`]: R === TRe(m, k) || l === "year" && Number(R) % 10 === 9
        }, u(k))),
        onClick: (z) => {
          z.stopPropagation(), N || o(k);
        },
        onMouseenter: () => {
          !N && g && g(k);
        },
        onMouseleave: () => {
          !N && y && y(k);
        }
      }, [f ? f(k) : $("div", {
        class: `${C}-inner`
      }, [d(k)])]));
    }
    w.push($("tr", {
      key: x,
      class: s && s(I)
    }, [E]));
  }
  return $("div", {
    class: `${t}-body`
  }, [$("table", {
    class: `${t}-content`
  }, [h && $("thead", null, [$("tr", null, [h])]), $("tbody", null, [w])])]);
}
vd.displayName = "PanelBody";
vd.inheritAttrs = !1;
const k2 = 3, $6 = 4;
function rT(e) {
  const t = Vo(e), n = ya - 1, {
    prefixCls: o,
    viewDate: l,
    generateConfig: r
  } = t, a = `${o}-cell`, i = r.getYear(l), s = Math.floor(i / ya) * ya, c = Math.floor(i / as) * as, u = c + as - 1, d = r.setYear(l, c - Math.ceil((k2 * $6 * ya - as) / 2)), f = (p) => {
    const m = r.getYear(p), v = m + n;
    return {
      [`${a}-in-view`]: c <= m && v <= u,
      [`${a}-selected`]: m === s
    };
  };
  return $(vd, Q(Q({}, t), {}, {
    rowNum: $6,
    colNum: k2,
    baseDate: d,
    getCellText: (p) => {
      const m = r.getYear(p);
      return `${m}-${m + n}`;
    },
    getCellClassName: f,
    getCellDate: (p, m) => r.addYear(p, m * ya)
  }), null);
}
rT.displayName = "DecadeBody";
rT.inheritAttrs = !1;
const Dg = /* @__PURE__ */ new Map();
function PRe(e, t) {
  let n;
  function o() {
    pS(e) ? t() : n = rn(() => {
      o();
    });
  }
  return o(), () => {
    rn.cancel(n);
  };
}
function N2(e, t, n) {
  if (Dg.get(e) && rn.cancel(Dg.get(e)), n <= 0) {
    Dg.set(e, rn(() => {
      e.scrollTop = t;
    }));
    return;
  }
  const l = (t - e.scrollTop) / n * 10;
  Dg.set(e, rn(() => {
    e.scrollTop += l, e.scrollTop !== t && N2(e, t, n - 10);
  }));
}
function Lp(e, t) {
  let {
    onLeftRight: n,
    onCtrlLeftRight: o,
    onUpDown: l,
    onPageUpDown: r,
    onEnter: a
  } = t;
  const {
    which: i,
    ctrlKey: s,
    metaKey: c
  } = e;
  switch (i) {
    case ot.LEFT:
      if (s || c) {
        if (o)
          return o(-1), !0;
      } else if (n)
        return n(-1), !0;
      break;
    case ot.RIGHT:
      if (s || c) {
        if (o)
          return o(1), !0;
      } else if (n)
        return n(1), !0;
      break;
    case ot.UP:
      if (l)
        return l(-1), !0;
      break;
    case ot.DOWN:
      if (l)
        return l(1), !0;
      break;
    case ot.PAGE_UP:
      if (r)
        return r(-1), !0;
      break;
    case ot.PAGE_DOWN:
      if (r)
        return r(1), !0;
      break;
    case ot.ENTER:
      if (a)
        return a(), !0;
      break;
  }
  return !1;
}
function bW(e, t, n, o) {
  let l = e;
  if (!l)
    switch (t) {
      case "time":
        l = o ? "hh:mm:ss a" : "HH:mm:ss";
        break;
      case "week":
        l = "gggg-wo";
        break;
      case "month":
        l = "YYYY-MM";
        break;
      case "quarter":
        l = "YYYY-[Q]Q";
        break;
      case "year":
        l = "YYYY";
        break;
      default:
        l = n ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
    }
  return l;
}
function yW(e, t, n) {
  const o = e === "time" ? 8 : 10, l = typeof t == "function" ? t(n.getNow()).length : t.length;
  return Math.max(o, l) + 2;
}
let av = null;
const Lg = /* @__PURE__ */ new Set();
function kRe(e) {
  return !av && typeof window != "undefined" && window.addEventListener && (av = (t) => {
    [...Lg].forEach((n) => {
      n(t);
    });
  }, window.addEventListener("mousedown", av)), Lg.add(e), () => {
    Lg.delete(e), Lg.size === 0 && (window.removeEventListener("mousedown", av), av = null);
  };
}
function NRe(e) {
  var t;
  const n = e.target;
  return e.composed && n.shadowRoot && ((t = e.composedPath) === null || t === void 0 ? void 0 : t.call(e)[0]) || n;
}
const MRe = (e) => e === "month" || e === "date" ? "year" : e, ARe = (e) => e === "date" ? "month" : e, RRe = (e) => e === "month" || e === "date" ? "quarter" : e, DRe = (e) => e === "date" ? "week" : e, LRe = {
  year: MRe,
  month: ARe,
  quarter: RRe,
  week: DRe,
  time: null,
  date: null
};
function SW(e, t) {
  return process.env.NODE_ENV === "test" ? !1 : e.some((n) => n && n.contains(t));
}
const ya = 10, as = ya * 10;
function aT(e) {
  const t = Vo(e), {
    prefixCls: n,
    onViewDateChange: o,
    generateConfig: l,
    viewDate: r,
    operationRef: a,
    onSelect: i,
    onPanelChange: s
  } = t, c = `${n}-decade-panel`;
  a.value = {
    onKeydown: (f) => Lp(f, {
      onLeftRight: (p) => {
        i(l.addYear(r, p * ya), "key");
      },
      onCtrlLeftRight: (p) => {
        i(l.addYear(r, p * as), "key");
      },
      onUpDown: (p) => {
        i(l.addYear(r, p * ya * k2), "key");
      },
      onEnter: () => {
        s("year", r);
      }
    })
  };
  const u = (f) => {
    const p = l.addYear(r, f * as);
    o(p), s(null, p);
  }, d = (f) => {
    i(f, "mouse"), s("year", f);
  };
  return $("div", {
    class: c
  }, [$(lT, Q(Q({}, t), {}, {
    prefixCls: n,
    onPrevDecades: () => {
      u(-1);
    },
    onNextDecades: () => {
      u(1);
    }
  }), null), $(rT, Q(Q({}, t), {}, {
    prefixCls: n,
    onSelect: d
  }), null)]);
}
aT.displayName = "DecadePanel";
aT.inheritAttrs = !1;
const Mb = 7;
function md(e, t) {
  if (!e && !t)
    return !0;
  if (!e || !t)
    return !1;
}
function BRe(e, t, n) {
  const o = md(t, n);
  if (typeof o == "boolean")
    return o;
  const l = Math.floor(e.getYear(t) / 10), r = Math.floor(e.getYear(n) / 10);
  return l === r;
}
function TS(e, t, n) {
  const o = md(t, n);
  return typeof o == "boolean" ? o : e.getYear(t) === e.getYear(n);
}
function M2(e, t) {
  return Math.floor(e.getMonth(t) / 3) + 1;
}
function CW(e, t, n) {
  const o = md(t, n);
  return typeof o == "boolean" ? o : TS(e, t, n) && M2(e, t) === M2(e, n);
}
function iT(e, t, n) {
  const o = md(t, n);
  return typeof o == "boolean" ? o : TS(e, t, n) && e.getMonth(t) === e.getMonth(n);
}
function is(e, t, n) {
  const o = md(t, n);
  return typeof o == "boolean" ? o : e.getYear(t) === e.getYear(n) && e.getMonth(t) === e.getMonth(n) && e.getDate(t) === e.getDate(n);
}
function FRe(e, t, n) {
  const o = md(t, n);
  return typeof o == "boolean" ? o : e.getHour(t) === e.getHour(n) && e.getMinute(t) === e.getMinute(n) && e.getSecond(t) === e.getSecond(n);
}
function wW(e, t, n, o) {
  const l = md(n, o);
  return typeof l == "boolean" ? l : e.locale.getWeek(t, n) === e.locale.getWeek(t, o);
}
function $f(e, t, n) {
  return is(e, t, n) && FRe(e, t, n);
}
function Bg(e, t, n, o) {
  return !t || !n || !o ? !1 : !is(e, t, o) && !is(e, n, o) && e.isAfter(o, t) && e.isAfter(n, o);
}
function VRe(e, t, n) {
  const o = t.locale.getWeekFirstDay(e), l = t.setDate(n, 1), r = t.getWeekDay(l);
  let a = t.addDate(l, o - r);
  return t.getMonth(a) === t.getMonth(n) && t.getDate(a) > 1 && (a = t.addDate(a, -7)), a;
}
function Bv(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  switch (t) {
    case "year":
      return n.addYear(e, o * 10);
    case "quarter":
    case "month":
      return n.addYear(e, o);
    default:
      return n.addMonth(e, o);
  }
}
function yl(e, t) {
  let {
    generateConfig: n,
    locale: o,
    format: l
  } = t;
  return typeof l == "function" ? l(e) : n.locale.format(o.locale, e, l);
}
function $W(e, t) {
  let {
    generateConfig: n,
    locale: o,
    formatList: l
  } = t;
  return !e || typeof l[0] == "function" ? null : n.locale.parse(o.locale, e, l);
}
function A2(e) {
  let {
    cellDate: t,
    mode: n,
    disabledDate: o,
    generateConfig: l
  } = e;
  if (!o) return !1;
  const r = (a, i, s) => {
    let c = i;
    for (; c <= s; ) {
      let u;
      switch (a) {
        case "date": {
          if (u = l.setDate(t, c), !o(u))
            return !1;
          break;
        }
        case "month": {
          if (u = l.setMonth(t, c), !A2({
            cellDate: u,
            mode: "month",
            generateConfig: l,
            disabledDate: o
          }))
            return !1;
          break;
        }
        case "year": {
          if (u = l.setYear(t, c), !A2({
            cellDate: u,
            mode: "year",
            generateConfig: l,
            disabledDate: o
          }))
            return !1;
          break;
        }
      }
      c += 1;
    }
    return !0;
  };
  switch (n) {
    case "date":
    case "week":
      return o(t);
    case "month": {
      const i = l.getDate(l.getEndDate(t));
      return r("date", 1, i);
    }
    case "quarter": {
      const a = Math.floor(l.getMonth(t) / 3) * 3, i = a + 2;
      return r("month", a, i);
    }
    case "year":
      return r("month", 0, 11);
    case "decade": {
      const a = l.getYear(t), i = Math.floor(a / ya) * ya, s = i + ya - 1;
      return r("year", i, s);
    }
  }
}
function sT(e) {
  const t = Vo(e), {
    hideHeader: n
  } = Ri();
  if (n.value)
    return null;
  const {
    prefixCls: o,
    generateConfig: l,
    locale: r,
    value: a,
    format: i
  } = t, s = `${o}-header`;
  return $(Lc, {
    prefixCls: s
  }, {
    default: () => [a ? yl(a, {
      locale: r,
      format: i,
      generateConfig: l
    }) : ""]
  });
}
sT.displayName = "TimeHeader";
sT.inheritAttrs = !1;
const Fg = /* @__PURE__ */ le({
  name: "TimeUnitColumn",
  props: ["prefixCls", "units", "onSelect", "value", "active", "hideDisabledOptions"],
  setup(e) {
    const {
      open: t
    } = Ri(), n = /* @__PURE__ */ Ce(null), o = /* @__PURE__ */ H(/* @__PURE__ */ new Map()), l = /* @__PURE__ */ H();
    return pe(() => e.value, () => {
      const r = o.value.get(e.value);
      r && t.value !== !1 && N2(n.value, r.offsetTop, 120);
    }), yt(() => {
      var r;
      (r = l.value) === null || r === void 0 || r.call(l);
    }), pe(t, () => {
      var r;
      (r = l.value) === null || r === void 0 || r.call(l), Ke(() => {
        if (t.value) {
          const a = o.value.get(e.value);
          a && (l.value = PRe(a, () => {
            N2(n.value, a.offsetTop, 0);
          }));
        }
      });
    }, {
      immediate: !0,
      flush: "post"
    }), () => {
      const {
        prefixCls: r,
        units: a,
        onSelect: i,
        value: s,
        active: c,
        hideDisabledOptions: u
      } = e, d = `${r}-cell`;
      return $("ul", {
        class: ke(`${r}-column`, {
          [`${r}-column-active`]: c
        }),
        ref: n,
        style: {
          position: "relative"
        }
      }, [a.map((f) => u && f.disabled ? null : $("li", {
        key: f.value,
        ref: (p) => {
          o.value.set(f.value, p);
        },
        class: ke(d, {
          [`${d}-disabled`]: f.disabled,
          [`${d}-selected`]: s === f.value
        }),
        onClick: () => {
          f.disabled || i(f.value);
        }
      }, [$("div", {
        class: `${d}-inner`
      }, [f.label])]))]);
    };
  }
});
function xW(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0", o = String(e);
  for (; o.length < t; )
    o = `${n}${e}`;
  return o;
}
const zRe = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return t;
};
function EW(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function OW(e) {
  const t = {};
  return Object.keys(e).forEach((n) => {
    (n.startsWith("data-") || n.startsWith("aria-") || n === "role" || n === "name") && !n.startsWith("data-__") && (t[n] = e[n]);
  }), t;
}
function An(e, t) {
  return e ? e[t] : null;
}
function Gr(e, t, n) {
  const o = [An(e, 0), An(e, 1)];
  return o[n] = typeof t == "function" ? t(o[n]) : t, !o[0] && !o[1] ? null : o;
}
function kw(e, t, n, o) {
  const l = [];
  for (let r = e; r <= t; r += n)
    l.push({
      label: xW(r, 2),
      value: r,
      disabled: (o || []).includes(r)
    });
  return l;
}
const HRe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "TimeBody",
  inheritAttrs: !1,
  props: ["generateConfig", "prefixCls", "operationRef", "activeColumnIndex", "value", "showHour", "showMinute", "showSecond", "use12Hours", "hourStep", "minuteStep", "secondStep", "disabledHours", "disabledMinutes", "disabledSeconds", "disabledTime", "hideDisabledOptions", "onSelect"],
  setup(e) {
    const t = O(() => e.value ? e.generateConfig.getHour(e.value) : -1), n = O(() => e.use12Hours ? t.value >= 12 : !1), o = O(() => e.use12Hours ? t.value % 12 : t.value), l = O(() => e.value ? e.generateConfig.getMinute(e.value) : -1), r = O(() => e.value ? e.generateConfig.getSecond(e.value) : -1), a = /* @__PURE__ */ H(e.generateConfig.getNow()), i = /* @__PURE__ */ H(), s = /* @__PURE__ */ H(), c = /* @__PURE__ */ H();
    vp(() => {
      a.value = e.generateConfig.getNow();
    }), Ot(() => {
      if (e.disabledTime) {
        const h = e.disabledTime(a);
        [i.value, s.value, c.value] = [h.disabledHours, h.disabledMinutes, h.disabledSeconds];
      } else
        [i.value, s.value, c.value] = [e.disabledHours, e.disabledMinutes, e.disabledSeconds];
    });
    const u = (h, g, y, b) => {
      let C = e.value || e.generateConfig.getNow();
      const w = Math.max(0, g), x = Math.max(0, y), E = Math.max(0, b);
      return C = gW(e.generateConfig, C, !e.use12Hours || !h ? w : w + 12, x, E), C;
    }, d = O(() => {
      var h;
      return kw(0, 23, (h = e.hourStep) !== null && h !== void 0 ? h : 1, i.value && i.value());
    }), f = O(() => {
      if (!e.use12Hours)
        return [!1, !1];
      const h = [!0, !0];
      return d.value.forEach((g) => {
        let {
          disabled: y,
          value: b
        } = g;
        y || (b >= 12 ? h[1] = !1 : h[0] = !1);
      }), h;
    }), p = O(() => e.use12Hours ? d.value.filter(n.value ? (h) => h.value >= 12 : (h) => h.value < 12).map((h) => {
      const g = h.value % 12, y = g === 0 ? "12" : xW(g, 2);
      return _(_({}, h), {
        label: y,
        value: g
      });
    }) : d.value), m = O(() => {
      var h;
      return kw(0, 59, (h = e.minuteStep) !== null && h !== void 0 ? h : 1, s.value && s.value(t.value));
    }), v = O(() => {
      var h;
      return kw(0, 59, (h = e.secondStep) !== null && h !== void 0 ? h : 1, c.value && c.value(t.value, l.value));
    });
    return () => {
      const {
        prefixCls: h,
        operationRef: g,
        activeColumnIndex: y,
        showHour: b,
        showMinute: C,
        showSecond: w,
        use12Hours: x,
        hideDisabledOptions: E,
        onSelect: I
      } = e, T = [], P = `${h}-content`, k = `${h}-time-panel`;
      g.value = {
        onUpDown: (z) => {
          const D = T[y];
          if (D) {
            const F = D.units.findIndex((A) => A.value === D.value), M = D.units.length;
            for (let A = 1; A < M; A += 1) {
              const L = D.units[(F + z * A + M) % M];
              if (L.disabled !== !0) {
                D.onSelect(L.value);
                break;
              }
            }
          }
        }
      };
      function N(z, D, F, M, A) {
        z !== !1 && T.push({
          node: _n(D, {
            prefixCls: k,
            value: F,
            active: y === T.length,
            onSelect: A,
            units: M,
            hideDisabledOptions: E
          }),
          onSelect: A,
          value: F,
          units: M
        });
      }
      N(b, $(Fg, {
        key: "hour"
      }, null), o.value, p.value, (z) => {
        I(u(n.value, z, l.value, r.value), "mouse");
      }), N(C, $(Fg, {
        key: "minute"
      }, null), l.value, m.value, (z) => {
        I(u(n.value, o.value, z, r.value), "mouse");
      }), N(w, $(Fg, {
        key: "second"
      }, null), r.value, v.value, (z) => {
        I(u(n.value, o.value, l.value, z), "mouse");
      });
      let R = -1;
      return typeof n.value == "boolean" && (R = n.value ? 1 : 0), N(x === !0, $(Fg, {
        key: "12hours"
      }, null), R, [{
        label: "AM",
        value: 0,
        disabled: f.value[0]
      }, {
        label: "PM",
        value: 1,
        disabled: f.value[1]
      }], (z) => {
        I(u(!!z, o.value, l.value, r.value), "mouse");
      }), $("div", {
        class: P
      }, [T.map((z) => {
        let {
          node: D
        } = z;
        return D;
      })]);
    };
  }
}), jRe = (e) => e.filter((t) => t !== !1).length;
function PS(e) {
  const t = Vo(e), {
    generateConfig: n,
    format: o = "HH:mm:ss",
    prefixCls: l,
    active: r,
    operationRef: a,
    showHour: i,
    showMinute: s,
    showSecond: c,
    use12Hours: u = !1,
    onSelect: d,
    value: f
  } = t, p = `${l}-time-panel`, m = /* @__PURE__ */ H(), v = /* @__PURE__ */ H(-1), h = jRe([i, s, c, u]);
  return a.value = {
    onKeydown: (g) => Lp(g, {
      onLeftRight: (y) => {
        v.value = (v.value + y + h) % h;
      },
      onUpDown: (y) => {
        v.value === -1 ? v.value = 0 : m.value && m.value.onUpDown(y);
      },
      onEnter: () => {
        d(f || n.getNow(), "key"), v.value = -1;
      }
    }),
    onBlur: () => {
      v.value = -1;
    }
  }, $("div", {
    class: ke(p, {
      [`${p}-active`]: r
    })
  }, [$(sT, Q(Q({}, t), {}, {
    format: o,
    prefixCls: l
  }), null), $(HRe, Q(Q({}, t), {}, {
    prefixCls: l,
    activeColumnIndex: v.value,
    operationRef: m
  }), null)]);
}
PS.displayName = "TimePanel";
PS.inheritAttrs = !1;
function kS(e) {
  let {
    cellPrefixCls: t,
    generateConfig: n,
    rangedValue: o,
    hoverRangedValue: l,
    isInView: r,
    isSameCell: a,
    offsetCell: i,
    today: s,
    value: c
  } = e;
  function u(d) {
    const f = i(d, -1), p = i(d, 1), m = An(o, 0), v = An(o, 1), h = An(l, 0), g = An(l, 1), y = Bg(n, h, g, d);
    function b(T) {
      return a(m, T);
    }
    function C(T) {
      return a(v, T);
    }
    const w = a(h, d), x = a(g, d), E = (y || x) && (!r(f) || C(f)), I = (y || w) && (!r(p) || b(p));
    return {
      // In view
      [`${t}-in-view`]: r(d),
      // Range
      [`${t}-in-range`]: Bg(n, m, v, d),
      [`${t}-range-start`]: b(d),
      [`${t}-range-end`]: C(d),
      [`${t}-range-start-single`]: b(d) && !v,
      [`${t}-range-end-single`]: C(d) && !m,
      [`${t}-range-start-near-hover`]: b(d) && (a(f, h) || Bg(n, h, g, f)),
      [`${t}-range-end-near-hover`]: C(d) && (a(p, g) || Bg(n, h, g, p)),
      // Range Hover
      [`${t}-range-hover`]: y,
      [`${t}-range-hover-start`]: w,
      [`${t}-range-hover-end`]: x,
      // Range Edge
      [`${t}-range-hover-edge-start`]: E,
      [`${t}-range-hover-edge-end`]: I,
      [`${t}-range-hover-edge-start-near-range`]: E && a(f, v),
      [`${t}-range-hover-edge-end-near-range`]: I && a(p, m),
      // Others
      [`${t}-today`]: a(s, d),
      [`${t}-selected`]: a(c, d)
    };
  }
  return u;
}
const _W = Symbol("RangeContextProps"), WRe = (e) => {
  at(_W, e);
}, kh = () => ze(_W, {
  rangedValue: /* @__PURE__ */ H(),
  hoverRangedValue: /* @__PURE__ */ H(),
  inRange: /* @__PURE__ */ H(),
  panelPosition: /* @__PURE__ */ H()
}), KRe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "PanelContextProvider",
  inheritAttrs: !1,
  props: {
    value: {
      type: Object,
      default: () => ({})
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = {
      rangedValue: /* @__PURE__ */ H(e.value.rangedValue),
      hoverRangedValue: /* @__PURE__ */ H(e.value.hoverRangedValue),
      inRange: /* @__PURE__ */ H(e.value.inRange),
      panelPosition: /* @__PURE__ */ H(e.value.panelPosition)
    };
    return WRe(o), pe(() => e.value, () => {
      Object.keys(e.value).forEach((l) => {
        o[l] && (o[l].value = e.value[l]);
      });
    }), () => {
      var l;
      return (l = n.default) === null || l === void 0 ? void 0 : l.call(n);
    };
  }
});
function NS(e) {
  const t = Vo(e), {
    prefixCls: n,
    generateConfig: o,
    prefixColumn: l,
    locale: r,
    rowCount: a,
    viewDate: i,
    value: s,
    dateRender: c
  } = t, {
    rangedValue: u,
    hoverRangedValue: d
  } = kh(), f = VRe(r.locale, o, i), p = `${n}-cell`, m = o.locale.getWeekFirstDay(r.locale), v = o.getNow(), h = [], g = r.shortWeekDays || (o.locale.getShortWeekDays ? o.locale.getShortWeekDays(r.locale) : []);
  l && h.push($("th", {
    key: "empty",
    "aria-label": "empty cell"
  }, null));
  for (let C = 0; C < Mb; C += 1)
    h.push($("th", {
      key: C
    }, [g[(C + m) % Mb]]));
  const y = kS({
    cellPrefixCls: p,
    today: v,
    value: s,
    generateConfig: o,
    rangedValue: l ? null : u.value,
    hoverRangedValue: l ? null : d.value,
    isSameCell: (C, w) => is(o, C, w),
    isInView: (C) => iT(o, C, i),
    offsetCell: (C, w) => o.addDate(C, w)
  }), b = c ? (C) => c({
    current: C,
    today: v
  }) : void 0;
  return $(vd, Q(Q({}, t), {}, {
    rowNum: a,
    colNum: Mb,
    baseDate: f,
    getCellNode: b,
    getCellText: o.getDate,
    getCellClassName: y,
    getCellDate: o.addDate,
    titleCell: (C) => yl(C, {
      locale: r,
      format: "YYYY-MM-DD",
      generateConfig: o
    }),
    headerCells: h
  }), null);
}
NS.displayName = "DateBody";
NS.inheritAttrs = !1;
NS.props = [
  "prefixCls",
  "generateConfig",
  "value?",
  "viewDate",
  "locale",
  "rowCount",
  "onSelect",
  "dateRender?",
  "disabledDate?",
  // Used for week panel
  "prefixColumn?",
  "rowClassName?"
];
function cT(e) {
  const t = Vo(e), {
    prefixCls: n,
    generateConfig: o,
    locale: l,
    viewDate: r,
    onNextMonth: a,
    onPrevMonth: i,
    onNextYear: s,
    onPrevYear: c,
    onYearClick: u,
    onMonthClick: d
  } = t, {
    hideHeader: f
  } = Ri();
  if (f.value)
    return null;
  const p = `${n}-header`, m = l.shortMonths || (o.locale.getShortMonths ? o.locale.getShortMonths(l.locale) : []), v = o.getMonth(r), h = $("button", {
    type: "button",
    key: "year",
    onClick: u,
    tabindex: -1,
    class: `${n}-year-btn`
  }, [yl(r, {
    locale: l,
    format: l.yearFormat,
    generateConfig: o
  })]), g = $("button", {
    type: "button",
    key: "month",
    onClick: d,
    tabindex: -1,
    class: `${n}-month-btn`
  }, [l.monthFormat ? yl(r, {
    locale: l,
    format: l.monthFormat,
    generateConfig: o
  }) : m[v]]), y = l.monthBeforeYear ? [g, h] : [h, g];
  return $(Lc, Q(Q({}, t), {}, {
    prefixCls: p,
    onSuperPrev: c,
    onPrev: i,
    onNext: a,
    onSuperNext: s
  }), {
    default: () => [y]
  });
}
cT.displayName = "DateHeader";
cT.inheritAttrs = !1;
const URe = 6;
function Nh(e) {
  const t = Vo(e), {
    prefixCls: n,
    panelName: o = "date",
    keyboardConfig: l,
    active: r,
    operationRef: a,
    generateConfig: i,
    value: s,
    viewDate: c,
    onViewDateChange: u,
    onPanelChange: d,
    onSelect: f
  } = t, p = `${n}-${o}-panel`;
  a.value = {
    onKeydown: (h) => Lp(h, _({
      onLeftRight: (g) => {
        f(i.addDate(s || c, g), "key");
      },
      onCtrlLeftRight: (g) => {
        f(i.addYear(s || c, g), "key");
      },
      onUpDown: (g) => {
        f(i.addDate(s || c, g * Mb), "key");
      },
      onPageUpDown: (g) => {
        f(i.addMonth(s || c, g), "key");
      }
    }, l))
  };
  const m = (h) => {
    const g = i.addYear(c, h);
    u(g), d(null, g);
  }, v = (h) => {
    const g = i.addMonth(c, h);
    u(g), d(null, g);
  };
  return $("div", {
    class: ke(p, {
      [`${p}-active`]: r
    })
  }, [$(cT, Q(Q({}, t), {}, {
    prefixCls: n,
    value: s,
    viewDate: c,
    onPrevYear: () => {
      m(-1);
    },
    onNextYear: () => {
      m(1);
    },
    onPrevMonth: () => {
      v(-1);
    },
    onNextMonth: () => {
      v(1);
    },
    onMonthClick: () => {
      d("month", c);
    },
    onYearClick: () => {
      d("year", c);
    }
  }), null), $(NS, Q(Q({}, t), {}, {
    onSelect: (h) => f(h, "mouse"),
    prefixCls: n,
    value: s,
    viewDate: c,
    rowCount: URe
  }), null)]);
}
Nh.displayName = "DatePanel";
Nh.inheritAttrs = !1;
const x6 = zRe("date", "time");
function uT(e) {
  const t = Vo(e), {
    prefixCls: n,
    operationRef: o,
    generateConfig: l,
    value: r,
    defaultValue: a,
    disabledTime: i,
    showTime: s,
    onSelect: c
  } = t, u = `${n}-datetime-panel`, d = /* @__PURE__ */ H(null), f = /* @__PURE__ */ H({}), p = /* @__PURE__ */ H({}), m = typeof s == "object" ? _({}, s) : {};
  function v(b) {
    const C = x6.indexOf(d.value) + b;
    return x6[C] || null;
  }
  const h = (b) => {
    p.value.onBlur && p.value.onBlur(b), d.value = null;
  };
  o.value = {
    onKeydown: (b) => {
      if (b.which === ot.TAB) {
        const C = v(b.shiftKey ? -1 : 1);
        return d.value = C, C && b.preventDefault(), !0;
      }
      if (d.value) {
        const C = d.value === "date" ? f : p;
        return C.value && C.value.onKeydown && C.value.onKeydown(b), !0;
      }
      return [ot.LEFT, ot.RIGHT, ot.UP, ot.DOWN].includes(b.which) ? (d.value = "date", !0) : !1;
    },
    onBlur: h,
    onClose: h
  };
  const g = (b, C) => {
    let w = b;
    C === "date" && !r && m.defaultValue ? (w = l.setHour(w, l.getHour(m.defaultValue)), w = l.setMinute(w, l.getMinute(m.defaultValue)), w = l.setSecond(w, l.getSecond(m.defaultValue))) : C === "time" && !r && a && (w = l.setYear(w, l.getYear(a)), w = l.setMonth(w, l.getMonth(a)), w = l.setDate(w, l.getDate(a))), c && c(w, "mouse");
  }, y = i ? i(r || null) : {};
  return $("div", {
    class: ke(u, {
      [`${u}-active`]: d.value
    })
  }, [$(Nh, Q(Q({}, t), {}, {
    operationRef: f,
    active: d.value === "date",
    onSelect: (b) => {
      g(Nb(l, b, !r && typeof s == "object" ? s.defaultValue : null), "date");
    }
  }), null), $(PS, Q(Q(Q(Q({}, t), {}, {
    format: void 0
  }, m), y), {}, {
    disabledTime: null,
    defaultValue: void 0,
    operationRef: p,
    active: d.value === "time",
    onSelect: (b) => {
      g(b, "time");
    }
  }), null)]);
}
uT.displayName = "DatetimePanel";
uT.inheritAttrs = !1;
function dT(e) {
  const t = Vo(e), {
    prefixCls: n,
    generateConfig: o,
    locale: l,
    value: r
  } = t, a = `${n}-cell`, i = (u) => $("td", {
    key: "week",
    class: ke(a, `${a}-week`)
  }, [o.locale.getWeek(l.locale, u)]), s = `${n}-week-panel-row`, c = (u) => ke(s, {
    [`${s}-selected`]: wW(o, l.locale, r, u)
  });
  return $(Nh, Q(Q({}, t), {}, {
    panelName: "week",
    prefixColumn: i,
    rowClassName: c,
    keyboardConfig: {
      onLeftRight: null
    }
  }), null);
}
dT.displayName = "WeekPanel";
dT.inheritAttrs = !1;
function fT(e) {
  const t = Vo(e), {
    prefixCls: n,
    generateConfig: o,
    locale: l,
    viewDate: r,
    onNextYear: a,
    onPrevYear: i,
    onYearClick: s
  } = t, {
    hideHeader: c
  } = Ri();
  if (c.value)
    return null;
  const u = `${n}-header`;
  return $(Lc, Q(Q({}, t), {}, {
    prefixCls: u,
    onSuperPrev: i,
    onSuperNext: a
  }), {
    default: () => [$("button", {
      type: "button",
      onClick: s,
      class: `${n}-year-btn`
    }, [yl(r, {
      locale: l,
      format: l.yearFormat,
      generateConfig: o
    })])]
  });
}
fT.displayName = "MonthHeader";
fT.inheritAttrs = !1;
const IW = 3, GRe = 4;
function pT(e) {
  const t = Vo(e), {
    prefixCls: n,
    locale: o,
    value: l,
    viewDate: r,
    generateConfig: a,
    monthCellRender: i
  } = t, {
    rangedValue: s,
    hoverRangedValue: c
  } = kh(), u = `${n}-cell`, d = kS({
    cellPrefixCls: u,
    value: l,
    generateConfig: a,
    rangedValue: s.value,
    hoverRangedValue: c.value,
    isSameCell: (v, h) => iT(a, v, h),
    isInView: () => !0,
    offsetCell: (v, h) => a.addMonth(v, h)
  }), f = o.shortMonths || (a.locale.getShortMonths ? a.locale.getShortMonths(o.locale) : []), p = a.setMonth(r, 0), m = i ? (v) => i({
    current: v,
    locale: o
  }) : void 0;
  return $(vd, Q(Q({}, t), {}, {
    rowNum: GRe,
    colNum: IW,
    baseDate: p,
    getCellNode: m,
    getCellText: (v) => o.monthFormat ? yl(v, {
      locale: o,
      format: o.monthFormat,
      generateConfig: a
    }) : f[a.getMonth(v)],
    getCellClassName: d,
    getCellDate: a.addMonth,
    titleCell: (v) => yl(v, {
      locale: o,
      format: "YYYY-MM",
      generateConfig: a
    })
  }), null);
}
pT.displayName = "MonthBody";
pT.inheritAttrs = !1;
function vT(e) {
  const t = Vo(e), {
    prefixCls: n,
    operationRef: o,
    onViewDateChange: l,
    generateConfig: r,
    value: a,
    viewDate: i,
    onPanelChange: s,
    onSelect: c
  } = t, u = `${n}-month-panel`;
  o.value = {
    onKeydown: (f) => Lp(f, {
      onLeftRight: (p) => {
        c(r.addMonth(a || i, p), "key");
      },
      onCtrlLeftRight: (p) => {
        c(r.addYear(a || i, p), "key");
      },
      onUpDown: (p) => {
        c(r.addMonth(a || i, p * IW), "key");
      },
      onEnter: () => {
        s("date", a || i);
      }
    })
  };
  const d = (f) => {
    const p = r.addYear(i, f);
    l(p), s(null, p);
  };
  return $("div", {
    class: u
  }, [$(fT, Q(Q({}, t), {}, {
    prefixCls: n,
    onPrevYear: () => {
      d(-1);
    },
    onNextYear: () => {
      d(1);
    },
    onYearClick: () => {
      s("year", i);
    }
  }), null), $(pT, Q(Q({}, t), {}, {
    prefixCls: n,
    onSelect: (f) => {
      c(f, "mouse"), s("date", f);
    }
  }), null)]);
}
vT.displayName = "MonthPanel";
vT.inheritAttrs = !1;
function mT(e) {
  const t = Vo(e), {
    prefixCls: n,
    generateConfig: o,
    locale: l,
    viewDate: r,
    onNextYear: a,
    onPrevYear: i,
    onYearClick: s
  } = t, {
    hideHeader: c
  } = Ri();
  if (c.value)
    return null;
  const u = `${n}-header`;
  return $(Lc, Q(Q({}, t), {}, {
    prefixCls: u,
    onSuperPrev: i,
    onSuperNext: a
  }), {
    default: () => [$("button", {
      type: "button",
      onClick: s,
      class: `${n}-year-btn`
    }, [yl(r, {
      locale: l,
      format: l.yearFormat,
      generateConfig: o
    })])]
  });
}
mT.displayName = "QuarterHeader";
mT.inheritAttrs = !1;
const YRe = 4, XRe = 1;
function hT(e) {
  const t = Vo(e), {
    prefixCls: n,
    locale: o,
    value: l,
    viewDate: r,
    generateConfig: a
  } = t, {
    rangedValue: i,
    hoverRangedValue: s
  } = kh(), c = `${n}-cell`, u = kS({
    cellPrefixCls: c,
    value: l,
    generateConfig: a,
    rangedValue: i.value,
    hoverRangedValue: s.value,
    isSameCell: (f, p) => CW(a, f, p),
    isInView: () => !0,
    offsetCell: (f, p) => a.addMonth(f, p * 3)
  }), d = a.setDate(a.setMonth(r, 0), 1);
  return $(vd, Q(Q({}, t), {}, {
    rowNum: XRe,
    colNum: YRe,
    baseDate: d,
    getCellText: (f) => yl(f, {
      locale: o,
      format: o.quarterFormat || "[Q]Q",
      generateConfig: a
    }),
    getCellClassName: u,
    getCellDate: (f, p) => a.addMonth(f, p * 3),
    titleCell: (f) => yl(f, {
      locale: o,
      format: "YYYY-[Q]Q",
      generateConfig: a
    })
  }), null);
}
hT.displayName = "QuarterBody";
hT.inheritAttrs = !1;
function gT(e) {
  const t = Vo(e), {
    prefixCls: n,
    operationRef: o,
    onViewDateChange: l,
    generateConfig: r,
    value: a,
    viewDate: i,
    onPanelChange: s,
    onSelect: c
  } = t, u = `${n}-quarter-panel`;
  o.value = {
    onKeydown: (f) => Lp(f, {
      onLeftRight: (p) => {
        c(r.addMonth(a || i, p * 3), "key");
      },
      onCtrlLeftRight: (p) => {
        c(r.addYear(a || i, p), "key");
      },
      onUpDown: (p) => {
        c(r.addYear(a || i, p), "key");
      }
    })
  };
  const d = (f) => {
    const p = r.addYear(i, f);
    l(p), s(null, p);
  };
  return $("div", {
    class: u
  }, [$(mT, Q(Q({}, t), {}, {
    prefixCls: n,
    onPrevYear: () => {
      d(-1);
    },
    onNextYear: () => {
      d(1);
    },
    onYearClick: () => {
      s("year", i);
    }
  }), null), $(hT, Q(Q({}, t), {}, {
    prefixCls: n,
    onSelect: (f) => {
      c(f, "mouse");
    }
  }), null)]);
}
gT.displayName = "QuarterPanel";
gT.inheritAttrs = !1;
function bT(e) {
  const t = Vo(e), {
    prefixCls: n,
    generateConfig: o,
    viewDate: l,
    onPrevDecade: r,
    onNextDecade: a,
    onDecadeClick: i
  } = t, {
    hideHeader: s
  } = Ri();
  if (s.value)
    return null;
  const c = `${n}-header`, u = o.getYear(l), d = Math.floor(u / rc) * rc, f = d + rc - 1;
  return $(Lc, Q(Q({}, t), {}, {
    prefixCls: c,
    onSuperPrev: r,
    onSuperNext: a
  }), {
    default: () => [$("button", {
      type: "button",
      onClick: i,
      class: `${n}-decade-btn`
    }, [d, Ft("-"), f])]
  });
}
bT.displayName = "YearHeader";
bT.inheritAttrs = !1;
const R2 = 3, E6 = 4;
function yT(e) {
  const t = Vo(e), {
    prefixCls: n,
    value: o,
    viewDate: l,
    locale: r,
    generateConfig: a
  } = t, {
    rangedValue: i,
    hoverRangedValue: s
  } = kh(), c = `${n}-cell`, u = a.getYear(l), d = Math.floor(u / rc) * rc, f = d + rc - 1, p = a.setYear(l, d - Math.ceil((R2 * E6 - rc) / 2)), m = (h) => {
    const g = a.getYear(h);
    return d <= g && g <= f;
  }, v = kS({
    cellPrefixCls: c,
    value: o,
    generateConfig: a,
    rangedValue: i.value,
    hoverRangedValue: s.value,
    isSameCell: (h, g) => TS(a, h, g),
    isInView: m,
    offsetCell: (h, g) => a.addYear(h, g)
  });
  return $(vd, Q(Q({}, t), {}, {
    rowNum: E6,
    colNum: R2,
    baseDate: p,
    getCellText: a.getYear,
    getCellClassName: v,
    getCellDate: a.addYear,
    titleCell: (h) => yl(h, {
      locale: r,
      format: "YYYY",
      generateConfig: a
    })
  }), null);
}
yT.displayName = "YearBody";
yT.inheritAttrs = !1;
const rc = 10;
function ST(e) {
  const t = Vo(e), {
    prefixCls: n,
    operationRef: o,
    onViewDateChange: l,
    generateConfig: r,
    value: a,
    viewDate: i,
    sourceMode: s,
    onSelect: c,
    onPanelChange: u
  } = t, d = `${n}-year-panel`;
  o.value = {
    onKeydown: (p) => Lp(p, {
      onLeftRight: (m) => {
        c(r.addYear(a || i, m), "key");
      },
      onCtrlLeftRight: (m) => {
        c(r.addYear(a || i, m * rc), "key");
      },
      onUpDown: (m) => {
        c(r.addYear(a || i, m * R2), "key");
      },
      onEnter: () => {
        u(s === "date" ? "date" : "month", a || i);
      }
    })
  };
  const f = (p) => {
    const m = r.addYear(i, p * 10);
    l(m), u(null, m);
  };
  return $("div", {
    class: d
  }, [$(bT, Q(Q({}, t), {}, {
    prefixCls: n,
    onPrevDecade: () => {
      f(-1);
    },
    onNextDecade: () => {
      f(1);
    },
    onDecadeClick: () => {
      u("decade", i);
    }
  }), null), $(yT, Q(Q({}, t), {}, {
    prefixCls: n,
    onSelect: (p) => {
      u(s === "date" ? "date" : "month", p), c(p, "mouse");
    }
  }), null)]);
}
ST.displayName = "YearPanel";
ST.inheritAttrs = !1;
function TW(e, t, n) {
  return n ? $("div", {
    class: `${e}-footer-extra`
  }, [n(t)]) : null;
}
function PW(e) {
  let {
    prefixCls: t,
    components: n = {},
    needConfirmButton: o,
    onNow: l,
    onOk: r,
    okDisabled: a,
    showNow: i,
    locale: s
  } = e, c, u;
  if (o) {
    const d = n.button || "button";
    l && i !== !1 && (c = $("li", {
      class: `${t}-now`
    }, [$("a", {
      class: `${t}-now-btn`,
      onClick: l
    }, [s.now])])), u = o && $("li", {
      class: `${t}-ok`
    }, [$(d, {
      disabled: a,
      onClick: (f) => {
        f.stopPropagation(), r && r();
      }
    }, {
      default: () => [s.ok]
    })]);
  }
  return !c && !u ? null : $("ul", {
    class: `${t}-ranges`
  }, [c, u]);
}
function qRe() {
  return /* @__PURE__ */ le({
    name: "PickerPanel",
    inheritAttrs: !1,
    props: {
      prefixCls: String,
      locale: Object,
      generateConfig: Object,
      value: Object,
      defaultValue: Object,
      pickerValue: Object,
      defaultPickerValue: Object,
      disabledDate: Function,
      mode: String,
      picker: {
        type: String,
        default: "date"
      },
      tabindex: {
        type: [Number, String],
        default: 0
      },
      showNow: {
        type: Boolean,
        default: void 0
      },
      showTime: [Boolean, Object],
      showToday: Boolean,
      renderExtraFooter: Function,
      dateRender: Function,
      hideHeader: {
        type: Boolean,
        default: void 0
      },
      onSelect: Function,
      onChange: Function,
      onPanelChange: Function,
      onMousedown: Function,
      onPickerValueChange: Function,
      onOk: Function,
      components: Object,
      direction: String,
      hourStep: {
        type: Number,
        default: 1
      },
      minuteStep: {
        type: Number,
        default: 1
      },
      secondStep: {
        type: Number,
        default: 1
      }
    },
    setup(e, t) {
      let {
        attrs: n
      } = t;
      const o = O(() => e.picker === "date" && !!e.showTime || e.picker === "time"), l = O(() => 24 % e.hourStep === 0), r = O(() => 60 % e.minuteStep === 0), a = O(() => 60 % e.secondStep === 0);
      process.env.NODE_ENV !== "production" && Ot(() => {
        const {
          generateConfig: M,
          value: A,
          hourStep: L = 1,
          minuteStep: B = 1,
          secondStep: V = 1
        } = e;
        bn(!A || M.isValidate(A), "Invalidate date pass to `value`."), bn(!A || M.isValidate(A), "Invalidate date pass to `defaultValue`."), bn(l.value, `\`hourStep\` ${L} is invalid. It should be a factor of 24.`), bn(r.value, `\`minuteStep\` ${B} is invalid. It should be a factor of 60.`), bn(a.value, `\`secondStep\` ${V} is invalid. It should be a factor of 60.`);
      });
      const i = Ri(), {
        operationRef: s,
        onSelect: c,
        hideRanges: u,
        defaultOpenValue: d
      } = i, {
        inRange: f,
        panelPosition: p,
        rangedValue: m,
        hoverRangedValue: v
      } = kh(), h = /* @__PURE__ */ H({}), [g, y] = ro(null, {
        value: /* @__PURE__ */ ft(e, "value"),
        defaultValue: e.defaultValue,
        postState: (M) => !M && (d != null && d.value) && e.picker === "time" ? d.value : M
      }), [b, C] = ro(null, {
        value: /* @__PURE__ */ ft(e, "pickerValue"),
        defaultValue: e.defaultPickerValue || g.value,
        postState: (M) => {
          const {
            generateConfig: A,
            showTime: L,
            defaultValue: B
          } = e, V = A.getNow();
          return M ? !g.value && e.showTime ? typeof L == "object" ? Nb(A, Array.isArray(M) ? M[0] : M, L.defaultValue || V) : B ? Nb(A, Array.isArray(M) ? M[0] : M, B) : Nb(A, Array.isArray(M) ? M[0] : M, V) : M : V;
        }
      }), w = (M) => {
        C(M), e.onPickerValueChange && e.onPickerValueChange(M);
      }, x = (M) => {
        const A = LRe[e.picker];
        return A ? A(M) : M;
      }, [E, I] = ro(() => e.picker === "time" ? "time" : x("date"), {
        value: /* @__PURE__ */ ft(e, "mode")
      });
      pe(() => e.picker, () => {
        I(e.picker);
      });
      const T = /* @__PURE__ */ H(E.value), P = (M) => {
        T.value = M;
      }, k = (M, A) => {
        const {
          onPanelChange: L,
          generateConfig: B
        } = e, V = x(M || E.value);
        P(E.value), I(V), L && (E.value !== V || $f(B, b.value, b.value)) && L(A, V);
      }, N = function(M, A) {
        let L = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        const {
          picker: B,
          generateConfig: V,
          onSelect: j,
          onChange: W,
          disabledDate: Y
        } = e;
        (E.value === B || L) && (y(M), j && j(M), c && c(M, A), W && !$f(V, M, g.value) && !(Y != null && Y(M)) && W(M));
      }, R = (M) => h.value && h.value.onKeydown ? ([ot.LEFT, ot.RIGHT, ot.UP, ot.DOWN, ot.PAGE_UP, ot.PAGE_DOWN, ot.ENTER].includes(M.which) && M.preventDefault(), h.value.onKeydown(M)) : (bn(!1, "Panel not correct handle keyDown event. Please help to fire issue about this."), !1), z = (M) => {
        h.value && h.value.onBlur && h.value.onBlur(M);
      }, D = () => {
        const {
          generateConfig: M,
          hourStep: A,
          minuteStep: L,
          secondStep: B
        } = e, V = M.getNow(), j = IRe(M.getHour(V), M.getMinute(V), M.getSecond(V), l.value ? A : 1, r.value ? L : 1, a.value ? B : 1), W = gW(
          M,
          V,
          j[0],
          // hour
          j[1],
          // minute
          j[2]
        );
        N(W, "submit");
      }, F = O(() => {
        const {
          prefixCls: M,
          direction: A
        } = e;
        return ke(`${M}-panel`, {
          [`${M}-panel-has-range`]: m && m.value && m.value[0] && m.value[1],
          [`${M}-panel-has-range-hover`]: v && v.value && v.value[0] && v.value[1],
          [`${M}-panel-rtl`]: A === "rtl"
        });
      });
      return oT(_(_({}, i), {
        mode: E,
        hideHeader: O(() => {
          var M;
          return e.hideHeader !== void 0 ? e.hideHeader : (M = i.hideHeader) === null || M === void 0 ? void 0 : M.value;
        }),
        hidePrevBtn: O(() => f.value && p.value === "right"),
        hideNextBtn: O(() => f.value && p.value === "left")
      })), pe(() => e.value, () => {
        e.value && C(e.value);
      }), () => {
        const {
          prefixCls: M = "ant-picker",
          locale: A,
          generateConfig: L,
          disabledDate: B,
          picker: V = "date",
          tabindex: j = 0,
          showNow: W,
          showTime: Y,
          showToday: U,
          renderExtraFooter: te,
          onMousedown: J,
          onOk: re,
          components: oe
        } = e;
        s && p.value !== "right" && (s.value = {
          onKeydown: R,
          onClose: () => {
            h.value && h.value.onClose && h.value.onClose();
          }
        });
        let q;
        const K = _(_(_({}, n), e), {
          operationRef: h,
          prefixCls: M,
          viewDate: b.value,
          value: g.value,
          onViewDateChange: w,
          sourceMode: T.value,
          onPanelChange: k,
          disabledDate: B
        });
        switch (delete K.onChange, delete K.onSelect, E.value) {
          case "decade":
            q = $(aT, Q(Q({}, K), {}, {
              onSelect: (fe, me) => {
                w(fe), N(fe, me);
              }
            }), null);
            break;
          case "year":
            q = $(ST, Q(Q({}, K), {}, {
              onSelect: (fe, me) => {
                w(fe), N(fe, me);
              }
            }), null);
            break;
          case "month":
            q = $(vT, Q(Q({}, K), {}, {
              onSelect: (fe, me) => {
                w(fe), N(fe, me);
              }
            }), null);
            break;
          case "quarter":
            q = $(gT, Q(Q({}, K), {}, {
              onSelect: (fe, me) => {
                w(fe), N(fe, me);
              }
            }), null);
            break;
          case "week":
            q = $(dT, Q(Q({}, K), {}, {
              onSelect: (fe, me) => {
                w(fe), N(fe, me);
              }
            }), null);
            break;
          case "time":
            delete K.showTime, q = $(PS, Q(Q(Q({}, K), typeof Y == "object" ? Y : null), {}, {
              onSelect: (fe, me) => {
                w(fe), N(fe, me);
              }
            }), null);
            break;
          default:
            Y ? q = $(uT, Q(Q({}, K), {}, {
              onSelect: (fe, me) => {
                w(fe), N(fe, me);
              }
            }), null) : q = $(Nh, Q(Q({}, K), {}, {
              onSelect: (fe, me) => {
                w(fe), N(fe, me);
              }
            }), null);
        }
        let se, Z;
        u != null && u.value || (se = TW(M, E.value, te), Z = PW({
          prefixCls: M,
          components: oe,
          needConfirmButton: o.value,
          okDisabled: !g.value || B && B(g.value),
          locale: A,
          showNow: W,
          onNow: o.value && D,
          onOk: () => {
            g.value && (N(g.value, "submit", !0), re && re(g.value));
          }
        }));
        let ee;
        if (U && E.value === "date" && V === "date" && !Y) {
          const fe = L.getNow(), me = `${M}-today-btn`, ge = B && B(fe);
          ee = $("a", {
            class: ke(me, ge && `${me}-disabled`),
            "aria-disabled": ge,
            onClick: () => {
              ge || N(fe, "mouse", !0);
            }
          }, [A.today]);
        }
        return $("div", {
          tabindex: j,
          class: ke(F.value, n.class),
          style: n.style,
          onKeydown: R,
          onBlur: z,
          onMousedown: J
        }, [q, se || Z || ee ? $("div", {
          class: `${M}-footer`
        }, [se, Z, ee]) : null]);
      };
    }
  });
}
const JRe = qRe(), CT = (e) => $(JRe, e), ZRe = {
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
function kW(e, t) {
  let {
    slots: n
  } = t;
  const {
    prefixCls: o,
    popupStyle: l,
    visible: r,
    dropdownClassName: a,
    dropdownAlign: i,
    transitionName: s,
    getPopupContainer: c,
    range: u,
    popupPlacement: d,
    direction: f
  } = Vo(e), p = `${o}-dropdown`;
  return $(fd, {
    showAction: [],
    hideAction: [],
    popupPlacement: d !== void 0 ? d : f === "rtl" ? "bottomRight" : "bottomLeft",
    builtinPlacements: ZRe,
    prefixCls: p,
    popupTransitionName: s,
    popupAlign: i,
    popupVisible: r,
    popupClassName: ke(a, {
      [`${p}-range`]: u,
      [`${p}-rtl`]: f === "rtl"
    }),
    popupStyle: l,
    getPopupContainer: c
  }, {
    default: n.default,
    popup: n.popupElement
  });
}
const NW = /* @__PURE__ */ le({
  name: "PresetPanel",
  props: {
    prefixCls: String,
    presets: {
      type: Array,
      default: () => []
    },
    onClick: Function,
    onHover: Function
  },
  setup(e) {
    return () => e.presets.length ? $("div", {
      class: `${e.prefixCls}-presets`
    }, [$("ul", null, [e.presets.map((t, n) => {
      let {
        label: o,
        value: l
      } = t;
      return $("li", {
        key: n,
        onClick: (r) => {
          r.stopPropagation(), e.onClick(l);
        },
        onMouseenter: () => {
          var r;
          (r = e.onHover) === null || r === void 0 || r.call(e, l);
        },
        onMouseleave: () => {
          var r;
          (r = e.onHover) === null || r === void 0 || r.call(e, null);
        }
      }, [o]);
    })])]) : null;
  }
});
function D2(e) {
  let {
    open: t,
    value: n,
    isClickOutside: o,
    triggerOpen: l,
    forwardKeydown: r,
    onKeydown: a,
    blurToCancel: i,
    onSubmit: s,
    onCancel: c,
    onFocus: u,
    onBlur: d
  } = e;
  const f = /* @__PURE__ */ Ce(!1), p = /* @__PURE__ */ Ce(!1), m = /* @__PURE__ */ Ce(!1), v = /* @__PURE__ */ Ce(!1), h = /* @__PURE__ */ Ce(!1), g = O(() => ({
    onMousedown: () => {
      f.value = !0, l(!0);
    },
    onKeydown: (b) => {
      if (a(b, () => {
        h.value = !0;
      }), !h.value) {
        switch (b.which) {
          case ot.ENTER: {
            t.value ? s() !== !1 && (f.value = !0) : l(!0), b.preventDefault();
            return;
          }
          case ot.TAB: {
            f.value && t.value && !b.shiftKey ? (f.value = !1, b.preventDefault()) : !f.value && t.value && !r(b) && b.shiftKey && (f.value = !0, b.preventDefault());
            return;
          }
          case ot.ESC: {
            f.value = !0, c();
            return;
          }
        }
        !t.value && ![ot.SHIFT].includes(b.which) ? l(!0) : f.value || r(b);
      }
    },
    onFocus: (b) => {
      f.value = !0, p.value = !0, u && u(b);
    },
    onBlur: (b) => {
      if (m.value || !o(document.activeElement)) {
        m.value = !1;
        return;
      }
      i.value ? setTimeout(() => {
        let {
          activeElement: C
        } = document;
        for (; C && C.shadowRoot; )
          C = C.shadowRoot.activeElement;
        o(C) && c();
      }, 0) : t.value && (l(!1), v.value && s()), p.value = !1, d && d(b);
    }
  }));
  pe(t, () => {
    v.value = !1;
  }), pe(n, () => {
    v.value = !0;
  });
  const y = /* @__PURE__ */ Ce();
  return nt(() => {
    y.value = kRe((b) => {
      const C = NRe(b);
      if (t.value) {
        const w = o(C);
        w ? (!p.value || w) && l(!1) : (m.value = !0, rn(() => {
          m.value = !1;
        }));
      }
    });
  }), yt(() => {
    y.value && y.value();
  }), [g, {
    focused: p,
    typing: f
  }];
}
function L2(e) {
  let {
    valueTexts: t,
    onTextChange: n
  } = e;
  const o = /* @__PURE__ */ H("");
  function l(a) {
    o.value = a, n(a);
  }
  function r() {
    o.value = t.value[0];
  }
  return pe(() => [...t.value], function(a) {
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    a.join("||") !== i.join("||") && t.value.every((s) => s !== o.value) && r();
  }, {
    immediate: !0
  }), [o, l, r];
}
function Iy(e, t) {
  let {
    formatList: n,
    generateConfig: o,
    locale: l
  } = t;
  const r = PI(() => {
    if (!e.value)
      return [[""], ""];
    let s = "";
    const c = [];
    for (let u = 0; u < n.value.length; u += 1) {
      const d = n.value[u], f = yl(e.value, {
        generateConfig: o.value,
        locale: l.value,
        format: d
      });
      c.push(f), u === 0 && (s = f);
    }
    return [c, s];
  }, [e, n], (s, c) => c[0] !== s[0] || !Wd(c[1], s[1])), a = O(() => r.value[0]), i = O(() => r.value[1]);
  return [a, i];
}
function B2(e, t) {
  let {
    formatList: n,
    generateConfig: o,
    locale: l
  } = t;
  const r = /* @__PURE__ */ H(null);
  let a;
  function i(d) {
    let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (rn.cancel(a), f) {
      r.value = d;
      return;
    }
    a = rn(() => {
      r.value = d;
    });
  }
  const [, s] = Iy(r, {
    formatList: n,
    generateConfig: o,
    locale: l
  });
  function c(d) {
    i(d);
  }
  function u() {
    let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    i(null, d);
  }
  return pe(e, () => {
    u(!0);
  }), yt(() => {
    rn.cancel(a);
  }), [s, c, u];
}
function MW(e, t) {
  return O(() => e != null && e.value ? e.value : t != null && t.value ? (pr(!1, "`ranges` is deprecated. Please use `presets` instead."), Object.keys(t.value).map((o) => {
    const l = t.value[o], r = typeof l == "function" ? l() : l;
    return {
      label: o,
      value: r
    };
  })) : []);
}
function AW(e) {
  const {
    picker: t,
    disabledHours: n,
    disabledMinutes: o,
    disabledSeconds: l
  } = e;
  t === "time" && (n || o || l) && bn(!1, "'disabledHours', 'disabledMinutes', 'disabledSeconds' will be removed in the next major version, please use 'disabledTime' instead.");
}
function QRe() {
  return /* @__PURE__ */ le({
    name: "Picker",
    inheritAttrs: !1,
    props: ["prefixCls", "id", "tabindex", "dropdownClassName", "dropdownAlign", "popupStyle", "transitionName", "generateConfig", "locale", "inputReadOnly", "allowClear", "autofocus", "showTime", "showNow", "showHour", "showMinute", "showSecond", "picker", "format", "use12Hours", "value", "defaultValue", "open", "defaultOpen", "defaultOpenValue", "suffixIcon", "presets", "clearIcon", "disabled", "disabledDate", "placeholder", "getPopupContainer", "panelRender", "inputRender", "onChange", "onOpenChange", "onPanelChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onContextmenu", "onClick", "onKeydown", "onSelect", "direction", "autocomplete", "showToday", "renderExtraFooter", "dateRender", "minuteStep", "hourStep", "secondStep", "hideDisabledOptions"],
    setup(e, t) {
      let {
        attrs: n,
        expose: o
      } = t;
      const l = /* @__PURE__ */ H(null), r = O(() => e.presets), a = MW(r), i = O(() => {
        var B;
        return (B = e.picker) !== null && B !== void 0 ? B : "date";
      }), s = O(() => i.value === "date" && !!e.showTime || i.value === "time");
      process.env.NODE_ENV !== "production" && AW(e);
      const c = O(() => EW(bW(e.format, i.value, e.showTime, e.use12Hours))), u = /* @__PURE__ */ H(null), d = /* @__PURE__ */ H(null), f = /* @__PURE__ */ H(null), [p, m] = ro(null, {
        value: /* @__PURE__ */ ft(e, "value"),
        defaultValue: e.defaultValue
      }), v = /* @__PURE__ */ H(p.value), h = (B) => {
        v.value = B;
      }, g = /* @__PURE__ */ H(null), [y, b] = ro(!1, {
        value: /* @__PURE__ */ ft(e, "open"),
        defaultValue: e.defaultOpen,
        postState: (B) => e.disabled ? !1 : B,
        onChange: (B) => {
          e.onOpenChange && e.onOpenChange(B), !B && g.value && g.value.onClose && g.value.onClose();
        }
      }), [C, w] = Iy(v, {
        formatList: c,
        generateConfig: /* @__PURE__ */ ft(e, "generateConfig"),
        locale: /* @__PURE__ */ ft(e, "locale")
      }), [x, E, I] = L2({
        valueTexts: C,
        onTextChange: (B) => {
          const V = $W(B, {
            locale: e.locale,
            formatList: c.value,
            generateConfig: e.generateConfig
          });
          V && (!e.disabledDate || !e.disabledDate(V)) && h(V);
        }
      }), T = (B) => {
        const {
          onChange: V,
          generateConfig: j,
          locale: W
        } = e;
        h(B), m(B), V && !$f(j, p.value, B) && V(B, B ? yl(B, {
          generateConfig: j,
          locale: W,
          format: c.value[0]
        }) : "");
      }, P = (B) => {
        e.disabled && B || b(B);
      }, k = (B) => y.value && g.value && g.value.onKeydown ? g.value.onKeydown(B) : (bn(!1, "Picker not correct forward Keydown operation. Please help to fire issue about this."), !1), N = function() {
        e.onMouseup && e.onMouseup(...arguments), l.value && (l.value.focus(), P(!0));
      }, [R, {
        focused: z,
        typing: D
      }] = D2({
        blurToCancel: s,
        open: y,
        value: x,
        triggerOpen: P,
        forwardKeydown: k,
        isClickOutside: (B) => !SW([u.value, d.value, f.value], B),
        onSubmit: () => (
          // When user typing disabledDate with keyboard and enter, this value will be empty
          !v.value || // Normal disabled check
          e.disabledDate && e.disabledDate(v.value) ? !1 : (T(v.value), P(!1), I(), !0)
        ),
        onCancel: () => {
          P(!1), h(p.value), I();
        },
        onKeydown: (B, V) => {
          var j;
          (j = e.onKeydown) === null || j === void 0 || j.call(e, B, V);
        },
        onFocus: (B) => {
          var V;
          (V = e.onFocus) === null || V === void 0 || V.call(e, B);
        },
        onBlur: (B) => {
          var V;
          (V = e.onBlur) === null || V === void 0 || V.call(e, B);
        }
      });
      pe([y, C], () => {
        y.value || (h(p.value), !C.value.length || C.value[0] === "" ? E("") : w.value !== x.value && I());
      }), pe(i, () => {
        y.value || I();
      }), pe(p, () => {
        h(p.value);
      });
      const [F, M, A] = B2(x, {
        formatList: c,
        generateConfig: /* @__PURE__ */ ft(e, "generateConfig"),
        locale: /* @__PURE__ */ ft(e, "locale")
      }), L = (B, V) => {
        (V === "submit" || V !== "key" && !s.value) && (T(B), P(!1));
      };
      return oT({
        operationRef: g,
        hideHeader: O(() => i.value === "time"),
        onSelect: L,
        open: y,
        defaultOpenValue: /* @__PURE__ */ ft(e, "defaultOpenValue"),
        onDateMouseenter: M,
        onDateMouseleave: A
      }), o({
        focus: () => {
          l.value && l.value.focus();
        },
        blur: () => {
          l.value && l.value.blur();
        }
      }), () => {
        const {
          prefixCls: B = "rc-picker",
          id: V,
          tabindex: j,
          dropdownClassName: W,
          dropdownAlign: Y,
          popupStyle: U,
          transitionName: te,
          generateConfig: J,
          locale: re,
          inputReadOnly: oe,
          allowClear: q,
          autofocus: K,
          picker: se = "date",
          defaultOpenValue: Z,
          suffixIcon: ee,
          clearIcon: fe,
          disabled: me,
          placeholder: ge,
          getPopupContainer: he,
          panelRender: $e,
          onMousedown: ne,
          onMouseenter: ae,
          onMouseleave: ce,
          onContextmenu: xe,
          onClick: Te,
          onSelect: Se,
          direction: be,
          autocomplete: ie = "off"
        } = e, we = _(_(_({}, e), n), {
          class: ke({
            [`${B}-panel-focused`]: !D.value
          }),
          style: void 0,
          pickerValue: void 0,
          onPickerValueChange: void 0,
          onChange: null
        });
        let Ne = $("div", {
          class: `${B}-panel-layout`
        }, [$(NW, {
          prefixCls: B,
          presets: a.value,
          onClick: (De) => {
            T(De), P(!1);
          }
        }, null), $(CT, Q(Q({}, we), {}, {
          generateConfig: J,
          value: v.value,
          locale: re,
          tabindex: -1,
          onSelect: (De) => {
            Se == null || Se(De), h(De);
          },
          direction: be,
          onPanelChange: (De, _e) => {
            const {
              onPanelChange: Ze
            } = e;
            A(!0), Ze == null || Ze(De, _e);
          }
        }), null)]);
        $e && (Ne = $e(Ne));
        const tt = $("div", {
          class: `${B}-panel-container`,
          ref: u,
          onMousedown: (De) => {
            De.preventDefault();
          }
        }, [Ne]);
        let Pe;
        ee && (Pe = $("span", {
          class: `${B}-suffix`
        }, [ee]));
        let Re;
        q && p.value && !me && (Re = $("span", {
          onMousedown: (De) => {
            De.preventDefault(), De.stopPropagation();
          },
          onMouseup: (De) => {
            De.preventDefault(), De.stopPropagation(), T(null), P(!1);
          },
          class: `${B}-clear`,
          role: "button"
        }, [fe || $("span", {
          class: `${B}-clear-btn`
        }, null)]));
        const Le = _(_(_(_({
          id: V,
          tabindex: j,
          disabled: me,
          readonly: oe || typeof c.value[0] == "function" || !D.value,
          value: F.value || x.value,
          onInput: (De) => {
            E(De.target.value);
          },
          autofocus: K,
          placeholder: ge,
          ref: l,
          title: x.value
        }, R.value), {
          size: yW(se, c.value[0], J)
        }), OW(e)), {
          autocomplete: ie
        }), Ue = e.inputRender ? e.inputRender(Le) : $("input", Le, null);
        process.env.NODE_ENV !== "production" && bn(!Z, "`defaultOpenValue` may confuse user for the current value status. Please use `defaultValue` instead.");
        const Ae = be === "rtl" ? "bottomRight" : "bottomLeft";
        return $("div", {
          ref: f,
          class: ke(B, n.class, {
            [`${B}-disabled`]: me,
            [`${B}-focused`]: z.value,
            [`${B}-rtl`]: be === "rtl"
          }),
          style: n.style,
          onMousedown: ne,
          onMouseup: N,
          onMouseenter: ae,
          onMouseleave: ce,
          onContextmenu: xe,
          onClick: Te
        }, [$("div", {
          class: ke(`${B}-input`, {
            [`${B}-input-placeholder`]: !!F.value
          }),
          ref: d
        }, [Ue, Pe, Re]), $(kW, {
          visible: y.value,
          popupStyle: U,
          prefixCls: B,
          dropdownClassName: W,
          dropdownAlign: Y,
          getPopupContainer: he,
          transitionName: te,
          popupPlacement: Ae,
          direction: be
        }, {
          default: () => [$("div", {
            style: {
              pointerEvents: "none",
              position: "absolute",
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            }
          }, null)],
          popupElement: () => tt
        })]);
      };
    }
  });
}
const eDe = QRe();
function tDe(e, t) {
  let {
    picker: n,
    locale: o,
    selectedValue: l,
    disabledDate: r,
    disabled: a,
    generateConfig: i
  } = e;
  const s = O(() => An(l.value, 0)), c = O(() => An(l.value, 1));
  function u(v) {
    return i.value.locale.getWeekFirstDate(o.value.locale, v);
  }
  function d(v) {
    const h = i.value.getYear(v), g = i.value.getMonth(v);
    return h * 100 + g;
  }
  function f(v) {
    const h = i.value.getYear(v), g = M2(i.value, v);
    return h * 10 + g;
  }
  return [(v) => {
    var h;
    if (r && (!((h = r == null ? void 0 : r.value) === null || h === void 0) && h.call(r, v)))
      return !0;
    if (a[1] && c)
      return !is(i.value, v, c.value) && i.value.isAfter(v, c.value);
    if (t.value[1] && c.value)
      switch (n.value) {
        case "quarter":
          return f(v) > f(c.value);
        case "month":
          return d(v) > d(c.value);
        case "week":
          return u(v) > u(c.value);
        default:
          return !is(i.value, v, c.value) && i.value.isAfter(v, c.value);
      }
    return !1;
  }, (v) => {
    var h;
    if (!((h = r.value) === null || h === void 0) && h.call(r, v))
      return !0;
    if (a[0] && s)
      return !is(i.value, v, c.value) && i.value.isAfter(s.value, v);
    if (t.value[0] && s.value)
      switch (n.value) {
        case "quarter":
          return f(v) < f(s.value);
        case "month":
          return d(v) < d(s.value);
        case "week":
          return u(v) < u(s.value);
        default:
          return !is(i.value, v, s.value) && i.value.isAfter(s.value, v);
      }
    return !1;
  }];
}
function nDe(e, t, n, o) {
  const l = Bv(e, n, o, 1);
  function r(a) {
    return a(e, t) ? "same" : a(l, t) ? "closing" : "far";
  }
  switch (n) {
    case "year":
      return r((a, i) => BRe(o, a, i));
    case "quarter":
    case "month":
      return r((a, i) => TS(o, a, i));
    default:
      return r((a, i) => iT(o, a, i));
  }
}
function oDe(e, t, n, o) {
  const l = An(e, 0), r = An(e, 1);
  if (t === 0)
    return l;
  if (l && r)
    switch (nDe(l, r, n, o)) {
      case "same":
        return l;
      case "closing":
        return l;
      default:
        return Bv(r, n, o, -1);
    }
  return l;
}
function lDe(e) {
  let {
    values: t,
    picker: n,
    defaultDates: o,
    generateConfig: l
  } = e;
  const r = /* @__PURE__ */ H([An(o, 0), An(o, 1)]), a = /* @__PURE__ */ H(null), i = O(() => An(t.value, 0)), s = O(() => An(t.value, 1)), c = (p) => r.value[p] ? r.value[p] : An(a.value, p) || oDe(t.value, p, n.value, l.value) || i.value || s.value || l.value.getNow(), u = /* @__PURE__ */ H(null), d = /* @__PURE__ */ H(null);
  Ot(() => {
    u.value = c(0), d.value = c(1);
  });
  function f(p, m) {
    if (p) {
      let v = Gr(a.value, p, m);
      r.value = Gr(r.value, null, m) || [null, null];
      const h = (m + 1) % 2;
      An(t.value, h) || (v = Gr(v, p, h)), a.value = v;
    } else (i.value || s.value) && (a.value = null);
  }
  return [u, d, f];
}
function RW(e) {
  return NE() ? (ME(e), !0) : !1;
}
function rDe(e) {
  return typeof e == "function" ? e() : S(e);
}
function wT(e) {
  var t;
  const n = rDe(e);
  return (t = n == null ? void 0 : n.$el) !== null && t !== void 0 ? t : n;
}
function aDe(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  xt() ? nt(e) : t ? e() : Ke(e);
}
function DW(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const n = /* @__PURE__ */ Ce(), o = () => n.value = !!e();
  return o(), aDe(o, t), n;
}
var Nw;
const LW = typeof window != "undefined";
LW && (!((Nw = window == null ? void 0 : window.navigator) === null || Nw === void 0) && Nw.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
const BW = LW ? window : void 0;
var iDe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function sDe(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    window: o = BW
  } = n, l = iDe(n, ["window"]);
  let r;
  const a = DW(() => o && "ResizeObserver" in o), i = () => {
    r && (r.disconnect(), r = void 0);
  }, s = pe(() => wT(e), (u) => {
    i(), a.value && o && u && (r = new ResizeObserver(t), r.observe(u, l));
  }, {
    immediate: !0,
    flush: "post"
  }), c = () => {
    i(), s();
  };
  return RW(c), {
    isSupported: a,
    stop: c
  };
}
function iv(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    width: 0,
    height: 0
  }, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    box: o = "content-box"
  } = n, l = /* @__PURE__ */ Ce(t.width), r = /* @__PURE__ */ Ce(t.height);
  return sDe(e, (a) => {
    let [i] = a;
    const s = o === "border-box" ? i.borderBoxSize : o === "content-box" ? i.contentBoxSize : i.devicePixelContentBoxSize;
    s ? (l.value = s.reduce((c, u) => {
      let {
        inlineSize: d
      } = u;
      return c + d;
    }, 0), r.value = s.reduce((c, u) => {
      let {
        blockSize: d
      } = u;
      return c + d;
    }, 0)) : (l.value = i.contentRect.width, r.value = i.contentRect.height);
  }, n), pe(() => wT(e), (a) => {
    l.value = a ? t.width : 0, r.value = a ? t.height : 0;
  }), {
    width: l,
    height: r
  };
}
function O6(e, t) {
  return e && e[0] && e[1] && t.isAfter(e[0], e[1]) ? [e[1], e[0]] : e;
}
function _6(e, t, n, o) {
  return !!(e || o && o[t] || n[(t + 1) % 2]);
}
function cDe() {
  return /* @__PURE__ */ le({
    name: "RangerPicker",
    inheritAttrs: !1,
    props: ["prefixCls", "id", "popupStyle", "dropdownClassName", "transitionName", "dropdownAlign", "getPopupContainer", "generateConfig", "locale", "placeholder", "autofocus", "disabled", "format", "picker", "showTime", "showNow", "showHour", "showMinute", "showSecond", "use12Hours", "separator", "value", "defaultValue", "defaultPickerValue", "open", "defaultOpen", "disabledDate", "disabledTime", "dateRender", "panelRender", "ranges", "allowEmpty", "allowClear", "suffixIcon", "clearIcon", "pickerRef", "inputReadOnly", "mode", "renderExtraFooter", "onChange", "onOpenChange", "onPanelChange", "onCalendarChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onClick", "onOk", "onKeydown", "components", "order", "direction", "activePickerIndex", "autocomplete", "minuteStep", "hourStep", "secondStep", "hideDisabledOptions", "disabledMinutes", "presets", "prevIcon", "nextIcon", "superPrevIcon", "superNextIcon"],
    setup(e, t) {
      let {
        attrs: n,
        expose: o
      } = t;
      const l = O(() => e.picker === "date" && !!e.showTime || e.picker === "time"), r = O(() => e.presets), a = O(() => e.ranges), i = MW(r, a), s = /* @__PURE__ */ H({}), c = /* @__PURE__ */ H(null), u = /* @__PURE__ */ H(null), d = /* @__PURE__ */ H(null), f = /* @__PURE__ */ H(null), p = /* @__PURE__ */ H(null), m = /* @__PURE__ */ H(null), v = /* @__PURE__ */ H(null), h = /* @__PURE__ */ H(null);
      process.env.NODE_ENV !== "production" && AW(e);
      const g = O(() => EW(bW(e.format, e.picker, e.showTime, e.use12Hours))), [y, b] = ro(0, {
        value: /* @__PURE__ */ ft(e, "activePickerIndex")
      }), C = /* @__PURE__ */ H(null), w = O(() => {
        const {
          disabled: st
        } = e;
        return Array.isArray(st) ? st : [st || !1, st || !1];
      }), [x, E] = ro(null, {
        value: /* @__PURE__ */ ft(e, "value"),
        defaultValue: e.defaultValue,
        postState: (st) => e.picker === "time" && !e.order ? st : O6(st, e.generateConfig)
      }), [I, T, P] = lDe({
        values: x,
        picker: /* @__PURE__ */ ft(e, "picker"),
        defaultDates: e.defaultPickerValue,
        generateConfig: /* @__PURE__ */ ft(e, "generateConfig")
      }), [k, N] = ro(x.value, {
        postState: (st) => {
          let Yt = st;
          if (w.value[0] && w.value[1])
            return Yt;
          for (let Kt = 0; Kt < 2; Kt += 1)
            w.value[Kt] && !An(Yt, Kt) && !An(e.allowEmpty, Kt) && (Yt = Gr(Yt, e.generateConfig.getNow(), Kt));
          return Yt;
        }
      }), [R, z] = ro([e.picker, e.picker], {
        value: /* @__PURE__ */ ft(e, "mode")
      });
      pe(() => e.picker, () => {
        z([e.picker, e.picker]);
      });
      const D = (st, Yt) => {
        var Kt;
        z(st), (Kt = e.onPanelChange) === null || Kt === void 0 || Kt.call(e, Yt, st);
      }, [F, M] = tDe({
        picker: /* @__PURE__ */ ft(e, "picker"),
        selectedValue: k,
        locale: /* @__PURE__ */ ft(e, "locale"),
        disabled: w,
        disabledDate: /* @__PURE__ */ ft(e, "disabledDate"),
        generateConfig: /* @__PURE__ */ ft(e, "generateConfig")
      }, s), [A, L] = ro(!1, {
        value: /* @__PURE__ */ ft(e, "open"),
        defaultValue: e.defaultOpen,
        postState: (st) => w.value[y.value] ? !1 : st,
        onChange: (st) => {
          var Yt;
          (Yt = e.onOpenChange) === null || Yt === void 0 || Yt.call(e, st), !st && C.value && C.value.onClose && C.value.onClose();
        }
      }), B = O(() => A.value && y.value === 0), V = O(() => A.value && y.value === 1), j = /* @__PURE__ */ H(0), W = /* @__PURE__ */ H(0), Y = /* @__PURE__ */ H(0), {
        width: U
      } = iv(c);
      pe([A, U], () => {
        !A.value && c.value && (Y.value = U.value);
      });
      const {
        width: te
      } = iv(u), {
        width: J
      } = iv(h), {
        width: re
      } = iv(d), {
        width: oe
      } = iv(p);
      pe([y, A, te, J, re, oe, () => e.direction], () => {
        W.value = 0, y.value ? d.value && p.value && (W.value = re.value + oe.value, te.value && J.value && W.value > te.value - J.value - (e.direction === "rtl" || h.value.offsetLeft > W.value ? 0 : h.value.offsetLeft) && (j.value = W.value)) : y.value === 0 && (j.value = 0);
      }, {
        immediate: !0
      });
      const q = /* @__PURE__ */ H();
      function K(st, Yt) {
        if (st)
          clearTimeout(q.value), s.value[Yt] = !0, b(Yt), L(st), A.value || P(null, Yt);
        else if (y.value === Yt) {
          L(st);
          const Kt = s.value;
          q.value = setTimeout(() => {
            Kt === s.value && (s.value = {});
          });
        }
      }
      function se(st) {
        K(!0, st), setTimeout(() => {
          const Yt = [m, v][st];
          Yt.value && Yt.value.focus();
        }, 0);
      }
      function Z(st, Yt) {
        let Kt = st, Ln = An(Kt, 0), Zn = An(Kt, 1);
        const {
          generateConfig: ho,
          locale: ul,
          picker: zo,
          order: ir,
          onCalendarChange: hl,
          allowEmpty: Go,
          onChange: He,
          showTime: St
        } = e;
        Ln && Zn && ho.isAfter(Ln, Zn) && (// WeekPicker only compare week
        zo === "week" && !wW(ho, ul.locale, Ln, Zn) || // QuotaPicker only compare week
        zo === "quarter" && !CW(ho, Ln, Zn) || // Other non-TimePicker compare date
        zo !== "week" && zo !== "quarter" && zo !== "time" && !(St ? $f(ho, Ln, Zn) : is(ho, Ln, Zn)) ? (Yt === 0 ? (Kt = [Ln, null], Zn = null) : (Ln = null, Kt = [null, Zn]), s.value = {
          [Yt]: !0
        }) : (zo !== "time" || ir !== !1) && (Kt = O6(Kt, ho))), N(Kt);
        const Xt = Kt && Kt[0] ? yl(Kt[0], {
          generateConfig: ho,
          locale: ul,
          format: g.value[0]
        }) : "", Mn = Kt && Kt[1] ? yl(Kt[1], {
          generateConfig: ho,
          locale: ul,
          format: g.value[0]
        }) : "";
        hl && hl(Kt, [Xt, Mn], {
          range: Yt === 0 ? "start" : "end"
        });
        const jn = _6(Ln, 0, w.value, Go), so = _6(Zn, 1, w.value, Go);
        (Kt === null || jn && so) && (E(Kt), He && (!$f(ho, An(x.value, 0), Ln) || !$f(ho, An(x.value, 1), Zn)) && He(Kt, [Xt, Mn]));
        let Ao = null;
        Yt === 0 && !w.value[1] ? Ao = 1 : Yt === 1 && !w.value[0] && (Ao = 0), Ao !== null && Ao !== y.value && (!s.value[Ao] || !An(Kt, Ao)) && An(Kt, Yt) ? se(Ao) : K(!1, Yt);
      }
      const ee = (st) => A && C.value && C.value.onKeydown ? C.value.onKeydown(st) : (bn(!1, "Picker not correct forward Keydown operation. Please help to fire issue about this."), !1), fe = {
        formatList: g,
        generateConfig: /* @__PURE__ */ ft(e, "generateConfig"),
        locale: /* @__PURE__ */ ft(e, "locale")
      }, [me, ge] = Iy(O(() => An(k.value, 0)), fe), [he, $e] = Iy(O(() => An(k.value, 1)), fe), ne = (st, Yt) => {
        const Kt = $W(st, {
          locale: e.locale,
          formatList: g.value,
          generateConfig: e.generateConfig
        });
        Kt && !(Yt === 0 ? F : M)(Kt) && (N(Gr(k.value, Kt, Yt)), P(Kt, Yt));
      }, [ae, ce, xe] = L2({
        valueTexts: me,
        onTextChange: (st) => ne(st, 0)
      }), [Te, Se, be] = L2({
        valueTexts: he,
        onTextChange: (st) => ne(st, 1)
      }), [ie, we] = Bn(null), [Ne, tt] = Bn(null), [Pe, Re, Le] = B2(ae, fe), [Ue, Ae, De] = B2(Te, fe), _e = (st) => {
        tt(Gr(k.value, st, y.value)), y.value === 0 ? Re(st) : Ae(st);
      }, Ze = () => {
        tt(Gr(k.value, null, y.value)), y.value === 0 ? Le() : De();
      }, dt = (st, Yt) => ({
        forwardKeydown: ee,
        onBlur: (Kt) => {
          var Ln;
          (Ln = e.onBlur) === null || Ln === void 0 || Ln.call(e, Kt);
        },
        isClickOutside: (Kt) => !SW([u.value, d.value, f.value, c.value], Kt),
        onFocus: (Kt) => {
          var Ln;
          b(st), (Ln = e.onFocus) === null || Ln === void 0 || Ln.call(e, Kt);
        },
        triggerOpen: (Kt) => {
          K(Kt, st);
        },
        onSubmit: () => {
          if (
            // When user typing disabledDate with keyboard and enter, this value will be empty
            !k.value || // Normal disabled check
            e.disabledDate && e.disabledDate(k.value[st])
          )
            return !1;
          Z(k.value, st), Yt();
        },
        onCancel: () => {
          K(!1, st), N(x.value), Yt();
        }
      }), [Tt, {
        focused: jt,
        typing: Qt
      }] = D2(_(_({}, dt(0, xe)), {
        blurToCancel: l,
        open: B,
        value: ae,
        onKeydown: (st, Yt) => {
          var Kt;
          (Kt = e.onKeydown) === null || Kt === void 0 || Kt.call(e, st, Yt);
        }
      })), [je, {
        focused: lt,
        typing: Ct
      }] = D2(_(_({}, dt(1, be)), {
        blurToCancel: l,
        open: V,
        value: Te,
        onKeydown: (st, Yt) => {
          var Kt;
          (Kt = e.onKeydown) === null || Kt === void 0 || Kt.call(e, st, Yt);
        }
      })), vn = (st) => {
        var Yt;
        (Yt = e.onClick) === null || Yt === void 0 || Yt.call(e, st), !A.value && !m.value.contains(st.target) && !v.value.contains(st.target) && (w.value[0] ? w.value[1] || se(1) : se(0));
      }, tn = (st) => {
        var Yt;
        (Yt = e.onMousedown) === null || Yt === void 0 || Yt.call(e, st), A.value && (jt.value || lt.value) && !m.value.contains(st.target) && !v.value.contains(st.target) && st.preventDefault();
      }, ct = O(() => {
        var st;
        return !((st = x.value) === null || st === void 0) && st[0] ? yl(x.value[0], {
          locale: e.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: e.generateConfig
        }) : "";
      }), pt = O(() => {
        var st;
        return !((st = x.value) === null || st === void 0) && st[1] ? yl(x.value[1], {
          locale: e.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: e.generateConfig
        }) : "";
      });
      pe([A, me, he], () => {
        A.value || (N(x.value), !me.value.length || me.value[0] === "" ? ce("") : ge.value !== ae.value && xe(), !he.value.length || he.value[0] === "" ? Se("") : $e.value !== Te.value && be());
      }), pe([ct, pt], () => {
        N(x.value);
      }), process.env.NODE_ENV !== "production" && Ot(() => {
        const {
          value: st,
          disabled: Yt
        } = e;
        st && Array.isArray(Yt) && (An(Yt, 0) && !An(st, 0) || An(Yt, 1) && !An(st, 1)) && bn(!1, "`disabled` should not set with empty `value`. You should set `allowEmpty` or `value` instead.");
      }), o({
        focus: () => {
          m.value && m.value.focus();
        },
        blur: () => {
          m.value && m.value.blur(), v.value && v.value.blur();
        }
      });
      const Lt = O(() => A.value && Ne.value && Ne.value[0] && Ne.value[1] && e.generateConfig.isAfter(Ne.value[1], Ne.value[0]) ? Ne.value : null);
      function Gn() {
        let st = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, Yt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          generateConfig: Kt,
          showTime: Ln,
          dateRender: Zn,
          direction: ho,
          disabledTime: ul,
          prefixCls: zo,
          locale: ir
        } = e;
        let hl = Ln;
        if (Ln && typeof Ln == "object" && Ln.defaultValue) {
          const He = Ln.defaultValue;
          hl = _(_({}, Ln), {
            defaultValue: An(He, y.value) || void 0
          });
        }
        let Go = null;
        return Zn && (Go = (He) => {
          let {
            current: St,
            today: Xt
          } = He;
          return Zn({
            current: St,
            today: Xt,
            info: {
              range: y.value ? "end" : "start"
            }
          });
        }), $(KRe, {
          value: {
            inRange: !0,
            panelPosition: st,
            rangedValue: ie.value || k.value,
            hoverRangedValue: Lt.value
          }
        }, {
          default: () => [$(CT, Q(Q(Q({}, e), Yt), {}, {
            dateRender: Go,
            showTime: hl,
            mode: R.value[y.value],
            generateConfig: Kt,
            style: void 0,
            direction: ho,
            disabledDate: y.value === 0 ? F : M,
            disabledTime: (He) => ul ? ul(He, y.value === 0 ? "start" : "end") : !1,
            class: ke({
              [`${zo}-panel-focused`]: y.value === 0 ? !Qt.value : !Ct.value
            }),
            value: An(k.value, y.value),
            locale: ir,
            tabIndex: -1,
            onPanelChange: (He, St) => {
              y.value === 0 && Le(!0), y.value === 1 && De(!0), D(Gr(R.value, St, y.value), Gr(k.value, He, y.value));
              let Xt = He;
              st === "right" && R.value[y.value] === St && (Xt = Bv(Xt, St, Kt, -1)), P(Xt, y.value);
            },
            onOk: null,
            onSelect: void 0,
            onChange: void 0,
            defaultValue: y.value === 0 ? An(k.value, 1) : An(k.value, 0)
          }), null)]
        });
      }
      const To = (st, Yt) => {
        const Kt = Gr(k.value, st, y.value);
        Yt === "submit" || Yt !== "key" && !l.value ? (Z(Kt, y.value), y.value === 0 ? Le() : De()) : N(Kt);
      };
      return oT({
        operationRef: C,
        hideHeader: O(() => e.picker === "time"),
        onDateMouseenter: _e,
        onDateMouseleave: Ze,
        hideRanges: O(() => !0),
        onSelect: To,
        open: A
      }), () => {
        const {
          prefixCls: st = "rc-picker",
          id: Yt,
          popupStyle: Kt,
          dropdownClassName: Ln,
          transitionName: Zn,
          dropdownAlign: ho,
          getPopupContainer: ul,
          generateConfig: zo,
          locale: ir,
          placeholder: hl,
          autofocus: Go,
          picker: He = "date",
          showTime: St,
          separator: Xt = "~",
          disabledDate: Mn,
          panelRender: jn,
          allowClear: so,
          suffixIcon: xo,
          clearIcon: Ao,
          inputReadOnly: wr,
          renderExtraFooter: Ts,
          onMouseenter: bd,
          onMouseleave: et,
          onMouseup: Pt,
          onOk: qt,
          components: ln,
          direction: go,
          autocomplete: Wl = "off"
        } = e, Bc = go === "rtl" ? {
          right: `${W.value}px`
        } : {
          left: `${W.value}px`
        };
        function yd() {
          let sr;
          const Ps = TW(st, R.value[y.value], Ts), KP = PW({
            prefixCls: st,
            components: ln,
            needConfirmButton: l.value,
            okDisabled: !An(k.value, y.value) || Mn && Mn(k.value[y.value]),
            locale: ir,
            onOk: () => {
              An(k.value, y.value) && (Z(k.value, y.value), qt && qt(k.value));
            }
          });
          if (He !== "time" && !St) {
            const ks = y.value === 0 ? I.value : T.value, KY = Bv(ks, He, zo), dC = R.value[y.value] === He, UP = Gn(dC ? "left" : !1, {
              pickerValue: ks,
              onPickerValueChange: (fC) => {
                P(fC, y.value);
              }
            }), GP = Gn("right", {
              pickerValue: KY,
              onPickerValueChange: (fC) => {
                P(Bv(fC, He, zo, -1), y.value);
              }
            });
            go === "rtl" ? sr = $(Ge, null, [GP, dC && UP]) : sr = $(Ge, null, [UP, dC && GP]);
          } else
            sr = Gn();
          let uC = $("div", {
            class: `${st}-panel-layout`
          }, [$(NW, {
            prefixCls: st,
            presets: i.value,
            onClick: (ks) => {
              Z(ks, null), K(!1, y.value);
            },
            onHover: (ks) => {
              we(ks);
            }
          }, null), $("div", null, [$("div", {
            class: `${st}-panels`
          }, [sr]), (Ps || KP) && $("div", {
            class: `${st}-footer`
          }, [Ps, KP])])]);
          return jn && (uC = jn(uC)), $("div", {
            class: `${st}-panel-container`,
            style: {
              marginLeft: `${j.value}px`
            },
            ref: u,
            onMousedown: (ks) => {
              ks.preventDefault();
            }
          }, [uC]);
        }
        const iC = $("div", {
          class: ke(`${st}-range-wrapper`, `${st}-${He}-range-wrapper`),
          style: {
            minWidth: `${Y.value}px`
          }
        }, [$("div", {
          ref: h,
          class: `${st}-range-arrow`,
          style: Bc
        }, null), yd()]);
        let sC;
        xo && (sC = $("span", {
          class: `${st}-suffix`
        }, [xo]));
        let Wh;
        so && (An(x.value, 0) && !w.value[0] || An(x.value, 1) && !w.value[1]) && (Wh = $("span", {
          onMousedown: (sr) => {
            sr.preventDefault(), sr.stopPropagation();
          },
          onMouseup: (sr) => {
            sr.preventDefault(), sr.stopPropagation();
            let Ps = x.value;
            w.value[0] || (Ps = Gr(Ps, null, 0)), w.value[1] || (Ps = Gr(Ps, null, 1)), Z(Ps, null), K(!1, y.value);
          },
          class: `${st}-clear`
        }, [Ao || $("span", {
          class: `${st}-clear-btn`
        }, null)]));
        const Kh = {
          size: yW(He, g.value[0], zo)
        };
        let Kp = 0, cC = 0;
        d.value && f.value && p.value && (y.value === 0 ? cC = d.value.offsetWidth : (Kp = W.value, cC = f.value.offsetWidth));
        const WY = go === "rtl" ? {
          right: `${Kp}px`
        } : {
          left: `${Kp}px`
        };
        return $("div", Q({
          ref: c,
          class: ke(st, `${st}-range`, n.class, {
            [`${st}-disabled`]: w.value[0] && w.value[1],
            [`${st}-focused`]: y.value === 0 ? jt.value : lt.value,
            [`${st}-rtl`]: go === "rtl"
          }),
          style: n.style,
          onClick: vn,
          onMouseenter: bd,
          onMouseleave: et,
          onMousedown: tn,
          onMouseup: Pt
        }, OW(e)), [$("div", {
          class: ke(`${st}-input`, {
            [`${st}-input-active`]: y.value === 0,
            [`${st}-input-placeholder`]: !!Pe.value
          }),
          ref: d
        }, [$("input", Q(Q(Q({
          id: Yt,
          disabled: w.value[0],
          readonly: wr || typeof g.value[0] == "function" || !Qt.value,
          value: Pe.value || ae.value,
          onInput: (sr) => {
            ce(sr.target.value);
          },
          autofocus: Go,
          placeholder: An(hl, 0) || "",
          ref: m
        }, Tt.value), Kh), {}, {
          autocomplete: Wl
        }), null)]), $("div", {
          class: `${st}-range-separator`,
          ref: p
        }, [Xt]), $("div", {
          class: ke(`${st}-input`, {
            [`${st}-input-active`]: y.value === 1,
            [`${st}-input-placeholder`]: !!Ue.value
          }),
          ref: f
        }, [$("input", Q(Q(Q({
          disabled: w.value[1],
          readonly: wr || typeof g.value[0] == "function" || !Ct.value,
          value: Ue.value || Te.value,
          onInput: (sr) => {
            Se(sr.target.value);
          },
          placeholder: An(hl, 1) || "",
          ref: v
        }, je.value), Kh), {}, {
          autocomplete: Wl
        }), null)]), $("div", {
          class: `${st}-active-bar`,
          style: _(_({}, WY), {
            width: `${cC}px`,
            position: "absolute"
          })
        }, null), sC, Wh, $(kW, {
          visible: A.value,
          popupStyle: Kt,
          prefixCls: st,
          dropdownClassName: Ln,
          dropdownAlign: ho,
          getPopupContainer: ul,
          transitionName: Zn,
          range: !0,
          direction: go
        }, {
          default: () => [$("div", {
            style: {
              pointerEvents: "none",
              position: "absolute",
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            }
          }, null)],
          popupElement: () => iC
        })]);
      };
    }
  });
}
const uDe = cDe();
var dDe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const fDe = {
  prefixCls: String,
  name: String,
  id: String,
  type: String,
  defaultChecked: {
    type: [Boolean, Number],
    default: void 0
  },
  checked: {
    type: [Boolean, Number],
    default: void 0
  },
  disabled: Boolean,
  tabindex: {
    type: [Number, String]
  },
  readonly: Boolean,
  autofocus: Boolean,
  value: de.any,
  required: Boolean
}, FW = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Checkbox",
  inheritAttrs: !1,
  props: sn(fDe, {
    prefixCls: "rc-checkbox",
    type: "checkbox",
    defaultChecked: !1
  }),
  emits: ["click", "change"],
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      expose: l
    } = t;
    const r = /* @__PURE__ */ H(e.checked === void 0 ? e.defaultChecked : e.checked), a = /* @__PURE__ */ H();
    pe(() => e.checked, () => {
      r.value = e.checked;
    }), l({
      focus() {
        var u;
        (u = a.value) === null || u === void 0 || u.focus();
      },
      blur() {
        var u;
        (u = a.value) === null || u === void 0 || u.blur();
      }
    });
    const i = /* @__PURE__ */ H(), s = (u) => {
      if (e.disabled)
        return;
      e.checked === void 0 && (r.value = u.target.checked), u.shiftKey = i.value;
      const d = {
        target: _(_({}, e), {
          checked: u.target.checked
        }),
        stopPropagation() {
          u.stopPropagation();
        },
        preventDefault() {
          u.preventDefault();
        },
        nativeEvent: u
      };
      e.checked !== void 0 && (a.value.checked = !!e.checked), o("change", d), i.value = !1;
    }, c = (u) => {
      o("click", u), i.value = u.shiftKey;
    };
    return () => {
      const {
        prefixCls: u,
        name: d,
        id: f,
        type: p,
        disabled: m,
        readonly: v,
        tabindex: h,
        autofocus: g,
        value: y,
        required: b
      } = e, C = dDe(e, ["prefixCls", "name", "id", "type", "disabled", "readonly", "tabindex", "autofocus", "value", "required"]), {
        class: w,
        onFocus: x,
        onBlur: E,
        onKeydown: I,
        onKeypress: T,
        onKeyup: P
      } = n, k = _(_({}, C), n), N = Object.keys(k).reduce((D, F) => ((F.startsWith("data-") || F.startsWith("aria-") || F === "role") && (D[F] = k[F]), D), {}), R = ke(u, w, {
        [`${u}-checked`]: r.value,
        [`${u}-disabled`]: m
      }), z = _(_({
        name: d,
        id: f,
        type: p,
        readonly: v,
        disabled: m,
        tabindex: h,
        class: `${u}-input`,
        checked: !!r.value,
        autofocus: g,
        value: y
      }, N), {
        onChange: s,
        onClick: c,
        onFocus: x,
        onBlur: E,
        onKeydown: I,
        onKeypress: T,
        onKeyup: P,
        required: b
      });
      return $("span", {
        class: R
      }, [$("input", Q({
        ref: a
      }, z), null), $("span", {
        class: `${u}-inner`
      }, null)]);
    };
  }
}), VW = Symbol("radioGroupContextKey"), pDe = (e) => {
  at(VW, e);
}, vDe = () => ze(VW, void 0), zW = Symbol("radioOptionTypeContextKey"), mDe = (e) => {
  at(zW, e);
}, hDe = () => ze(zW, void 0), gDe = new mn("antRadioEffect", {
  "0%": {
    transform: "scale(1)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(1.6)",
    opacity: 0
  }
}), bDe = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e, o = `${t}-group`;
  return {
    [o]: _(_({}, nn(e)), {
      display: "inline-block",
      fontSize: 0,
      // RTL
      [`&${o}-rtl`]: {
        direction: "rtl"
      },
      [`${n}-badge ${n}-badge-count`]: {
        zIndex: 1
      },
      [`> ${n}-badge:not(:first-child) > ${n}-button-wrapper`]: {
        borderInlineStart: "none"
      }
    })
  };
}, yDe = (e) => {
  const {
    componentCls: t,
    radioWrapperMarginRight: n,
    radioCheckedColor: o,
    radioSize: l,
    motionDurationSlow: r,
    motionDurationMid: a,
    motionEaseInOut: i,
    motionEaseInOutCirc: s,
    radioButtonBg: c,
    colorBorder: u,
    lineWidth: d,
    radioDotSize: f,
    colorBgContainerDisabled: p,
    colorTextDisabled: m,
    paddingXS: v,
    radioDotDisabledColor: h,
    lineType: g,
    radioDotDisabledSize: y,
    wireframe: b,
    colorWhite: C
  } = e, w = `${t}-inner`;
  return {
    [`${t}-wrapper`]: _(_({}, nn(e)), {
      position: "relative",
      display: "inline-flex",
      alignItems: "baseline",
      marginInlineStart: 0,
      marginInlineEnd: n,
      cursor: "pointer",
      // RTL
      [`&${t}-wrapper-rtl`]: {
        direction: "rtl"
      },
      "&-disabled": {
        cursor: "not-allowed",
        color: e.colorTextDisabled
      },
      "&::after": {
        display: "inline-block",
        width: 0,
        overflow: "hidden",
        content: '"\\a0"'
      },
      // hashId  wrapper 
      [`${t}-checked::after`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: "100%",
        height: "100%",
        border: `${d}px ${g} ${o}`,
        borderRadius: "50%",
        visibility: "hidden",
        animationName: gDe,
        animationDuration: r,
        animationTimingFunction: i,
        animationFillMode: "both",
        content: '""'
      },
      [t]: _(_({}, nn(e)), {
        position: "relative",
        display: "inline-block",
        outline: "none",
        cursor: "pointer",
        alignSelf: "center"
      }),
      [`${t}-wrapper:hover &,
        &:hover ${w}`]: {
        borderColor: o
      },
      [`${t}-input:focus-visible + ${w}`]: _({}, bs(e)),
      [`${t}:hover::after, ${t}-wrapper:hover &::after`]: {
        visibility: "visible"
      },
      [`${t}-inner`]: {
        "&::after": {
          boxSizing: "border-box",
          position: "absolute",
          insetBlockStart: "50%",
          insetInlineStart: "50%",
          display: "block",
          width: l,
          height: l,
          marginBlockStart: l / -2,
          marginInlineStart: l / -2,
          backgroundColor: b ? o : C,
          borderBlockStart: 0,
          borderInlineStart: 0,
          borderRadius: l,
          transform: "scale(0)",
          opacity: 0,
          transition: `all ${r} ${s}`,
          content: '""'
        },
        boxSizing: "border-box",
        position: "relative",
        insetBlockStart: 0,
        insetInlineStart: 0,
        display: "block",
        width: l,
        height: l,
        backgroundColor: c,
        borderColor: u,
        borderStyle: "solid",
        borderWidth: d,
        borderRadius: "50%",
        transition: `all ${a}`
      },
      [`${t}-input`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineEnd: 0,
        insetBlockEnd: 0,
        insetInlineStart: 0,
        zIndex: 1,
        cursor: "pointer",
        opacity: 0
      },
      // 
      [`${t}-checked`]: {
        [w]: {
          borderColor: o,
          backgroundColor: b ? c : o,
          "&::after": {
            transform: `scale(${f / l})`,
            opacity: 1,
            transition: `all ${r} ${s}`
          }
        }
      },
      [`${t}-disabled`]: {
        cursor: "not-allowed",
        [w]: {
          backgroundColor: p,
          borderColor: u,
          cursor: "not-allowed",
          "&::after": {
            backgroundColor: h
          }
        },
        [`${t}-input`]: {
          cursor: "not-allowed"
        },
        [`${t}-disabled + span`]: {
          color: m,
          cursor: "not-allowed"
        },
        [`&${t}-checked`]: {
          [w]: {
            "&::after": {
              transform: `scale(${y / l})`
            }
          }
        }
      },
      [`span${t} + *`]: {
        paddingInlineStart: v,
        paddingInlineEnd: v
      }
    })
  };
}, SDe = (e) => {
  const {
    radioButtonColor: t,
    controlHeight: n,
    componentCls: o,
    lineWidth: l,
    lineType: r,
    colorBorder: a,
    motionDurationSlow: i,
    motionDurationMid: s,
    radioButtonPaddingHorizontal: c,
    fontSize: u,
    radioButtonBg: d,
    fontSizeLG: f,
    controlHeightLG: p,
    controlHeightSM: m,
    paddingXS: v,
    borderRadius: h,
    borderRadiusSM: g,
    borderRadiusLG: y,
    radioCheckedColor: b,
    radioButtonCheckedBg: C,
    radioButtonHoverColor: w,
    radioButtonActiveColor: x,
    radioSolidCheckedColor: E,
    colorTextDisabled: I,
    colorBgContainerDisabled: T,
    radioDisabledButtonCheckedColor: P,
    radioDisabledButtonCheckedBg: k
  } = e;
  return {
    [`${o}-button-wrapper`]: {
      position: "relative",
      display: "inline-block",
      height: n,
      margin: 0,
      paddingInline: c,
      paddingBlock: 0,
      color: t,
      fontSize: u,
      lineHeight: `${n - l * 2}px`,
      background: d,
      border: `${l}px ${r} ${a}`,
      // strange align fix for chrome but works
      // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
      borderBlockStartWidth: l + 0.02,
      borderInlineStartWidth: 0,
      borderInlineEndWidth: l,
      cursor: "pointer",
      transition: [`color ${s}`, `background ${s}`, `border-color ${s}`, `box-shadow ${s}`].join(","),
      a: {
        color: t
      },
      [`> ${o}-button`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: -1,
        width: "100%",
        height: "100%"
      },
      "&:not(:first-child)": {
        "&::before": {
          position: "absolute",
          insetBlockStart: -l,
          insetInlineStart: -l,
          display: "block",
          boxSizing: "content-box",
          width: 1,
          height: "100%",
          paddingBlock: l,
          paddingInline: 0,
          backgroundColor: a,
          transition: `background-color ${i}`,
          content: '""'
        }
      },
      "&:first-child": {
        borderInlineStart: `${l}px ${r} ${a}`,
        borderStartStartRadius: h,
        borderEndStartRadius: h
      },
      "&:last-child": {
        borderStartEndRadius: h,
        borderEndEndRadius: h
      },
      "&:first-child:last-child": {
        borderRadius: h
      },
      [`${o}-group-large &`]: {
        height: p,
        fontSize: f,
        lineHeight: `${p - l * 2}px`,
        "&:first-child": {
          borderStartStartRadius: y,
          borderEndStartRadius: y
        },
        "&:last-child": {
          borderStartEndRadius: y,
          borderEndEndRadius: y
        }
      },
      [`${o}-group-small &`]: {
        height: m,
        paddingInline: v - l,
        paddingBlock: 0,
        lineHeight: `${m - l * 2}px`,
        "&:first-child": {
          borderStartStartRadius: g,
          borderEndStartRadius: g
        },
        "&:last-child": {
          borderStartEndRadius: g,
          borderEndEndRadius: g
        }
      },
      "&:hover": {
        position: "relative",
        color: b
      },
      "&:has(:focus-visible)": _({}, bs(e)),
      [`${o}-inner, input[type='checkbox'], input[type='radio']`]: {
        width: 0,
        height: 0,
        opacity: 0,
        pointerEvents: "none"
      },
      [`&-checked:not(${o}-button-wrapper-disabled)`]: {
        zIndex: 1,
        color: b,
        background: C,
        borderColor: b,
        "&::before": {
          backgroundColor: b
        },
        "&:first-child": {
          borderColor: b
        },
        "&:hover": {
          color: w,
          borderColor: w,
          "&::before": {
            backgroundColor: w
          }
        },
        "&:active": {
          color: x,
          borderColor: x,
          "&::before": {
            backgroundColor: x
          }
        }
      },
      [`${o}-group-solid &-checked:not(${o}-button-wrapper-disabled)`]: {
        color: E,
        background: b,
        borderColor: b,
        "&:hover": {
          color: E,
          background: w,
          borderColor: w
        },
        "&:active": {
          color: E,
          background: x,
          borderColor: x
        }
      },
      "&-disabled": {
        color: I,
        backgroundColor: T,
        borderColor: a,
        cursor: "not-allowed",
        "&:first-child, &:hover": {
          color: I,
          backgroundColor: T,
          borderColor: a
        }
      },
      [`&-disabled${o}-button-wrapper-checked`]: {
        color: P,
        backgroundColor: k,
        borderColor: a,
        boxShadow: "none"
      }
    }
  };
}, HW = Zt("Radio", (e) => {
  const {
    padding: t,
    lineWidth: n,
    controlItemBgActiveDisabled: o,
    colorTextDisabled: l,
    colorBgContainer: r,
    fontSizeLG: a,
    controlOutline: i,
    colorPrimaryHover: s,
    colorPrimaryActive: c,
    colorText: u,
    colorPrimary: d,
    marginXS: f,
    controlOutlineWidth: p,
    colorTextLightSolid: m,
    wireframe: v
  } = e, h = `0 0 0 ${p}px ${i}`, g = h, y = a, b = 4, C = y - b * 2, w = v ? C : y - (b + n) * 2, x = d, E = u, I = s, T = c, P = t - n, R = Vt(e, {
    radioFocusShadow: h,
    radioButtonFocusShadow: g,
    radioSize: y,
    radioDotSize: w,
    radioDotDisabledSize: C,
    radioCheckedColor: x,
    radioDotDisabledColor: l,
    radioSolidCheckedColor: m,
    radioButtonBg: r,
    radioButtonCheckedBg: r,
    radioButtonColor: E,
    radioButtonHoverColor: I,
    radioButtonActiveColor: T,
    radioButtonPaddingHorizontal: P,
    radioDisabledButtonCheckedBg: o,
    radioDisabledButtonCheckedColor: l,
    radioWrapperMarginRight: f
  });
  return [bDe(R), yDe(R), SDe(R)];
});
var CDe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const jW = () => ({
  prefixCls: String,
  checked: Qe(),
  disabled: Qe(),
  isGroup: Qe(),
  value: de.any,
  name: String,
  id: String,
  autofocus: Qe(),
  onChange: Fe(),
  onFocus: Fe(),
  onBlur: Fe(),
  onClick: Fe(),
  "onUpdate:checked": Fe(),
  "onUpdate:value": Fe()
}), Jl = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ARadio",
  inheritAttrs: !1,
  props: jW(),
  setup(e, t) {
    let {
      emit: n,
      expose: o,
      slots: l,
      attrs: r
    } = t;
    const a = Ko(), i = sl.useInject(), s = hDe(), c = vDe(), u = Cr(), d = O(() => {
      var I;
      return (I = v.value) !== null && I !== void 0 ? I : u.value;
    }), f = /* @__PURE__ */ H(), {
      prefixCls: p,
      direction: m,
      disabled: v
    } = bt("radio", e), h = O(() => (c == null ? void 0 : c.optionType.value) === "button" || s === "button" ? `${p.value}-button` : p.value), g = Cr(), [y, b] = HW(p);
    o({
      focus: () => {
        f.value.focus();
      },
      blur: () => {
        f.value.blur();
      }
    });
    const x = (I) => {
      const T = I.target.checked;
      n("update:checked", T), n("update:value", T), n("change", I), a.onFieldChange();
    }, E = (I) => {
      n("change", I), c && c.onChange && c.onChange(I);
    };
    return () => {
      var I;
      const T = c, {
        prefixCls: P,
        id: k = a.id.value
      } = e, N = CDe(e, ["prefixCls", "id"]), R = _(_({
        prefixCls: h.value,
        id: k
      }, pn(N, ["onUpdate:checked", "onUpdate:value"])), {
        disabled: (I = v.value) !== null && I !== void 0 ? I : g.value
      });
      T ? (R.name = T.name.value, R.onChange = E, R.checked = e.value === T.value.value, R.disabled = d.value || T.disabled.value) : R.onChange = x;
      const z = ke({
        [`${h.value}-wrapper`]: !0,
        [`${h.value}-wrapper-checked`]: R.checked,
        [`${h.value}-wrapper-disabled`]: R.disabled,
        [`${h.value}-wrapper-rtl`]: m.value === "rtl",
        [`${h.value}-wrapper-in-form-item`]: i.isFormItemInput
      }, r.class, b.value);
      return y($("label", Q(Q({}, r), {}, {
        class: z
      }), [$(FW, Q(Q({}, R), {}, {
        type: "radio",
        ref: f
      }), null), l.default && $("span", null, [l.default()])]));
    };
  }
}), wDe = () => ({
  prefixCls: String,
  value: de.any,
  size: At(),
  options: $n(),
  disabled: Qe(),
  name: String,
  buttonStyle: At("outline"),
  id: String,
  optionType: At("default"),
  onChange: Fe(),
  "onUpdate:value": Fe()
}), $T = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ARadioGroup",
  inheritAttrs: !1,
  props: wDe(),
  // emits: ['update:value', 'change'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: l
    } = t;
    const r = Ko(), {
      prefixCls: a,
      direction: i,
      size: s
    } = bt("radio", e), [c, u] = HW(a), d = /* @__PURE__ */ H(e.value), f = /* @__PURE__ */ H(!1);
    return pe(() => e.value, (m) => {
      d.value = m, f.value = !1;
    }), pDe({
      onChange: (m) => {
        const v = d.value, {
          value: h
        } = m.target;
        "value" in e || (d.value = h), !f.value && h !== v && (f.value = !0, o("update:value", h), o("change", m), r.onFieldChange()), Ke(() => {
          f.value = !1;
        });
      },
      value: d,
      disabled: O(() => e.disabled),
      name: O(() => e.name),
      optionType: O(() => e.optionType)
    }), () => {
      var m;
      const {
        options: v,
        buttonStyle: h,
        id: g = r.id.value
      } = e, y = `${a.value}-group`, b = ke(y, `${y}-${h}`, {
        [`${y}-${s.value}`]: s.value,
        [`${y}-rtl`]: i.value === "rtl"
      }, l.class, u.value);
      let C = null;
      return v && v.length > 0 ? C = v.map((w) => {
        if (typeof w == "string" || typeof w == "number")
          return $(Jl, {
            key: w,
            prefixCls: a.value,
            disabled: e.disabled,
            value: w,
            checked: d.value === w
          }, {
            default: () => [w]
          });
        const {
          value: x,
          disabled: E,
          label: I
        } = w;
        return $(Jl, {
          key: `radio-group-value-options-${x}`,
          prefixCls: a.value,
          disabled: E || e.disabled,
          value: x,
          checked: d.value === x
        }, {
          default: () => [I]
        });
      }) : C = (m = n.default) === null || m === void 0 ? void 0 : m.call(n), c($("div", Q(Q({}, l), {}, {
        class: b,
        id: g
      }), [C]));
    };
  }
}), Ty = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ARadioButton",
  inheritAttrs: !1,
  props: jW(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l
    } = bt("radio", e);
    return mDe("button"), () => {
      var r;
      return $(Jl, Q(Q(Q({}, o), e), {}, {
        prefixCls: l.value
      }), {
        default: () => [(r = n.default) === null || r === void 0 ? void 0 : r.call(n)]
      });
    };
  }
});
Jl.Group = $T;
Jl.Button = Ty;
Jl.install = function(e) {
  return e.component(Jl.name, Jl), e.component(Jl.Group.name, Jl.Group), e.component(Jl.Button.name, Jl.Button), e;
};
const $De = 10, xDe = 20;
function WW(e) {
  const {
    fullscreen: t,
    validRange: n,
    generateConfig: o,
    locale: l,
    prefixCls: r,
    value: a,
    onChange: i,
    divRef: s
  } = e, c = o.getYear(a || o.getNow());
  let u = c - $De, d = u + xDe;
  n && (u = o.getYear(n[0]), d = o.getYear(n[1]) + 1);
  const f = l && l.year === "" ? "" : "", p = [];
  for (let m = u; m < d; m++)
    p.push({
      label: `${m}${f}`,
      value: m
    });
  return $(pl, {
    size: t ? void 0 : "small",
    options: p,
    value: c,
    class: `${r}-year-select`,
    onChange: (m) => {
      let v = o.setYear(a, m);
      if (n) {
        const [h, g] = n, y = o.getYear(v), b = o.getMonth(v);
        y === o.getYear(g) && b > o.getMonth(g) && (v = o.setMonth(v, o.getMonth(g))), y === o.getYear(h) && b < o.getMonth(h) && (v = o.setMonth(v, o.getMonth(h)));
      }
      i(v);
    },
    getPopupContainer: () => s.value
  }, null);
}
WW.inheritAttrs = !1;
function KW(e) {
  const {
    prefixCls: t,
    fullscreen: n,
    validRange: o,
    value: l,
    generateConfig: r,
    locale: a,
    onChange: i,
    divRef: s
  } = e, c = r.getMonth(l || r.getNow());
  let u = 0, d = 11;
  if (o) {
    const [m, v] = o, h = r.getYear(l);
    r.getYear(v) === h && (d = r.getMonth(v)), r.getYear(m) === h && (u = r.getMonth(m));
  }
  const f = a.shortMonths || r.locale.getShortMonths(a.locale), p = [];
  for (let m = u; m <= d; m += 1)
    p.push({
      label: f[m],
      value: m
    });
  return $(pl, {
    size: n ? void 0 : "small",
    class: `${t}-month-select`,
    value: c,
    options: p,
    onChange: (m) => {
      i(r.setMonth(l, m));
    },
    getPopupContainer: () => s.value
  }, null);
}
KW.inheritAttrs = !1;
function UW(e) {
  const {
    prefixCls: t,
    locale: n,
    mode: o,
    fullscreen: l,
    onModeChange: r
  } = e;
  return $($T, {
    onChange: (a) => {
      let {
        target: {
          value: i
        }
      } = a;
      r(i);
    },
    value: o,
    size: l ? void 0 : "small",
    class: `${t}-mode-switch`
  }, {
    default: () => [$(Ty, {
      value: "month"
    }, {
      default: () => [n.month]
    }), $(Ty, {
      value: "year"
    }, {
      default: () => [n.year]
    })]
  });
}
UW.inheritAttrs = !1;
const EDe = /* @__PURE__ */ le({
  name: "CalendarHeader",
  inheritAttrs: !1,
  props: ["mode", "prefixCls", "value", "validRange", "generateConfig", "locale", "mode", "fullscreen"],
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const o = /* @__PURE__ */ H(null), l = sl.useInject();
    return sl.useProvide(l, {
      isFormItemInput: !1
    }), () => {
      const r = _(_({}, e), n), {
        prefixCls: a,
        fullscreen: i,
        mode: s,
        onChange: c,
        onModeChange: u
      } = r, d = _(_({}, r), {
        fullscreen: i,
        divRef: o
      });
      return $("div", {
        class: `${a}-header`,
        ref: o
      }, [$(WW, Q(Q({}, d), {}, {
        onChange: (f) => {
          c(f, "year");
        }
      }), null), s === "month" && $(KW, Q(Q({}, d), {}, {
        onChange: (f) => {
          c(f, "month");
        }
      }), null), $(UW, Q(Q({}, d), {}, {
        onModeChange: u
      }), null)]);
    };
  }
}), xT = (e) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color: e,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
}), Bp = (e) => ({
  borderColor: e.inputBorderHoverColor,
  borderInlineEndWidth: e.lineWidth
}), xc = (e) => ({
  borderColor: e.inputBorderHoverColor,
  boxShadow: `0 0 0 ${e.controlOutlineWidth}px ${e.controlOutline}`,
  borderInlineEndWidth: e.lineWidth,
  outline: 0
}), ET = (e) => ({
  color: e.colorTextDisabled,
  backgroundColor: e.colorBgContainerDisabled,
  borderColor: e.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "&:hover": _({}, Bp(Vt(e, {
    inputBorderHoverColor: e.colorBorder
  })))
}), GW = (e) => {
  const {
    inputPaddingVerticalLG: t,
    fontSizeLG: n,
    lineHeightLG: o,
    borderRadiusLG: l,
    inputPaddingHorizontalLG: r
  } = e;
  return {
    padding: `${t}px ${r}px`,
    fontSize: n,
    lineHeight: o,
    borderRadius: l
  };
}, OT = (e) => ({
  padding: `${e.inputPaddingVerticalSM}px ${e.controlPaddingHorizontalSM - 1}px`,
  borderRadius: e.borderRadiusSM
}), Mh = (e, t) => {
  const {
    componentCls: n,
    colorError: o,
    colorWarning: l,
    colorErrorOutline: r,
    colorWarningOutline: a,
    colorErrorBorderHover: i,
    colorWarningBorderHover: s
  } = e;
  return {
    [`&-status-error:not(${t}-disabled):not(${t}-borderless)${t}`]: {
      borderColor: o,
      "&:hover": {
        borderColor: i
      },
      "&:focus, &-focused": _({}, xc(Vt(e, {
        inputBorderActiveColor: o,
        inputBorderHoverColor: o,
        controlOutline: r
      }))),
      [`${n}-prefix`]: {
        color: o
      }
    },
    [`&-status-warning:not(${t}-disabled):not(${t}-borderless)${t}`]: {
      borderColor: l,
      "&:hover": {
        borderColor: s
      },
      "&:focus, &-focused": _({}, xc(Vt(e, {
        inputBorderActiveColor: l,
        inputBorderHoverColor: l,
        controlOutline: a
      }))),
      [`${n}-prefix`]: {
        color: l
      }
    }
  };
}, hd = (e) => _(_({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${e.inputPaddingVertical}px ${e.inputPaddingHorizontal}px`,
  color: e.colorText,
  fontSize: e.fontSize,
  lineHeight: e.lineHeight,
  backgroundColor: e.colorBgContainer,
  backgroundImage: "none",
  borderWidth: e.lineWidth,
  borderStyle: e.lineType,
  borderColor: e.colorBorder,
  borderRadius: e.borderRadius,
  transition: `all ${e.motionDurationMid}`
}, xT(e.colorTextPlaceholder)), {
  "&:hover": _({}, Bp(e)),
  "&:focus, &-focused": _({}, xc(e)),
  "&-disabled, &[disabled]": _({}, ET(e)),
  "&-borderless": {
    "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
      backgroundColor: "transparent",
      border: "none",
      boxShadow: "none"
    }
  },
  // Reset height for `textarea`s
  "textarea&": {
    maxWidth: "100%",
    height: "auto",
    minHeight: e.controlHeight,
    lineHeight: e.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${e.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  // Size
  "&-lg": _({}, GW(e)),
  "&-sm": _({}, OT(e)),
  // RTL
  "&-rtl": {
    direction: "rtl"
  },
  "&-textarea-rtl": {
    direction: "rtl"
  }
}), YW = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    "&[class*='col-']": {
      paddingInlineEnd: e.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${t}, &-lg > ${t}-group-addon`]: _({}, GW(e)),
    [`&-sm ${t}, &-sm > ${t}-group-addon`]: _({}, OT(e)),
    [`> ${t}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${t}-group`]: {
      "&-addon, &-wrap": {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${e.inputPaddingHorizontal}px`,
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.fontSize,
        textAlign: "center",
        backgroundColor: e.colorFillAlter,
        border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
        borderRadius: e.borderRadius,
        transition: `all ${e.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${n}-select`]: {
          margin: `-${e.inputPaddingVertical + 1}px -${e.inputPaddingHorizontal}px`,
          [`&${n}-select-single:not(${n}-select-customize-input)`]: {
            [`${n}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${e.lineWidth}px ${e.lineType} transparent`,
              boxShadow: "none"
            }
          },
          "&-open, &-focused": {
            [`${n}-select-selector`]: {
              color: e.colorPrimary
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${n}-cascader-picker`]: {
          margin: `-9px -${e.inputPaddingHorizontal}px`,
          backgroundColor: "transparent",
          [`${n}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    },
    [`${t}`]: {
      float: "inline-start",
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${t}:first-child, ${t}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${n}-select ${n}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}-affix-wrapper`]: {
      [`&:not(:first-child) ${t}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${t}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}:last-child, ${t}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${n}-select ${n}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${t}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${t}-search &`]: {
          borderStartStartRadius: e.borderRadius,
          borderEndStartRadius: e.borderRadius
        }
      },
      [`&:not(:first-child), ${t}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${t}-group-compact`]: _(_({
      display: "block"
    }, ja()), {
      [`${t}-group-addon, ${t}-group-wrap, > ${t}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: e.lineWidth,
          "&:hover": {
            zIndex: 1
          },
          "&:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-block",
        float: "none",
        verticalAlign: "top",
        borderRadius: 0
      },
      [`& > ${t}-affix-wrapper`]: {
        display: "inline-flex"
      },
      [`& > ${n}-picker-range`]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: -e.lineWidth,
        borderInlineEndWidth: e.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [`${t}`]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${n}-select > ${n}-select-selector,
      & > ${n}-select-auto-complete ${t},
      & > ${n}-cascader-picker ${t},
      & > ${t}-group-wrapper ${t}`]: {
        borderInlineEndWidth: e.lineWidth,
        borderRadius: 0,
        "&:hover": {
          zIndex: 1
        },
        "&:focus": {
          zIndex: 1
        }
      },
      [`& > ${n}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${n}-select > ${n}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${n}-select:first-child > ${n}-select-selector,
      & > ${n}-select-auto-complete:first-child ${t},
      & > ${n}-cascader-picker:first-child ${t}`]: {
        borderStartStartRadius: e.borderRadius,
        borderEndStartRadius: e.borderRadius
      },
      [`& > *:last-child,
      & > ${n}-select:last-child > ${n}-select-selector,
      & > ${n}-cascader-picker:last-child ${t},
      & > ${n}-cascader-picker-focused:last-child ${t}`]: {
        borderInlineEndWidth: e.lineWidth,
        borderStartEndRadius: e.borderRadius,
        borderEndEndRadius: e.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${n}-select-auto-complete ${t}`]: {
        verticalAlign: "top"
      },
      [`${t}-group-wrapper + ${t}-group-wrapper`]: {
        marginInlineStart: -e.lineWidth,
        [`${t}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${t}-group-wrapper:not(:last-child)`]: {
        [`&${t}-search > ${t}-group`]: {
          [`& > ${t}-group-addon > ${t}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${t}`]: {
            borderStartStartRadius: e.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: e.borderRadius
          }
        }
      }
    }),
    [`&&-sm ${n}-btn`]: {
      fontSize: e.fontSizeSM,
      height: e.controlHeightSM,
      lineHeight: "normal"
    },
    [`&&-lg ${n}-btn`]: {
      fontSize: e.fontSizeLG,
      height: e.controlHeightLG,
      lineHeight: "normal"
    },
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&&-lg ${n}-select-single ${n}-select-selector`]: {
      height: `${e.controlHeightLG}px`,
      [`${n}-select-selection-item, ${n}-select-selection-placeholder`]: {
        // -2 is for the border size & override default
        lineHeight: `${e.controlHeightLG - 2}px`
      },
      [`${n}-select-selection-search-input`]: {
        height: `${e.controlHeightLG}px`
      }
    },
    [`&&-sm ${n}-select-single ${n}-select-selector`]: {
      height: `${e.controlHeightSM}px`,
      [`${n}-select-selection-item, ${n}-select-selection-placeholder`]: {
        // -2 is for the border size & override default
        lineHeight: `${e.controlHeightSM - 2}px`
      },
      [`${n}-select-selection-search-input`]: {
        height: `${e.controlHeightSM}px`
      }
    }
  };
}, ODe = (e) => {
  const {
    componentCls: t,
    controlHeightSM: n,
    lineWidth: o
  } = e, r = (n - o * 2 - 16) / 2;
  return {
    [t]: _(_(_(_({}, nn(e)), hd(e)), Mh(e, t)), {
      '&[type="color"]': {
        height: e.controlHeight,
        [`&${t}-lg`]: {
          height: e.controlHeightLG
        },
        [`&${t}-sm`]: {
          height: n,
          paddingTop: r,
          paddingBottom: r
        }
      }
    })
  };
}, _De = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // ========================= Input =========================
    [`${t}-clear-icon`]: {
      margin: 0,
      color: e.colorTextQuaternary,
      fontSize: e.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${e.motionDurationSlow}`,
      "&:hover": {
        color: e.colorTextTertiary
      },
      "&:active": {
        color: e.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${e.inputAffixPadding}px`
      }
    },
    // ======================= TextArea ========================
    "&-textarea-with-clear-btn": {
      padding: "0 !important",
      border: "0 !important",
      [`${t}-clear-icon`]: {
        position: "absolute",
        insetBlockStart: e.paddingXS,
        insetInlineEnd: e.paddingXS,
        zIndex: 1
      }
    }
  };
}, IDe = (e) => {
  const {
    componentCls: t,
    inputAffixPadding: n,
    colorTextDescription: o,
    motionDurationSlow: l,
    colorIcon: r,
    colorIconHover: a,
    iconCls: i
  } = e;
  return {
    [`${t}-affix-wrapper`]: _(_(_(_(_({}, hd(e)), {
      display: "inline-flex",
      [`&:not(${t}-affix-wrapper-disabled):hover`]: _(_({}, Bp(e)), {
        zIndex: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      }),
      "&-focused, &:focus": {
        zIndex: 1
      },
      "&-disabled": {
        [`${t}[disabled]`]: {
          background: "transparent"
        }
      },
      [`> input${t}`]: {
        padding: 0,
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${t}`]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: e.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: o
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: e.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: n
        },
        "&-suffix": {
          marginInlineStart: n
        }
      }
    }), _De(e)), {
      // password
      [`${i}${t}-password-icon`]: {
        color: r,
        cursor: "pointer",
        transition: `all ${l}`,
        "&:hover": {
          color: a
        }
      }
    }), Mh(e, `${t}-affix-wrapper`))
  };
}, TDe = (e) => {
  const {
    componentCls: t,
    colorError: n,
    colorSuccess: o,
    borderRadiusLG: l,
    borderRadiusSM: r
  } = e;
  return {
    [`${t}-group`]: _(_(_({}, nn(e)), YW(e)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": {
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${t}-group-addon`]: {
            borderRadius: l
          }
        },
        "&-sm": {
          [`${t}-group-addon`]: {
            borderRadius: r
          }
        },
        // Status
        "&-status-error": {
          [`${t}-group-addon`]: {
            color: n,
            borderColor: n
          }
        },
        "&-status-warning": {
          [`${t}-group-addon:last-child`]: {
            color: o,
            borderColor: o
          }
        }
      }
    })
  };
}, PDe = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e, o = `${t}-search`;
  return {
    [o]: {
      [`${t}`]: {
        "&:hover, &:focus": {
          borderColor: e.colorPrimaryHover,
          [`+ ${t}-group-addon ${o}-button:not(${n}-btn-primary)`]: {
            borderInlineStartColor: e.colorPrimaryHover
          }
        }
      },
      [`${t}-affix-wrapper`]: {
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
      [`${t}-lg`]: {
        lineHeight: e.lineHeightLG - 2e-4
      },
      [`> ${t}-group`]: {
        [`> ${t}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${o}-button`]: {
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: e.borderRadius,
            borderEndEndRadius: e.borderRadius,
            borderEndStartRadius: 0
          },
          [`${o}-button:not(${n}-btn-primary)`]: {
            color: e.colorTextDescription,
            "&:hover": {
              color: e.colorPrimaryHover
            },
            "&:active": {
              color: e.colorPrimaryActive
            },
            [`&${n}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${o}-button`]: {
        height: e.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`&-large ${o}-button`]: {
        height: e.controlHeightLG
      },
      [`&-small ${o}-button`]: {
        height: e.controlHeightSM
      },
      "&-rtl": {
        direction: "rtl"
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${t}-compact-item`]: {
        [`&:not(${t}-compact-last-item)`]: {
          [`${t}-group-addon`]: {
            [`${t}-search-button`]: {
              marginInlineEnd: -e.lineWidth,
              borderRadius: 0
            }
          }
        },
        [`&:not(${t}-compact-first-item)`]: {
          [`${t},${t}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${t}-group-addon ${t}-search-button,
        > ${t},
        ${t}-affix-wrapper`]: {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          }
        },
        [`> ${t}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
};
function gd(e) {
  return Vt(e, {
    inputAffixPadding: e.paddingXXS,
    inputPaddingVertical: Math.max(Math.round((e.controlHeight - e.fontSize * e.lineHeight) / 2 * 10) / 10 - e.lineWidth, 3),
    inputPaddingVerticalLG: Math.ceil((e.controlHeightLG - e.fontSizeLG * e.lineHeightLG) / 2 * 10) / 10 - e.lineWidth,
    inputPaddingVerticalSM: Math.max(Math.round((e.controlHeightSM - e.fontSize * e.lineHeight) / 2 * 10) / 10 - e.lineWidth, 0),
    inputPaddingHorizontal: e.paddingSM - e.lineWidth,
    inputPaddingHorizontalSM: e.paddingXS - e.lineWidth,
    inputPaddingHorizontalLG: e.controlPaddingHorizontal - e.lineWidth,
    inputBorderHoverColor: e.colorPrimaryHover,
    inputBorderActiveColor: e.colorPrimaryHover
  });
}
const kDe = (e) => {
  const {
    componentCls: t,
    inputPaddingHorizontal: n,
    paddingLG: o
  } = e, l = `${t}-textarea`;
  return {
    [l]: {
      position: "relative",
      [`${l}-suffix`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: n,
        bottom: 0,
        zIndex: 1,
        display: "inline-flex",
        alignItems: "center",
        margin: "auto"
      },
      "&-status-error,\n        &-status-warning,\n        &-status-success,\n        &-status-validating": {
        [`&${l}-has-feedback`]: {
          [`${t}`]: {
            paddingInlineEnd: o
          }
        }
      },
      "&-show-count": {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${t}`]: {
          height: "100%"
        },
        "&::after": {
          color: e.colorTextDescription,
          whiteSpace: "nowrap",
          content: "attr(data-count)",
          pointerEvents: "none",
          float: "right"
        }
      },
      "&-rtl": {
        "&::after": {
          float: "left"
        }
      }
    }
  };
}, _T = Zt("Input", (e) => {
  const t = gd(e);
  return [
    ODe(t),
    kDe(t),
    IDe(t),
    TDe(t),
    PDe(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    Rp(t)
  ];
}), Mw = (e, t, n, o) => {
  const {
    lineHeight: l
  } = e, r = Math.floor(n * l) + 2, a = Math.max((t - r) / 2, 0), i = Math.max(t - r - a, 0);
  return {
    padding: `${a}px ${o}px ${i}px`
  };
}, NDe = (e) => {
  const {
    componentCls: t,
    pickerCellCls: n,
    pickerCellInnerCls: o,
    pickerPanelCellHeight: l,
    motionDurationSlow: r,
    borderRadiusSM: a,
    motionDurationMid: i,
    controlItemBgHover: s,
    lineWidth: c,
    lineType: u,
    colorPrimary: d,
    controlItemBgActive: f,
    colorTextLightSolid: p,
    controlHeightSM: m,
    pickerDateHoverRangeBorderColor: v,
    pickerCellBorderGap: h,
    pickerBasicCellHoverWithRangeColor: g,
    pickerPanelCellWidth: y,
    colorTextDisabled: b,
    colorBgContainerDisabled: C
  } = e;
  return {
    "&::before": {
      position: "absolute",
      top: "50%",
      insetInlineStart: 0,
      insetInlineEnd: 0,
      zIndex: 1,
      height: l,
      transform: "translateY(-50%)",
      transition: `all ${r}`,
      content: '""'
    },
    // >>> Default
    [o]: {
      position: "relative",
      zIndex: 2,
      display: "inline-block",
      minWidth: l,
      height: l,
      lineHeight: `${l}px`,
      borderRadius: a,
      transition: `background ${i}, border ${i}`
    },
    // >>> Hover
    [`&:hover:not(${n}-in-view),
    &:hover:not(${n}-selected):not(${n}-range-start):not(${n}-range-end):not(${n}-range-hover-start):not(${n}-range-hover-end)`]: {
      [o]: {
        background: s
      }
    },
    // >>> Today
    [`&-in-view${n}-today ${o}`]: {
      "&::before": {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 1,
        border: `${c}px ${u} ${d}`,
        borderRadius: a,
        content: '""'
      }
    },
    // >>> In Range
    [`&-in-view${n}-in-range`]: {
      position: "relative",
      "&::before": {
        background: f
      }
    },
    // >>> Selected
    [`&-in-view${n}-selected ${o},
      &-in-view${n}-range-start ${o},
      &-in-view${n}-range-end ${o}`]: {
      color: p,
      background: d
    },
    [`&-in-view${n}-range-start:not(${n}-range-start-single),
      &-in-view${n}-range-end:not(${n}-range-end-single)`]: {
      "&::before": {
        background: f
      }
    },
    [`&-in-view${n}-range-start::before`]: {
      insetInlineStart: "50%"
    },
    [`&-in-view${n}-range-end::before`]: {
      insetInlineEnd: "50%"
    },
    // >>> Range Hover
    [`&-in-view${n}-range-hover-start:not(${n}-in-range):not(${n}-range-start):not(${n}-range-end),
      &-in-view${n}-range-hover-end:not(${n}-in-range):not(${n}-range-start):not(${n}-range-end),
      &-in-view${n}-range-hover-start${n}-range-start-single,
      &-in-view${n}-range-hover-start${n}-range-start${n}-range-end${n}-range-end-near-hover,
      &-in-view${n}-range-hover-end${n}-range-start${n}-range-end${n}-range-start-near-hover,
      &-in-view${n}-range-hover-end${n}-range-end-single,
      &-in-view${n}-range-hover:not(${n}-in-range)`]: {
      "&::after": {
        position: "absolute",
        top: "50%",
        zIndex: 0,
        height: m,
        borderTop: `${c}px dashed ${v}`,
        borderBottom: `${c}px dashed ${v}`,
        transform: "translateY(-50%)",
        transition: `all ${r}`,
        content: '""'
      }
    },
    // Add space for stash
    "&-range-hover-start::after,\n      &-range-hover-end::after,\n      &-range-hover::after": {
      insetInlineEnd: 0,
      insetInlineStart: h
    },
    // Hover with in range
    [`&-in-view${n}-in-range${n}-range-hover::before,
      &-in-view${n}-range-start${n}-range-hover::before,
      &-in-view${n}-range-end${n}-range-hover::before,
      &-in-view${n}-range-start:not(${n}-range-start-single)${n}-range-hover-start::before,
      &-in-view${n}-range-end:not(${n}-range-end-single)${n}-range-hover-end::before,
      ${t}-panel
      > :not(${t}-date-panel)
      &-in-view${n}-in-range${n}-range-hover-start::before,
      ${t}-panel
      > :not(${t}-date-panel)
      &-in-view${n}-in-range${n}-range-hover-end::before`]: {
      background: g
    },
    // range start border-radius
    [`&-in-view${n}-range-start:not(${n}-range-start-single):not(${n}-range-end) ${o}`]: {
      borderStartStartRadius: a,
      borderEndStartRadius: a,
      borderStartEndRadius: 0,
      borderEndEndRadius: 0
    },
    // range end border-radius
    [`&-in-view${n}-range-end:not(${n}-range-end-single):not(${n}-range-start) ${o}`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      borderStartEndRadius: a,
      borderEndEndRadius: a
    },
    [`&-range-hover${n}-range-end::after`]: {
      insetInlineStart: "50%"
    },
    // Edge start
    [`tr > &-in-view${n}-range-hover:first-child::after,
      tr > &-in-view${n}-range-hover-end:first-child::after,
      &-in-view${n}-start${n}-range-hover-edge-start${n}-range-hover-edge-start-near-range::after,
      &-in-view${n}-range-hover-edge-start:not(${n}-range-hover-edge-start-near-range)::after,
      &-in-view${n}-range-hover-start::after`]: {
      insetInlineStart: (y - l) / 2,
      borderInlineStart: `${c}px dashed ${v}`,
      borderStartStartRadius: c,
      borderEndStartRadius: c
    },
    // Edge end
    [`tr > &-in-view${n}-range-hover:last-child::after,
      tr > &-in-view${n}-range-hover-start:last-child::after,
      &-in-view${n}-end${n}-range-hover-edge-end${n}-range-hover-edge-end-near-range::after,
      &-in-view${n}-range-hover-edge-end:not(${n}-range-hover-edge-end-near-range)::after,
      &-in-view${n}-range-hover-end::after`]: {
      insetInlineEnd: (y - l) / 2,
      borderInlineEnd: `${c}px dashed ${v}`,
      borderStartEndRadius: c,
      borderEndEndRadius: c
    },
    // >>> Disabled
    "&-disabled": {
      color: b,
      pointerEvents: "none",
      [o]: {
        background: "transparent"
      },
      "&::before": {
        background: C
      }
    },
    [`&-disabled${n}-today ${o}::before`]: {
      borderColor: b
    }
  };
}, XW = (e) => {
  const {
    componentCls: t,
    pickerCellInnerCls: n,
    pickerYearMonthCellWidth: o,
    pickerControlIconSize: l,
    pickerPanelCellWidth: r,
    paddingSM: a,
    paddingXS: i,
    paddingXXS: s,
    colorBgContainer: c,
    lineWidth: u,
    lineType: d,
    borderRadiusLG: f,
    colorPrimary: p,
    colorTextHeading: m,
    colorSplit: v,
    pickerControlIconBorderWidth: h,
    colorIcon: g,
    pickerTextHeight: y,
    motionDurationMid: b,
    colorIconHover: C,
    fontWeightStrong: w,
    pickerPanelCellHeight: x,
    pickerCellPaddingVertical: E,
    colorTextDisabled: I,
    colorText: T,
    fontSize: P,
    pickerBasicCellHoverWithRangeColor: k,
    motionDurationSlow: N,
    pickerPanelWithoutTimeCellHeight: R,
    pickerQuarterPanelContentHeight: z,
    colorLink: D,
    colorLinkActive: F,
    colorLinkHover: M,
    pickerDateHoverRangeBorderColor: A,
    borderRadiusSM: L,
    colorTextLightSolid: B,
    borderRadius: V,
    controlItemBgHover: j,
    pickerTimePanelColumnHeight: W,
    pickerTimePanelColumnWidth: Y,
    pickerTimePanelCellHeight: U,
    controlItemBgActive: te,
    marginXXS: J
  } = e, re = r * 7 + a * 2 + 4, oe = (re - i * 2) / 3 - o - a;
  return {
    [t]: {
      "&-panel": {
        display: "inline-flex",
        flexDirection: "column",
        textAlign: "center",
        background: c,
        border: `${u}px ${d} ${v}`,
        borderRadius: f,
        outline: "none",
        "&-focused": {
          borderColor: p
        },
        "&-rtl": {
          direction: "rtl",
          [`${t}-prev-icon,
              ${t}-super-prev-icon`]: {
            transform: "rotate(45deg)"
          },
          [`${t}-next-icon,
              ${t}-super-next-icon`]: {
            transform: "rotate(-135deg)"
          }
        }
      },
      // ========================================================
      // =                     Shared Panel                     =
      // ========================================================
      "&-decade-panel,\n        &-year-panel,\n        &-quarter-panel,\n        &-month-panel,\n        &-week-panel,\n        &-date-panel,\n        &-time-panel": {
        display: "flex",
        flexDirection: "column",
        width: re
      },
      // ======================= Header =======================
      "&-header": {
        display: "flex",
        padding: `0 ${i}px`,
        color: m,
        borderBottom: `${u}px ${d} ${v}`,
        "> *": {
          flex: "none"
        },
        button: {
          padding: 0,
          color: g,
          lineHeight: `${y}px`,
          background: "transparent",
          border: 0,
          cursor: "pointer",
          transition: `color ${b}`
        },
        "> button": {
          minWidth: "1.6em",
          fontSize: P,
          "&:hover": {
            color: C
          }
        },
        "&-view": {
          flex: "auto",
          fontWeight: w,
          lineHeight: `${y}px`,
          button: {
            color: "inherit",
            fontWeight: "inherit",
            verticalAlign: "top",
            "&:not(:first-child)": {
              marginInlineStart: i
            },
            "&:hover": {
              color: p
            }
          }
        }
      },
      // Arrow button
      "&-prev-icon,\n        &-next-icon,\n        &-super-prev-icon,\n        &-super-next-icon": {
        position: "relative",
        display: "inline-block",
        width: l,
        height: l,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          display: "inline-block",
          width: l,
          height: l,
          border: "0 solid currentcolor",
          borderBlockStartWidth: h,
          borderBlockEndWidth: 0,
          borderInlineStartWidth: h,
          borderInlineEndWidth: 0,
          content: '""'
        }
      },
      "&-super-prev-icon,\n        &-super-next-icon": {
        "&::after": {
          position: "absolute",
          top: Math.ceil(l / 2),
          insetInlineStart: Math.ceil(l / 2),
          display: "inline-block",
          width: l,
          height: l,
          border: "0 solid currentcolor",
          borderBlockStartWidth: h,
          borderBlockEndWidth: 0,
          borderInlineStartWidth: h,
          borderInlineEndWidth: 0,
          content: '""'
        }
      },
      "&-prev-icon,\n        &-super-prev-icon": {
        transform: "rotate(-45deg)"
      },
      "&-next-icon,\n        &-super-next-icon": {
        transform: "rotate(135deg)"
      },
      // ======================== Body ========================
      "&-content": {
        width: "100%",
        tableLayout: "fixed",
        borderCollapse: "collapse",
        "th, td": {
          position: "relative",
          minWidth: x,
          fontWeight: "normal"
        },
        th: {
          height: x + E * 2,
          color: T,
          verticalAlign: "middle"
        }
      },
      "&-cell": _({
        padding: `${E}px 0`,
        color: I,
        cursor: "pointer",
        // In view
        "&-in-view": {
          color: T
        }
      }, NDe(e)),
      // DatePanel only
      [`&-date-panel ${t}-cell-in-view${t}-cell-in-range${t}-cell-range-hover-start ${n},
        &-date-panel ${t}-cell-in-view${t}-cell-in-range${t}-cell-range-hover-end ${n}`]: {
        "&::after": {
          position: "absolute",
          top: 0,
          bottom: 0,
          zIndex: -1,
          background: k,
          transition: `all ${N}`,
          content: '""'
        }
      },
      [`&-date-panel
        ${t}-cell-in-view${t}-cell-in-range${t}-cell-range-hover-start
        ${n}::after`]: {
        insetInlineEnd: -(r - x) / 2,
        insetInlineStart: 0
      },
      [`&-date-panel ${t}-cell-in-view${t}-cell-in-range${t}-cell-range-hover-end ${n}::after`]: {
        insetInlineEnd: 0,
        insetInlineStart: -(r - x) / 2
      },
      // Hover with range start & end
      [`&-range-hover${t}-range-start::after`]: {
        insetInlineEnd: "50%"
      },
      "&-decade-panel,\n        &-year-panel,\n        &-quarter-panel,\n        &-month-panel": {
        [`${t}-content`]: {
          height: R * 4
        },
        [n]: {
          padding: `0 ${i}px`
        }
      },
      "&-quarter-panel": {
        [`${t}-content`]: {
          height: z
        }
      },
      // ======================== Footer ========================
      [`&-panel ${t}-footer`]: {
        borderTop: `${u}px ${d} ${v}`
      },
      "&-footer": {
        width: "min-content",
        minWidth: "100%",
        lineHeight: `${y - 2 * u}px`,
        textAlign: "center",
        "&-extra": {
          padding: `0 ${a}`,
          lineHeight: `${y - 2 * u}px`,
          textAlign: "start",
          "&:not(:last-child)": {
            borderBottom: `${u}px ${d} ${v}`
          }
        }
      },
      "&-now": {
        textAlign: "start"
      },
      "&-today-btn": {
        color: D,
        "&:hover": {
          color: M
        },
        "&:active": {
          color: F
        },
        [`&${t}-today-btn-disabled`]: {
          color: I,
          cursor: "not-allowed"
        }
      },
      // ========================================================
      // =                       Special                        =
      // ========================================================
      // ===================== Decade Panel =====================
      "&-decade-panel": {
        [n]: {
          padding: `0 ${i / 2}px`
        },
        [`${t}-cell::before`]: {
          display: "none"
        }
      },
      // ============= Year & Quarter & Month Panel =============
      "&-year-panel,\n        &-quarter-panel,\n        &-month-panel": {
        [`${t}-body`]: {
          padding: `0 ${i}px`
        },
        [n]: {
          width: o
        },
        [`${t}-cell-range-hover-start::after`]: {
          insetInlineStart: oe,
          borderInlineStart: `${u}px dashed ${A}`,
          borderStartStartRadius: L,
          borderBottomStartRadius: L,
          borderStartEndRadius: 0,
          borderBottomEndRadius: 0,
          [`${t}-panel-rtl &`]: {
            insetInlineEnd: oe,
            borderInlineEnd: `${u}px dashed ${A}`,
            borderStartStartRadius: 0,
            borderBottomStartRadius: 0,
            borderStartEndRadius: L,
            borderBottomEndRadius: L
          }
        },
        [`${t}-cell-range-hover-end::after`]: {
          insetInlineEnd: oe,
          borderInlineEnd: `${u}px dashed ${A}`,
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          borderStartEndRadius: V,
          borderEndEndRadius: V,
          [`${t}-panel-rtl &`]: {
            insetInlineStart: oe,
            borderInlineStart: `${u}px dashed ${A}`,
            borderStartStartRadius: V,
            borderEndStartRadius: V,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        }
      },
      // ====================== Week Panel ======================
      "&-week-panel": {
        [`${t}-body`]: {
          padding: `${i}px ${a}px`
        },
        // Clear cell style
        [`${t}-cell`]: {
          [`&:hover ${n},
            &-selected ${n},
            ${n}`]: {
            background: "transparent !important"
          }
        },
        "&-row": {
          td: {
            transition: `background ${b}`,
            "&:first-child": {
              borderStartStartRadius: L,
              borderEndStartRadius: L
            },
            "&:last-child": {
              borderStartEndRadius: L,
              borderEndEndRadius: L
            }
          },
          "&:hover td": {
            background: j
          },
          "&-selected td,\n            &-selected:hover td": {
            background: p,
            [`&${t}-cell-week`]: {
              color: new xn(B).setAlpha(0.5).toHexString()
            },
            [`&${t}-cell-today ${n}::before`]: {
              borderColor: B
            },
            [n]: {
              color: B
            }
          }
        }
      },
      // ====================== Date Panel ======================
      "&-date-panel": {
        [`${t}-body`]: {
          padding: `${i}px ${a}px`
        },
        [`${t}-content`]: {
          width: r * 7,
          th: {
            width: r
          }
        }
      },
      // ==================== Datetime Panel ====================
      "&-datetime-panel": {
        display: "flex",
        [`${t}-time-panel`]: {
          borderInlineStart: `${u}px ${d} ${v}`
        },
        [`${t}-date-panel,
          ${t}-time-panel`]: {
          transition: `opacity ${N}`
        },
        // Keyboard
        "&-active": {
          [`${t}-date-panel,
            ${t}-time-panel`]: {
            opacity: 0.3,
            "&-active": {
              opacity: 1
            }
          }
        }
      },
      // ====================== Time Panel ======================
      "&-time-panel": {
        width: "auto",
        minWidth: "auto",
        direction: "ltr",
        [`${t}-content`]: {
          display: "flex",
          flex: "auto",
          height: W
        },
        "&-column": {
          flex: "1 0 auto",
          width: Y,
          margin: `${s}px 0`,
          padding: 0,
          overflowY: "hidden",
          textAlign: "start",
          listStyle: "none",
          transition: `background ${b}`,
          overflowX: "hidden",
          "&::after": {
            display: "block",
            height: W - U,
            content: '""'
          },
          "&:not(:first-child)": {
            borderInlineStart: `${u}px ${d} ${v}`
          },
          "&-active": {
            background: new xn(te).setAlpha(0.2).toHexString()
          },
          "&:hover": {
            overflowY: "auto"
          },
          "> li": {
            margin: 0,
            padding: 0,
            [`&${t}-time-panel-cell`]: {
              marginInline: J,
              [`${t}-time-panel-cell-inner`]: {
                display: "block",
                width: Y - 2 * J,
                height: U,
                margin: 0,
                paddingBlock: 0,
                paddingInlineEnd: 0,
                paddingInlineStart: (Y - U) / 2,
                color: T,
                lineHeight: `${U}px`,
                borderRadius: L,
                cursor: "pointer",
                transition: `background ${b}`,
                "&:hover": {
                  background: j
                }
              },
              "&-selected": {
                [`${t}-time-panel-cell-inner`]: {
                  background: te
                }
              },
              "&-disabled": {
                [`${t}-time-panel-cell-inner`]: {
                  color: I,
                  background: "transparent",
                  cursor: "not-allowed"
                }
              }
            }
          }
        }
      },
      // https://github.com/ant-design/ant-design/issues/39227
      [`&-datetime-panel ${t}-time-panel-column:after`]: {
        height: W - U + s * 2
      }
    }
  };
}, MDe = (e) => {
  const {
    componentCls: t,
    colorBgContainer: n,
    colorError: o,
    colorErrorOutline: l,
    colorWarning: r,
    colorWarningOutline: a
  } = e;
  return {
    [t]: {
      [`&-status-error${t}`]: {
        "&, &:not([disabled]):hover": {
          backgroundColor: n,
          borderColor: o
        },
        "&-focused, &:focus": _({}, xc(Vt(e, {
          inputBorderActiveColor: o,
          inputBorderHoverColor: o,
          controlOutline: l
        }))),
        [`${t}-active-bar`]: {
          background: o
        }
      },
      [`&-status-warning${t}`]: {
        "&, &:not([disabled]):hover": {
          backgroundColor: n,
          borderColor: r
        },
        "&-focused, &:focus": _({}, xc(Vt(e, {
          inputBorderActiveColor: r,
          inputBorderHoverColor: r,
          controlOutline: a
        }))),
        [`${t}-active-bar`]: {
          background: r
        }
      }
    }
  };
}, ADe = (e) => {
  const {
    componentCls: t,
    antCls: n,
    boxShadowPopoverArrow: o,
    controlHeight: l,
    fontSize: r,
    inputPaddingHorizontal: a,
    colorBgContainer: i,
    lineWidth: s,
    lineType: c,
    colorBorder: u,
    borderRadius: d,
    motionDurationMid: f,
    colorBgContainerDisabled: p,
    colorTextDisabled: m,
    colorTextPlaceholder: v,
    controlHeightLG: h,
    fontSizeLG: g,
    controlHeightSM: y,
    inputPaddingHorizontalSM: b,
    paddingXS: C,
    marginXS: w,
    colorTextDescription: x,
    lineWidthBold: E,
    lineHeight: I,
    colorPrimary: T,
    motionDurationSlow: P,
    zIndexPopup: k,
    paddingXXS: N,
    paddingSM: R,
    pickerTextHeight: z,
    controlItemBgActive: D,
    colorPrimaryBorder: F,
    sizePopupArrow: M,
    borderRadiusXS: A,
    borderRadiusOuter: L,
    colorBgElevated: B,
    borderRadiusLG: V,
    boxShadowSecondary: j,
    borderRadiusSM: W,
    colorSplit: Y,
    controlItemBgHover: U,
    presetsWidth: te,
    presetsMaxWidth: J
  } = e;
  return [
    {
      [t]: _(_(_({}, nn(e)), Mw(e, l, r, a)), {
        position: "relative",
        display: "inline-flex",
        alignItems: "center",
        background: i,
        lineHeight: 1,
        border: `${s}px ${c} ${u}`,
        borderRadius: d,
        transition: `border ${f}, box-shadow ${f}`,
        "&:hover, &-focused": _({}, Bp(e)),
        "&-focused": _({}, xc(e)),
        [`&${t}-disabled`]: {
          background: p,
          borderColor: u,
          cursor: "not-allowed",
          [`${t}-suffix`]: {
            color: m
          }
        },
        [`&${t}-borderless`]: {
          backgroundColor: "transparent !important",
          borderColor: "transparent !important",
          boxShadow: "none !important"
        },
        // ======================== Input =========================
        [`${t}-input`]: {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          width: "100%",
          "> input": _(_({}, hd(e)), {
            flex: "auto",
            // Fix Firefox flex not correct:
            // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
            minWidth: 1,
            height: "auto",
            padding: 0,
            background: "transparent",
            border: 0,
            "&:focus": {
              boxShadow: "none"
            },
            "&[disabled]": {
              background: "transparent"
            }
          }),
          "&:hover": {
            [`${t}-clear`]: {
              opacity: 1
            }
          },
          "&-placeholder": {
            "> input": {
              color: v
            }
          }
        },
        // Size
        "&-large": _(_({}, Mw(e, h, g, a)), {
          [`${t}-input > input`]: {
            fontSize: g
          }
        }),
        "&-small": _({}, Mw(e, y, r, b)),
        [`${t}-suffix`]: {
          display: "flex",
          flex: "none",
          alignSelf: "center",
          marginInlineStart: C / 2,
          color: m,
          lineHeight: 1,
          pointerEvents: "none",
          "> *": {
            verticalAlign: "top",
            "&:not(:last-child)": {
              marginInlineEnd: w
            }
          }
        },
        [`${t}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineEnd: 0,
          color: m,
          lineHeight: 1,
          background: i,
          transform: "translateY(-50%)",
          cursor: "pointer",
          opacity: 0,
          transition: `opacity ${f}, color ${f}`,
          "> *": {
            verticalAlign: "top"
          },
          "&:hover": {
            color: x
          }
        },
        [`${t}-separator`]: {
          position: "relative",
          display: "inline-block",
          width: "1em",
          height: g,
          color: m,
          fontSize: g,
          verticalAlign: "top",
          cursor: "default",
          [`${t}-focused &`]: {
            color: x
          },
          [`${t}-range-separator &`]: {
            [`${t}-disabled &`]: {
              cursor: "not-allowed"
            }
          }
        },
        // ======================== Range =========================
        "&-range": {
          position: "relative",
          display: "inline-flex",
          // Clear
          [`${t}-clear`]: {
            insetInlineEnd: a
          },
          "&:hover": {
            [`${t}-clear`]: {
              opacity: 1
            }
          },
          // Active bar
          [`${t}-active-bar`]: {
            bottom: -s,
            height: E,
            marginInlineStart: a,
            background: T,
            opacity: 0,
            transition: `all ${P} ease-out`,
            pointerEvents: "none"
          },
          [`&${t}-focused`]: {
            [`${t}-active-bar`]: {
              opacity: 1
            }
          },
          [`${t}-range-separator`]: {
            alignItems: "center",
            padding: `0 ${C}px`,
            lineHeight: 1
          },
          [`&${t}-small`]: {
            [`${t}-clear`]: {
              insetInlineEnd: b
            },
            [`${t}-active-bar`]: {
              marginInlineStart: b
            }
          }
        },
        // ======================= Dropdown =======================
        "&-dropdown": _(_(_({}, nn(e)), XW(e)), {
          position: "absolute",
          // Fix incorrect position of picker popup
          // https://github.com/ant-design/ant-design/issues/35590
          top: -9999,
          left: {
            _skip_check_: !0,
            value: -9999
          },
          zIndex: k,
          [`&${t}-dropdown-hidden`]: {
            display: "none"
          },
          [`&${t}-dropdown-placement-bottomLeft`]: {
            [`${t}-range-arrow`]: {
              top: 0,
              display: "block",
              transform: "translateY(-100%)"
            }
          },
          [`&${t}-dropdown-placement-topLeft`]: {
            [`${t}-range-arrow`]: {
              bottom: 0,
              display: "block",
              transform: "translateY(100%) rotate(180deg)"
            }
          },
          [`&${n}-slide-up-enter${n}-slide-up-enter-active${t}-dropdown-placement-topLeft,
          &${n}-slide-up-enter${n}-slide-up-enter-active${t}-dropdown-placement-topRight,
          &${n}-slide-up-appear${n}-slide-up-appear-active${t}-dropdown-placement-topLeft,
          &${n}-slide-up-appear${n}-slide-up-appear-active${t}-dropdown-placement-topRight`]: {
            animationName: CS
          },
          [`&${n}-slide-up-enter${n}-slide-up-enter-active${t}-dropdown-placement-bottomLeft,
          &${n}-slide-up-enter${n}-slide-up-enter-active${t}-dropdown-placement-bottomRight,
          &${n}-slide-up-appear${n}-slide-up-appear-active${t}-dropdown-placement-bottomLeft,
          &${n}-slide-up-appear${n}-slide-up-appear-active${t}-dropdown-placement-bottomRight`]: {
            animationName: yS
          },
          [`&${n}-slide-up-leave${n}-slide-up-leave-active${t}-dropdown-placement-topLeft,
          &${n}-slide-up-leave${n}-slide-up-leave-active${t}-dropdown-placement-topRight`]: {
            animationName: wS
          },
          [`&${n}-slide-up-leave${n}-slide-up-leave-active${t}-dropdown-placement-bottomLeft,
          &${n}-slide-up-leave${n}-slide-up-leave-active${t}-dropdown-placement-bottomRight`]: {
            animationName: SS
          },
          // Time picker with additional style
          [`${t}-panel > ${t}-time-panel`]: {
            paddingTop: N
          },
          // ======================== Ranges ========================
          [`${t}-ranges`]: {
            marginBottom: 0,
            padding: `${N}px ${R}px`,
            overflow: "hidden",
            lineHeight: `${z - 2 * s - C / 2}px`,
            textAlign: "start",
            listStyle: "none",
            display: "flex",
            justifyContent: "space-between",
            "> li": {
              display: "inline-block"
            },
            // https://github.com/ant-design/ant-design/issues/23687
            [`${t}-preset > ${n}-tag-blue`]: {
              color: T,
              background: D,
              borderColor: F,
              cursor: "pointer"
            },
            [`${t}-ok`]: {
              marginInlineStart: "auto"
            }
          },
          [`${t}-range-wrapper`]: {
            display: "flex",
            position: "relative"
          },
          [`${t}-range-arrow`]: _({
            position: "absolute",
            zIndex: 1,
            display: "none",
            marginInlineStart: a * 1.5,
            transition: `left ${P} ease-out`
          }, cI(M, A, L, B, o)),
          [`${t}-panel-container`]: {
            overflow: "hidden",
            verticalAlign: "top",
            background: B,
            borderRadius: V,
            boxShadow: j,
            transition: `margin ${P}`,
            // ======================== Layout ========================
            [`${t}-panel-layout`]: {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "stretch"
            },
            // ======================== Preset ========================
            [`${t}-presets`]: {
              display: "flex",
              flexDirection: "column",
              minWidth: te,
              maxWidth: J,
              ul: {
                height: 0,
                flex: "auto",
                listStyle: "none",
                overflow: "auto",
                margin: 0,
                padding: C,
                borderInlineEnd: `${s}px ${c} ${Y}`,
                li: _(_({}, Fo), {
                  borderRadius: W,
                  paddingInline: C,
                  paddingBlock: (y - Math.round(r * I)) / 2,
                  cursor: "pointer",
                  transition: `all ${P}`,
                  "+ li": {
                    marginTop: w
                  },
                  "&:hover": {
                    background: U
                  }
                })
              }
            },
            // ======================== Panels ========================
            [`${t}-panels`]: {
              display: "inline-flex",
              flexWrap: "nowrap",
              direction: "ltr",
              [`${t}-panel`]: {
                borderWidth: `0 0 ${s}px`
              },
              "&:last-child": {
                [`${t}-panel`]: {
                  borderWidth: 0
                }
              }
            },
            [`${t}-panel`]: {
              verticalAlign: "top",
              background: "transparent",
              borderRadius: 0,
              borderWidth: 0,
              [`${t}-content,
            table`]: {
                textAlign: "center"
              },
              "&-focused": {
                borderColor: u
              }
            }
          }
        }),
        "&-dropdown-range": {
          padding: `${M * 2 / 3}px 0`,
          "&-hidden": {
            display: "none"
          }
        },
        "&-rtl": {
          direction: "rtl",
          [`${t}-separator`]: {
            transform: "rotate(180deg)"
          },
          [`${t}-footer`]: {
            "&-extra": {
              direction: "rtl"
            }
          }
        }
      })
    },
    // Follow code may reuse in other components
    _i(e, "slide-up"),
    _i(e, "slide-down"),
    cp(e, "move-up"),
    cp(e, "move-down")
  ];
}, qW = (e) => {
  const {
    componentCls: n,
    controlHeightLG: o,
    controlHeightSM: l,
    colorPrimary: r,
    paddingXXS: a
  } = e;
  return {
    pickerCellCls: `${n}-cell`,
    pickerCellInnerCls: `${n}-cell-inner`,
    pickerTextHeight: o,
    pickerPanelCellWidth: l * 1.5,
    pickerPanelCellHeight: l,
    pickerDateHoverRangeBorderColor: new xn(r).lighten(20).toHexString(),
    pickerBasicCellHoverWithRangeColor: new xn(r).lighten(35).toHexString(),
    pickerPanelWithoutTimeCellHeight: o * 1.65,
    pickerYearMonthCellWidth: o * 1.5,
    pickerTimePanelColumnHeight: 28 * 8,
    pickerTimePanelColumnWidth: o * 1.4,
    pickerTimePanelCellHeight: 28,
    pickerQuarterPanelContentHeight: o * 1.4,
    pickerCellPaddingVertical: a,
    pickerCellBorderGap: 2,
    pickerControlIconSize: 7,
    pickerControlIconBorderWidth: 1.5
  };
}, JW = Zt("DatePicker", (e) => {
  const t = Vt(gd(e), qW(e));
  return [
    ADe(t),
    MDe(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    Rp(e, {
      focusElCls: `${e.componentCls}-focused`
    })
  ];
}, (e) => ({
  presetsWidth: 120,
  presetsMaxWidth: 200,
  zIndexPopup: e.zIndexPopupBase + 50
})), RDe = (e) => {
  const {
    calendarCls: t,
    componentCls: n,
    calendarFullBg: o,
    calendarFullPanelBg: l,
    calendarItemActiveBg: r
  } = e;
  return {
    [t]: _(_(_({}, XW(e)), nn(e)), {
      background: o,
      "&-rtl": {
        direction: "rtl"
      },
      [`${t}-header`]: {
        display: "flex",
        justifyContent: "flex-end",
        padding: `${e.paddingSM}px 0`,
        [`${t}-year-select`]: {
          minWidth: e.yearControlWidth
        },
        [`${t}-month-select`]: {
          minWidth: e.monthControlWidth,
          marginInlineStart: e.marginXS
        },
        [`${t}-mode-switch`]: {
          marginInlineStart: e.marginXS
        }
      }
    }),
    [`${t} ${n}-panel`]: {
      background: l,
      border: 0,
      borderTop: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`,
      borderRadius: 0,
      [`${n}-month-panel, ${n}-date-panel`]: {
        width: "auto"
      },
      [`${n}-body`]: {
        padding: `${e.paddingXS}px 0`
      },
      [`${n}-content`]: {
        width: "100%"
      }
    },
    [`${t}-mini`]: {
      borderRadius: e.borderRadiusLG,
      [`${t}-header`]: {
        paddingInlineEnd: e.paddingXS,
        paddingInlineStart: e.paddingXS
      },
      [`${n}-panel`]: {
        borderRadius: `0 0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px`
      },
      [`${n}-content`]: {
        height: e.miniContentHeight,
        th: {
          height: "auto",
          padding: 0,
          lineHeight: `${e.weekHeight}px`
        }
      },
      [`${n}-cell::before`]: {
        pointerEvents: "none"
      }
    },
    [`${t}${t}-full`]: {
      [`${n}-panel`]: {
        display: "block",
        width: "100%",
        textAlign: "end",
        background: o,
        border: 0,
        [`${n}-body`]: {
          "th, td": {
            padding: 0
          },
          th: {
            height: "auto",
            paddingInlineEnd: e.paddingSM,
            paddingBottom: e.paddingXXS,
            lineHeight: `${e.weekHeight}px`
          }
        }
      },
      [`${n}-cell`]: {
        "&::before": {
          display: "none"
        },
        "&:hover": {
          [`${t}-date`]: {
            background: e.controlItemBgHover
          }
        },
        [`${t}-date-today::before`]: {
          display: "none"
        },
        // >>> Selected
        [`&-in-view${n}-cell-selected`]: {
          [`${t}-date, ${t}-date-today`]: {
            background: r
          }
        },
        "&-selected, &-selected:hover": {
          [`${t}-date, ${t}-date-today`]: {
            [`${t}-date-value`]: {
              color: e.colorPrimary
            }
          }
        }
      },
      [`${t}-date`]: {
        display: "block",
        width: "auto",
        height: "auto",
        margin: `0 ${e.marginXS / 2}px`,
        padding: `${e.paddingXS / 2}px ${e.paddingXS}px 0`,
        border: 0,
        borderTop: `${e.lineWidthBold}px ${e.lineType} ${e.colorSplit}`,
        borderRadius: 0,
        transition: `background ${e.motionDurationSlow}`,
        "&-value": {
          lineHeight: `${e.dateValueHeight}px`,
          transition: `color ${e.motionDurationSlow}`
        },
        "&-content": {
          position: "static",
          width: "auto",
          height: e.dateContentHeight,
          overflowY: "auto",
          color: e.colorText,
          lineHeight: e.lineHeight,
          textAlign: "start"
        },
        "&-today": {
          borderColor: e.colorPrimary,
          [`${t}-date-value`]: {
            color: e.colorText
          }
        }
      }
    },
    [`@media only screen and (max-width: ${e.screenXS}px) `]: {
      [`${t}`]: {
        [`${t}-header`]: {
          display: "block",
          [`${t}-year-select`]: {
            width: "50%"
          },
          [`${t}-month-select`]: {
            width: `calc(50% - ${e.paddingXS}px)`
          },
          [`${t}-mode-switch`]: {
            width: "100%",
            marginTop: e.marginXS,
            marginInlineStart: 0,
            "> label": {
              width: "50%",
              textAlign: "center"
            }
          }
        }
      }
    }
  };
}, DDe = Zt("Calendar", (e) => {
  const t = `${e.componentCls}-calendar`, n = Vt(gd(e), qW(e), {
    calendarCls: t,
    pickerCellInnerCls: `${e.componentCls}-cell-inner`,
    calendarFullBg: e.colorBgContainer,
    calendarFullPanelBg: e.colorBgContainer,
    calendarItemActiveBg: e.controlItemBgActive,
    dateValueHeight: e.controlHeightSM,
    weekHeight: e.controlHeightSM * 0.75,
    dateContentHeight: (e.fontSizeSM * e.lineHeightSM + e.marginXS) * 3 + e.lineWidth * 2
  });
  return [RDe(n)];
}, {
  yearControlWidth: 80,
  monthControlWidth: 70,
  miniContentHeight: 256
});
function LDe(e) {
  function t(r, a) {
    return r && a && e.getYear(r) === e.getYear(a);
  }
  function n(r, a) {
    return t(r, a) && e.getMonth(r) === e.getMonth(a);
  }
  function o(r, a) {
    return n(r, a) && e.getDate(r) === e.getDate(a);
  }
  const l = /* @__PURE__ */ le({
    name: "ACalendar",
    inheritAttrs: !1,
    props: {
      prefixCls: String,
      locale: {
        type: Object,
        default: void 0
      },
      validRange: {
        type: Array,
        default: void 0
      },
      disabledDate: {
        type: Function,
        default: void 0
      },
      dateFullCellRender: {
        type: Function,
        default: void 0
      },
      dateCellRender: {
        type: Function,
        default: void 0
      },
      monthFullCellRender: {
        type: Function,
        default: void 0
      },
      monthCellRender: {
        type: Function,
        default: void 0
      },
      headerRender: {
        type: Function,
        default: void 0
      },
      value: {
        type: [Object, String],
        default: void 0
      },
      defaultValue: {
        type: [Object, String],
        default: void 0
      },
      mode: {
        type: String,
        default: void 0
      },
      fullscreen: {
        type: Boolean,
        default: void 0
      },
      onChange: {
        type: Function,
        default: void 0
      },
      "onUpdate:value": {
        type: Function,
        default: void 0
      },
      onPanelChange: {
        type: Function,
        default: void 0
      },
      onSelect: {
        type: Function,
        default: void 0
      },
      valueFormat: {
        type: String,
        default: void 0
      }
    },
    slots: Object,
    setup(r, a) {
      let {
        emit: i,
        slots: s,
        attrs: c
      } = a;
      const u = r, {
        prefixCls: d,
        direction: f
      } = bt("picker", u), [p, m] = DDe(d), v = O(() => `${d.value}-calendar`), h = (D) => u.valueFormat ? e.toString(D, u.valueFormat) : D, g = O(() => u.value ? u.valueFormat ? e.toDate(u.value, u.valueFormat) : u.value : u.value === "" ? void 0 : u.value), y = O(() => u.defaultValue ? u.valueFormat ? e.toDate(u.defaultValue, u.valueFormat) : u.defaultValue : u.defaultValue === "" ? void 0 : u.defaultValue), [b, C] = ro(() => g.value || e.getNow(), {
        defaultValue: y.value,
        value: g
      }), [w, x] = ro("month", {
        value: /* @__PURE__ */ ft(u, "mode")
      }), E = O(() => w.value === "year" ? "month" : "date"), I = O(() => (D) => {
        var F;
        return (u.validRange ? e.isAfter(u.validRange[0], D) || e.isAfter(D, u.validRange[1]) : !1) || !!(!((F = u.disabledDate) === null || F === void 0) && F.call(u, D));
      }), T = (D, F) => {
        i("panelChange", h(D), F);
      }, P = (D) => {
        if (C(D), !o(D, b.value)) {
          (E.value === "date" && !n(D, b.value) || E.value === "month" && !t(D, b.value)) && T(D, w.value);
          const F = h(D);
          i("update:value", F), i("change", F);
        }
      }, k = (D) => {
        x(D), T(b.value, D);
      }, N = (D, F) => {
        P(D), i("select", h(D), {
          source: F
        });
      }, R = O(() => {
        const {
          locale: D
        } = u, F = _(_({}, _m), D);
        return F.lang = _(_({}, F.lang), (D || {}).lang), F;
      }), [z] = fa("Calendar", R);
      return () => {
        const D = e.getNow(), {
          dateFullCellRender: F = s == null ? void 0 : s.dateFullCellRender,
          dateCellRender: M = s == null ? void 0 : s.dateCellRender,
          monthFullCellRender: A = s == null ? void 0 : s.monthFullCellRender,
          monthCellRender: L = s == null ? void 0 : s.monthCellRender,
          headerRender: B = s == null ? void 0 : s.headerRender,
          fullscreen: V = !0,
          validRange: j
        } = u, W = (U) => {
          let {
            current: te
          } = U;
          return F ? F({
            current: te
          }) : $("div", {
            class: ke(`${d.value}-cell-inner`, `${v.value}-date`, {
              [`${v.value}-date-today`]: o(D, te)
            })
          }, [$("div", {
            class: `${v.value}-date-value`
          }, [String(e.getDate(te)).padStart(2, "0")]), $("div", {
            class: `${v.value}-date-content`
          }, [M && M({
            current: te
          })])]);
        }, Y = (U, te) => {
          let {
            current: J
          } = U;
          if (A)
            return A({
              current: J
            });
          const re = te.shortMonths || e.locale.getShortMonths(te.locale);
          return $("div", {
            class: ke(`${d.value}-cell-inner`, `${v.value}-date`, {
              [`${v.value}-date-today`]: n(D, J)
            })
          }, [$("div", {
            class: `${v.value}-date-value`
          }, [re[e.getMonth(J)]]), $("div", {
            class: `${v.value}-date-content`
          }, [L && L({
            current: J
          })])]);
        };
        return p($("div", Q(Q({}, c), {}, {
          class: ke(v.value, {
            [`${v.value}-full`]: V,
            [`${v.value}-mini`]: !V,
            [`${v.value}-rtl`]: f.value === "rtl"
          }, c.class, m.value)
        }), [B ? B({
          value: b.value,
          type: w.value,
          onChange: (U) => {
            N(U, "customize");
          },
          onTypeChange: k
        }) : $(EDe, {
          prefixCls: v.value,
          value: b.value,
          generateConfig: e,
          mode: w.value,
          fullscreen: V,
          locale: z.value.lang,
          validRange: j,
          onChange: N,
          onModeChange: k
        }, null), $(CT, {
          value: b.value,
          prefixCls: d.value,
          locale: z.value.lang,
          generateConfig: e,
          dateRender: W,
          monthCellRender: (U) => Y(U, z.value.lang),
          onSelect: (U) => {
            N(U, E.value);
          },
          mode: E.value,
          picker: E.value,
          disabledDate: I.value,
          hideHeader: !0
        }, null)]));
      };
    }
  });
  return l.install = function(r) {
    return r.component(l.name, l), r;
  }, l;
}
const BDe = LDe(nT), FDe = po(BDe);
function VDe(e) {
  const t = /* @__PURE__ */ Ce(), n = /* @__PURE__ */ Ce(!1);
  function o() {
    for (var l = arguments.length, r = new Array(l), a = 0; a < l; a++)
      r[a] = arguments[a];
    n.value || (rn.cancel(t.value), t.value = rn(() => {
      e(...r);
    }));
  }
  return yt(() => {
    n.value = !0, rn.cancel(t.value);
  }), o;
}
function zDe(e) {
  const t = /* @__PURE__ */ Ce([]), n = /* @__PURE__ */ Ce(typeof e == "function" ? e() : e), o = VDe(() => {
    let r = n.value;
    t.value.forEach((a) => {
      r = a(r);
    }), t.value = [], n.value = r;
  });
  function l(r) {
    t.value.push(r), o();
  }
  return [n, l];
}
const HDe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "TabNode",
  props: {
    id: {
      type: String
    },
    prefixCls: {
      type: String
    },
    tab: {
      type: Object
    },
    active: {
      type: Boolean
    },
    closable: {
      type: Boolean
    },
    editable: {
      type: Object
    },
    onClick: {
      type: Function
    },
    onResize: {
      type: Function
    },
    renderWrapper: {
      type: Function
    },
    removeAriaLabel: {
      type: String
    },
    // onRemove: { type: Function as PropType<() => void> },
    onFocus: {
      type: Function
    }
  },
  emits: ["click", "resize", "remove", "focus"],
  setup(e, t) {
    let {
      expose: n,
      attrs: o
    } = t;
    const l = /* @__PURE__ */ H();
    function r(s) {
      var c;
      !((c = e.tab) === null || c === void 0) && c.disabled || e.onClick(s);
    }
    n({
      domRef: l
    });
    function a(s) {
      var c;
      s.preventDefault(), s.stopPropagation(), e.editable.onEdit("remove", {
        key: (c = e.tab) === null || c === void 0 ? void 0 : c.key,
        event: s
      });
    }
    const i = O(() => {
      var s;
      return e.editable && e.closable !== !1 && !(!((s = e.tab) === null || s === void 0) && s.disabled);
    });
    return () => {
      var s;
      const {
        prefixCls: c,
        id: u,
        active: d,
        tab: {
          key: f,
          tab: p,
          disabled: m,
          closeIcon: v
        },
        renderWrapper: h,
        removeAriaLabel: g,
        editable: y,
        onFocus: b
      } = e, C = `${c}-tab`, w = $("div", {
        key: f,
        ref: l,
        class: ke(C, {
          [`${C}-with-remove`]: i.value,
          [`${C}-active`]: d,
          [`${C}-disabled`]: m
        }),
        style: o.style,
        onClick: r
      }, [$("div", {
        role: "tab",
        "aria-selected": d,
        id: u && `${u}-tab-${f}`,
        class: `${C}-btn`,
        "aria-controls": u && `${u}-panel-${f}`,
        "aria-disabled": m,
        tabindex: m ? null : 0,
        onClick: (x) => {
          x.stopPropagation(), r(x);
        },
        onKeydown: (x) => {
          [ot.SPACE, ot.ENTER].includes(x.which) && (x.preventDefault(), r(x));
        },
        onFocus: b
      }, [typeof p == "function" ? p() : p]), i.value && $("button", {
        type: "button",
        "aria-label": g || "remove",
        tabindex: 0,
        class: `${C}-remove`,
        onClick: (x) => {
          x.stopPropagation(), a(x);
        }
      }, [(v == null ? void 0 : v()) || ((s = y.removeIcon) === null || s === void 0 ? void 0 : s.call(y)) || ""])]);
      return h ? h(w) : w;
    };
  }
}), I6 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function jDe(e, t) {
  const n = /* @__PURE__ */ H(/* @__PURE__ */ new Map());
  return Ot(() => {
    var o, l;
    const r = /* @__PURE__ */ new Map(), a = e.value, i = t.value.get((o = a[0]) === null || o === void 0 ? void 0 : o.key) || I6, s = i.left + i.width;
    for (let c = 0; c < a.length; c += 1) {
      const {
        key: u
      } = a[c];
      let d = t.value.get(u);
      d || (d = t.value.get((l = a[c - 1]) === null || l === void 0 ? void 0 : l.key) || I6);
      const f = r.get(u) || _({}, d);
      f.right = s - f.left - f.width, r.set(u, f);
    }
    n.value = new Map(r);
  }), n;
}
const ZW = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AddButton",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    editable: {
      type: Object
    },
    locale: {
      type: Object,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      expose: n,
      attrs: o
    } = t;
    const l = /* @__PURE__ */ H();
    return n({
      domRef: l
    }), () => {
      const {
        prefixCls: r,
        editable: a,
        locale: i
      } = e;
      return !a || a.showAdd === !1 ? null : $("button", {
        ref: l,
        type: "button",
        class: `${r}-nav-add`,
        style: o.style,
        "aria-label": (i == null ? void 0 : i.addAriaLabel) || "Add tab",
        onClick: (s) => {
          a.onEdit("add", {
            event: s
          });
        }
      }, [a.addIcon ? a.addIcon() : "+"]);
    };
  }
}), WDe = {
  prefixCls: {
    type: String
  },
  id: {
    type: String
  },
  tabs: {
    type: Object
  },
  rtl: {
    type: Boolean
  },
  tabBarGutter: {
    type: Number
  },
  activeKey: {
    type: [String, Number]
  },
  mobile: {
    type: Boolean
  },
  moreIcon: de.any,
  moreTransitionName: {
    type: String
  },
  editable: {
    type: Object
  },
  locale: {
    type: Object,
    default: void 0
  },
  removeAriaLabel: String,
  onTabClick: {
    type: Function
  },
  popupClassName: String,
  getPopupContainer: Fe()
}, KDe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "OperationNode",
  inheritAttrs: !1,
  props: WDe,
  emits: ["tabClick"],
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const [l, r] = Bn(!1), [a, i] = Bn(null), s = (p) => {
      const m = e.tabs.filter((g) => !g.disabled);
      let v = m.findIndex((g) => g.key === a.value) || 0;
      const h = m.length;
      for (let g = 0; g < h; g += 1) {
        v = (v + p + h) % h;
        const y = m[v];
        if (!y.disabled) {
          i(y.key);
          return;
        }
      }
    }, c = (p) => {
      const {
        which: m
      } = p;
      if (!l.value) {
        [ot.DOWN, ot.SPACE, ot.ENTER].includes(m) && (r(!0), p.preventDefault());
        return;
      }
      switch (m) {
        case ot.UP:
          s(-1), p.preventDefault();
          break;
        case ot.DOWN:
          s(1), p.preventDefault();
          break;
        case ot.ESC:
          r(!1);
          break;
        case ot.SPACE:
        case ot.ENTER:
          a.value !== null && e.onTabClick(a.value, p);
          break;
      }
    }, u = O(() => `${e.id}-more-popup`), d = O(() => a.value !== null ? `${u.value}-${a.value}` : null), f = (p, m) => {
      p.preventDefault(), p.stopPropagation(), e.editable.onEdit("remove", {
        key: m,
        event: p
      });
    };
    return nt(() => {
      pe(a, () => {
        const p = document.getElementById(d.value);
        p && p.scrollIntoView && p.scrollIntoView(!1);
      }, {
        flush: "post",
        immediate: !0
      });
    }), pe(l, () => {
      l.value || i(null);
    }), ZI({}), () => {
      var p;
      const {
        prefixCls: m,
        id: v,
        tabs: h,
        locale: g,
        mobile: y,
        moreIcon: b = ((p = o.moreIcon) === null || p === void 0 ? void 0 : p.call(o)) || $(Th, null, null),
        moreTransitionName: C,
        editable: w,
        tabBarGutter: x,
        rtl: E,
        onTabClick: I,
        popupClassName: T
      } = e;
      if (!h.length) return null;
      const P = `${m}-dropdown`, k = g == null ? void 0 : g.dropdownAriaLabel, N = {
        [E ? "marginRight" : "marginLeft"]: x
      };
      h.length || (N.visibility = "hidden", N.order = 1);
      const R = ke({
        [`${P}-rtl`]: E,
        [`${T}`]: !0
      }), z = y ? null : $(Gj, {
        prefixCls: P,
        trigger: ["hover"],
        visible: l.value,
        transitionName: C,
        onVisibleChange: r,
        overlayClassName: R,
        mouseEnterDelay: 0.1,
        mouseLeaveDelay: 0.1,
        getPopupContainer: e.getPopupContainer
      }, {
        overlay: () => $(Do, {
          onClick: (D) => {
            let {
              key: F,
              domEvent: M
            } = D;
            I(F, M), r(!1);
          },
          id: u.value,
          tabindex: -1,
          role: "listbox",
          "aria-activedescendant": d.value,
          selectedKeys: [a.value],
          "aria-label": k !== void 0 ? k : "expanded dropdown"
        }, {
          default: () => [h.map((D) => {
            var F, M;
            const A = w && D.closable !== !1 && !D.disabled;
            return $(bi, {
              key: D.key,
              id: `${u.value}-${D.key}`,
              role: "option",
              "aria-controls": v && `${v}-panel-${D.key}`,
              disabled: D.disabled
            }, {
              default: () => [$("span", null, [typeof D.tab == "function" ? D.tab() : D.tab]), A && $("button", {
                type: "button",
                "aria-label": e.removeAriaLabel || "remove",
                tabindex: 0,
                class: `${P}-menu-item-remove`,
                onClick: (L) => {
                  L.stopPropagation(), f(L, D.key);
                }
              }, [((F = D.closeIcon) === null || F === void 0 ? void 0 : F.call(D)) || ((M = w.removeIcon) === null || M === void 0 ? void 0 : M.call(w)) || ""])]
            });
          })]
        }),
        default: () => $("button", {
          type: "button",
          class: `${m}-nav-more`,
          style: N,
          tabindex: -1,
          "aria-hidden": "true",
          "aria-haspopup": "listbox",
          "aria-controls": u.value,
          id: `${v}-more`,
          "aria-expanded": l.value,
          onKeydown: c
        }, [b])
      });
      return $("div", {
        class: ke(`${m}-nav-operations`, n.class),
        style: n.style
      }, [z, $(ZW, {
        prefixCls: m,
        locale: g,
        editable: w
      }, null)]);
    };
  }
}), QW = Symbol("tabsContextKey"), UDe = (e) => {
  at(QW, e);
}, eK = () => ze(QW, {
  tabs: /* @__PURE__ */ H([]),
  prefixCls: /* @__PURE__ */ H()
}), GDe = 0.1, T6 = 0.01, Ab = 20, P6 = Math.pow(0.995, Ab);
function YDe(e, t) {
  const [n, o] = Bn(), [l, r] = Bn(0), [a, i] = Bn(0), [s, c] = Bn(), u = /* @__PURE__ */ H();
  function d(w) {
    const {
      screenX: x,
      screenY: E
    } = w.touches[0];
    o({
      x,
      y: E
    }), clearInterval(u.value);
  }
  function f(w) {
    if (!n.value) return;
    w.preventDefault();
    const {
      screenX: x,
      screenY: E
    } = w.touches[0], I = x - n.value.x, T = E - n.value.y;
    t(I, T), o({
      x,
      y: E
    });
    const P = Date.now();
    i(P - l.value), r(P), c({
      x: I,
      y: T
    });
  }
  function p() {
    if (!n.value) return;
    const w = s.value;
    if (o(null), c(null), w) {
      const x = w.x / a.value, E = w.y / a.value, I = Math.abs(x), T = Math.abs(E);
      if (Math.max(I, T) < GDe) return;
      let P = x, k = E;
      u.value = setInterval(() => {
        if (Math.abs(P) < T6 && Math.abs(k) < T6) {
          clearInterval(u.value);
          return;
        }
        P *= P6, k *= P6, t(P * Ab, k * Ab);
      }, Ab);
    }
  }
  const m = /* @__PURE__ */ H();
  function v(w) {
    const {
      deltaX: x,
      deltaY: E
    } = w;
    let I = 0;
    const T = Math.abs(x), P = Math.abs(E);
    T === P ? I = m.value === "x" ? x : E : T > P ? (I = x, m.value = "x") : (I = E, m.value = "y"), t(-I, -I) && w.preventDefault();
  }
  const h = /* @__PURE__ */ H({
    onTouchStart: d,
    onTouchMove: f,
    onTouchEnd: p,
    onWheel: v
  });
  function g(w) {
    h.value.onTouchStart(w);
  }
  function y(w) {
    h.value.onTouchMove(w);
  }
  function b(w) {
    h.value.onTouchEnd(w);
  }
  function C(w) {
    h.value.onWheel(w);
  }
  nt(() => {
    var w, x;
    document.addEventListener("touchmove", y, {
      passive: !1
    }), document.addEventListener("touchend", b, {
      passive: !1
    }), (w = e.value) === null || w === void 0 || w.addEventListener("touchstart", g, {
      passive: !1
    }), (x = e.value) === null || x === void 0 || x.addEventListener("wheel", C, {
      passive: !1
    });
  }), yt(() => {
    document.removeEventListener("touchmove", y), document.removeEventListener("touchend", b);
  });
}
function k6(e, t) {
  const n = /* @__PURE__ */ H(e);
  function o(l) {
    const r = typeof l == "function" ? l(n.value) : l;
    r !== n.value && t(r, n.value), n.value = r;
  }
  return [n, o];
}
const IT = () => {
  const e = /* @__PURE__ */ H(/* @__PURE__ */ new Map()), t = (n) => (o) => {
    e.value.set(n, o);
  };
  return vp(() => {
    e.value = /* @__PURE__ */ new Map();
  }), [t, e];
}, N6 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
}, XDe = () => ({
  id: {
    type: String
  },
  tabPosition: {
    type: String
  },
  activeKey: {
    type: [String, Number]
  },
  rtl: {
    type: Boolean
  },
  animated: Nt(),
  editable: Nt(),
  moreIcon: de.any,
  moreTransitionName: {
    type: String
  },
  mobile: {
    type: Boolean
  },
  tabBarGutter: {
    type: Number
  },
  renderTabBar: {
    type: Function
  },
  locale: Nt(),
  popupClassName: String,
  getPopupContainer: Fe(),
  onTabClick: {
    type: Function
  },
  onTabScroll: {
    type: Function
  }
}), qDe = (e, t) => {
  const {
    offsetWidth: n,
    offsetHeight: o,
    offsetTop: l,
    offsetLeft: r
  } = e, {
    width: a,
    height: i,
    x: s,
    y: c
  } = e.getBoundingClientRect();
  return Math.abs(a - n) < 1 ? [a, i, s - t.x, c - t.y] : [n, o, r, l];
}, M6 = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "TabNavList",
  inheritAttrs: !1,
  props: XDe(),
  slots: Object,
  emits: ["tabClick", "tabScroll"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      tabs: l,
      prefixCls: r
    } = eK(), a = /* @__PURE__ */ Ce(), i = /* @__PURE__ */ Ce(), s = /* @__PURE__ */ Ce(), c = /* @__PURE__ */ Ce(), [u, d] = IT(), f = O(() => e.tabPosition === "top" || e.tabPosition === "bottom"), [p, m] = k6(0, (he, $e) => {
      f.value && e.onTabScroll && e.onTabScroll({
        direction: he > $e ? "left" : "right"
      });
    }), [v, h] = k6(0, (he, $e) => {
      !f.value && e.onTabScroll && e.onTabScroll({
        direction: he > $e ? "top" : "bottom"
      });
    }), [g, y] = Bn(0), [b, C] = Bn(0), [w, x] = Bn(null), [E, I] = Bn(null), [T, P] = Bn(0), [k, N] = Bn(0), [R, z] = zDe(/* @__PURE__ */ new Map()), D = jDe(l, R), F = O(() => `${r.value}-nav-operations-hidden`), M = /* @__PURE__ */ Ce(0), A = /* @__PURE__ */ Ce(0);
    Ot(() => {
      f.value ? e.rtl ? (M.value = 0, A.value = Math.max(0, g.value - w.value)) : (M.value = Math.min(0, w.value - g.value), A.value = 0) : (M.value = Math.min(0, E.value - b.value), A.value = 0);
    });
    const L = (he) => he < M.value ? M.value : he > A.value ? A.value : he, B = /* @__PURE__ */ Ce(), [V, j] = Bn(), W = () => {
      j(Date.now());
    }, Y = () => {
      clearTimeout(B.value);
    }, U = (he, $e) => {
      he((ne) => L(ne + $e));
    };
    YDe(a, (he, $e) => {
      if (f.value) {
        if (w.value >= g.value)
          return !1;
        U(m, he);
      } else {
        if (E.value >= b.value)
          return !1;
        U(h, $e);
      }
      return Y(), W(), !0;
    }), pe(V, () => {
      Y(), V.value && (B.value = setTimeout(() => {
        j(0);
      }, 100));
    });
    const te = function() {
      let he = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activeKey;
      const $e = D.value.get(he) || {
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0
      };
      if (f.value) {
        let ne = p.value;
        e.rtl ? $e.right < p.value ? ne = $e.right : $e.right + $e.width > p.value + w.value && (ne = $e.right + $e.width - w.value) : $e.left < -p.value ? ne = -$e.left : $e.left + $e.width > -p.value + w.value && (ne = -($e.left + $e.width - w.value)), h(0), m(L(ne));
      } else {
        let ne = v.value;
        $e.top < -v.value ? ne = -$e.top : $e.top + $e.height > -v.value + E.value && (ne = -($e.top + $e.height - E.value)), m(0), h(L(ne));
      }
    }, J = /* @__PURE__ */ Ce(0), re = /* @__PURE__ */ Ce(0);
    Ot(() => {
      let he, $e, ne, ae, ce, xe;
      const Te = D.value;
      ["top", "bottom"].includes(e.tabPosition) ? (he = "width", ae = w.value, ce = g.value, xe = T.value, $e = e.rtl ? "right" : "left", ne = Math.abs(p.value)) : (he = "height", ae = E.value, ce = g.value, xe = k.value, $e = "top", ne = -v.value);
      let Se = ae;
      ce + xe > ae && ce < ae && (Se = ae - xe);
      const be = l.value;
      if (!be.length)
        return [J.value, re.value] = [0, 0];
      const ie = be.length;
      let we = ie;
      for (let tt = 0; tt < ie; tt += 1) {
        const Pe = Te.get(be[tt].key) || N6;
        if (Pe[$e] + Pe[he] > ne + Se) {
          we = tt - 1;
          break;
        }
      }
      let Ne = 0;
      for (let tt = ie - 1; tt >= 0; tt -= 1)
        if ((Te.get(be[tt].key) || N6)[$e] < ne) {
          Ne = tt + 1;
          break;
        }
      return [J.value, re.value] = [Ne, we];
    });
    const oe = () => {
      z(() => {
        var he;
        const $e = /* @__PURE__ */ new Map(), ne = (he = i.value) === null || he === void 0 ? void 0 : he.getBoundingClientRect();
        return l.value.forEach((ae) => {
          let {
            key: ce
          } = ae;
          const xe = d.value.get(ce), Te = (xe == null ? void 0 : xe.$el) || xe;
          if (Te) {
            const [Se, be, ie, we] = qDe(Te, ne);
            $e.set(ce, {
              width: Se,
              height: be,
              left: ie,
              top: we
            });
          }
        }), $e;
      });
    };
    pe(() => l.value.map((he) => he.key).join("%%"), () => {
      oe();
    }, {
      flush: "post"
    });
    const q = () => {
      var he, $e, ne, ae, ce;
      const xe = ((he = a.value) === null || he === void 0 ? void 0 : he.offsetWidth) || 0, Te = (($e = a.value) === null || $e === void 0 ? void 0 : $e.offsetHeight) || 0, Se = ((ne = c.value) === null || ne === void 0 ? void 0 : ne.$el) || {}, be = Se.offsetWidth || 0, ie = Se.offsetHeight || 0;
      x(xe), I(Te), P(be), N(ie);
      const we = (((ae = i.value) === null || ae === void 0 ? void 0 : ae.offsetWidth) || 0) - be, Ne = (((ce = i.value) === null || ce === void 0 ? void 0 : ce.offsetHeight) || 0) - ie;
      y(we), C(Ne), oe();
    }, K = O(() => [...l.value.slice(0, J.value), ...l.value.slice(re.value + 1)]), [se, Z] = Bn(), ee = O(() => D.value.get(e.activeKey)), fe = /* @__PURE__ */ Ce(), me = () => {
      rn.cancel(fe.value);
    };
    pe([ee, f, () => e.rtl], () => {
      const he = {};
      ee.value && (f.value ? (e.rtl ? he.right = ru(ee.value.right) : he.left = ru(ee.value.left), he.width = ru(ee.value.width)) : (he.top = ru(ee.value.top), he.height = ru(ee.value.height))), me(), fe.value = rn(() => {
        Z(he);
      });
    }), pe([() => e.activeKey, ee, D, f], () => {
      te();
    }, {
      flush: "post"
    }), pe([() => e.rtl, () => e.tabBarGutter, () => e.activeKey, () => l.value], () => {
      q();
    }, {
      flush: "post"
    });
    const ge = (he) => {
      let {
        position: $e,
        prefixCls: ne,
        extra: ae
      } = he;
      if (!ae) return null;
      const ce = ae == null ? void 0 : ae({
        position: $e
      });
      return ce ? $("div", {
        class: `${ne}-extra-content`
      }, [ce]) : null;
    };
    return yt(() => {
      Y(), me();
    }), () => {
      const {
        id: he,
        animated: $e,
        activeKey: ne,
        rtl: ae,
        editable: ce,
        locale: xe,
        tabPosition: Te,
        tabBarGutter: Se,
        onTabClick: be
      } = e, {
        class: ie,
        style: we
      } = n, Ne = r.value, tt = !!K.value.length, Pe = `${Ne}-nav-wrap`;
      let Re, Le, Ue, Ae;
      f.value ? ae ? (Le = p.value > 0, Re = p.value + w.value < g.value) : (Re = p.value < 0, Le = -p.value + w.value < g.value) : (Ue = v.value < 0, Ae = -v.value + E.value < b.value);
      const De = {};
      Te === "top" || Te === "bottom" ? De[ae ? "marginRight" : "marginLeft"] = typeof Se == "number" ? `${Se}px` : Se : De.marginTop = typeof Se == "number" ? `${Se}px` : Se;
      const _e = l.value.map((Ze, dt) => {
        const {
          key: Tt
        } = Ze;
        return $(HDe, {
          id: he,
          prefixCls: Ne,
          key: Tt,
          tab: Ze,
          style: dt === 0 ? void 0 : De,
          closable: Ze.closable,
          editable: ce,
          active: Tt === ne,
          removeAriaLabel: xe == null ? void 0 : xe.removeAriaLabel,
          ref: u(Tt),
          onClick: (jt) => {
            be(Tt, jt);
          },
          onFocus: () => {
            te(Tt), W(), a.value && (ae || (a.value.scrollLeft = 0), a.value.scrollTop = 0);
          }
        }, o);
      });
      return $("div", {
        role: "tablist",
        class: ke(`${Ne}-nav`, ie),
        style: we,
        onKeydown: () => {
          W();
        }
      }, [$(ge, {
        position: "left",
        prefixCls: Ne,
        extra: o.leftExtra
      }, null), $(ca, {
        onResize: q
      }, {
        default: () => [$("div", {
          class: ke(Pe, {
            [`${Pe}-ping-left`]: Re,
            [`${Pe}-ping-right`]: Le,
            [`${Pe}-ping-top`]: Ue,
            [`${Pe}-ping-bottom`]: Ae
          }),
          ref: a
        }, [$(ca, {
          onResize: q
        }, {
          default: () => [$("div", {
            ref: i,
            class: `${Ne}-nav-list`,
            style: {
              transform: `translate(${p.value}px, ${v.value}px)`,
              transition: V.value ? "none" : void 0
            }
          }, [_e, $(ZW, {
            ref: c,
            prefixCls: Ne,
            locale: xe,
            editable: ce,
            style: _(_({}, _e.length === 0 ? void 0 : De), {
              visibility: tt ? "hidden" : null
            })
          }, null), $("div", {
            class: ke(`${Ne}-ink-bar`, {
              [`${Ne}-ink-bar-animated`]: $e.inkBar
            }),
            style: se.value
          }, null)])]
        })])]
      }), $(KDe, Q(Q({}, e), {}, {
        removeAriaLabel: xe == null ? void 0 : xe.removeAriaLabel,
        ref: s,
        prefixCls: Ne,
        tabs: K.value,
        class: !tt && F.value
      }), La(o, ["moreIcon"])), $(ge, {
        position: "right",
        prefixCls: Ne,
        extra: o.rightExtra
      }, null), $(ge, {
        position: "right",
        prefixCls: Ne,
        extra: o.tabBarExtraContent
      }, null)]);
    };
  }
}), JDe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "TabPanelList",
  inheritAttrs: !1,
  props: {
    activeKey: {
      type: [String, Number]
    },
    id: {
      type: String
    },
    rtl: {
      type: Boolean
    },
    animated: {
      type: Object,
      default: void 0
    },
    tabPosition: {
      type: String
    },
    destroyInactiveTabPane: {
      type: Boolean
    }
  },
  setup(e) {
    const {
      tabs: t,
      prefixCls: n
    } = eK();
    return () => {
      const {
        id: o,
        activeKey: l,
        animated: r,
        tabPosition: a,
        rtl: i,
        destroyInactiveTabPane: s
      } = e, c = r.tabPane, u = n.value, d = t.value.findIndex((f) => f.key === l);
      return $("div", {
        class: `${u}-content-holder`
      }, [$("div", {
        class: [`${u}-content`, `${u}-content-${a}`, {
          [`${u}-content-animated`]: c
        }],
        style: d && c ? {
          [i ? "marginRight" : "marginLeft"]: `-${d}00%`
        } : null
      }, [t.value.map((f) => _n(f.node, {
        key: f.key,
        prefixCls: u,
        tabKey: f.key,
        id: o,
        animated: c,
        active: f.key === l,
        destroyInactiveTabPane: s
      }))])]);
    };
  }
});
var ZDe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { tag: "path", attrs: { d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, name: "plus", theme: "outlined" };
function A6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      QDe(e, l, n[l]);
    });
  }
  return e;
}
function QDe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var TT = function(t, n) {
  var o = A6({}, t, n.attrs);
  return $(cn, A6({}, o, {
    icon: ZDe
  }), null);
};
TT.displayName = "PlusOutlined";
TT.inheritAttrs = !1;
const e5e = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n
  } = e;
  return [
    {
      [t]: {
        [`${t}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${n}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${n}`
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    [_i(e, "slide-up"), _i(e, "slide-down")]
  ];
}, t5e = (e) => {
  const {
    componentCls: t,
    tabsCardHorizontalPadding: n,
    tabsCardHeadBackground: o,
    tabsCardGutter: l,
    colorSplit: r
  } = e;
  return {
    [`${t}-card`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-tab`]: {
          margin: 0,
          padding: n,
          background: o,
          border: `${e.lineWidth}px ${e.lineType} ${r}`,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseInOut}`
        },
        [`${t}-tab-active`]: {
          color: e.colorPrimary,
          background: e.colorBgContainer
        },
        [`${t}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${t}-top, &${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginLeft: {
              _skip_check_: !0,
              value: `${l}px`
            }
          }
        }
      },
      [`&${t}-top`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`
          },
          [`${t}-tab-active`]: {
            borderBottomColor: e.colorBgContainer
          }
        }
      },
      [`&${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: `0 0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px`
          },
          [`${t}-tab-active`]: {
            borderTopColor: e.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${t}-left, &${t}-right`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginTop: `${l}px`
          }
        }
      },
      [`&${t}-left`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${e.borderRadiusLG}px 0 0 ${e.borderRadiusLG}px`
            }
          },
          [`${t}-tab-active`]: {
            borderRightColor: {
              _skip_check_: !0,
              value: e.colorBgContainer
            }
          }
        }
      },
      [`&${t}-right`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px 0`
            }
          },
          [`${t}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: !0,
              value: e.colorBgContainer
            }
          }
        }
      }
    }
  };
}, n5e = (e) => {
  const {
    componentCls: t,
    tabsHoverColor: n,
    dropdownEdgeChildVerticalPadding: o
  } = e;
  return {
    [`${t}-dropdown`]: _(_({}, nn(e)), {
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: !0,
        value: -9999
      },
      zIndex: e.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${t}-dropdown-menu`]: {
        maxHeight: e.tabsDropdownHeight,
        margin: 0,
        padding: `${o}px 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: !0,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: e.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: e.borderRadiusLG,
        outline: "none",
        boxShadow: e.boxShadowSecondary,
        "&-item": _(_({}, Fo), {
          display: "flex",
          alignItems: "center",
          minWidth: e.tabsDropdownWidth,
          margin: 0,
          padding: `${e.paddingXXS}px ${e.paddingSM}px`,
          color: e.colorText,
          fontWeight: "normal",
          fontSize: e.fontSize,
          lineHeight: e.lineHeight,
          cursor: "pointer",
          transition: `all ${e.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: !0,
              value: e.marginSM
            },
            color: e.colorTextDescription,
            fontSize: e.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: n
            }
          },
          "&:hover": {
            background: e.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: e.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        })
      }
    })
  };
}, o5e = (e) => {
  const {
    componentCls: t,
    margin: n,
    colorSplit: o
  } = e;
  return {
    // ========================== Top & Bottom ==========================
    [`${t}-top, ${t}-bottom`]: {
      flexDirection: "column",
      [`> ${t}-nav, > div > ${t}-nav`]: {
        margin: `0 0 ${n}px 0`,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: !0,
            value: 0
          },
          left: {
            _skip_check_: !0,
            value: 0
          },
          borderBottom: `${e.lineWidth}px ${e.lineType} ${o}`,
          content: "''"
        },
        [`${t}-ink-bar`]: {
          height: e.lineWidthBold,
          "&-animated": {
            transition: `width ${e.motionDurationSlow}, left ${e.motionDurationSlow},
            right ${e.motionDurationSlow}`
          }
        },
        [`${t}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: e.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: e.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: e.boxShadowTabsOverflowRight
          },
          [`&${t}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${t}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${t}-top`]: {
      [`> ${t}-nav,
        > div > ${t}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${t}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${t}-bottom`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        order: 1,
        marginTop: `${n}px`,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${t}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${t}-left, ${t}-right`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        flexDirection: "column",
        minWidth: e.controlHeight * 1.25,
        // >>>>>>>>>>> Tab
        [`${t}-tab`]: {
          padding: `${e.paddingXS}px ${e.paddingLG}px`,
          textAlign: "center"
        },
        [`${t}-tab + ${t}-tab`]: {
          margin: `${e.margin}px 0 0 0`
        },
        // >>>>>>>>>>> Nav
        [`${t}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: e.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: e.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: e.boxShadowTabsOverflowBottom
          },
          [`&${t}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${t}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${t}-ink-bar`]: {
          width: e.lineWidthBold,
          "&-animated": {
            transition: `height ${e.motionDurationSlow}, top ${e.motionDurationSlow}`
          }
        },
        [`${t}-nav-list, ${t}-nav-operations`]: {
          flex: "1 0 auto",
          flexDirection: "column"
        }
      }
    },
    [`${t}-left`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-ink-bar`]: {
          right: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        marginLeft: {
          _skip_check_: !0,
          value: `-${e.lineWidth}px`
        },
        borderLeft: {
          _skip_check_: !0,
          value: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`
        },
        [`> ${t}-content > ${t}-tabpane`]: {
          paddingLeft: {
            _skip_check_: !0,
            value: e.paddingLG
          }
        }
      }
    },
    [`${t}-right`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        order: 1,
        [`${t}-ink-bar`]: {
          left: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: !0,
          value: -e.lineWidth
        },
        borderRight: {
          _skip_check_: !0,
          value: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`
        },
        [`> ${t}-content > ${t}-tabpane`]: {
          paddingRight: {
            _skip_check_: !0,
            value: e.paddingLG
          }
        }
      }
    }
  };
}, l5e = (e) => {
  const {
    componentCls: t,
    padding: n
  } = e;
  return {
    [t]: {
      "&-small": {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: `${e.paddingXS}px 0`,
            fontSize: e.fontSize
          }
        }
      },
      "&-large": {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: `${n}px 0`,
            fontSize: e.fontSizeLG
          }
        }
      }
    },
    [`${t}-card`]: {
      [`&${t}-small`]: {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: `${e.paddingXXS * 1.5}px ${n}px`
          }
        },
        [`&${t}-bottom`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: `0 0 ${e.borderRadius}px ${e.borderRadius}px`
          }
        },
        [`&${t}-top`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: `${e.borderRadius}px ${e.borderRadius}px 0 0`
          }
        },
        [`&${t}-right`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${e.borderRadius}px ${e.borderRadius}px 0`
            }
          }
        },
        [`&${t}-left`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${e.borderRadius}px 0 0 ${e.borderRadius}px`
            }
          }
        }
      },
      [`&${t}-large`]: {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: `${e.paddingXS}px ${n}px ${e.paddingXXS * 1.5}px`
          }
        }
      }
    }
  };
}, r5e = (e) => {
  const {
    componentCls: t,
    tabsActiveColor: n,
    tabsHoverColor: o,
    iconCls: l,
    tabsHorizontalGutter: r
  } = e, a = `${t}-tab`;
  return {
    [a]: {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      padding: `${e.paddingSM}px 0`,
      fontSize: `${e.fontSize}px`,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      "&-btn, &-remove": _({
        "&:focus:not(:focus-visible), &:active": {
          color: n
        }
      }, ys(e)),
      "&-btn": {
        outline: "none",
        transition: "all 0.3s"
      },
      "&-remove": {
        flex: "none",
        marginRight: {
          _skip_check_: !0,
          value: -e.marginXXS
        },
        marginLeft: {
          _skip_check_: !0,
          value: e.marginXS
        },
        color: e.colorTextDescription,
        fontSize: e.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${e.motionDurationSlow}`,
        "&:hover": {
          color: e.colorTextHeading
        }
      },
      "&:hover": {
        color: o
      },
      [`&${a}-active ${a}-btn`]: {
        color: e.colorPrimary,
        textShadow: e.tabsActiveTextShadow
      },
      [`&${a}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${a}-disabled ${a}-btn, &${a}-disabled ${t}-remove`]: {
        "&:focus, &:active": {
          color: e.colorTextDisabled
        }
      },
      [`& ${a}-remove ${l}`]: {
        margin: 0
      },
      [l]: {
        marginRight: {
          _skip_check_: !0,
          value: e.marginSM
        }
      }
    },
    [`${a} + ${a}`]: {
      margin: {
        _skip_check_: !0,
        value: `0 0 0 ${r}px`
      }
    }
  };
}, a5e = (e) => {
  const {
    componentCls: t,
    tabsHorizontalGutter: n,
    iconCls: o,
    tabsCardGutter: l
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl",
      [`${t}-nav`]: {
        [`${t}-tab`]: {
          margin: {
            _skip_check_: !0,
            value: `0 0 0 ${n}px`
          },
          [`${t}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          },
          [o]: {
            marginRight: {
              _skip_check_: !0,
              value: 0
            },
            marginLeft: {
              _skip_check_: !0,
              value: `${e.marginSM}px`
            }
          },
          [`${t}-tab-remove`]: {
            marginRight: {
              _skip_check_: !0,
              value: `${e.marginXS}px`
            },
            marginLeft: {
              _skip_check_: !0,
              value: `-${e.marginXXS}px`
            },
            [o]: {
              margin: 0
            }
          }
        }
      },
      [`&${t}-left`]: {
        [`> ${t}-nav`]: {
          order: 1
        },
        [`> ${t}-content-holder`]: {
          order: 0
        }
      },
      [`&${t}-right`]: {
        [`> ${t}-nav`]: {
          order: 0
        },
        [`> ${t}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${t}-card${t}-top, &${t}-card${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginRight: {
              _skip_check_: !0,
              value: `${l}px`
            },
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          }
        }
      }
    },
    [`${t}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${t}-menu-item`]: {
      [`${t}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: !0,
          value: "right"
        }
      }
    }
  };
}, i5e = (e) => {
  const {
    componentCls: t,
    tabsCardHorizontalPadding: n,
    tabsCardHeight: o,
    tabsCardGutter: l,
    tabsHoverColor: r,
    tabsActiveColor: a,
    colorSplit: i
  } = e;
  return {
    [t]: _(_(_(_({}, nn(e)), {
      display: "flex",
      // ========================== Navigation ==========================
      [`> ${t}-nav, > div > ${t}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${t}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          // >>>>> Ping shadow
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${e.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${t}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${e.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${t}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${t}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${t}-nav-more`]: {
          position: "relative",
          padding: n,
          background: "transparent",
          border: 0,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: !0,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: e.controlHeightLG / 8,
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${t}-nav-add`]: _({
          minWidth: `${o}px`,
          marginLeft: {
            _skip_check_: !0,
            value: `${l}px`
          },
          padding: `0 ${e.paddingXS}px`,
          background: "transparent",
          border: `${e.lineWidth}px ${e.lineType} ${i}`,
          borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`,
          outline: "none",
          cursor: "pointer",
          color: e.colorText,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseInOut}`,
          "&:hover": {
            color: r
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: a
          }
        }, ys(e))
      },
      [`${t}-extra-content`]: {
        flex: "none"
      },
      // ============================ InkBar ============================
      [`${t}-ink-bar`]: {
        position: "absolute",
        background: e.colorPrimary,
        pointerEvents: "none"
      }
    }), r5e(e)), {
      // =========================== TabPanes ===========================
      [`${t}-content`]: {
        position: "relative",
        display: "flex",
        width: "100%",
        "&-animated": {
          transition: "margin 0.3s"
        }
      },
      [`${t}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${t}-tabpane`]: {
        outline: "none",
        flex: "none",
        width: "100%"
      }
    }),
    [`${t}-centered`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-nav-wrap`]: {
          [`&:not([class*='${t}-nav-wrap-ping'])`]: {
            justifyContent: "center"
          }
        }
      }
    }
  };
}, s5e = Zt("Tabs", (e) => {
  const t = e.controlHeightLG, n = Vt(e, {
    tabsHoverColor: e.colorPrimaryHover,
    tabsActiveColor: e.colorPrimaryActive,
    tabsCardHorizontalPadding: `${(t - Math.round(e.fontSize * e.lineHeight)) / 2 - e.lineWidth}px ${e.padding}px`,
    tabsCardHeight: t,
    tabsCardGutter: e.marginXXS / 2,
    tabsHorizontalGutter: 32,
    tabsCardHeadBackground: e.colorFillAlter,
    dropdownEdgeChildVerticalPadding: e.paddingXXS,
    tabsActiveTextShadow: "0 0 0.25px currentcolor",
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120
  });
  return [l5e(n), a5e(n), o5e(n), n5e(n), t5e(n), i5e(n), e5e(n)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 50
}));
let R6 = 0;
const tK = () => ({
  prefixCls: {
    type: String
  },
  id: {
    type: String
  },
  popupClassName: String,
  getPopupContainer: Fe(),
  activeKey: {
    type: [String, Number]
  },
  defaultActiveKey: {
    type: [String, Number]
  },
  direction: At(),
  animated: zt([Boolean, Object]),
  renderTabBar: Fe(),
  tabBarGutter: {
    type: Number
  },
  tabBarStyle: Nt(),
  tabPosition: At(),
  destroyInactiveTabPane: Qe(),
  hideAdd: Boolean,
  type: At(),
  size: At(),
  centered: Boolean,
  onEdit: Fe(),
  onChange: Fe(),
  onTabClick: Fe(),
  onTabScroll: Fe(),
  "onUpdate:activeKey": Fe(),
  // Accessibility
  locale: Nt(),
  onPrevClick: Fe(),
  onNextClick: Fe(),
  tabBarExtraContent: de.any
});
function c5e(e) {
  return e.map((t) => {
    if (Io(t)) {
      const n = _({}, t.props || {});
      for (const [f, p] of Object.entries(n))
        delete n[f], n[Tp(f)] = p;
      const o = t.children || {}, l = t.key !== void 0 ? t.key : void 0, {
        tab: r = o.tab,
        disabled: a,
        forceRender: i,
        closable: s,
        animated: c,
        active: u,
        destroyInactiveTabPane: d
      } = n;
      return _(_({
        key: l
      }, n), {
        node: t,
        closeIcon: o.closeIcon,
        tab: r,
        disabled: a === "" || a,
        forceRender: i === "" || i,
        closable: s === "" || s,
        animated: c === "" || c,
        active: u === "" || u,
        destroyInactiveTabPane: d === "" || d
      });
    }
    return null;
  }).filter((t) => t);
}
const u5e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "InternalTabs",
  inheritAttrs: !1,
  props: _(_({}, sn(tK(), {
    tabPosition: "top",
    animated: {
      inkBar: !0,
      tabPane: !1
    }
  })), {
    tabs: $n()
  }),
  slots: Object,
  // emits: ['tabClick', 'tabScroll', 'change', 'update:activeKey'],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    un(e.onPrevClick === void 0 && e.onNextClick === void 0, "Tabs", "`onPrevClick / @prevClick` and `onNextClick / @nextClick` has been removed. Please use `onTabScroll / @tabScroll` instead."), un(e.tabBarExtraContent === void 0, "Tabs", "`tabBarExtraContent` prop has been removed. Please use `rightExtra` slot instead."), un(o.tabBarExtraContent === void 0, "Tabs", "`tabBarExtraContent` slot is deprecated. Please use `rightExtra` slot instead.");
    const {
      prefixCls: l,
      direction: r,
      size: a,
      rootPrefixCls: i,
      getPopupContainer: s
    } = bt("tabs", e), [c, u] = s5e(l), d = O(() => r.value === "rtl"), f = O(() => {
      const {
        animated: E,
        tabPosition: I
      } = e;
      return E === !1 || ["left", "right"].includes(I) ? {
        inkBar: !1,
        tabPane: !1
      } : E === !0 ? {
        inkBar: !0,
        tabPane: !0
      } : _({
        inkBar: !0,
        tabPane: !1
      }, typeof E == "object" ? E : {});
    }), [p, m] = Bn(!1);
    nt(() => {
      m(_I());
    });
    const [v, h] = ro(() => {
      var E;
      return (E = e.tabs[0]) === null || E === void 0 ? void 0 : E.key;
    }, {
      value: O(() => e.activeKey),
      defaultValue: e.defaultActiveKey
    }), [g, y] = Bn(() => e.tabs.findIndex((E) => E.key === v.value));
    Ot(() => {
      var E;
      let I = e.tabs.findIndex((T) => T.key === v.value);
      I === -1 && (I = Math.max(0, Math.min(g.value, e.tabs.length - 1)), h((E = e.tabs[I]) === null || E === void 0 ? void 0 : E.key)), y(I);
    });
    const [b, C] = ro(null, {
      value: O(() => e.id)
    }), w = O(() => p.value && !["left", "right"].includes(e.tabPosition) ? "top" : e.tabPosition);
    nt(() => {
      e.id || (C(`rc-tabs-${process.env.NODE_ENV === "test" ? "test" : R6}`), R6 += 1);
    });
    const x = (E, I) => {
      var T, P;
      (T = e.onTabClick) === null || T === void 0 || T.call(e, E, I);
      const k = E !== v.value;
      h(E), k && ((P = e.onChange) === null || P === void 0 || P.call(e, E));
    };
    return UDe({
      tabs: O(() => e.tabs),
      prefixCls: l
    }), () => {
      const {
        id: E,
        type: I,
        tabBarGutter: T,
        tabBarStyle: P,
        locale: k,
        destroyInactiveTabPane: N,
        renderTabBar: R = o.renderTabBar,
        onTabScroll: z,
        hideAdd: D,
        centered: F
      } = e, M = {
        id: b.value,
        activeKey: v.value,
        animated: f.value,
        tabPosition: w.value,
        rtl: d.value,
        mobile: p.value
      };
      let A;
      I === "editable-card" && (A = {
        onEdit: (j, W) => {
          let {
            key: Y,
            event: U
          } = W;
          var te;
          (te = e.onEdit) === null || te === void 0 || te.call(e, j === "add" ? U : Y, j);
        },
        removeIcon: () => $(Hl, null, null),
        addIcon: o.addIcon ? o.addIcon : () => $(TT, null, null),
        showAdd: D !== !0
      });
      let L;
      const B = _(_({}, M), {
        moreTransitionName: `${i.value}-slide-up`,
        editable: A,
        locale: k,
        tabBarGutter: T,
        onTabClick: x,
        onTabScroll: z,
        style: P,
        getPopupContainer: s.value,
        popupClassName: ke(e.popupClassName, u.value)
      });
      R ? L = R(_(_({}, B), {
        DefaultTabBar: M6
      })) : L = $(M6, B, La(o, ["moreIcon", "leftExtra", "rightExtra", "tabBarExtraContent"]));
      const V = l.value;
      return c($("div", Q(Q({}, n), {}, {
        id: E,
        class: ke(V, `${V}-${w.value}`, {
          [u.value]: !0,
          [`${V}-${a.value}`]: a.value,
          [`${V}-card`]: ["card", "editable-card"].includes(I),
          [`${V}-editable-card`]: I === "editable-card",
          [`${V}-centered`]: F,
          [`${V}-mobile`]: p.value,
          [`${V}-editable`]: I === "editable-card",
          [`${V}-rtl`]: d.value
        }, n.class)
      }), [L, $(JDe, Q(Q({
        destroyInactiveTabPane: N
      }, M), {}, {
        animated: f.value
      }), null)]));
    };
  }
}), Nu = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ATabs",
  inheritAttrs: !1,
  props: sn(tK(), {
    tabPosition: "top",
    animated: {
      inkBar: !0,
      tabPane: !1
    }
  }),
  slots: Object,
  // emits: ['tabClick', 'tabScroll', 'change', 'update:activeKey'],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: l
    } = t;
    const r = (a) => {
      l("update:activeKey", a), l("change", a);
    };
    return () => {
      var a;
      const i = c5e(Fn((a = o.default) === null || a === void 0 ? void 0 : a.call(o)));
      return $(u5e, Q(Q(Q({}, pn(e, ["onUpdate:activeKey"])), n), {}, {
        onChange: r,
        tabs: i
      }), o);
    };
  }
}), d5e = () => ({
  tab: de.any,
  disabled: {
    type: Boolean
  },
  forceRender: {
    type: Boolean
  },
  closable: {
    type: Boolean
  },
  animated: {
    type: Boolean
  },
  active: {
    type: Boolean
  },
  destroyInactiveTabPane: {
    type: Boolean
  },
  // Pass by TabPaneList
  prefixCls: {
    type: String
  },
  tabKey: {
    type: [String, Number]
  },
  id: {
    type: String
  }
  // closeIcon: PropTypes.any,
}), Py = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ATabPane",
  inheritAttrs: !1,
  __ANT_TAB_PANE: !0,
  props: d5e(),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const l = /* @__PURE__ */ H(e.forceRender);
    pe([() => e.active, () => e.destroyInactiveTabPane], () => {
      e.active ? l.value = !0 : e.destroyInactiveTabPane && (l.value = !1);
    }, {
      immediate: !0
    });
    const r = O(() => e.active ? {} : e.animated ? {
      visibility: "hidden",
      height: 0,
      overflowY: "hidden"
    } : {
      display: "none"
    });
    return () => {
      var a;
      const {
        prefixCls: i,
        forceRender: s,
        id: c,
        active: u,
        tabKey: d
      } = e;
      return $("div", {
        id: c && `${c}-panel-${d}`,
        role: "tabpanel",
        tabindex: u ? 0 : -1,
        "aria-labelledby": c && `${c}-tab-${d}`,
        "aria-hidden": !u,
        style: [r.value, n.style],
        class: [`${i}-tabpane`, u && `${i}-tabpane-active`, n.class]
      }, [(u || l.value || s) && ((a = o.default) === null || a === void 0 ? void 0 : a.call(o))]);
    };
  }
});
Nu.TabPane = Py;
Nu.install = function(e) {
  return e.component(Nu.name, Nu), e.component(Py.name, Py), e;
};
const f5e = (e) => {
  const {
    antCls: t,
    componentCls: n,
    cardHeadHeight: o,
    cardPaddingBase: l,
    cardHeadTabsMarginBottom: r
  } = e;
  return _(_({
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: o,
    marginBottom: -1,
    padding: `0 ${l}px`,
    color: e.colorTextHeading,
    fontWeight: e.fontWeightStrong,
    fontSize: e.fontSizeLG,
    background: "transparent",
    borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorBorderSecondary}`,
    borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`
  }, ja()), {
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": _(_({
      display: "inline-block",
      flex: 1
    }, Fo), {
      [`
          > ${n}-typography,
          > ${n}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    }),
    [`${t}-tabs-top`]: {
      clear: "both",
      marginBottom: r,
      color: e.colorText,
      fontWeight: "normal",
      fontSize: e.fontSize,
      "&-bar": {
        borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorBorderSecondary}`
      }
    }
  });
}, p5e = (e) => {
  const {
    cardPaddingBase: t,
    colorBorderSecondary: n,
    cardShadow: o,
    lineWidth: l
  } = e;
  return {
    width: "33.33%",
    padding: t,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${l}px 0 0 0 ${n},
      0 ${l}px 0 0 ${n},
      ${l}px ${l}px 0 0 ${n},
      ${l}px 0 0 0 ${n} inset,
      0 ${l}px 0 0 ${n} inset;
    `,
    transition: `all ${e.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: o
    }
  };
}, v5e = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    cardActionsLiMargin: o,
    cardActionsIconSize: l,
    colorBorderSecondary: r
  } = e;
  return _(_({
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: e.colorBgContainer,
    borderTop: `${e.lineWidth}px ${e.lineType} ${r}`,
    display: "flex",
    borderRadius: `0 0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px `
  }, ja()), {
    "& > li": {
      margin: o,
      color: e.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: e.cardActionsIconSize * 2,
        fontSize: e.fontSize,
        lineHeight: e.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: e.colorPrimary,
          transition: `color ${e.motionDurationMid}`
        },
        [`a:not(${t}-btn), > ${n}`]: {
          display: "inline-block",
          width: "100%",
          color: e.colorTextDescription,
          lineHeight: `${e.fontSize * e.lineHeight}px`,
          transition: `color ${e.motionDurationMid}`,
          "&:hover": {
            color: e.colorPrimary
          }
        },
        [`> ${n}`]: {
          fontSize: l,
          lineHeight: `${l * e.lineHeight}px`
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${e.lineWidth}px ${e.lineType} ${r}`
      }
    }
  });
}, m5e = (e) => _(_({
  margin: `-${e.marginXXS}px 0`,
  display: "flex"
}, ja()), {
  "&-avatar": {
    paddingInlineEnd: e.padding
  },
  "&-detail": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: e.marginXS
    }
  },
  "&-title": _({
    color: e.colorTextHeading,
    fontWeight: e.fontWeightStrong,
    fontSize: e.fontSizeLG
  }, Fo),
  "&-description": {
    color: e.colorTextDescription
  }
}), h5e = (e) => {
  const {
    componentCls: t,
    cardPaddingBase: n,
    colorFillAlter: o
  } = e;
  return {
    [`${t}-head`]: {
      padding: `0 ${n}px`,
      background: o,
      "&-title": {
        fontSize: e.fontSize
      }
    },
    [`${t}-body`]: {
      padding: `${e.padding}px ${n}px`
    }
  };
}, g5e = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    overflow: "hidden",
    [`${t}-body`]: {
      userSelect: "none"
    }
  };
}, b5e = (e) => {
  const {
    componentCls: t,
    cardShadow: n,
    cardHeadPadding: o,
    colorBorderSecondary: l,
    boxShadow: r,
    cardPaddingBase: a
  } = e;
  return {
    [t]: _(_({}, nn(e)), {
      position: "relative",
      background: e.colorBgContainer,
      borderRadius: e.borderRadiusLG,
      [`&:not(${t}-bordered)`]: {
        boxShadow: r
      },
      [`${t}-head`]: f5e(e),
      [`${t}-extra`]: {
        // https://stackoverflow.com/a/22429853/3040605
        marginInlineStart: "auto",
        color: "",
        fontWeight: "normal",
        fontSize: e.fontSize
      },
      [`${t}-body`]: _({
        padding: a,
        borderRadius: ` 0 0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px`
      }, ja()),
      [`${t}-grid`]: p5e(e),
      [`${t}-cover`]: {
        "> *": {
          display: "block",
          width: "100%"
        },
        img: {
          borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`
        }
      },
      [`${t}-actions`]: v5e(e),
      [`${t}-meta`]: m5e(e)
    }),
    [`${t}-bordered`]: {
      border: `${e.lineWidth}px ${e.lineType} ${l}`,
      [`${t}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${t}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${e.motionDurationMid}, border-color ${e.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: n
      }
    },
    [`${t}-contain-grid`]: {
      [`${t}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${t}-loading) ${t}-body`]: {
        marginBlockStart: -e.lineWidth,
        marginInlineStart: -e.lineWidth,
        padding: 0
      }
    },
    [`${t}-contain-tabs`]: {
      [`> ${t}-head`]: {
        [`${t}-head-title, ${t}-extra`]: {
          paddingTop: o
        }
      }
    },
    [`${t}-type-inner`]: h5e(e),
    [`${t}-loading`]: g5e(e),
    [`${t}-rtl`]: {
      direction: "rtl"
    }
  };
}, y5e = (e) => {
  const {
    componentCls: t,
    cardPaddingSM: n,
    cardHeadHeightSM: o
  } = e;
  return {
    [`${t}-small`]: {
      [`> ${t}-head`]: {
        minHeight: o,
        padding: `0 ${n}px`,
        fontSize: e.fontSize,
        [`> ${t}-head-wrapper`]: {
          [`> ${t}-extra`]: {
            fontSize: e.fontSize
          }
        }
      },
      [`> ${t}-body`]: {
        padding: n
      }
    },
    [`${t}-small${t}-contain-tabs`]: {
      [`> ${t}-head`]: {
        [`${t}-head-title, ${t}-extra`]: {
          minHeight: o,
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
}, S5e = Zt("Card", (e) => {
  const t = Vt(e, {
    cardShadow: e.boxShadowCard,
    cardHeadHeight: e.fontSizeLG * e.lineHeightLG + e.padding * 2,
    cardHeadHeightSM: e.fontSize * e.lineHeight + e.paddingXS * 2,
    cardHeadPadding: e.padding,
    cardPaddingBase: e.paddingLG,
    cardHeadTabsMarginBottom: -e.padding - e.lineWidth,
    cardActionsLiMargin: `${e.paddingSM}px 0`,
    cardActionsIconSize: e.fontSize,
    cardPaddingSM: 12
    // Fixed padding.
  });
  return [
    // Style
    b5e(t),
    // Size
    y5e(t)
  ];
}), C5e = () => ({
  prefixCls: String,
  width: {
    type: [Number, String]
  }
}), MS = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "SkeletonTitle",
  props: C5e(),
  setup(e) {
    return () => {
      const {
        prefixCls: t,
        width: n
      } = e, o = typeof n == "number" ? `${n}px` : n;
      return $("h3", {
        class: t,
        style: {
          width: o
        }
      }, null);
    };
  }
}), w5e = () => ({
  prefixCls: String,
  width: {
    type: [Number, String, Array]
  },
  rows: Number
}), $5e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "SkeletonParagraph",
  props: w5e(),
  setup(e) {
    const t = (n) => {
      const {
        width: o,
        rows: l = 2
      } = e;
      if (Array.isArray(o))
        return o[n];
      if (l - 1 === n)
        return o;
    };
    return () => {
      const {
        prefixCls: n,
        rows: o
      } = e, l = [...Array(o)].map((r, a) => {
        const i = t(a);
        return $("li", {
          key: a,
          style: {
            width: typeof i == "number" ? `${i}px` : i
          }
        }, null);
      });
      return $("ul", {
        class: n
      }, [l]);
    };
  }
}), AS = () => ({
  prefixCls: String,
  size: [String, Number],
  shape: String,
  active: {
    type: Boolean,
    default: void 0
  }
}), Ah = (e) => {
  const {
    prefixCls: t,
    size: n,
    shape: o
  } = e, l = ke({
    [`${t}-lg`]: n === "large",
    [`${t}-sm`]: n === "small"
  }), r = ke({
    [`${t}-circle`]: o === "circle",
    [`${t}-square`]: o === "square",
    [`${t}-round`]: o === "round"
  }), a = typeof n == "number" ? {
    width: `${n}px`,
    height: `${n}px`,
    lineHeight: `${n}px`
  } : {};
  return $("span", {
    class: ke(t, l, r),
    style: a
  }, null);
};
Ah.displayName = "SkeletonElement";
const x5e = new mn("ant-skeleton-loading", {
  "0%": {
    transform: "translateX(-37.5%)"
  },
  "100%": {
    transform: "translateX(37.5%)"
  }
}), RS = (e) => ({
  height: e,
  lineHeight: `${e}px`
}), xf = (e) => _({
  width: e
}, RS(e)), E5e = (e) => ({
  position: "relative",
  // fix https://github.com/ant-design/ant-design/issues/36444
  // https://monshin.github.io/202109/css/safari-border-radius-overflow-hidden/
  /* stylelint-disable-next-line property-no-vendor-prefix,value-no-vendor-prefix */
  zIndex: 0,
  overflow: "hidden",
  background: "transparent",
  "&::after": {
    position: "absolute",
    top: 0,
    insetInlineEnd: "-150%",
    bottom: 0,
    insetInlineStart: "-150%",
    background: e.skeletonLoadingBackground,
    animationName: x5e,
    animationDuration: e.skeletonLoadingMotionDuration,
    animationTimingFunction: "ease",
    animationIterationCount: "infinite",
    content: '""'
  }
}), Aw = (e) => _({
  width: e * 5,
  minWidth: e * 5
}, RS(e)), O5e = (e) => {
  const {
    skeletonAvatarCls: t,
    color: n,
    controlHeight: o,
    controlHeightLG: l,
    controlHeightSM: r
  } = e;
  return {
    [`${t}`]: _({
      display: "inline-block",
      verticalAlign: "top",
      background: n
    }, xf(o)),
    [`${t}${t}-circle`]: {
      borderRadius: "50%"
    },
    [`${t}${t}-lg`]: _({}, xf(l)),
    [`${t}${t}-sm`]: _({}, xf(r))
  };
}, _5e = (e) => {
  const {
    controlHeight: t,
    borderRadiusSM: n,
    skeletonInputCls: o,
    controlHeightLG: l,
    controlHeightSM: r,
    color: a
  } = e;
  return {
    [`${o}`]: _({
      display: "inline-block",
      verticalAlign: "top",
      background: a,
      borderRadius: n
    }, Aw(t)),
    [`${o}-lg`]: _({}, Aw(l)),
    [`${o}-sm`]: _({}, Aw(r))
  };
}, D6 = (e) => _({
  width: e
}, RS(e)), I5e = (e) => {
  const {
    skeletonImageCls: t,
    imageSizeBase: n,
    color: o,
    borderRadiusSM: l
  } = e;
  return {
    [`${t}`]: _(_({
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "top",
      background: o,
      borderRadius: l
    }, D6(n * 2)), {
      [`${t}-path`]: {
        fill: "#bfbfbf"
      },
      [`${t}-svg`]: _(_({}, D6(n)), {
        maxWidth: n * 4,
        maxHeight: n * 4
      }),
      [`${t}-svg${t}-svg-circle`]: {
        borderRadius: "50%"
      }
    }),
    [`${t}${t}-circle`]: {
      borderRadius: "50%"
    }
  };
}, Rw = (e, t, n) => {
  const {
    skeletonButtonCls: o
  } = e;
  return {
    [`${n}${o}-circle`]: {
      width: t,
      minWidth: t,
      borderRadius: "50%"
    },
    [`${n}${o}-round`]: {
      borderRadius: t
    }
  };
}, Dw = (e) => _({
  width: e * 2,
  minWidth: e * 2
}, RS(e)), T5e = (e) => {
  const {
    borderRadiusSM: t,
    skeletonButtonCls: n,
    controlHeight: o,
    controlHeightLG: l,
    controlHeightSM: r,
    color: a
  } = e;
  return _(_(_(_(_({
    [`${n}`]: _({
      display: "inline-block",
      verticalAlign: "top",
      background: a,
      borderRadius: t,
      width: o * 2,
      minWidth: o * 2
    }, Dw(o))
  }, Rw(e, o, n)), {
    [`${n}-lg`]: _({}, Dw(l))
  }), Rw(e, l, `${n}-lg`)), {
    [`${n}-sm`]: _({}, Dw(r))
  }), Rw(e, r, `${n}-sm`));
}, P5e = (e) => {
  const {
    componentCls: t,
    skeletonAvatarCls: n,
    skeletonTitleCls: o,
    skeletonParagraphCls: l,
    skeletonButtonCls: r,
    skeletonInputCls: a,
    skeletonImageCls: i,
    controlHeight: s,
    controlHeightLG: c,
    controlHeightSM: u,
    color: d,
    padding: f,
    marginSM: p,
    borderRadius: m,
    skeletonTitleHeight: v,
    skeletonBlockRadius: h,
    skeletonParagraphLineHeight: g,
    controlHeightXS: y,
    skeletonParagraphMarginTop: b
  } = e;
  return {
    [`${t}`]: {
      display: "table",
      width: "100%",
      [`${t}-header`]: {
        display: "table-cell",
        paddingInlineEnd: f,
        verticalAlign: "top",
        // Avatar
        [`${n}`]: _({
          display: "inline-block",
          verticalAlign: "top",
          background: d
        }, xf(s)),
        [`${n}-circle`]: {
          borderRadius: "50%"
        },
        [`${n}-lg`]: _({}, xf(c)),
        [`${n}-sm`]: _({}, xf(u))
      },
      [`${t}-content`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        // Title
        [`${o}`]: {
          width: "100%",
          height: v,
          background: d,
          borderRadius: h,
          [`+ ${l}`]: {
            marginBlockStart: u
          }
        },
        // paragraph
        [`${l}`]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: g,
            listStyle: "none",
            background: d,
            borderRadius: h,
            "+ li": {
              marginBlockStart: y
            }
          }
        },
        [`${l}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${t}-content`]: {
        [`${o}, ${l} > li`]: {
          borderRadius: m
        }
      }
    },
    [`${t}-with-avatar ${t}-content`]: {
      // Title
      [`${o}`]: {
        marginBlockStart: p,
        [`+ ${l}`]: {
          marginBlockStart: b
        }
      }
    },
    // Skeleton element
    [`${t}${t}-element`]: _(_(_(_({
      display: "inline-block",
      width: "auto"
    }, T5e(e)), O5e(e)), _5e(e)), I5e(e)),
    // Skeleton Block Button, Input
    [`${t}${t}-block`]: {
      width: "100%",
      [`${r}`]: {
        width: "100%"
      },
      [`${a}`]: {
        width: "100%"
      }
    },
    // With active animation
    [`${t}${t}-active`]: {
      [`
        ${o},
        ${l} > li,
        ${n},
        ${r},
        ${a},
        ${i}
      `]: _({}, E5e(e))
    }
  };
}, Rh = Zt("Skeleton", (e) => {
  const {
    componentCls: t
  } = e, n = Vt(e, {
    skeletonAvatarCls: `${t}-avatar`,
    skeletonTitleCls: `${t}-title`,
    skeletonParagraphCls: `${t}-paragraph`,
    skeletonButtonCls: `${t}-button`,
    skeletonInputCls: `${t}-input`,
    skeletonImageCls: `${t}-image`,
    imageSizeBase: e.controlHeight * 1.5,
    skeletonTitleHeight: e.controlHeight / 2,
    skeletonBlockRadius: e.borderRadiusSM,
    skeletonParagraphLineHeight: e.controlHeight / 2,
    skeletonParagraphMarginTop: e.marginLG + e.marginXXS,
    borderRadius: 100,
    skeletonLoadingBackground: `linear-gradient(90deg, ${e.color} 25%, ${e.colorGradientEnd} 37%, ${e.color} 63%)`,
    skeletonLoadingMotionDuration: "1.4s"
  });
  return [P5e(n)];
}, (e) => {
  const {
    colorFillContent: t,
    colorFill: n
  } = e;
  return {
    color: t,
    colorGradientEnd: n
  };
}), k5e = () => ({
  active: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  avatar: {
    type: [Boolean, Object],
    default: void 0
  },
  title: {
    type: [Boolean, Object],
    default: void 0
  },
  paragraph: {
    type: [Boolean, Object],
    default: void 0
  },
  round: {
    type: Boolean,
    default: void 0
  }
});
function Lw(e) {
  return e && typeof e == "object" ? e : {};
}
function N5e(e, t) {
  return e && !t ? {
    size: "large",
    shape: "square"
  } : {
    size: "large",
    shape: "circle"
  };
}
function M5e(e, t) {
  return !e && t ? {
    width: "38%"
  } : e && t ? {
    width: "50%"
  } : {};
}
function A5e(e, t) {
  const n = {};
  return (!e || !t) && (n.width = "61%"), !e && t ? n.rows = 3 : n.rows = 2, n;
}
const Tl = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeleton",
  props: sn(k5e(), {
    avatar: !1,
    title: !0,
    paragraph: !0
  }),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o,
      direction: l
    } = bt("skeleton", e), [r, a] = Rh(o);
    return () => {
      var i;
      const {
        loading: s,
        avatar: c,
        title: u,
        paragraph: d,
        active: f,
        round: p
      } = e, m = o.value;
      if (s || e.loading === void 0) {
        const v = !!c || c === "", h = !!u || u === "", g = !!d || d === "";
        let y;
        if (v) {
          const w = _(_({
            prefixCls: `${m}-avatar`
          }, N5e(h, g)), Lw(c));
          y = $("div", {
            class: `${m}-header`
          }, [$(Ah, w, null)]);
        }
        let b;
        if (h || g) {
          let w;
          if (h) {
            const E = _(_({
              prefixCls: `${m}-title`
            }, M5e(v, g)), Lw(u));
            w = $(MS, E, null);
          }
          let x;
          if (g) {
            const E = _(_({
              prefixCls: `${m}-paragraph`
            }, A5e(v, h)), Lw(d));
            x = $($5e, E, null);
          }
          b = $("div", {
            class: `${m}-content`
          }, [w, x]);
        }
        const C = ke(m, {
          [`${m}-with-avatar`]: v,
          [`${m}-active`]: f,
          [`${m}-rtl`]: l.value === "rtl",
          [`${m}-round`]: p,
          [a.value]: !0
        });
        return r($("div", {
          class: C
        }, [y, b]));
      }
      return (i = n.default) === null || i === void 0 ? void 0 : i.call(n);
    };
  }
}), R5e = () => _(_({}, AS()), {
  size: String,
  block: Boolean
}), PT = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonButton",
  props: sn(R5e(), {
    size: "default"
  }),
  setup(e) {
    const {
      prefixCls: t
    } = bt("skeleton", e), [n, o] = Rh(t), l = O(() => ke(t.value, `${t.value}-element`, {
      [`${t.value}-active`]: e.active,
      [`${t.value}-block`]: e.block
    }, o.value));
    return () => n($("div", {
      class: l.value
    }, [$(Ah, Q(Q({}, e), {}, {
      prefixCls: `${t.value}-button`
    }), null)]));
  }
}), kT = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonInput",
  props: _(_({}, pn(AS(), ["shape"])), {
    size: String,
    block: Boolean
  }),
  setup(e) {
    const {
      prefixCls: t
    } = bt("skeleton", e), [n, o] = Rh(t), l = O(() => ke(t.value, `${t.value}-element`, {
      [`${t.value}-active`]: e.active,
      [`${t.value}-block`]: e.block
    }, o.value));
    return () => n($("div", {
      class: l.value
    }, [$(Ah, Q(Q({}, e), {}, {
      prefixCls: `${t.value}-input`
    }), null)]));
  }
}), D5e = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z", NT = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonImage",
  props: pn(AS(), ["size", "shape", "active"]),
  setup(e) {
    const {
      prefixCls: t
    } = bt("skeleton", e), [n, o] = Rh(t), l = O(() => ke(t.value, `${t.value}-element`, o.value));
    return () => n($("div", {
      class: l.value
    }, [$("div", {
      class: `${t.value}-image`
    }, [$("svg", {
      viewBox: "0 0 1098 1024",
      xmlns: "http://www.w3.org/2000/svg",
      class: `${t.value}-image-svg`
    }, [$("path", {
      d: D5e,
      class: `${t.value}-image-path`
    }, null)])])]));
  }
}), L5e = () => _(_({}, AS()), {
  shape: String
}), MT = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonAvatar",
  props: sn(L5e(), {
    size: "default",
    shape: "circle"
  }),
  setup(e) {
    const {
      prefixCls: t
    } = bt("skeleton", e), [n, o] = Rh(t), l = O(() => ke(t.value, `${t.value}-element`, {
      [`${t.value}-active`]: e.active
    }, o.value));
    return () => n($("div", {
      class: l.value
    }, [$(Ah, Q(Q({}, e), {}, {
      prefixCls: `${t.value}-avatar`
    }), null)]));
  }
});
Tl.Button = PT;
Tl.Avatar = MT;
Tl.Input = kT;
Tl.Image = NT;
Tl.Title = MS;
Tl.install = function(e) {
  return e.component(Tl.name, Tl), e.component(Tl.Button.name, PT), e.component(Tl.Avatar.name, MT), e.component(Tl.Input.name, kT), e.component(Tl.Image.name, NT), e.component(Tl.Title.name, MS), e;
};
const {
  TabPane: B5e
} = Nu, F5e = () => ({
  prefixCls: String,
  title: de.any,
  extra: de.any,
  bordered: {
    type: Boolean,
    default: !0
  },
  bodyStyle: {
    type: Object,
    default: void 0
  },
  headStyle: {
    type: Object,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: !1
  },
  hoverable: {
    type: Boolean,
    default: !1
  },
  type: {
    type: String
  },
  size: {
    type: String
  },
  actions: de.any,
  tabList: {
    type: Array
  },
  tabBarExtraContent: de.any,
  activeTabKey: String,
  defaultActiveTabKey: String,
  cover: de.any,
  onTabChange: {
    type: Function
  }
}), Ef = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ACard",
  inheritAttrs: !1,
  props: F5e(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r,
      size: a
    } = bt("card", e), [i, s] = S5e(l), c = (f) => f.map((m, v) => dn(m) && !$h(m) || !dn(m) ? $("li", {
      style: {
        width: `${100 / f.length}%`
      },
      key: `action-${v}`
    }, [$("span", null, [m])]) : null), u = (f) => {
      var p;
      (p = e.onTabChange) === null || p === void 0 || p.call(e, f);
    }, d = function() {
      let f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], p;
      return f.forEach((m) => {
        m && I1(m.type) && m.type.__ANT_CARD_GRID && (p = !0);
      }), p;
    };
    return () => {
      var f, p, m, v, h, g;
      const {
        headStyle: y = {},
        bodyStyle: b = {},
        loading: C,
        bordered: w = !0,
        type: x,
        tabList: E,
        hoverable: I,
        activeTabKey: T,
        defaultActiveTabKey: P,
        tabBarExtraContent: k = ov((f = n.tabBarExtraContent) === null || f === void 0 ? void 0 : f.call(n)),
        title: N = ov((p = n.title) === null || p === void 0 ? void 0 : p.call(n)),
        extra: R = ov((m = n.extra) === null || m === void 0 ? void 0 : m.call(n)),
        actions: z = ov((v = n.actions) === null || v === void 0 ? void 0 : v.call(n)),
        cover: D = ov((h = n.cover) === null || h === void 0 ? void 0 : h.call(n))
      } = e, F = Fn((g = n.default) === null || g === void 0 ? void 0 : g.call(n)), M = l.value, A = {
        [`${M}`]: !0,
        [s.value]: !0,
        [`${M}-loading`]: C,
        [`${M}-bordered`]: w,
        [`${M}-hoverable`]: !!I,
        [`${M}-contain-grid`]: d(F),
        [`${M}-contain-tabs`]: E && E.length,
        [`${M}-${a.value}`]: a.value,
        [`${M}-type-${x}`]: !!x,
        [`${M}-rtl`]: r.value === "rtl"
      }, L = $(Tl, {
        loading: !0,
        active: !0,
        paragraph: {
          rows: 4
        },
        title: !1
      }, {
        default: () => [F]
      }), B = T !== void 0, V = {
        size: "large",
        [B ? "activeKey" : "defaultActiveKey"]: B ? T : P,
        onChange: u,
        class: `${M}-head-tabs`
      };
      let j;
      const W = E && E.length ? $(Nu, V, {
        default: () => [E.map((J) => {
          const {
            tab: re,
            slots: oe
          } = J, q = oe == null ? void 0 : oe.tab;
          un(!oe, "Card", "tabList slots is deprecated, Please use `customTab` instead.");
          let K = re !== void 0 ? re : n[q] ? n[q](J) : null;
          return K = fS(n, "customTab", J, () => [K]), $(B5e, {
            tab: K,
            key: J.key,
            disabled: J.disabled
          }, null);
        })],
        rightExtra: k ? () => k : null
      }) : null;
      (N || R || W) && (j = $("div", {
        class: `${M}-head`,
        style: y
      }, [$("div", {
        class: `${M}-head-wrapper`
      }, [N && $("div", {
        class: `${M}-head-title`
      }, [N]), R && $("div", {
        class: `${M}-extra`
      }, [R])]), W]));
      const Y = D ? $("div", {
        class: `${M}-cover`
      }, [D]) : null, U = $("div", {
        class: `${M}-body`,
        style: b
      }, [C ? L : F]), te = z && z.length ? $("ul", {
        class: `${M}-actions`
      }, [c(z)]) : null;
      return i($("div", Q(Q({
        ref: "cardContainerRef"
      }, o), {}, {
        class: [A, o.class]
      }), [j, Y, F && F.length ? U : null, te]));
    };
  }
}), V5e = () => ({
  prefixCls: String,
  title: Pl(),
  description: Pl(),
  avatar: Pl()
}), ky = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ACardMeta",
  props: V5e(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o
    } = bt("card", e);
    return () => {
      const l = {
        [`${o.value}-meta`]: !0
      }, r = Wo(n, e, "avatar"), a = Wo(n, e, "title"), i = Wo(n, e, "description"), s = r ? $("div", {
        class: `${o.value}-meta-avatar`
      }, [r]) : null, c = a ? $("div", {
        class: `${o.value}-meta-title`
      }, [a]) : null, u = i ? $("div", {
        class: `${o.value}-meta-description`
      }, [i]) : null, d = c || u ? $("div", {
        class: `${o.value}-meta-detail`
      }, [c, u]) : null;
      return $("div", {
        class: l
      }, [s, d]);
    };
  }
}), z5e = () => ({
  prefixCls: String,
  hoverable: {
    type: Boolean,
    default: !0
  }
}), Ny = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ACardGrid",
  __ANT_CARD_GRID: !0,
  props: z5e(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o
    } = bt("card", e), l = O(() => ({
      [`${o.value}-grid`]: !0,
      [`${o.value}-grid-hoverable`]: e.hoverable
    }));
    return () => {
      var r;
      return $("div", {
        class: l.value
      }, [(r = n.default) === null || r === void 0 ? void 0 : r.call(n)]);
    };
  }
});
Ef.Meta = ky;
Ef.Grid = Ny;
Ef.install = function(e) {
  return e.component(Ef.name, Ef), e.component(ky.name, ky), e.component(Ny.name, Ny), e;
};
const H5e = () => ({
  prefixCls: String,
  activeKey: zt([Array, Number, String]),
  defaultActiveKey: zt([Array, Number, String]),
  accordion: Qe(),
  destroyInactivePanel: Qe(),
  bordered: Qe(),
  expandIcon: Fe(),
  openAnimation: de.object,
  expandIconPosition: At(),
  collapsible: At(),
  ghost: Qe(),
  onChange: Fe(),
  "onUpdate:activeKey": Fe()
}), nK = () => ({
  openAnimation: de.object,
  prefixCls: String,
  header: de.any,
  headerClass: String,
  showArrow: Qe(),
  isActive: Qe(),
  destroyInactivePanel: Qe(),
  /** @deprecated Use `collapsible="disabled"` instead */
  disabled: Qe(),
  accordion: Qe(),
  forceRender: Qe(),
  expandIcon: Fe(),
  extra: de.any,
  panelKey: zt(),
  collapsible: At(),
  role: String,
  onItemClick: Fe()
}), j5e = (e) => {
  const {
    componentCls: t,
    collapseContentBg: n,
    padding: o,
    collapseContentPaddingHorizontal: l,
    collapseHeaderBg: r,
    collapseHeaderPadding: a,
    collapsePanelBorderRadius: i,
    lineWidth: s,
    lineType: c,
    colorBorder: u,
    colorText: d,
    colorTextHeading: f,
    colorTextDisabled: p,
    fontSize: m,
    lineHeight: v,
    marginSM: h,
    paddingSM: g,
    motionDurationSlow: y,
    fontSizeIcon: b
  } = e, C = `${s}px ${c} ${u}`;
  return {
    [t]: _(_({}, nn(e)), {
      backgroundColor: r,
      border: C,
      borderBottom: 0,
      borderRadius: `${i}px`,
      "&-rtl": {
        direction: "rtl"
      },
      [`& > ${t}-item`]: {
        borderBottom: C,
        "&:last-child": {
          [`
            &,
            & > ${t}-header`]: {
            borderRadius: `0 0 ${i}px ${i}px`
          }
        },
        [`> ${t}-header`]: {
          position: "relative",
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "flex-start",
          padding: a,
          color: f,
          lineHeight: v,
          cursor: "pointer",
          transition: `all ${y}, visibility 0s`,
          [`> ${t}-header-text`]: {
            flex: "auto"
          },
          "&:focus": {
            outline: "none"
          },
          // >>>>> Arrow
          [`${t}-expand-icon`]: {
            height: m * v,
            display: "flex",
            alignItems: "center",
            paddingInlineEnd: h
          },
          [`${t}-arrow`]: _(_({}, cd()), {
            fontSize: b,
            svg: {
              transition: `transform ${y}`
            }
          }),
          // >>>>> Text
          [`${t}-header-text`]: {
            marginInlineEnd: "auto"
          }
        },
        [`${t}-header-collapsible-only`]: {
          cursor: "default",
          [`${t}-header-text`]: {
            flex: "none",
            cursor: "pointer"
          },
          [`${t}-expand-icon`]: {
            cursor: "pointer"
          }
        },
        [`${t}-icon-collapsible-only`]: {
          cursor: "default",
          [`${t}-expand-icon`]: {
            cursor: "pointer"
          }
        },
        [`&${t}-no-arrow`]: {
          [`> ${t}-header`]: {
            paddingInlineStart: g
          }
        }
      },
      [`${t}-content`]: {
        color: d,
        backgroundColor: n,
        borderTop: C,
        [`& > ${t}-content-box`]: {
          padding: `${o}px ${l}px`
        },
        "&-hidden": {
          display: "none"
        }
      },
      [`${t}-item:last-child`]: {
        [`> ${t}-content`]: {
          borderRadius: `0 0 ${i}px ${i}px`
        }
      },
      [`& ${t}-item-disabled > ${t}-header`]: {
        "\n          &,\n          & > .arrow\n        ": {
          color: p,
          cursor: "not-allowed"
        }
      },
      // ========================== Icon Position ==========================
      [`&${t}-icon-position-end`]: {
        [`& > ${t}-item`]: {
          [`> ${t}-header`]: {
            [`${t}-expand-icon`]: {
              order: 1,
              paddingInlineEnd: 0,
              paddingInlineStart: h
            }
          }
        }
      }
    })
  };
}, W5e = (e) => {
  const {
    componentCls: t
  } = e, n = `> ${t}-item > ${t}-header ${t}-arrow svg`;
  return {
    [`${t}-rtl`]: {
      [n]: {
        transform: "rotate(180deg)"
      }
    }
  };
}, K5e = (e) => {
  const {
    componentCls: t,
    collapseHeaderBg: n,
    paddingXXS: o,
    colorBorder: l
  } = e;
  return {
    [`${t}-borderless`]: {
      backgroundColor: n,
      border: 0,
      [`> ${t}-item`]: {
        borderBottom: `1px solid ${l}`
      },
      [`
        > ${t}-item:last-child,
        > ${t}-item:last-child ${t}-header
      `]: {
        borderRadius: 0
      },
      [`> ${t}-item:last-child`]: {
        borderBottom: 0
      },
      [`> ${t}-item > ${t}-content`]: {
        backgroundColor: "transparent",
        borderTop: 0
      },
      [`> ${t}-item > ${t}-content > ${t}-content-box`]: {
        paddingTop: o
      }
    }
  };
}, U5e = (e) => {
  const {
    componentCls: t,
    paddingSM: n
  } = e;
  return {
    [`${t}-ghost`]: {
      backgroundColor: "transparent",
      border: 0,
      [`> ${t}-item`]: {
        borderBottom: 0,
        [`> ${t}-content`]: {
          backgroundColor: "transparent",
          border: 0,
          [`> ${t}-content-box`]: {
            paddingBlock: n
          }
        }
      }
    }
  };
}, G5e = Zt("Collapse", (e) => {
  const t = Vt(e, {
    collapseContentBg: e.colorBgContainer,
    collapseHeaderBg: e.colorFillAlter,
    collapseHeaderPadding: `${e.paddingSM}px ${e.padding}px`,
    collapsePanelBorderRadius: e.borderRadiusLG,
    collapseContentPaddingHorizontal: 16
    // Fixed value
  });
  return [j5e(t), K5e(t), U5e(t), W5e(t), Ih(t)];
});
function L6(e) {
  let t = e;
  if (!Array.isArray(t)) {
    const n = typeof t;
    t = n === "number" || n === "string" ? [t] : [];
  }
  return t.map((n) => String(n));
}
const Fv = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ACollapse",
  inheritAttrs: !1,
  props: sn(H5e(), {
    accordion: !1,
    destroyInactivePanel: !1,
    bordered: !0,
    expandIconPosition: "start"
  }),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: l
    } = t;
    const r = /* @__PURE__ */ H(L6(hy([e.activeKey, e.defaultActiveKey])));
    pe(() => e.activeKey, () => {
      r.value = L6(e.activeKey);
    }, {
      deep: !0
    });
    const {
      prefixCls: a,
      direction: i,
      rootPrefixCls: s
    } = bt("collapse", e), [c, u] = G5e(a), d = O(() => {
      const {
        expandIconPosition: g
      } = e;
      return g !== void 0 ? g : i.value === "rtl" ? "end" : "start";
    }), f = (g) => {
      const {
        expandIcon: y = o.expandIcon
      } = e, b = y ? y(g) : $(Br, {
        rotate: g.isActive ? 90 : void 0
      }, null);
      return $("div", {
        class: [`${a.value}-expand-icon`, u.value],
        onClick: () => ["header", "icon"].includes(e.collapsible) && m(g.panelKey)
      }, [Io(Array.isArray(y) ? b[0] : b) ? _n(b, {
        class: `${a.value}-arrow`
      }, !1) : b]);
    }, p = (g) => {
      e.activeKey === void 0 && (r.value = g);
      const y = e.accordion ? g[0] : g;
      l("update:activeKey", y), l("change", y);
    }, m = (g) => {
      let y = r.value;
      if (e.accordion)
        y = y[0] === g ? [] : [g];
      else {
        y = [...y];
        const b = y.indexOf(g);
        b > -1 ? y.splice(b, 1) : y.push(g);
      }
      p(y);
    }, v = (g, y) => {
      var b, C, w;
      if ($h(g)) return;
      const x = r.value, {
        accordion: E,
        destroyInactivePanel: I,
        collapsible: T,
        openAnimation: P
      } = e, k = P || Ph(`${s.value}-motion-collapse`), N = String((b = g.key) !== null && b !== void 0 ? b : y), {
        header: R = (w = (C = g.children) === null || C === void 0 ? void 0 : C.header) === null || w === void 0 ? void 0 : w.call(C),
        headerClass: z,
        collapsible: D,
        disabled: F
      } = g.props || {};
      let M = !1;
      E ? M = x[0] === N : M = x.indexOf(N) > -1;
      let A = D != null ? D : T;
      (F || F === "") && (A = "disabled");
      const L = {
        key: N,
        panelKey: N,
        header: R,
        headerClass: z,
        isActive: M,
        prefixCls: a.value,
        destroyInactivePanel: I,
        openAnimation: k,
        accordion: E,
        onItemClick: A === "disabled" ? null : m,
        expandIcon: f,
        collapsible: A
      };
      return _n(g, L);
    }, h = () => {
      var g;
      return Fn((g = o.default) === null || g === void 0 ? void 0 : g.call(o)).map(v);
    };
    return () => {
      const {
        accordion: g,
        bordered: y,
        ghost: b
      } = e, C = ke(a.value, {
        [`${a.value}-borderless`]: !y,
        [`${a.value}-icon-position-${d.value}`]: !0,
        [`${a.value}-rtl`]: i.value === "rtl",
        [`${a.value}-ghost`]: !!b,
        [n.class]: !!n.class
      }, u.value);
      return c($("div", Q(Q({
        class: C
      }, sPe(n)), {}, {
        style: n.style,
        role: g ? "tablist" : null
      }), [h()]));
    };
  }
}), Y5e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "PanelContent",
  props: nK(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = /* @__PURE__ */ Ce(!1);
    return Ot(() => {
      (e.isActive || e.forceRender) && (o.value = !0);
    }), () => {
      var l;
      if (!o.value) return null;
      const {
        prefixCls: r,
        isActive: a,
        role: i
      } = e;
      return $("div", {
        class: ke(`${r}-content`, {
          [`${r}-content-active`]: a,
          [`${r}-content-inactive`]: !a
        }),
        role: i
      }, [$("div", {
        class: `${r}-content-box`
      }, [(l = n.default) === null || l === void 0 ? void 0 : l.call(n)])]);
    };
  }
}), My = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ACollapsePanel",
  inheritAttrs: !1,
  props: sn(nK(), {
    showArrow: !0,
    isActive: !1,
    onItemClick() {
    },
    headerClass: "",
    forceRender: !1
  }),
  slots: Object,
  // emits: ['itemClick'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: l
    } = t;
    un(e.disabled === void 0, "Collapse.Panel", '`disabled` is deprecated. Please use `collapsible="disabled"` instead.');
    const {
      prefixCls: r
    } = bt("collapse", e), a = () => {
      o("itemClick", e.panelKey);
    }, i = (s) => {
      (s.key === "Enter" || s.keyCode === 13 || s.which === 13) && a();
    };
    return () => {
      var s, c;
      const {
        header: u = (s = n.header) === null || s === void 0 ? void 0 : s.call(n),
        headerClass: d,
        isActive: f,
        showArrow: p,
        destroyInactivePanel: m,
        accordion: v,
        forceRender: h,
        openAnimation: g,
        expandIcon: y = n.expandIcon,
        extra: b = (c = n.extra) === null || c === void 0 ? void 0 : c.call(n),
        collapsible: C
      } = e, w = C === "disabled", x = r.value, E = ke(`${x}-header`, {
        [d]: d,
        [`${x}-header-collapsible-only`]: C === "header",
        [`${x}-icon-collapsible-only`]: C === "icon"
      }), I = ke({
        [`${x}-item`]: !0,
        [`${x}-item-active`]: f,
        [`${x}-item-disabled`]: w,
        [`${x}-no-arrow`]: !p,
        [`${l.class}`]: !!l.class
      });
      let T = $("i", {
        class: "arrow"
      }, null);
      p && typeof y == "function" && (T = y(e));
      const P = _t($(Y5e, {
        prefixCls: x,
        isActive: f,
        forceRender: h,
        role: v ? "tabpanel" : null
      }, {
        default: n.default
      }), [[Jt, f]]), k = _({
        appear: !1,
        css: !1
      }, g);
      return $("div", Q(Q({}, l), {}, {
        class: I
      }), [$("div", {
        class: E,
        onClick: () => !["header", "icon"].includes(C) && a(),
        role: v ? "tab" : "button",
        tabindex: w ? -1 : 0,
        "aria-expanded": f,
        onKeypress: i
      }, [p && T, $("span", {
        onClick: () => C === "header" && a(),
        class: `${x}-header-text`
      }, [u]), b && $("div", {
        class: `${x}-extra`
      }, [b])]), $(Vn, k, {
        default: () => [!m || f ? P : null]
      })]);
    };
  }
});
Fv.Panel = My;
Fv.install = function(e) {
  return e.component(Fv.name, Fv), e.component(My.name, My), e;
};
const X5e = function(e) {
  return e.replace(/[A-Z]/g, function(t) {
    return "-" + t.toLowerCase();
  }).toLowerCase();
}, q5e = function(e) {
  return /[height|width]$/.test(e);
}, B6 = function(e) {
  let t = "";
  const n = Object.keys(e);
  return n.forEach(function(o, l) {
    let r = e[o];
    o = X5e(o), q5e(o) && typeof r == "number" && (r = r + "px"), r === !0 ? t += o : r === !1 ? t += "not " + o : t += "(" + o + ": " + r + ")", l < n.length - 1 && (t += " and ");
  }), t;
};
function Bw(e) {
  let t = "";
  return typeof e == "string" ? e : e instanceof Array ? (e.forEach(function(n, o) {
    t += B6(n), o < e.length - 1 && (t += ", ");
  }), t) : B6(e);
}
const oK = {
  accessibility: {
    type: Boolean,
    default: !0
  },
  // 
  adaptiveHeight: {
    type: Boolean,
    default: !1
  },
  afterChange: de.any.def(null),
  arrows: {
    type: Boolean,
    default: !0
  },
  autoplay: {
    type: Boolean,
    default: !1
  },
  autoplaySpeed: de.number.def(3e3),
  beforeChange: de.any.def(null),
  centerMode: {
    type: Boolean,
    default: !1
  },
  centerPadding: de.string.def("50px"),
  cssEase: de.string.def("ease"),
  dots: {
    type: Boolean,
    default: !1
  },
  dotsClass: de.string.def("slick-dots"),
  draggable: {
    type: Boolean,
    default: !0
  },
  unslick: {
    type: Boolean,
    default: !1
  },
  easing: de.string.def("linear"),
  edgeFriction: de.number.def(0.35),
  fade: {
    type: Boolean,
    default: !1
  },
  focusOnSelect: {
    type: Boolean,
    default: !1
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  initialSlide: de.number.def(0),
  lazyLoad: de.any.def(null),
  verticalSwiping: {
    type: Boolean,
    default: !1
  },
  asNavFor: de.any.def(null),
  // hover
  pauseOnDotsHover: {
    type: Boolean,
    default: !1
  },
  // focus
  pauseOnFocus: {
    type: Boolean,
    default: !1
  },
  // hover
  pauseOnHover: {
    type: Boolean,
    default: !0
  },
  responsive: de.array,
  rows: de.number.def(1),
  rtl: {
    type: Boolean,
    default: !1
  },
  slide: de.string.def("div"),
  slidesPerRow: de.number.def(1),
  slidesToScroll: de.number.def(1),
  slidesToShow: de.number.def(1),
  speed: de.number.def(500),
  swipe: {
    type: Boolean,
    default: !0
  },
  swipeEvent: de.any.def(null),
  swipeToSlide: {
    type: Boolean,
    default: !1
  },
  touchMove: {
    type: Boolean,
    default: !0
  },
  touchThreshold: de.number.def(5),
  useCSS: {
    type: Boolean,
    default: !0
  },
  useTransform: {
    type: Boolean,
    default: !0
  },
  variableWidth: {
    type: Boolean,
    default: !1
  },
  vertical: {
    type: Boolean,
    default: !1
  },
  waitForAnimate: {
    type: Boolean,
    default: !0
  },
  children: de.array,
  __propsSymbol__: de.any
}, J5e = {
  animating: !1,
  autoplaying: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlide: 0,
  direction: 1,
  dragging: !1,
  edgeDragged: !1,
  initialized: !1,
  lazyLoadedList: [],
  listHeight: null,
  listWidth: null,
  scrolling: !1,
  slideCount: null,
  slideHeight: null,
  slideWidth: null,
  swipeLeft: null,
  swiped: !1,
  swiping: !1,
  touchObject: {
    startX: 0,
    startY: 0,
    curX: 0,
    curY: 0
  },
  trackStyle: {},
  trackWidth: 0,
  targetSlide: 0
};
function F2(e, t, n) {
  return Math.max(t, Math.min(e, n));
}
const Of = (e) => {
  ["touchstart", "touchmove", "wheel"].includes(e.type) || e.preventDefault();
}, Ay = (e) => {
  const t = [], n = lK(e), o = rK(e);
  for (let l = n; l < o; l++)
    e.lazyLoadedList.indexOf(l) < 0 && t.push(l);
  return t;
}, lK = (e) => e.currentSlide - Z5e(e), rK = (e) => e.currentSlide + Q5e(e), Z5e = (e) => e.centerMode ? Math.floor(e.slidesToShow / 2) + (parseInt(e.centerPadding) > 0 ? 1 : 0) : 0, Q5e = (e) => e.centerMode ? Math.floor((e.slidesToShow - 1) / 2) + 1 + (parseInt(e.centerPadding) > 0 ? 1 : 0) : e.slidesToShow, V2 = (e) => e && e.offsetWidth || 0, AT = (e) => e && e.offsetHeight || 0, aK = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n;
  const o = e.startX - e.curX, l = e.startY - e.curY, r = Math.atan2(l, o);
  return n = Math.round(r * 180 / Math.PI), n < 0 && (n = 360 - Math.abs(n)), n <= 45 && n >= 0 || n <= 360 && n >= 315 ? "left" : n >= 135 && n <= 225 ? "right" : t === !0 ? n >= 35 && n <= 135 ? "up" : "down" : "vertical";
}, DS = (e) => {
  let t = !0;
  return e.infinite || (e.centerMode && e.currentSlide >= e.slideCount - 1 || e.slideCount <= e.slidesToShow || e.currentSlide >= e.slideCount - e.slidesToShow) && (t = !1), t;
}, Fw = (e, t) => {
  const n = {};
  return t.forEach((o) => n[o] = e[o]), n;
}, eLe = (e) => {
  const t = e.children.length, n = e.listRef, o = Math.ceil(V2(n)), l = e.trackRef, r = Math.ceil(V2(l));
  let a;
  if (e.vertical)
    a = o;
  else {
    let p = e.centerMode && parseInt(e.centerPadding) * 2;
    typeof e.centerPadding == "string" && e.centerPadding.slice(-1) === "%" && (p *= o / 100), a = Math.ceil((o - p) / e.slidesToShow);
  }
  const i = n && AT(n.querySelector('[data-index="0"]')), s = i * e.slidesToShow;
  let c = e.currentSlide === void 0 ? e.initialSlide : e.currentSlide;
  e.rtl && e.currentSlide === void 0 && (c = t - 1 - e.initialSlide);
  let u = e.lazyLoadedList || [];
  const d = Ay(_(_({}, e), {
    currentSlide: c,
    lazyLoadedList: u
  }));
  u = u.concat(d);
  const f = {
    slideCount: t,
    slideWidth: a,
    listWidth: o,
    trackWidth: r,
    currentSlide: c,
    slideHeight: i,
    listHeight: s,
    lazyLoadedList: u
  };
  return e.autoplaying === null && e.autoplay && (f.autoplaying = "playing"), f;
}, tLe = (e) => {
  const {
    waitForAnimate: t,
    animating: n,
    fade: o,
    infinite: l,
    index: r,
    slideCount: a,
    lazyLoad: i,
    currentSlide: s,
    centerMode: c,
    slidesToScroll: u,
    slidesToShow: d,
    useCSS: f
  } = e;
  let {
    lazyLoadedList: p
  } = e;
  if (t && n) return {};
  let m = r, v, h, g, y = {}, b = {};
  const C = l ? r : F2(r, 0, a - 1);
  if (o) {
    if (!l && (r < 0 || r >= a)) return {};
    r < 0 ? m = r + a : r >= a && (m = r - a), i && p.indexOf(m) < 0 && (p = p.concat(m)), y = {
      animating: !0,
      currentSlide: m,
      lazyLoadedList: p,
      targetSlide: m
    }, b = {
      animating: !1,
      targetSlide: m
    };
  } else
    v = m, m < 0 ? (v = m + a, l ? a % u !== 0 && (v = a - a % u) : v = 0) : !DS(e) && m > s ? m = v = s : c && m >= a ? (m = l ? a : a - 1, v = l ? 0 : a - 1) : m >= a && (v = m - a, l ? a % u !== 0 && (v = 0) : v = a - d), !l && m + d >= a && (v = a - d), h = zm(_(_({}, e), {
      slideIndex: m
    })), g = zm(_(_({}, e), {
      slideIndex: v
    })), l || (h === g && (m = v), h = g), i && (p = p.concat(Ay(_(_({}, e), {
      currentSlide: m
    })))), f ? (y = {
      animating: !0,
      currentSlide: v,
      trackStyle: iK(_(_({}, e), {
        left: h
      })),
      lazyLoadedList: p,
      targetSlide: C
    }, b = {
      animating: !1,
      currentSlide: v,
      trackStyle: Vm(_(_({}, e), {
        left: g
      })),
      swipeLeft: null,
      targetSlide: C
    }) : y = {
      currentSlide: v,
      trackStyle: Vm(_(_({}, e), {
        left: g
      })),
      lazyLoadedList: p,
      targetSlide: C
    };
  return {
    state: y,
    nextState: b
  };
}, nLe = (e, t) => {
  let n, o, l;
  const {
    slidesToScroll: r,
    slidesToShow: a,
    slideCount: i,
    currentSlide: s,
    targetSlide: c,
    lazyLoad: u,
    infinite: d
  } = e, p = i % r !== 0 ? 0 : (i - s) % r;
  if (t.message === "previous")
    o = p === 0 ? r : a - p, l = s - o, u && !d && (n = s - o, l = n === -1 ? i - 1 : n), d || (l = c - r);
  else if (t.message === "next")
    o = p === 0 ? r : p, l = s + o, u && !d && (l = (s + r) % i + p), d || (l = c + r);
  else if (t.message === "dots")
    l = t.index * t.slidesToScroll;
  else if (t.message === "children") {
    if (l = t.index, d) {
      const m = cLe(_(_({}, e), {
        targetSlide: l
      }));
      l > t.currentSlide && m === "left" ? l = l - i : l < t.currentSlide && m === "right" && (l = l + i);
    }
  } else t.message === "index" && (l = Number(t.index));
  return l;
}, oLe = (e, t, n) => e.target.tagName.match("TEXTAREA|INPUT|SELECT") || !t ? "" : e.keyCode === 37 ? n ? "next" : "previous" : e.keyCode === 39 ? n ? "previous" : "next" : "", lLe = (e, t, n) => (e.target.tagName === "IMG" && Of(e), !t || !n && e.type.indexOf("mouse") !== -1 ? "" : {
  dragging: !0,
  touchObject: {
    startX: e.touches ? e.touches[0].pageX : e.clientX,
    startY: e.touches ? e.touches[0].pageY : e.clientY,
    curX: e.touches ? e.touches[0].pageX : e.clientX,
    curY: e.touches ? e.touches[0].pageY : e.clientY
  }
}), rLe = (e, t) => {
  const {
    scrolling: n,
    animating: o,
    vertical: l,
    swipeToSlide: r,
    verticalSwiping: a,
    rtl: i,
    currentSlide: s,
    edgeFriction: c,
    edgeDragged: u,
    onEdge: d,
    swiped: f,
    swiping: p,
    slideCount: m,
    slidesToScroll: v,
    infinite: h,
    touchObject: g,
    swipeEvent: y,
    listHeight: b,
    listWidth: C
  } = t;
  if (n) return;
  if (o) return Of(e);
  l && r && a && Of(e);
  let w, x = {};
  const E = zm(t);
  g.curX = e.touches ? e.touches[0].pageX : e.clientX, g.curY = e.touches ? e.touches[0].pageY : e.clientY, g.swipeLength = Math.round(Math.sqrt(Math.pow(g.curX - g.startX, 2)));
  const I = Math.round(Math.sqrt(Math.pow(g.curY - g.startY, 2)));
  if (!a && !p && I > 10)
    return {
      scrolling: !0
    };
  a && (g.swipeLength = I);
  let T = (i ? -1 : 1) * (g.curX > g.startX ? 1 : -1);
  a && (T = g.curY > g.startY ? 1 : -1);
  const P = Math.ceil(m / v), k = aK(t.touchObject, a);
  let N = g.swipeLength;
  return h || (s === 0 && (k === "right" || k === "down") || s + 1 >= P && (k === "left" || k === "up") || !DS(t) && (k === "left" || k === "up")) && (N = g.swipeLength * c, u === !1 && d && (d(k), x.edgeDragged = !0)), !f && y && (y(k), x.swiped = !0), l ? w = E + N * (b / C) * T : i ? w = E - N * T : w = E + N * T, a && (w = E + N * T), x = _(_({}, x), {
    touchObject: g,
    swipeLeft: w,
    trackStyle: Vm(_(_({}, t), {
      left: w
    }))
  }), Math.abs(g.curX - g.startX) < Math.abs(g.curY - g.startY) * 0.8 || g.swipeLength > 10 && (x.swiping = !0, Of(e)), x;
}, aLe = (e, t) => {
  const {
    dragging: n,
    swipe: o,
    touchObject: l,
    listWidth: r,
    touchThreshold: a,
    verticalSwiping: i,
    listHeight: s,
    swipeToSlide: c,
    scrolling: u,
    onSwipe: d,
    targetSlide: f,
    currentSlide: p,
    infinite: m
  } = t;
  if (!n)
    return o && Of(e), {};
  const v = i ? s / a : r / a, h = aK(l, i), g = {
    dragging: !1,
    edgeDragged: !1,
    scrolling: !1,
    swiping: !1,
    swiped: !1,
    swipeLeft: null,
    touchObject: {}
  };
  if (u || !l.swipeLength)
    return g;
  if (l.swipeLength > v) {
    Of(e), d && d(h);
    let y, b;
    const C = m ? p : f;
    switch (h) {
      case "left":
      case "up":
        b = C + V6(t), y = c ? F6(t, b) : b, g.currentDirection = 0;
        break;
      case "right":
      case "down":
        b = C - V6(t), y = c ? F6(t, b) : b, g.currentDirection = 1;
        break;
      default:
        y = C;
    }
    g.triggerSlideHandler = y;
  } else {
    const y = zm(t);
    g.trackStyle = iK(_(_({}, t), {
      left: y
    }));
  }
  return g;
}, iLe = (e) => {
  const t = e.infinite ? e.slideCount * 2 : e.slideCount;
  let n = e.infinite ? e.slidesToShow * -1 : 0, o = e.infinite ? e.slidesToShow * -1 : 0;
  const l = [];
  for (; n < t; )
    l.push(n), n = o + e.slidesToScroll, o += Math.min(e.slidesToScroll, e.slidesToShow);
  return l;
}, F6 = (e, t) => {
  const n = iLe(e);
  let o = 0;
  if (t > n[n.length - 1])
    t = n[n.length - 1];
  else
    for (const l in n) {
      if (t < n[l]) {
        t = o;
        break;
      }
      o = n[l];
    }
  return t;
}, V6 = (e) => {
  const t = e.centerMode ? e.slideWidth * Math.floor(e.slidesToShow / 2) : 0;
  if (e.swipeToSlide) {
    let n;
    const o = e.listRef, l = o.querySelectorAll && o.querySelectorAll(".slick-slide") || [];
    if (Array.from(l).every((i) => {
      if (e.vertical) {
        if (i.offsetTop + AT(i) / 2 > e.swipeLeft * -1)
          return n = i, !1;
      } else if (i.offsetLeft - t + V2(i) / 2 > e.swipeLeft * -1)
        return n = i, !1;
      return !0;
    }), !n)
      return 0;
    const r = e.rtl === !0 ? e.slideCount - e.currentSlide : e.currentSlide;
    return Math.abs(n.dataset.index - r) || 1;
  } else
    return e.slidesToScroll;
}, RT = (e, t) => t.reduce((n, o) => n && e.hasOwnProperty(o), !0) ? null : console.error("Keys Missing:", e), Vm = (e) => {
  RT(e, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth"]);
  let t, n;
  const o = e.slideCount + 2 * e.slidesToShow;
  e.vertical ? n = o * e.slideHeight : t = sLe(e) * e.slideWidth;
  let l = {
    opacity: 1,
    transition: "",
    WebkitTransition: ""
  };
  if (e.useTransform) {
    const r = e.vertical ? "translate3d(0px, " + e.left + "px, 0px)" : "translate3d(" + e.left + "px, 0px, 0px)", a = e.vertical ? "translate3d(0px, " + e.left + "px, 0px)" : "translate3d(" + e.left + "px, 0px, 0px)", i = e.vertical ? "translateY(" + e.left + "px)" : "translateX(" + e.left + "px)";
    l = _(_({}, l), {
      WebkitTransform: r,
      transform: a,
      msTransform: i
    });
  } else
    e.vertical ? l.top = e.left : l.left = e.left;
  return e.fade && (l = {
    opacity: 1
  }), t && (l.width = t + "px"), n && (l.height = n + "px"), window && !window.addEventListener && window.attachEvent && (e.vertical ? l.marginTop = e.left + "px" : l.marginLeft = e.left + "px"), l;
}, iK = (e) => {
  RT(e, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth", "speed", "cssEase"]);
  const t = Vm(e);
  return e.useTransform ? (t.WebkitTransition = "-webkit-transform " + e.speed + "ms " + e.cssEase, t.transition = "transform " + e.speed + "ms " + e.cssEase) : e.vertical ? t.transition = "top " + e.speed + "ms " + e.cssEase : t.transition = "left " + e.speed + "ms " + e.cssEase, t;
}, zm = (e) => {
  if (e.unslick)
    return 0;
  RT(e, ["slideIndex", "trackRef", "infinite", "centerMode", "slideCount", "slidesToShow", "slidesToScroll", "slideWidth", "listWidth", "variableWidth", "slideHeight"]);
  const {
    slideIndex: t,
    trackRef: n,
    infinite: o,
    centerMode: l,
    slideCount: r,
    slidesToShow: a,
    slidesToScroll: i,
    slideWidth: s,
    listWidth: c,
    variableWidth: u,
    slideHeight: d,
    fade: f,
    vertical: p
  } = e;
  let m = 0, v, h, g = 0;
  if (f || e.slideCount === 1)
    return 0;
  let y = 0;
  if (o ? (y = -ss(e), r % i !== 0 && t + i > r && (y = -(t > r ? a - (t - r) : r % i)), l && (y += parseInt(a / 2))) : (r % i !== 0 && t + i > r && (y = a - r % i), l && (y = parseInt(a / 2))), m = y * s, g = y * d, p ? v = t * d * -1 + g : v = t * s * -1 + m, u === !0) {
    let b;
    const C = n;
    if (b = t + ss(e), h = C && C.childNodes[b], v = h ? h.offsetLeft * -1 : 0, l === !0) {
      b = o ? t + ss(e) : t, h = C && C.children[b], v = 0;
      for (let w = 0; w < b; w++)
        v -= C && C.children[w] && C.children[w].offsetWidth;
      v -= parseInt(e.centerPadding), v += h && (c - h.offsetWidth) / 2;
    }
  }
  return v;
}, ss = (e) => e.unslick || !e.infinite ? 0 : e.variableWidth ? e.slideCount : e.slidesToShow + (e.centerMode ? 1 : 0), Rb = (e) => e.unslick || !e.infinite ? 0 : e.slideCount, sLe = (e) => e.slideCount === 1 ? 1 : ss(e) + e.slideCount + Rb(e), cLe = (e) => e.targetSlide > e.currentSlide ? e.targetSlide > e.currentSlide + uLe(e) ? "left" : "right" : e.targetSlide < e.currentSlide - dLe(e) ? "right" : "left", uLe = (e) => {
  let {
    slidesToShow: t,
    centerMode: n,
    rtl: o,
    centerPadding: l
  } = e;
  if (n) {
    let r = (t - 1) / 2 + 1;
    return parseInt(l) > 0 && (r += 1), o && t % 2 === 0 && (r += 1), r;
  }
  return o ? 0 : t - 1;
}, dLe = (e) => {
  let {
    slidesToShow: t,
    centerMode: n,
    rtl: o,
    centerPadding: l
  } = e;
  if (n) {
    let r = (t - 1) / 2 + 1;
    return parseInt(l) > 0 && (r += 1), !o && t % 2 === 0 && (r += 1), r;
  }
  return o ? t - 1 : 0;
}, z6 = () => !!(typeof window != "undefined" && window.document && window.document.createElement), Vw = (e) => {
  let t, n, o, l;
  e.rtl ? l = e.slideCount - 1 - e.index : l = e.index;
  const r = l < 0 || l >= e.slideCount;
  e.centerMode ? (o = Math.floor(e.slidesToShow / 2), n = (l - e.currentSlide) % e.slideCount === 0, l > e.currentSlide - o - 1 && l <= e.currentSlide + o && (t = !0)) : t = e.currentSlide <= l && l < e.currentSlide + e.slidesToShow;
  let a;
  return e.targetSlide < 0 ? a = e.targetSlide + e.slideCount : e.targetSlide >= e.slideCount ? a = e.targetSlide - e.slideCount : a = e.targetSlide, {
    "slick-slide": !0,
    "slick-active": t,
    "slick-center": n,
    "slick-cloned": r,
    "slick-current": l === a
    // dubious in case of RTL
  };
}, fLe = function(e) {
  const t = {};
  return (e.variableWidth === void 0 || e.variableWidth === !1) && (t.width = e.slideWidth + (typeof e.slideWidth == "number" ? "px" : "")), e.fade && (t.position = "relative", e.vertical ? t.top = -e.index * parseInt(e.slideHeight) + "px" : t.left = -e.index * parseInt(e.slideWidth) + "px", t.opacity = e.currentSlide === e.index ? 1 : 0, e.useCSS && (t.transition = "opacity " + e.speed + "ms " + e.cssEase + ", visibility " + e.speed + "ms " + e.cssEase)), t;
}, zw = (e, t) => e.key + "-" + t, pLe = function(e, t) {
  let n;
  const o = [], l = [], r = [], a = t.length, i = lK(e), s = rK(e);
  return t.forEach((c, u) => {
    let d;
    const f = {
      message: "children",
      index: u,
      slidesToScroll: e.slidesToScroll,
      currentSlide: e.currentSlide
    };
    !e.lazyLoad || e.lazyLoad && e.lazyLoadedList.indexOf(u) >= 0 ? d = c : d = $("div");
    const p = fLe(_(_({}, e), {
      index: u
    })), m = d.props.class || "";
    let v = Vw(_(_({}, e), {
      index: u
    }));
    if (o.push(Rv(d, {
      key: "original" + zw(d, u),
      tabindex: "-1",
      "data-index": u,
      "aria-hidden": !v["slick-active"],
      class: ke(v, m),
      style: _(_({
        outline: "none"
      }, d.props.style || {}), p),
      onClick: () => {
        e.focusOnSelect && e.focusOnSelect(f);
      }
    })), e.infinite && e.fade === !1) {
      const h = a - u;
      h <= ss(e) && a !== e.slidesToShow && (n = -h, n >= i && (d = c), v = Vw(_(_({}, e), {
        index: n
      })), l.push(Rv(d, {
        key: "precloned" + zw(d, n),
        class: ke(v, m),
        tabindex: "-1",
        "data-index": n,
        "aria-hidden": !v["slick-active"],
        style: _(_({}, d.props.style || {}), p),
        onClick: () => {
          e.focusOnSelect && e.focusOnSelect(f);
        }
      }))), a !== e.slidesToShow && (n = a + u, n < s && (d = c), v = Vw(_(_({}, e), {
        index: n
      })), r.push(Rv(d, {
        key: "postcloned" + zw(d, n),
        tabindex: "-1",
        "data-index": n,
        "aria-hidden": !v["slick-active"],
        class: ke(v, m),
        style: _(_({}, d.props.style || {}), p),
        onClick: () => {
          e.focusOnSelect && e.focusOnSelect(f);
        }
      })));
    }
  }), e.rtl ? l.concat(o, r).reverse() : l.concat(o, r);
}, sK = (e, t) => {
  let {
    attrs: n,
    slots: o
  } = t;
  const l = pLe(n, Fn(o == null ? void 0 : o.default())), {
    onMouseenter: r,
    onMouseover: a,
    onMouseleave: i
  } = n, s = {
    onMouseenter: r,
    onMouseover: a,
    onMouseleave: i
  }, c = _({
    class: "slick-track",
    style: n.trackStyle
  }, s);
  return $("div", c, [l]);
};
sK.inheritAttrs = !1;
const vLe = function(e) {
  let t;
  return e.infinite ? t = Math.ceil(e.slideCount / e.slidesToScroll) : t = Math.ceil((e.slideCount - e.slidesToShow) / e.slidesToScroll) + 1, t;
}, cK = (e, t) => {
  let {
    attrs: n
  } = t;
  const {
    slideCount: o,
    slidesToScroll: l,
    slidesToShow: r,
    infinite: a,
    currentSlide: i,
    appendDots: s,
    customPaging: c,
    clickHandler: u,
    dotsClass: d,
    onMouseenter: f,
    onMouseover: p,
    onMouseleave: m
  } = n, v = vLe({
    slideCount: o,
    slidesToScroll: l,
    slidesToShow: r,
    infinite: a
  }), h = {
    onMouseenter: f,
    onMouseover: p,
    onMouseleave: m
  };
  let g = [];
  for (let y = 0; y < v; y++) {
    let T = function(P) {
      P && P.preventDefault(), u(I);
    };
    const b = (y + 1) * l - 1, C = a ? b : F2(b, 0, o - 1), w = C - (l - 1), x = a ? w : F2(w, 0, o - 1), E = ke({
      "slick-active": a ? i >= x && i <= C : i === x
    }), I = {
      message: "dots",
      index: y,
      slidesToScroll: l,
      currentSlide: i
    };
    g = g.concat($("li", {
      key: y,
      class: E
    }, [_n(c({
      i: y
    }), {
      onClick: T
    })]));
  }
  return _n(s({
    dots: g
  }), _({
    class: d
  }, h));
};
cK.inheritAttrs = !1;
function uK() {
}
function dK(e, t, n) {
  n && n.preventDefault(), t(e, n);
}
const fK = (e, t) => {
  let {
    attrs: n
  } = t;
  const {
    clickHandler: o,
    infinite: l,
    currentSlide: r,
    slideCount: a,
    slidesToShow: i
  } = n, s = {
    "slick-arrow": !0,
    "slick-prev": !0
  };
  let c = function(p) {
    dK({
      message: "previous"
    }, o, p);
  };
  !l && (r === 0 || a <= i) && (s["slick-disabled"] = !0, c = uK);
  const u = {
    key: "0",
    "data-role": "none",
    class: s,
    style: {
      display: "block"
    },
    onClick: c
  }, d = {
    currentSlide: r,
    slideCount: a
  };
  let f;
  return n.prevArrow ? f = _n(n.prevArrow(_(_({}, u), d)), {
    key: "0",
    class: s,
    style: {
      display: "block"
    },
    onClick: c
  }, !1) : f = $("button", Q({
    key: "0",
    type: "button"
  }, u), [" ", Ft("Previous")]), f;
};
fK.inheritAttrs = !1;
const pK = (e, t) => {
  let {
    attrs: n
  } = t;
  const {
    clickHandler: o,
    currentSlide: l,
    slideCount: r
  } = n, a = {
    "slick-arrow": !0,
    "slick-next": !0
  };
  let i = function(d) {
    dK({
      message: "next"
    }, o, d);
  };
  DS(n) || (a["slick-disabled"] = !0, i = uK);
  const s = {
    key: "1",
    "data-role": "none",
    class: ke(a),
    style: {
      display: "block"
    },
    onClick: i
  }, c = {
    currentSlide: l,
    slideCount: r
  };
  let u;
  return n.nextArrow ? u = _n(n.nextArrow(_(_({}, s), c)), {
    key: "1",
    class: ke(a),
    style: {
      display: "block"
    },
    onClick: i
  }, !1) : u = $("button", Q({
    key: "1",
    type: "button"
  }, s), [" ", Ft("Next")]), u;
};
pK.inheritAttrs = !1;
var mLe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function xr() {
}
const hLe = {
  name: "InnerSlider",
  mixins: [dd],
  inheritAttrs: !1,
  props: _({}, oK),
  data() {
    this.preProps = _({}, this.$props), this.list = null, this.track = null, this.callbackTimers = [], this.clickable = !0, this.debouncedResize = null;
    const e = this.ssrInit();
    return _(_(_({}, J5e), {
      currentSlide: this.initialSlide,
      slideCount: this.children.length
    }), e);
  },
  watch: {
    autoplay(e, t) {
      !t && e ? this.handleAutoPlay("playing") : e ? this.handleAutoPlay("update") : this.pause("paused");
    },
    __propsSymbol__() {
      const e = this.$props, t = _(_({
        listRef: this.list,
        trackRef: this.track
      }, e), this.$data);
      let n = !1;
      for (const o of Object.keys(this.preProps)) {
        if (!e.hasOwnProperty(o)) {
          n = !0;
          break;
        }
        if (!(typeof e[o] == "object" || typeof e[o] == "function" || typeof e[o] == "symbol") && e[o] !== this.preProps[o]) {
          n = !0;
          break;
        }
      }
      this.updateState(t, n, () => {
        this.currentSlide >= e.children.length && this.changeSlide({
          message: "index",
          index: e.children.length - e.slidesToShow,
          currentSlide: this.currentSlide
        }), !this.preProps.autoplay && e.autoplay ? this.handleAutoPlay("playing") : e.autoplay ? this.handleAutoPlay("update") : this.pause("paused");
      }), this.preProps = _({}, e);
    }
  },
  mounted() {
    if (this.__emit("init"), this.lazyLoad) {
      const e = Ay(_(_({}, this.$props), this.$data));
      e.length > 0 && (this.setState((t) => ({
        lazyLoadedList: t.lazyLoadedList.concat(e)
      })), this.__emit("lazyLoad", e));
    }
    this.$nextTick(() => {
      const e = _({
        listRef: this.list,
        trackRef: this.track,
        children: this.children
      }, this.$props);
      this.updateState(e, !0, () => {
        this.adaptHeight(), this.autoplay && this.handleAutoPlay("playing");
      }), this.lazyLoad === "progressive" && (this.lazyLoadTimer = setInterval(this.progressiveLazyLoad, 1e3)), this.ro = new tI(() => {
        this.animating ? (this.onWindowResized(!1), this.callbackTimers.push(setTimeout(() => this.onWindowResized(), this.speed))) : this.onWindowResized();
      }), this.ro.observe(this.list), document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), (t) => {
        t.onfocus = this.$props.pauseOnFocus ? this.onSlideFocus : null, t.onblur = this.$props.pauseOnFocus ? this.onSlideBlur : null;
      }), window.addEventListener ? window.addEventListener("resize", this.onWindowResized) : window.attachEvent("onresize", this.onWindowResized);
    });
  },
  beforeUnmount() {
    var e;
    this.animationEndCallback && clearTimeout(this.animationEndCallback), this.lazyLoadTimer && clearInterval(this.lazyLoadTimer), this.callbackTimers.length && (this.callbackTimers.forEach((t) => clearTimeout(t)), this.callbackTimers = []), window.addEventListener ? window.removeEventListener("resize", this.onWindowResized) : window.detachEvent("onresize", this.onWindowResized), this.autoplayTimer && clearInterval(this.autoplayTimer), (e = this.ro) === null || e === void 0 || e.disconnect();
  },
  updated() {
    if (this.checkImagesLoad(), this.__emit("reInit"), this.lazyLoad) {
      const e = Ay(_(_({}, this.$props), this.$data));
      e.length > 0 && (this.setState((t) => ({
        lazyLoadedList: t.lazyLoadedList.concat(e)
      })), this.__emit("lazyLoad"));
    }
    this.adaptHeight();
  },
  methods: {
    listRefHandler(e) {
      this.list = e;
    },
    trackRefHandler(e) {
      this.track = e;
    },
    adaptHeight() {
      if (this.adaptiveHeight && this.list) {
        const e = this.list.querySelector(`[data-index="${this.currentSlide}"]`);
        this.list.style.height = AT(e) + "px";
      }
    },
    onWindowResized(e) {
      this.debouncedResize && this.debouncedResize.cancel(), this.debouncedResize = Dr(() => this.resizeWindow(e), 50), this.debouncedResize();
    },
    resizeWindow() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      if (!!!this.track) return;
      const n = _(_({
        listRef: this.list,
        trackRef: this.track,
        children: this.children
      }, this.$props), this.$data);
      this.updateState(n, e, () => {
        this.autoplay ? this.handleAutoPlay("update") : this.pause("paused");
      }), this.setState({
        animating: !1
      }), clearTimeout(this.animationEndCallback), delete this.animationEndCallback;
    },
    updateState(e, t, n) {
      const o = eLe(e);
      e = _(_(_({}, e), o), {
        slideIndex: o.currentSlide
      });
      const l = zm(e);
      e = _(_({}, e), {
        left: l
      });
      const r = Vm(e);
      (t || this.children.length !== e.children.length) && (o.trackStyle = r), this.setState(o, n);
    },
    ssrInit() {
      const e = this.children;
      if (this.variableWidth) {
        let s = 0, c = 0;
        const u = [], d = ss(_(_(_({}, this.$props), this.$data), {
          slideCount: e.length
        })), f = Rb(_(_(_({}, this.$props), this.$data), {
          slideCount: e.length
        }));
        e.forEach((m) => {
          var v, h;
          const g = ((h = (v = m.props.style) === null || v === void 0 ? void 0 : v.width) === null || h === void 0 ? void 0 : h.split("px")[0]) || 0;
          u.push(g), s += g;
        });
        for (let m = 0; m < d; m++)
          c += u[u.length - 1 - m], s += u[u.length - 1 - m];
        for (let m = 0; m < f; m++)
          s += u[m];
        for (let m = 0; m < this.currentSlide; m++)
          c += u[m];
        const p = {
          width: s + "px",
          left: -c + "px"
        };
        if (this.centerMode) {
          const m = `${u[this.currentSlide]}px`;
          p.left = `calc(${p.left} + (100% - ${m}) / 2 ) `;
        }
        return {
          trackStyle: p
        };
      }
      const t = e.length, n = _(_(_({}, this.$props), this.$data), {
        slideCount: t
      }), o = ss(n) + Rb(n) + t, l = 100 / this.slidesToShow * o, r = 100 / o;
      let a = -r * (ss(n) + this.currentSlide) * l / 100;
      this.centerMode && (a += (100 - r * l / 100) / 2);
      const i = {
        width: l + "%",
        left: a + "%"
      };
      return {
        slideWidth: r + "%",
        trackStyle: i
      };
    },
    checkImagesLoad() {
      const e = this.list && this.list.querySelectorAll && this.list.querySelectorAll(".slick-slide img") || [], t = e.length;
      let n = 0;
      Array.prototype.forEach.call(e, (o) => {
        const l = () => ++n && n >= t && this.onWindowResized();
        if (!o.onclick)
          o.onclick = () => o.parentNode.focus();
        else {
          const r = o.onclick;
          o.onclick = () => {
            r(), o.parentNode.focus();
          };
        }
        o.onload || (this.$props.lazyLoad ? o.onload = () => {
          this.adaptHeight(), this.callbackTimers.push(setTimeout(this.onWindowResized, this.speed));
        } : (o.onload = l, o.onerror = () => {
          l(), this.__emit("lazyLoadError");
        }));
      });
    },
    progressiveLazyLoad() {
      const e = [], t = _(_({}, this.$props), this.$data);
      for (let n = this.currentSlide; n < this.slideCount + Rb(t); n++)
        if (this.lazyLoadedList.indexOf(n) < 0) {
          e.push(n);
          break;
        }
      for (let n = this.currentSlide - 1; n >= -ss(t); n--)
        if (this.lazyLoadedList.indexOf(n) < 0) {
          e.push(n);
          break;
        }
      e.length > 0 ? (this.setState((n) => ({
        lazyLoadedList: n.lazyLoadedList.concat(e)
      })), this.__emit("lazyLoad", e)) : this.lazyLoadTimer && (clearInterval(this.lazyLoadTimer), delete this.lazyLoadTimer);
    },
    slideHandler(e) {
      let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      const {
        asNavFor: n,
        beforeChange: o,
        speed: l,
        afterChange: r
      } = this.$props, {
        state: a,
        nextState: i
      } = tLe(_(_(_({
        index: e
      }, this.$props), this.$data), {
        trackRef: this.track,
        useCSS: this.useCSS && !t
      }));
      if (!a) return;
      o && o(this.currentSlide, a.currentSlide);
      const s = a.lazyLoadedList.filter((c) => this.lazyLoadedList.indexOf(c) < 0);
      this.$attrs.onLazyLoad && s.length > 0 && this.__emit("lazyLoad", s), !this.$props.waitForAnimate && this.animationEndCallback && (clearTimeout(this.animationEndCallback), r && r(this.currentSlide), delete this.animationEndCallback), this.setState(a, () => {
        n && this.asNavForIndex !== e && (this.asNavForIndex = e, n.innerSlider.slideHandler(e)), i && (this.animationEndCallback = setTimeout(() => {
          const {
            animating: c
          } = i, u = mLe(i, ["animating"]);
          this.setState(u, () => {
            this.callbackTimers.push(setTimeout(() => this.setState({
              animating: c
            }), 10)), r && r(a.currentSlide), delete this.animationEndCallback;
          });
        }, l));
      });
    },
    changeSlide(e) {
      let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      const n = _(_({}, this.$props), this.$data), o = nLe(n, e);
      if (!(o !== 0 && !o) && (t === !0 ? this.slideHandler(o, t) : this.slideHandler(o), this.$props.autoplay && this.handleAutoPlay("update"), this.$props.focusOnSelect)) {
        const l = this.list.querySelectorAll(".slick-current");
        l[0] && l[0].focus();
      }
    },
    clickHandler(e) {
      this.clickable === !1 && (e.stopPropagation(), e.preventDefault()), this.clickable = !0;
    },
    keyHandler(e) {
      const t = oLe(e, this.accessibility, this.rtl);
      t !== "" && this.changeSlide({
        message: t
      });
    },
    selectHandler(e) {
      this.changeSlide(e);
    },
    disableBodyScroll() {
      const e = (t) => {
        t = t || window.event, t.preventDefault && t.preventDefault(), t.returnValue = !1;
      };
      window.ontouchmove = e;
    },
    enableBodyScroll() {
      window.ontouchmove = null;
    },
    swipeStart(e) {
      this.verticalSwiping && this.disableBodyScroll();
      const t = lLe(e, this.swipe, this.draggable);
      t !== "" && this.setState(t);
    },
    swipeMove(e) {
      const t = rLe(e, _(_(_({}, this.$props), this.$data), {
        trackRef: this.track,
        listRef: this.list,
        slideIndex: this.currentSlide
      }));
      t && (t.swiping && (this.clickable = !1), this.setState(t));
    },
    swipeEnd(e) {
      const t = aLe(e, _(_(_({}, this.$props), this.$data), {
        trackRef: this.track,
        listRef: this.list,
        slideIndex: this.currentSlide
      }));
      if (!t) return;
      const n = t.triggerSlideHandler;
      delete t.triggerSlideHandler, this.setState(t), n !== void 0 && (this.slideHandler(n), this.$props.verticalSwiping && this.enableBodyScroll());
    },
    touchEnd(e) {
      this.swipeEnd(e), this.clickable = !0;
    },
    slickPrev() {
      this.callbackTimers.push(setTimeout(() => this.changeSlide({
        message: "previous"
      }), 0));
    },
    slickNext() {
      this.callbackTimers.push(setTimeout(() => this.changeSlide({
        message: "next"
      }), 0));
    },
    slickGoTo(e) {
      let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      if (e = Number(e), isNaN(e)) return "";
      this.callbackTimers.push(setTimeout(() => this.changeSlide({
        message: "index",
        index: e,
        currentSlide: this.currentSlide
      }, t), 0));
    },
    play() {
      let e;
      if (this.rtl)
        e = this.currentSlide - this.slidesToScroll;
      else if (DS(_(_({}, this.$props), this.$data)))
        e = this.currentSlide + this.slidesToScroll;
      else
        return !1;
      this.slideHandler(e);
    },
    handleAutoPlay(e) {
      this.autoplayTimer && clearInterval(this.autoplayTimer);
      const t = this.autoplaying;
      if (e === "update") {
        if (t === "hovered" || t === "focused" || t === "paused")
          return;
      } else if (e === "leave") {
        if (t === "paused" || t === "focused")
          return;
      } else if (e === "blur" && (t === "paused" || t === "hovered"))
        return;
      this.autoplayTimer = setInterval(this.play, this.autoplaySpeed + 50), this.setState({
        autoplaying: "playing"
      });
    },
    pause(e) {
      this.autoplayTimer && (clearInterval(this.autoplayTimer), this.autoplayTimer = null);
      const t = this.autoplaying;
      e === "paused" ? this.setState({
        autoplaying: "paused"
      }) : e === "focused" ? (t === "hovered" || t === "playing") && this.setState({
        autoplaying: "focused"
      }) : t === "playing" && this.setState({
        autoplaying: "hovered"
      });
    },
    onDotsOver() {
      this.autoplay && this.pause("hovered");
    },
    onDotsLeave() {
      this.autoplay && this.autoplaying === "hovered" && this.handleAutoPlay("leave");
    },
    onTrackOver() {
      this.autoplay && this.pause("hovered");
    },
    onTrackLeave() {
      this.autoplay && this.autoplaying === "hovered" && this.handleAutoPlay("leave");
    },
    onSlideFocus() {
      this.autoplay && this.pause("focused");
    },
    onSlideBlur() {
      this.autoplay && this.autoplaying === "focused" && this.handleAutoPlay("blur");
    },
    customPaging(e) {
      let {
        i: t
      } = e;
      return $("button", null, [t + 1]);
    },
    appendDots(e) {
      let {
        dots: t
      } = e;
      return $("ul", {
        style: {
          display: "block"
        }
      }, [t]);
    }
  },
  render() {
    const e = ke("slick-slider", this.$attrs.class, {
      "slick-vertical": this.vertical,
      "slick-initialized": !0
    }), t = _(_({}, this.$props), this.$data);
    let n = Fw(t, ["fade", "cssEase", "speed", "infinite", "centerMode", "focusOnSelect", "currentSlide", "lazyLoad", "lazyLoadedList", "rtl", "slideWidth", "slideHeight", "listHeight", "vertical", "slidesToShow", "slidesToScroll", "slideCount", "trackStyle", "variableWidth", "unslick", "centerPadding", "targetSlide", "useCSS"]);
    const {
      pauseOnHover: o
    } = this.$props;
    n = _(_({}, n), {
      focusOnSelect: this.focusOnSelect && this.clickable ? this.selectHandler : null,
      ref: this.trackRefHandler,
      onMouseleave: o ? this.onTrackLeave : xr,
      onMouseover: o ? this.onTrackOver : xr
    });
    let l;
    if (this.dots === !0 && this.slideCount >= this.slidesToShow) {
      let h = Fw(t, ["dotsClass", "slideCount", "slidesToShow", "currentSlide", "slidesToScroll", "clickHandler", "children", "infinite", "appendDots"]);
      h.customPaging = this.customPaging, h.appendDots = this.appendDots;
      const {
        customPaging: g,
        appendDots: y
      } = this.$slots;
      g && (h.customPaging = g), y && (h.appendDots = y);
      const {
        pauseOnDotsHover: b
      } = this.$props;
      h = _(_({}, h), {
        clickHandler: this.changeSlide,
        onMouseover: b ? this.onDotsOver : xr,
        onMouseleave: b ? this.onDotsLeave : xr
      }), l = $(cK, h, null);
    }
    let r, a;
    const i = Fw(t, ["infinite", "centerMode", "currentSlide", "slideCount", "slidesToShow"]);
    i.clickHandler = this.changeSlide;
    const {
      prevArrow: s,
      nextArrow: c
    } = this.$slots;
    s && (i.prevArrow = s), c && (i.nextArrow = c), this.arrows && (r = $(fK, i, null), a = $(pK, i, null));
    let u = null;
    this.vertical && (u = {
      height: typeof this.listHeight == "number" ? `${this.listHeight}px` : this.listHeight
    });
    let d = null;
    this.vertical === !1 ? this.centerMode === !0 && (d = {
      padding: "0px " + this.centerPadding
    }) : this.centerMode === !0 && (d = {
      padding: this.centerPadding + " 0px"
    });
    const f = _(_({}, u), d), p = this.touchMove;
    let m = {
      ref: this.listRefHandler,
      class: "slick-list",
      style: f,
      onClick: this.clickHandler,
      onMousedown: p ? this.swipeStart : xr,
      onMousemove: this.dragging && p ? this.swipeMove : xr,
      onMouseup: p ? this.swipeEnd : xr,
      onMouseleave: this.dragging && p ? this.swipeEnd : xr,
      [Ho ? "onTouchstartPassive" : "onTouchstart"]: p ? this.swipeStart : xr,
      [Ho ? "onTouchmovePassive" : "onTouchmove"]: this.dragging && p ? this.swipeMove : xr,
      onTouchend: p ? this.touchEnd : xr,
      onTouchcancel: this.dragging && p ? this.swipeEnd : xr,
      onKeydown: this.accessibility ? this.keyHandler : xr
    }, v = {
      class: e,
      dir: "ltr",
      style: this.$attrs.style
    };
    return this.unslick && (m = {
      class: "slick-list",
      ref: this.listRefHandler
    }, v = {
      class: e
    }), $("div", v, [this.unslick ? "" : r, $("div", m, [$(sK, n, {
      default: () => [this.children]
    })]), this.unslick ? "" : a, this.unslick ? "" : l]);
  }
}, gLe = /* @__PURE__ */ le({
  name: "Slider",
  mixins: [dd],
  inheritAttrs: !1,
  props: _({}, oK),
  data() {
    return this._responsiveMediaHandlers = [], {
      breakpoint: null
    };
  },
  // handles responsive breakpoints
  mounted() {
    if (this.responsive) {
      const e = this.responsive.map((n) => n.breakpoint);
      e.sort((n, o) => n - o), e.forEach((n, o) => {
        let l;
        o === 0 ? l = Bw({
          minWidth: 0,
          maxWidth: n
        }) : l = Bw({
          minWidth: e[o - 1] + 1,
          maxWidth: n
        }), z6() && this.media(l, () => {
          this.setState({
            breakpoint: n
          });
        });
      });
      const t = Bw({
        minWidth: e.slice(-1)[0]
      });
      z6() && this.media(t, () => {
        this.setState({
          breakpoint: null
        });
      });
    }
  },
  beforeUnmount() {
    this._responsiveMediaHandlers.forEach(function(e) {
      e.mql.removeListener(e.listener);
    });
  },
  methods: {
    innerSliderRefHandler(e) {
      this.innerSlider = e;
    },
    media(e, t) {
      const n = window.matchMedia(e), o = (l) => {
        let {
          matches: r
        } = l;
        r && t();
      };
      n.addListener(o), o(n), this._responsiveMediaHandlers.push({
        mql: n,
        query: e,
        listener: o
      });
    },
    slickPrev() {
      var e;
      (e = this.innerSlider) === null || e === void 0 || e.slickPrev();
    },
    slickNext() {
      var e;
      (e = this.innerSlider) === null || e === void 0 || e.slickNext();
    },
    slickGoTo(e) {
      let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      var n;
      (n = this.innerSlider) === null || n === void 0 || n.slickGoTo(e, t);
    },
    slickPause() {
      var e;
      (e = this.innerSlider) === null || e === void 0 || e.pause("paused");
    },
    slickPlay() {
      var e;
      (e = this.innerSlider) === null || e === void 0 || e.handleAutoPlay("play");
    }
  },
  render() {
    var e;
    let t, n;
    this.breakpoint ? (n = this.responsive.filter((i) => i.breakpoint === this.breakpoint), t = n[0].settings === "unslick" ? "unslick" : _(_({}, this.$props), n[0].settings)) : t = _({}, this.$props), t.centerMode && (t.slidesToScroll > 1 && process.env.NODE_ENV !== "production" && console.warn(`slidesToScroll should be equal to 1 in centerMode, you are using ${t.slidesToScroll}`), t.slidesToScroll = 1), t.fade && (t.slidesToShow > 1 && process.env.NODE_ENV !== "production" && console.warn(`slidesToShow should be equal to 1 when fade is true, you're using ${t.slidesToShow}`), t.slidesToScroll > 1 && process.env.NODE_ENV !== "production" && console.warn(`slidesToScroll should be equal to 1 when fade is true, you're using ${t.slidesToScroll}`), t.slidesToShow = 1, t.slidesToScroll = 1);
    let o = nS(this) || [];
    o = o.filter((i) => typeof i == "string" ? !!i.trim() : !!i), t.variableWidth && (t.rows > 1 || t.slidesPerRow > 1) && (console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1"), t.variableWidth = !1);
    const l = [];
    let r = null;
    for (let i = 0; i < o.length; i += t.rows * t.slidesPerRow) {
      const s = [];
      for (let c = i; c < i + t.rows * t.slidesPerRow; c += t.slidesPerRow) {
        const u = [];
        for (let d = c; d < c + t.slidesPerRow && (t.variableWidth && (!((e = o[d].props) === null || e === void 0) && e.style) && (r = o[d].props.style.width), !(d >= o.length)); d += 1)
          u.push(_n(o[d], {
            key: 100 * i + 10 * c + d,
            tabindex: -1,
            style: {
              width: `${100 / t.slidesPerRow}%`,
              display: "inline-block"
            }
          }));
        s.push($("div", {
          key: 10 * i + c
        }, [u]));
      }
      t.variableWidth ? l.push($("div", {
        key: i,
        style: {
          width: r
        }
      }, [s])) : l.push($("div", {
        key: i
      }, [s]));
    }
    if (t === "unslick") {
      const i = "regular slider " + (this.className || "");
      return $("div", {
        class: i
      }, [o]);
    } else l.length <= t.slidesToShow && (t.unslick = !0);
    const a = _(_(_({}, this.$attrs), t), {
      children: l,
      ref: this.innerSliderRefHandler
    });
    return $(hLe, Q(Q({}, a), {}, {
      __propsSymbol__: []
    }), this.$slots);
  }
}), bLe = (e) => {
  const {
    componentCls: t,
    antCls: n,
    carouselArrowSize: o,
    carouselDotOffset: l,
    marginXXS: r
  } = e, a = -o * 1.25, i = r;
  return {
    [t]: _(_({}, nn(e)), {
      ".slick-slider": {
        position: "relative",
        display: "block",
        boxSizing: "border-box",
        touchAction: "pan-y",
        WebkitTouchCallout: "none",
        WebkitTapHighlightColor: "transparent",
        ".slick-track, .slick-list": {
          transform: "translate3d(0, 0, 0)",
          touchAction: "pan-y"
        }
      },
      ".slick-list": {
        position: "relative",
        display: "block",
        margin: 0,
        padding: 0,
        overflow: "hidden",
        "&:focus": {
          outline: "none"
        },
        "&.dragging": {
          cursor: "pointer"
        },
        ".slick-slide": {
          pointerEvents: "none",
          // https://github.com/ant-design/ant-design/issues/23294
          [`input${n}-radio-input, input${n}-checkbox-input`]: {
            visibility: "hidden"
          },
          "&.slick-active": {
            pointerEvents: "auto",
            [`input${n}-radio-input, input${n}-checkbox-input`]: {
              visibility: "visible"
            }
          },
          // fix Carousel content height not match parent node
          // when children is empty node
          // https://github.com/ant-design/ant-design/issues/25878
          "> div > div": {
            verticalAlign: "bottom"
          }
        }
      },
      ".slick-track": {
        position: "relative",
        top: 0,
        insetInlineStart: 0,
        display: "block",
        "&::before, &::after": {
          display: "table",
          content: '""'
        },
        "&::after": {
          clear: "both"
        }
      },
      ".slick-slide": {
        display: "none",
        float: "left",
        height: "100%",
        minHeight: 1,
        img: {
          display: "block"
        },
        "&.dragging img": {
          pointerEvents: "none"
        }
      },
      ".slick-initialized .slick-slide": {
        display: "block"
      },
      ".slick-vertical .slick-slide": {
        display: "block",
        height: "auto"
      },
      ".slick-arrow.slick-hidden": {
        display: "none"
      },
      // Arrows
      ".slick-prev, .slick-next": {
        position: "absolute",
        top: "50%",
        display: "block",
        width: o,
        height: o,
        marginTop: -o / 2,
        padding: 0,
        color: "transparent",
        fontSize: 0,
        lineHeight: 0,
        background: "transparent",
        border: 0,
        outline: "none",
        cursor: "pointer",
        "&:hover, &:focus": {
          color: "transparent",
          background: "transparent",
          outline: "none",
          "&::before": {
            opacity: 1
          }
        },
        "&.slick-disabled::before": {
          opacity: 0.25
        }
      },
      ".slick-prev": {
        insetInlineStart: a,
        "&::before": {
          content: '""'
        }
      },
      ".slick-next": {
        insetInlineEnd: a,
        "&::before": {
          content: '""'
        }
      },
      // Dots
      ".slick-dots": {
        position: "absolute",
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 15,
        display: "flex !important",
        justifyContent: "center",
        paddingInlineStart: 0,
        listStyle: "none",
        "&-bottom": {
          bottom: l
        },
        "&-top": {
          top: l,
          bottom: "auto"
        },
        li: {
          position: "relative",
          display: "inline-block",
          flex: "0 1 auto",
          boxSizing: "content-box",
          width: e.dotWidth,
          height: e.dotHeight,
          marginInline: i,
          padding: 0,
          textAlign: "center",
          textIndent: -999,
          verticalAlign: "top",
          transition: `all ${e.motionDurationSlow}`,
          button: {
            position: "relative",
            display: "block",
            width: "100%",
            height: e.dotHeight,
            padding: 0,
            color: "transparent",
            fontSize: 0,
            background: e.colorBgContainer,
            border: 0,
            borderRadius: 1,
            outline: "none",
            cursor: "pointer",
            opacity: 0.3,
            transition: `all ${e.motionDurationSlow}`,
            "&: hover, &:focus": {
              opacity: 0.75
            },
            "&::after": {
              position: "absolute",
              inset: -i,
              content: '""'
            }
          },
          "&.slick-active": {
            width: e.dotWidthActive,
            "& button": {
              background: e.colorBgContainer,
              opacity: 1
            },
            "&: hover, &:focus": {
              opacity: 1
            }
          }
        }
      }
    })
  };
}, yLe = (e) => {
  const {
    componentCls: t,
    carouselDotOffset: n,
    marginXXS: o
  } = e, l = {
    width: e.dotHeight,
    height: e.dotWidth
  };
  return {
    [`${t}-vertical`]: {
      ".slick-dots": {
        top: "50%",
        bottom: "auto",
        flexDirection: "column",
        width: e.dotHeight,
        height: "auto",
        margin: 0,
        transform: "translateY(-50%)",
        "&-left": {
          insetInlineEnd: "auto",
          insetInlineStart: n
        },
        "&-right": {
          insetInlineEnd: n,
          insetInlineStart: "auto"
        },
        li: _(_({}, l), {
          margin: `${o}px 0`,
          verticalAlign: "baseline",
          button: l,
          "&.slick-active": _(_({}, l), {
            button: l
          })
        })
      }
    }
  };
}, SLe = (e) => {
  const {
    componentCls: t
  } = e;
  return [{
    [`${t}-rtl`]: {
      direction: "rtl",
      // Dots
      ".slick-dots": {
        [`${t}-rtl&`]: {
          flexDirection: "row-reverse"
        }
      }
    }
  }, {
    [`${t}-vertical`]: {
      ".slick-dots": {
        [`${t}-rtl&`]: {
          flexDirection: "column"
        }
      }
    }
  }];
}, CLe = Zt("Carousel", (e) => {
  const {
    controlHeightLG: t,
    controlHeightSM: n
  } = e, o = Vt(e, {
    carouselArrowSize: t / 2,
    carouselDotOffset: n / 2
  });
  return [bLe(o), yLe(o), SLe(o)];
}, {
  dotWidth: 16,
  dotHeight: 3,
  dotWidthActive: 24
});
var wLe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const $Le = () => ({
  effect: At(),
  dots: Qe(!0),
  vertical: Qe(),
  autoplay: Qe(),
  easing: String,
  beforeChange: Fe(),
  afterChange: Fe(),
  // style: PropTypes.React.CSSProperties,
  prefixCls: String,
  accessibility: Qe(),
  nextArrow: de.any,
  prevArrow: de.any,
  pauseOnHover: Qe(),
  // className: String,
  adaptiveHeight: Qe(),
  arrows: Qe(!1),
  autoplaySpeed: Number,
  centerMode: Qe(),
  centerPadding: String,
  cssEase: String,
  dotsClass: String,
  draggable: Qe(!1),
  fade: Qe(),
  focusOnSelect: Qe(),
  infinite: Qe(),
  initialSlide: Number,
  lazyLoad: At(),
  rtl: Qe(),
  slide: String,
  slidesToShow: Number,
  slidesToScroll: Number,
  speed: Number,
  swipe: Qe(),
  swipeToSlide: Qe(),
  swipeEvent: Fe(),
  touchMove: Qe(),
  touchThreshold: Number,
  variableWidth: Qe(),
  useCSS: Qe(),
  slickGoTo: Number,
  responsive: Array,
  dotPosition: At(),
  verticalSwiping: Qe(!1)
}), xLe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ACarousel",
  inheritAttrs: !1,
  props: $Le(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: l
    } = t;
    const r = /* @__PURE__ */ H();
    l({
      goTo: function(m) {
        let v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        var h;
        (h = r.value) === null || h === void 0 || h.slickGoTo(m, v);
      },
      autoplay: (m) => {
        var v, h;
        (h = (v = r.value) === null || v === void 0 ? void 0 : v.innerSlider) === null || h === void 0 || h.handleAutoPlay(m);
      },
      prev: () => {
        var m;
        (m = r.value) === null || m === void 0 || m.slickPrev();
      },
      next: () => {
        var m;
        (m = r.value) === null || m === void 0 || m.slickNext();
      },
      innerSlider: O(() => {
        var m;
        return (m = r.value) === null || m === void 0 ? void 0 : m.innerSlider;
      })
    }), Ot(() => {
      Hn(e.vertical === void 0, "Carousel", "`vertical` is deprecated, please use `dotPosition` instead.");
    });
    const {
      prefixCls: i,
      direction: s
    } = bt("carousel", e), [c, u] = CLe(i), d = O(() => e.dotPosition ? e.dotPosition : e.vertical !== void 0 && e.vertical ? "right" : "bottom"), f = O(() => d.value === "left" || d.value === "right"), p = O(() => {
      const m = "slick-dots";
      return ke({
        [m]: !0,
        [`${m}-${d.value}`]: !0,
        [`${e.dotsClass}`]: !!e.dotsClass
      });
    });
    return () => {
      const {
        dots: m,
        arrows: v,
        draggable: h,
        effect: g
      } = e, {
        class: y,
        style: b
      } = o, C = wLe(o, ["class", "style"]), w = g === "fade" ? !0 : e.fade, x = ke(i.value, {
        [`${i.value}-rtl`]: s.value === "rtl",
        [`${i.value}-vertical`]: f.value,
        [`${y}`]: !!y
      }, u.value);
      return c($("div", {
        class: x,
        style: b
      }, [$(gLe, Q(Q(Q({
        ref: r
      }, e), C), {}, {
        dots: !!m,
        dotsClass: p.value,
        arrows: v,
        draggable: h,
        fade: w,
        vertical: f.value
      }), n)]));
    };
  }
}), ELe = po(xLe), DT = "__RC_CASCADER_SPLIT__", vK = "SHOW_PARENT", mK = "SHOW_CHILD";
function dc(e) {
  return e.join(DT);
}
function ef(e) {
  return e.map(dc);
}
function OLe(e) {
  return e.split(DT);
}
function _Le(e) {
  const {
    label: t,
    value: n,
    children: o
  } = e || {}, l = n || "value";
  return {
    label: t || "label",
    value: l,
    key: l,
    children: o || "children"
  };
}
function yv(e, t) {
  var n, o;
  return (n = e.isLeaf) !== null && n !== void 0 ? n : !(!((o = e[t.children]) === null || o === void 0) && o.length);
}
function ILe(e) {
  const t = e.parentElement;
  if (!t)
    return;
  const n = e.offsetTop - t.offsetTop;
  n - t.scrollTop < 0 ? t.scrollTo({
    top: n
  }) : n + e.offsetHeight - t.scrollTop > t.offsetHeight && t.scrollTo({
    top: n + e.offsetHeight - t.offsetHeight
  });
}
const hK = Symbol("TreeContextKey"), TLe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "TreeContext",
  props: {
    value: {
      type: Object
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return at(hK, O(() => e.value)), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), LT = () => ze(hK, O(() => ({}))), gK = Symbol("KeysStateKey"), PLe = (e) => {
  at(gK, e);
}, bK = () => ze(gK, {
  expandedKeys: /* @__PURE__ */ Ce([]),
  selectedKeys: /* @__PURE__ */ Ce([]),
  loadedKeys: /* @__PURE__ */ Ce([]),
  loadingKeys: /* @__PURE__ */ Ce([]),
  checkedKeys: /* @__PURE__ */ Ce([]),
  halfCheckedKeys: /* @__PURE__ */ Ce([]),
  expandedKeysSet: O(() => /* @__PURE__ */ new Set()),
  selectedKeysSet: O(() => /* @__PURE__ */ new Set()),
  loadedKeysSet: O(() => /* @__PURE__ */ new Set()),
  loadingKeysSet: O(() => /* @__PURE__ */ new Set()),
  checkedKeysSet: O(() => /* @__PURE__ */ new Set()),
  halfCheckedKeysSet: O(() => /* @__PURE__ */ new Set()),
  flattenNodes: /* @__PURE__ */ Ce([])
}), kLe = (e) => {
  let {
    prefixCls: t,
    level: n,
    isStart: o,
    isEnd: l
  } = e;
  const r = `${t}-indent-unit`, a = [];
  for (let i = 0; i < n; i += 1)
    a.push($("span", {
      key: i,
      class: {
        [r]: !0,
        [`${r}-start`]: o[i],
        [`${r}-end`]: l[i]
      }
    }, null));
  return $("span", {
    "aria-hidden": "true",
    class: `${t}-indent`
  }, [a]);
}, yK = {
  eventKey: [String, Number],
  prefixCls: String,
  // By parent
  // expanded: { type: Boolean, default: undefined },
  // selected: { type: Boolean, default: undefined },
  // checked: { type: Boolean, default: undefined },
  // loaded: { type: Boolean, default: undefined },
  // loading: { type: Boolean, default: undefined },
  // halfChecked: { type: Boolean, default: undefined },
  // dragOver: { type: Boolean, default: undefined },
  // dragOverGapTop: { type: Boolean, default: undefined },
  // dragOverGapBottom: { type: Boolean, default: undefined },
  // pos: String,
  title: de.any,
  /** New added in Tree for easy data access */
  data: {
    type: Object,
    default: void 0
  },
  parent: {
    type: Object,
    default: void 0
  },
  isStart: {
    type: Array
  },
  isEnd: {
    type: Array
  },
  active: {
    type: Boolean,
    default: void 0
  },
  onMousemove: {
    type: Function
  },
  // By user
  isLeaf: {
    type: Boolean,
    default: void 0
  },
  checkable: {
    type: Boolean,
    default: void 0
  },
  selectable: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  disableCheckbox: {
    type: Boolean,
    default: void 0
  },
  icon: de.any,
  switcherIcon: de.any,
  domRef: {
    type: Function
  }
}, NLe = {
  prefixCls: {
    type: String
  },
  // data: { type: Array as PropType<FlattenNode[]> },
  motion: {
    type: Object
  },
  focusable: {
    type: Boolean
  },
  activeItem: {
    type: Object
  },
  focused: {
    type: Boolean
  },
  tabindex: {
    type: Number
  },
  checkable: {
    type: Boolean
  },
  selectable: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  // expandedKeys: { type: Array as PropType<Key[]> },
  // selectedKeys: { type: Array as PropType<Key[]> },
  // checkedKeys: { type: Array as PropType<Key[]> },
  // loadedKeys: { type: Array as PropType<Key[]> },
  // loadingKeys: { type: Array as PropType<Key[]> },
  // halfCheckedKeys: { type: Array as PropType<Key[]> },
  // keyEntities: { type: Object as PropType<Record<Key, DataEntity<DataNode>>> },
  // dragging: { type: Boolean as PropType<boolean> },
  // dragOverNodeKey: { type: [String, Number] as PropType<Key> },
  // dropPosition: { type: Number as PropType<number> },
  // Virtual list
  height: {
    type: Number
  },
  itemHeight: {
    type: Number
  },
  virtual: {
    type: Boolean
  },
  onScroll: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onActiveChange: {
    type: Function
  },
  onContextmenu: {
    type: Function
  },
  onListChangeStart: {
    type: Function
  },
  onListChangeEnd: {
    type: Function
  }
}, SK = () => ({
  prefixCls: String,
  focusable: {
    type: Boolean,
    default: void 0
  },
  activeKey: [Number, String],
  tabindex: Number,
  children: de.any,
  treeData: {
    type: Array
  },
  fieldNames: {
    type: Object
  },
  showLine: {
    type: [Boolean, Object],
    default: void 0
  },
  showIcon: {
    type: Boolean,
    default: void 0
  },
  icon: de.any,
  selectable: {
    type: Boolean,
    default: void 0
  },
  expandAction: [String, Boolean],
  disabled: {
    type: Boolean,
    default: void 0
  },
  multiple: {
    type: Boolean,
    default: void 0
  },
  checkable: {
    type: Boolean,
    default: void 0
  },
  checkStrictly: {
    type: Boolean,
    default: void 0
  },
  draggable: {
    type: [Function, Boolean]
  },
  defaultExpandParent: {
    type: Boolean,
    default: void 0
  },
  autoExpandParent: {
    type: Boolean,
    default: void 0
  },
  defaultExpandAll: {
    type: Boolean,
    default: void 0
  },
  defaultExpandedKeys: {
    type: Array
  },
  expandedKeys: {
    type: Array
  },
  defaultCheckedKeys: {
    type: Array
  },
  checkedKeys: {
    type: [Object, Array]
  },
  defaultSelectedKeys: {
    type: Array
  },
  selectedKeys: {
    type: Array
  },
  allowDrop: {
    type: Function
  },
  dropIndicatorRender: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onContextmenu: {
    type: Function
  },
  onClick: {
    type: Function
  },
  onDblclick: {
    type: Function
  },
  onScroll: {
    type: Function
  },
  onExpand: {
    type: Function
  },
  onCheck: {
    type: Function
  },
  onSelect: {
    type: Function
  },
  onLoad: {
    type: Function
  },
  loadData: {
    type: Function
  },
  loadedKeys: {
    type: Array
  },
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onRightClick: {
    type: Function
  },
  onDragstart: {
    type: Function
  },
  onDragenter: {
    type: Function
  },
  onDragover: {
    type: Function
  },
  onDragleave: {
    type: Function
  },
  onDragend: {
    type: Function
  },
  onDrop: {
    type: Function
  },
  /**
   * Used for `rc-tree-select` only.
   * Do not use in your production code directly since this will be refactor.
   */
  onActiveChange: {
    type: Function
  },
  filterTreeNode: {
    type: Function
  },
  motion: de.any,
  switcherIcon: de.any,
  // Virtual List
  height: Number,
  itemHeight: Number,
  virtual: {
    type: Boolean,
    default: void 0
  },
  // direction for drag logic
  direction: {
    type: String
  },
  rootClassName: String,
  rootStyle: Object
});
var MLe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const H6 = "open", j6 = "close", ALe = "---", z2 = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ATreeNode",
  inheritAttrs: !1,
  props: yK,
  isTreeNode: 1,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: l
    } = t;
    bn(!("slots" in e.data), `treeData slots is deprecated, please use ${Object.keys(e.data.slots || {}).map((Se) => "`v-slot:" + Se + "` ")}instead`);
    const r = /* @__PURE__ */ Ce(!1), a = LT(), {
      expandedKeysSet: i,
      selectedKeysSet: s,
      loadedKeysSet: c,
      loadingKeysSet: u,
      checkedKeysSet: d,
      halfCheckedKeysSet: f
    } = bK(), {
      dragOverNodeKey: p,
      dropPosition: m,
      keyEntities: v
    } = a.value, h = O(() => Db(e.eventKey, {
      expandedKeysSet: i.value,
      selectedKeysSet: s.value,
      loadedKeysSet: c.value,
      loadingKeysSet: u.value,
      checkedKeysSet: d.value,
      halfCheckedKeysSet: f.value,
      dragOverNodeKey: p,
      dropPosition: m,
      keyEntities: v
    })), g = _r(() => h.value.expanded), y = _r(() => h.value.selected), b = _r(() => h.value.checked), C = _r(() => h.value.loaded), w = _r(() => h.value.loading), x = _r(() => h.value.halfChecked), E = _r(() => h.value.dragOver), I = _r(() => h.value.dragOverGapTop), T = _r(() => h.value.dragOverGapBottom), P = _r(() => h.value.pos), k = /* @__PURE__ */ Ce(), N = O(() => {
      const {
        eventKey: Se
      } = e, {
        keyEntities: be
      } = a.value, {
        children: ie
      } = be[Se] || {};
      return !!(ie || []).length;
    }), R = O(() => {
      const {
        isLeaf: Se
      } = e, {
        loadData: be
      } = a.value, ie = N.value;
      return Se === !1 ? !1 : Se || !be && !ie || be && C.value && !ie;
    }), z = O(() => R.value ? null : g.value ? H6 : j6), D = O(() => {
      const {
        disabled: Se
      } = e, {
        disabled: be
      } = a.value;
      return !!(be || Se);
    }), F = O(() => {
      const {
        checkable: Se
      } = e, {
        checkable: be
      } = a.value;
      return !be || Se === !1 ? !1 : be;
    }), M = O(() => {
      const {
        selectable: Se
      } = e, {
        selectable: be
      } = a.value;
      return typeof Se == "boolean" ? Se : be;
    }), A = O(() => {
      const {
        data: Se,
        active: be,
        checkable: ie,
        disableCheckbox: we,
        disabled: Ne,
        selectable: tt
      } = e;
      return _(_({
        active: be,
        checkable: ie,
        disableCheckbox: we,
        disabled: Ne,
        selectable: tt
      }, Se), {
        dataRef: Se,
        data: Se,
        isLeaf: R.value,
        checked: b.value,
        expanded: g.value,
        loading: w.value,
        selected: y.value,
        halfChecked: x.value
      });
    }), L = xt(), B = O(() => {
      const {
        eventKey: Se
      } = e, {
        keyEntities: be
      } = a.value, {
        parent: ie
      } = be[Se] || {};
      return _(_({}, Lb(_({}, e, h.value))), {
        parent: ie
      });
    }), V = /* @__PURE__ */ kt({
      eventData: B,
      eventKey: O(() => e.eventKey),
      selectHandle: k,
      pos: P,
      key: L.vnode.key
    });
    l(V);
    const j = (Se) => {
      const {
        onNodeDoubleClick: be
      } = a.value;
      be(Se, B.value);
    }, W = (Se) => {
      if (D.value) return;
      const {
        onNodeSelect: be
      } = a.value;
      Se.preventDefault(), be(Se, B.value);
    }, Y = (Se) => {
      if (D.value) return;
      const {
        disableCheckbox: be
      } = e, {
        onNodeCheck: ie
      } = a.value;
      if (!F.value || be) return;
      Se.preventDefault();
      const we = !b.value;
      ie(Se, B.value, we);
    }, U = (Se) => {
      const {
        onNodeClick: be
      } = a.value;
      be(Se, B.value), M.value ? W(Se) : Y(Se);
    }, te = (Se) => {
      const {
        onNodeMouseEnter: be
      } = a.value;
      be(Se, B.value);
    }, J = (Se) => {
      const {
        onNodeMouseLeave: be
      } = a.value;
      be(Se, B.value);
    }, re = (Se) => {
      const {
        onNodeContextMenu: be
      } = a.value;
      be(Se, B.value);
    }, oe = (Se) => {
      const {
        onNodeDragStart: be
      } = a.value;
      Se.stopPropagation(), r.value = !0, be(Se, V);
      try {
        Se.dataTransfer.setData("text/plain", "");
      } catch (ie) {
      }
    }, q = (Se) => {
      const {
        onNodeDragEnter: be
      } = a.value;
      Se.preventDefault(), Se.stopPropagation(), be(Se, V);
    }, K = (Se) => {
      const {
        onNodeDragOver: be
      } = a.value;
      Se.preventDefault(), Se.stopPropagation(), be(Se, V);
    }, se = (Se) => {
      const {
        onNodeDragLeave: be
      } = a.value;
      Se.stopPropagation(), be(Se, V);
    }, Z = (Se) => {
      const {
        onNodeDragEnd: be
      } = a.value;
      Se.stopPropagation(), r.value = !1, be(Se, V);
    }, ee = (Se) => {
      const {
        onNodeDrop: be
      } = a.value;
      Se.preventDefault(), Se.stopPropagation(), r.value = !1, be(Se, V);
    }, fe = (Se) => {
      const {
        onNodeExpand: be
      } = a.value;
      w.value || be(Se, B.value);
    }, me = () => {
      const {
        data: Se
      } = e, {
        draggable: be
      } = a.value;
      return !!(be && (!be.nodeDraggable || be.nodeDraggable(Se)));
    }, ge = () => {
      const {
        draggable: Se,
        prefixCls: be
      } = a.value;
      return Se && (Se != null && Se.icon) ? $("span", {
        class: `${be}-draggable-icon`
      }, [Se.icon]) : null;
    }, he = () => {
      var Se, be, ie;
      const {
        switcherIcon: we = o.switcherIcon || ((Se = a.value.slots) === null || Se === void 0 ? void 0 : Se[(ie = (be = e.data) === null || be === void 0 ? void 0 : be.slots) === null || ie === void 0 ? void 0 : ie.switcherIcon])
      } = e, {
        switcherIcon: Ne
      } = a.value, tt = we || Ne;
      return typeof tt == "function" ? tt(A.value) : tt;
    }, $e = () => {
      const {
        loadData: Se,
        onNodeLoad: be
      } = a.value;
      w.value || Se && g.value && !R.value && !N.value && !C.value && be(B.value);
    };
    nt(() => {
      $e();
    }), $o(() => {
      $e();
    });
    const ne = () => {
      const {
        prefixCls: Se
      } = a.value, be = he();
      if (R.value)
        return be !== !1 ? $("span", {
          class: ke(`${Se}-switcher`, `${Se}-switcher-noop`)
        }, [be]) : null;
      const ie = ke(`${Se}-switcher`, `${Se}-switcher_${g.value ? H6 : j6}`);
      return be !== !1 ? $("span", {
        onClick: fe,
        class: ie
      }, [be]) : null;
    }, ae = () => {
      var Se, be;
      const {
        disableCheckbox: ie
      } = e, {
        prefixCls: we
      } = a.value, Ne = D.value;
      return F.value ? $("span", {
        class: ke(`${we}-checkbox`, b.value && `${we}-checkbox-checked`, !b.value && x.value && `${we}-checkbox-indeterminate`, (Ne || ie) && `${we}-checkbox-disabled`),
        onClick: Y
      }, [(be = (Se = a.value).customCheckable) === null || be === void 0 ? void 0 : be.call(Se)]) : null;
    }, ce = () => {
      const {
        prefixCls: Se
      } = a.value;
      return $("span", {
        class: ke(`${Se}-iconEle`, `${Se}-icon__${z.value || "docu"}`, w.value && `${Se}-icon_loading`)
      }, null);
    }, xe = () => {
      const {
        disabled: Se,
        eventKey: be
      } = e, {
        draggable: ie,
        dropLevelOffset: we,
        dropPosition: Ne,
        prefixCls: tt,
        indent: Pe,
        dropIndicatorRender: Re,
        dragOverNodeKey: Le,
        direction: Ue
      } = a.value;
      return !Se && ie !== !1 && Le === be ? Re({
        dropPosition: Ne,
        dropLevelOffset: we,
        indent: Pe,
        prefixCls: tt,
        direction: Ue
      }) : null;
    }, Te = () => {
      var Se, be, ie, we, Ne, tt;
      const {
        // title = slots.title ||
        //   context.value.slots?.[props.data?.slots?.title] ||
        //   context.value.slots?.title,
        // selected,
        icon: Pe = o.icon,
        // loading,
        data: Re
      } = e, Le = o.title || ((Se = a.value.slots) === null || Se === void 0 ? void 0 : Se[(ie = (be = e.data) === null || be === void 0 ? void 0 : be.slots) === null || ie === void 0 ? void 0 : ie.title]) || ((we = a.value.slots) === null || we === void 0 ? void 0 : we.title) || e.title, {
        prefixCls: Ue,
        showIcon: Ae,
        icon: De,
        loadData: _e
        // slots: contextSlots,
      } = a.value, Ze = D.value, dt = `${Ue}-node-content-wrapper`;
      let Tt;
      if (Ae) {
        const je = Pe || ((Ne = a.value.slots) === null || Ne === void 0 ? void 0 : Ne[(tt = Re == null ? void 0 : Re.slots) === null || tt === void 0 ? void 0 : tt.icon]) || De;
        Tt = je ? $("span", {
          class: ke(`${Ue}-iconEle`, `${Ue}-icon__customize`)
        }, [typeof je == "function" ? je(A.value) : je]) : ce();
      } else _e && w.value && (Tt = ce());
      let jt;
      typeof Le == "function" ? jt = Le(A.value) : jt = Le, jt = jt === void 0 ? ALe : jt;
      const Qt = $("span", {
        class: `${Ue}-title`
      }, [jt]);
      return $("span", {
        ref: k,
        title: typeof Le == "string" ? Le : "",
        class: ke(`${dt}`, `${dt}-${z.value || "normal"}`, !Ze && (y.value || r.value) && `${Ue}-node-selected`),
        onMouseenter: te,
        onMouseleave: J,
        onContextmenu: re,
        onClick: U,
        onDblclick: j
      }, [Tt, Qt, xe()]);
    };
    return () => {
      const Se = _(_({}, e), n), {
        eventKey: be,
        isLeaf: ie,
        isStart: we,
        isEnd: Ne,
        domRef: tt,
        active: Pe,
        data: Re,
        onMousemove: Le,
        selectable: Ue
      } = Se, Ae = MLe(Se, ["eventKey", "isLeaf", "isStart", "isEnd", "domRef", "active", "data", "onMousemove", "selectable"]), {
        prefixCls: De,
        filterTreeNode: _e,
        keyEntities: Ze,
        dropContainerKey: dt,
        dropTargetKey: Tt,
        draggingNodeKey: jt
      } = a.value, Qt = D.value, je = Mc(Ae, {
        aria: !0,
        data: !0
      }), {
        level: lt
      } = Ze[be] || {}, Ct = Ne[Ne.length - 1], vn = me(), tn = !Qt && vn, ct = jt === be, pt = Ue !== void 0 ? {
        "aria-selected": !!Ue
      } : void 0;
      return $("div", Q(Q({
        ref: tt,
        class: ke(n.class, `${De}-treenode`, {
          [`${De}-treenode-disabled`]: Qt,
          [`${De}-treenode-switcher-${g.value ? "open" : "close"}`]: !ie,
          [`${De}-treenode-checkbox-checked`]: b.value,
          [`${De}-treenode-checkbox-indeterminate`]: x.value,
          [`${De}-treenode-selected`]: y.value,
          [`${De}-treenode-loading`]: w.value,
          [`${De}-treenode-active`]: Pe,
          [`${De}-treenode-leaf-last`]: Ct,
          [`${De}-treenode-draggable`]: tn,
          dragging: ct,
          "drop-target": Tt === be,
          "drop-container": dt === be,
          "drag-over": !Qt && E.value,
          "drag-over-gap-top": !Qt && I.value,
          "drag-over-gap-bottom": !Qt && T.value,
          "filter-node": _e && _e(B.value)
        }),
        style: n.style,
        draggable: tn,
        "aria-grabbed": ct,
        onDragstart: tn ? oe : void 0,
        onDragenter: vn ? q : void 0,
        onDragover: vn ? K : void 0,
        onDragleave: vn ? se : void 0,
        onDrop: vn ? ee : void 0,
        onDragend: vn ? Z : void 0,
        onMousemove: Le
      }, pt), je), [$(kLe, {
        prefixCls: De,
        level: lt,
        isStart: we,
        isEnd: Ne
      }, null), ge(), ne(), ae(), Te()]);
    };
  }
});
function oi(e, t) {
  if (!e) return [];
  const n = e.slice(), o = n.indexOf(t);
  return o >= 0 && n.splice(o, 1), n;
}
function Ki(e, t) {
  const n = (e || []).slice();
  return n.indexOf(t) === -1 && n.push(t), n;
}
function BT(e) {
  return e.split("-");
}
function CK(e, t) {
  return `${e}-${t}`;
}
function RLe(e) {
  return e && e.type && e.type.isTreeNode;
}
function DLe(e, t) {
  const n = [], o = t[e];
  function l() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((a) => {
      let {
        key: i,
        children: s
      } = a;
      n.push(i), l(s);
    });
  }
  return l(o.children), n;
}
function LLe(e) {
  if (e.parent) {
    const t = BT(e.pos);
    return Number(t[t.length - 1]) === e.parent.children.length - 1;
  }
  return !1;
}
function BLe(e) {
  const t = BT(e.pos);
  return Number(t[t.length - 1]) === 0;
}
function W6(e, t, n, o, l, r, a, i, s, c) {
  var u;
  const {
    clientX: d,
    clientY: f
  } = e, {
    top: p,
    height: m
  } = e.target.getBoundingClientRect(), h = ((c === "rtl" ? -1 : 1) * (((l == null ? void 0 : l.x) || 0) - d) - 12) / o;
  let g = i[n.eventKey];
  if (f < p + m / 2) {
    const P = a.findIndex((R) => R.key === g.key), k = P <= 0 ? 0 : P - 1, N = a[k].key;
    g = i[N];
  }
  const y = g.key, b = g, C = g.key;
  let w = 0, x = 0;
  if (!s.has(y))
    for (let P = 0; P < h && LLe(g); P += 1)
      g = g.parent, x += 1;
  const E = t.eventData, I = g.node;
  let T = !0;
  return BLe(g) && g.level === 0 && f < p + m / 2 && r({
    dragNode: E,
    dropNode: I,
    dropPosition: -1
  }) && g.key === n.eventKey ? w = -1 : (b.children || []).length && s.has(C) ? r({
    dragNode: E,
    dropNode: I,
    dropPosition: 0
  }) ? w = 0 : T = !1 : x === 0 ? h > -1.5 ? r({
    dragNode: E,
    dropNode: I,
    dropPosition: 1
  }) ? w = 1 : T = !1 : r({
    dragNode: E,
    dropNode: I,
    dropPosition: 0
  }) ? w = 0 : r({
    dragNode: E,
    dropNode: I,
    dropPosition: 1
  }) ? w = 1 : T = !1 : r({
    dragNode: E,
    dropNode: I,
    dropPosition: 1
  }) ? w = 1 : T = !1, {
    dropPosition: w,
    dropLevelOffset: x,
    dropTargetKey: g.key,
    dropTargetPos: g.pos,
    dragOverNodeKey: C,
    dropContainerKey: w === 0 ? null : ((u = g.parent) === null || u === void 0 ? void 0 : u.key) || null,
    dropAllowed: T
  };
}
function K6(e, t) {
  if (!e) return;
  const {
    multiple: n
  } = t;
  return n ? e.slice() : e.length ? [e[0]] : e;
}
function Hw(e) {
  if (!e)
    return null;
  let t;
  if (Array.isArray(e))
    t = {
      checkedKeys: e,
      halfCheckedKeys: void 0
    };
  else if (typeof e == "object")
    t = {
      checkedKeys: e.checked || void 0,
      halfCheckedKeys: e.halfChecked || void 0
    };
  else
    return bn(!1, "`checkedKeys` is not an array or an object"), null;
  return t;
}
function H2(e, t) {
  const n = /* @__PURE__ */ new Set();
  function o(l) {
    if (n.has(l)) return;
    const r = t[l];
    if (!r) return;
    n.add(l);
    const {
      parent: a,
      node: i
    } = r;
    i.disabled || a && o(a.key);
  }
  return (e || []).forEach((l) => {
    o(l);
  }), [...n];
}
var FLe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function Dh(e, t) {
  return e != null ? e : t;
}
function LS(e) {
  const {
    title: t,
    _title: n,
    key: o,
    children: l
  } = e || {}, r = t || "title";
  return {
    title: r,
    _title: n || [r],
    key: o || "key",
    children: l || "children"
  };
}
function j2(e) {
  function t() {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return mo(n).map((l) => {
      var r, a, i, s;
      if (!RLe(l))
        return bn(!l, "Tree/TreeNode can only accept TreeNode as children."), null;
      const c = l.children || {}, u = l.key, d = {};
      for (const [P, k] of Object.entries(l.props))
        d[Tp(P)] = k;
      const {
        isLeaf: f,
        checkable: p,
        selectable: m,
        disabled: v,
        disableCheckbox: h
      } = d, g = {
        isLeaf: f || f === "" || void 0,
        checkable: p || p === "" || void 0,
        selectable: m || m === "" || void 0,
        disabled: v || v === "" || void 0,
        disableCheckbox: h || h === "" || void 0
      }, y = _(_({}, d), g), {
        title: b = (r = c.title) === null || r === void 0 ? void 0 : r.call(c, y),
        icon: C = (a = c.icon) === null || a === void 0 ? void 0 : a.call(c, y),
        switcherIcon: w = (i = c.switcherIcon) === null || i === void 0 ? void 0 : i.call(c, y)
      } = d, x = FLe(d, ["title", "icon", "switcherIcon"]), E = (s = c.default) === null || s === void 0 ? void 0 : s.call(c), I = _(_(_({}, x), {
        title: b,
        icon: C,
        switcherIcon: w,
        key: u,
        isLeaf: f
      }), g), T = t(E);
      return T.length && (I.children = T), I;
    });
  }
  return t(e);
}
function VLe(e, t, n) {
  const {
    _title: o,
    key: l,
    children: r
  } = LS(n), a = new Set(t === !0 ? [] : t), i = [];
  function s(c) {
    let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return c.map((d, f) => {
      const p = CK(u ? u.pos : "0", f), m = Dh(d[l], p);
      let v;
      for (let g = 0; g < o.length; g += 1) {
        const y = o[g];
        if (d[y] !== void 0) {
          v = d[y];
          break;
        }
      }
      const h = _(_({}, pn(d, [...o, l, r])), {
        title: v,
        key: m,
        parent: u,
        pos: p,
        children: null,
        data: d,
        isStart: [...u ? u.isStart : [], f === 0],
        isEnd: [...u ? u.isEnd : [], f === c.length - 1]
      });
      return i.push(h), t === !0 || a.has(m) ? h.children = s(d[r] || [], h) : h.children = [], h;
    });
  }
  return s(e), i;
}
function zLe(e, t, n) {
  let o = {};
  typeof n == "object" ? o = n : o = {
    externalGetKey: n
  }, o = o || {};
  const {
    childrenPropName: l,
    externalGetKey: r,
    fieldNames: a
  } = o, {
    key: i,
    children: s
  } = LS(a), c = l || s;
  let u;
  r ? typeof r == "string" ? u = (f) => f[r] : typeof r == "function" && (u = (f) => r(f)) : u = (f, p) => Dh(f[i], p);
  function d(f, p, m, v) {
    const h = f ? f[c] : e, g = f ? CK(m.pos, p) : "0", y = f ? [...v, f] : [];
    if (f) {
      const b = u(f, g), C = {
        node: f,
        index: p,
        pos: g,
        key: b,
        parentPos: m.node ? m.pos : null,
        level: m.level + 1,
        nodes: y
      };
      t(C);
    }
    h && h.forEach((b, C) => {
      d(b, C, {
        node: f,
        pos: g,
        level: m ? m.level + 1 : -1
      }, y);
    });
  }
  d(null);
}
function Lh(e) {
  let {
    initWrapper: t,
    processEntity: n,
    onProcessFinished: o,
    externalGetKey: l,
    childrenPropName: r,
    fieldNames: a
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 ? arguments[2] : void 0;
  const s = l || i, c = {}, u = {};
  let d = {
    posEntities: c,
    keyEntities: u
  };
  return t && (d = t(d) || d), zLe(e, (f) => {
    const {
      node: p,
      index: m,
      pos: v,
      key: h,
      parentPos: g,
      level: y,
      nodes: b
    } = f, C = {
      node: p,
      nodes: b,
      index: m,
      key: h,
      pos: v,
      level: y
    }, w = Dh(h, v);
    c[v] = C, u[w] = C, C.parent = c[g], C.parent && (C.parent.children = C.parent.children || [], C.parent.children.push(C)), n && n(C, d);
  }, {
    externalGetKey: s,
    childrenPropName: r,
    fieldNames: a
  }), o && o(d), d;
}
function Db(e, t) {
  let {
    expandedKeysSet: n,
    selectedKeysSet: o,
    loadedKeysSet: l,
    loadingKeysSet: r,
    checkedKeysSet: a,
    halfCheckedKeysSet: i,
    dragOverNodeKey: s,
    dropPosition: c,
    keyEntities: u
  } = t;
  const d = u[e];
  return {
    eventKey: e,
    expanded: n.has(e),
    selected: o.has(e),
    loaded: l.has(e),
    loading: r.has(e),
    checked: a.has(e),
    halfChecked: i.has(e),
    pos: String(d ? d.pos : ""),
    parent: d.parent,
    // [Legacy] Drag props
    // Since the interaction of drag is changed, the semantic of the props are
    // not accuracy, I think it should be finally removed
    dragOver: s === e && c === 0,
    dragOverGapTop: s === e && c === -1,
    dragOverGapBottom: s === e && c === 1
  };
}
function Lb(e) {
  const {
    data: t,
    expanded: n,
    selected: o,
    checked: l,
    loaded: r,
    loading: a,
    halfChecked: i,
    dragOver: s,
    dragOverGapTop: c,
    dragOverGapBottom: u,
    pos: d,
    active: f,
    eventKey: p
  } = e, m = _(_({
    dataRef: t
  }, t), {
    expanded: n,
    selected: o,
    checked: l,
    loaded: r,
    loading: a,
    halfChecked: i,
    dragOver: s,
    dragOverGapTop: c,
    dragOverGapBottom: u,
    pos: d,
    active: f,
    eventKey: p,
    key: p
  });
  return "props" in m || Object.defineProperty(m, "props", {
    get() {
      return bn(!1, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`."), e;
    }
  }), m;
}
const HLe = (e, t) => O(() => Lh(e.value, {
  fieldNames: t.value,
  initWrapper: (o) => _(_({}, o), {
    pathKeyEntities: {}
  }),
  processEntity: (o, l) => {
    const r = o.nodes.map((a) => a[t.value.value]).join(DT);
    l.pathKeyEntities[r] = o, o.key = r;
  }
}).pathKeyEntities);
function jLe(e) {
  const t = /* @__PURE__ */ Ce(!1), n = /* @__PURE__ */ H({});
  return Ot(() => {
    if (!e.value) {
      t.value = !1, n.value = {};
      return;
    }
    let o = {
      matchInputWidth: !0,
      limit: 50
    };
    e.value && typeof e.value == "object" && (o = _(_({}, o), e.value)), o.limit <= 0 && (delete o.limit, process.env.NODE_ENV !== "production" && bn(!1, "'limit' of showSearch should be positive number or false.")), t.value = !0, n.value = o;
  }), {
    showSearch: t,
    searchConfig: n
  };
}
const Vv = "__rc_cascader_search_mark__", WLe = (e, t, n) => {
  let {
    label: o
  } = n;
  return t.some((l) => String(l[o]).toLowerCase().includes(e.toLowerCase()));
}, KLe = (e) => {
  let {
    path: t,
    fieldNames: n
  } = e;
  return t.map((o) => o[n.label]).join(" / ");
}, ULe = (e, t, n, o, l, r) => O(() => {
  const {
    filter: a = WLe,
    render: i = KLe,
    limit: s = 50,
    sort: c
  } = l.value, u = [];
  if (!e.value)
    return [];
  function d(f, p) {
    f.forEach((m) => {
      if (!c && s > 0 && u.length >= s)
        return;
      const v = [...p, m], h = m[n.value.children];
      // If is leaf option
      (!h || h.length === 0 || // If is changeOnSelect
      r.value) && a(e.value, v, {
        label: n.value.label
      }) && u.push(_(_({}, m), {
        [n.value.label]: i({
          inputValue: e.value,
          path: v,
          prefixCls: o.value,
          fieldNames: n.value
        }),
        [Vv]: v
      })), h && d(m[n.value.children], v);
    });
  }
  return d(t.value, []), c && u.sort((f, p) => c(f[Vv], p[Vv], e.value, n.value)), s > 0 ? u.slice(0, s) : u;
});
function U6(e, t, n) {
  const o = new Set(e);
  return e.filter((l) => {
    const r = t[l], a = r ? r.parent : null, i = r ? r.children : null;
    return n === mK ? !(i && i.some((s) => s.key && o.has(s.key))) : !(a && !a.node.disabled && o.has(a.key));
  });
}
function Hm(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  var l;
  let r = t;
  const a = [];
  for (let i = 0; i < e.length; i += 1) {
    const s = e[i], c = r == null ? void 0 : r.findIndex((d) => {
      const f = d[n.value];
      return o ? String(f) === String(s) : f === s;
    }), u = c !== -1 ? r == null ? void 0 : r[c] : null;
    a.push({
      value: (l = u == null ? void 0 : u[n.value]) !== null && l !== void 0 ? l : s,
      index: c,
      option: u
    }), r = u == null ? void 0 : u[n.children];
  }
  return a;
}
const GLe = (e, t, n) => O(() => {
  const o = [], l = [];
  return n.value.forEach((r) => {
    Hm(r, e.value, t.value).every((i) => i.option) ? l.push(r) : o.push(r);
  }), [l, o];
});
function wK(e, t) {
  const n = /* @__PURE__ */ new Set();
  return e.forEach((o) => {
    t.has(o) || n.add(o);
  }), n;
}
function YLe(e) {
  const {
    disabled: t,
    disableCheckbox: n,
    checkable: o
  } = e || {};
  return !!(t || n) || o === !1;
}
function XLe(e, t, n, o) {
  const l = new Set(e), r = /* @__PURE__ */ new Set();
  for (let i = 0; i <= n; i += 1)
    (t.get(i) || /* @__PURE__ */ new Set()).forEach((c) => {
      const {
        key: u,
        node: d,
        children: f = []
      } = c;
      l.has(u) && !o(d) && f.filter((p) => !o(p.node)).forEach((p) => {
        l.add(p.key);
      });
    });
  const a = /* @__PURE__ */ new Set();
  for (let i = n; i >= 0; i -= 1)
    (t.get(i) || /* @__PURE__ */ new Set()).forEach((c) => {
      const {
        parent: u,
        node: d
      } = c;
      if (o(d) || !c.parent || a.has(c.parent.key))
        return;
      if (o(c.parent.node)) {
        a.add(u.key);
        return;
      }
      let f = !0, p = !1;
      (u.children || []).filter((m) => !o(m.node)).forEach((m) => {
        let {
          key: v
        } = m;
        const h = l.has(v);
        f && !h && (f = !1), !p && (h || r.has(v)) && (p = !0);
      }), f && l.add(u.key), p && r.add(u.key), a.add(u.key);
    });
  return {
    checkedKeys: Array.from(l),
    halfCheckedKeys: Array.from(wK(r, l))
  };
}
function qLe(e, t, n, o, l) {
  const r = new Set(e);
  let a = new Set(t);
  for (let s = 0; s <= o; s += 1)
    (n.get(s) || /* @__PURE__ */ new Set()).forEach((u) => {
      const {
        key: d,
        node: f,
        children: p = []
      } = u;
      !r.has(d) && !a.has(d) && !l(f) && p.filter((m) => !l(m.node)).forEach((m) => {
        r.delete(m.key);
      });
    });
  a = /* @__PURE__ */ new Set();
  const i = /* @__PURE__ */ new Set();
  for (let s = o; s >= 0; s -= 1)
    (n.get(s) || /* @__PURE__ */ new Set()).forEach((u) => {
      const {
        parent: d,
        node: f
      } = u;
      if (l(f) || !u.parent || i.has(u.parent.key))
        return;
      if (l(u.parent.node)) {
        i.add(d.key);
        return;
      }
      let p = !0, m = !1;
      (d.children || []).filter((v) => !l(v.node)).forEach((v) => {
        let {
          key: h
        } = v;
        const g = r.has(h);
        p && !g && (p = !1), !m && (g || a.has(h)) && (m = !0);
      }), p || r.delete(d.key), m && a.add(d.key), i.add(d.key);
    });
  return {
    checkedKeys: Array.from(r),
    halfCheckedKeys: Array.from(wK(a, r))
  };
}
function oa(e, t, n, o, l, r) {
  const a = [];
  let i;
  r ? i = r : i = YLe;
  const s = new Set(e.filter((u) => {
    const d = !!n[u];
    return d || a.push(u), d;
  }));
  gH(!a.length, `Tree missing follow keys: ${a.slice(0, 100).map((u) => `'${u}'`).join(", ")}`);
  let c;
  return t === !0 ? c = XLe(s, l, o, i) : c = qLe(s, t.halfCheckedKeys, l, o, i), c;
}
const JLe = (e, t, n, o, l) => O(() => {
  const r = l.value || // Default displayRender
  ((a) => {
    let {
      labels: i
    } = a;
    const s = o.value ? i.slice(-1) : i, c = " / ";
    return s.every((u) => ["string", "number"].includes(typeof u)) ? s.join(c) : s.reduce((u, d, f) => {
      const p = Io(d) ? _n(d, {
        key: f
      }) : d;
      return f === 0 ? [p] : [...u, c, p];
    }, []);
  });
  return e.value.map((a) => {
    const i = Hm(a, t.value, n.value), s = r({
      labels: i.map((u) => {
        let {
          option: d,
          value: f
        } = u;
        var p;
        return (p = d == null ? void 0 : d[n.value.label]) !== null && p !== void 0 ? p : f;
      }),
      selectedOptions: i.map((u) => {
        let {
          option: d
        } = u;
        return d;
      })
    }), c = dc(a);
    return {
      label: s,
      value: c,
      key: c,
      valueCells: a
    };
  });
}), $K = Symbol("CascaderContextKey"), ZLe = (e) => {
  at($K, e);
}, BS = () => ze($K), QLe = () => {
  const e = Oh(), {
    values: t
  } = BS(), [n, o] = Bn([]);
  return pe(() => e.open, () => {
    if (e.open && !e.multiple) {
      const l = t.value[0];
      o(l || []);
    }
  }, {
    immediate: !0
  }), [n, o];
}, eBe = (e, t, n, o, l, r) => {
  const a = Oh(), i = O(() => a.direction === "rtl"), [s, c, u] = [/* @__PURE__ */ H([]), /* @__PURE__ */ H(), /* @__PURE__ */ H([])];
  Ot(() => {
    let v = -1, h = t.value;
    const g = [], y = [], b = o.value.length;
    for (let w = 0; w < b && h; w += 1) {
      const x = h.findIndex((E) => E[n.value.value] === o.value[w]);
      if (x === -1)
        break;
      v = x, g.push(v), y.push(o.value[w]), h = h[v][n.value.children];
    }
    let C = t.value;
    for (let w = 0; w < g.length - 1; w += 1)
      C = C[g[w]][n.value.children];
    [s.value, c.value, u.value] = [y, v, C];
  });
  const d = (v) => {
    l(v);
  }, f = (v) => {
    const h = u.value.length;
    let g = c.value;
    g === -1 && v < 0 && (g = h);
    for (let y = 0; y < h; y += 1) {
      g = (g + v + h) % h;
      const b = u.value[g];
      if (b && !b.disabled) {
        const C = b[n.value.value], w = s.value.slice(0, -1).concat(C);
        d(w);
        return;
      }
    }
  }, p = () => {
    if (s.value.length > 1) {
      const v = s.value.slice(0, -1);
      d(v);
    } else
      a.toggleOpen(!1);
  }, m = () => {
    var v;
    const g = (((v = u.value[c.value]) === null || v === void 0 ? void 0 : v[n.value.children]) || []).find((y) => !y.disabled);
    if (g) {
      const y = [...s.value, g[n.value.value]];
      d(y);
    }
  };
  e.expose({
    // scrollTo: treeRef.current?.scrollTo,
    onKeydown: (v) => {
      const {
        which: h
      } = v;
      switch (h) {
        case ot.UP:
        case ot.DOWN: {
          let g = 0;
          h === ot.UP ? g = -1 : h === ot.DOWN && (g = 1), g !== 0 && f(g);
          break;
        }
        case ot.LEFT: {
          i.value ? m() : p();
          break;
        }
        case ot.RIGHT: {
          i.value ? p() : m();
          break;
        }
        case ot.BACKSPACE: {
          a.searchValue || p();
          break;
        }
        case ot.ENTER: {
          if (s.value.length) {
            const g = u.value[c.value], y = (g == null ? void 0 : g[Vv]) || [];
            y.length ? r(y.map((b) => b[n.value.value]), y[y.length - 1]) : r(s.value, g);
          }
          break;
        }
        case ot.ESC:
          a.toggleOpen(!1), open && v.stopPropagation();
      }
    },
    onKeyup: () => {
    }
  });
};
function FS(e) {
  let {
    prefixCls: t,
    checked: n,
    halfChecked: o,
    disabled: l,
    onClick: r
  } = e;
  const {
    customSlots: a,
    checkable: i
  } = BS(), s = i.value !== !1 ? a.value.checkable : i.value, c = typeof s == "function" ? s() : typeof s == "boolean" ? null : s;
  return $("span", {
    class: {
      [t]: !0,
      [`${t}-checked`]: n,
      [`${t}-indeterminate`]: !n && o,
      [`${t}-disabled`]: l
    },
    onClick: r
  }, [c]);
}
FS.props = ["prefixCls", "checked", "halfChecked", "disabled", "onClick"];
FS.displayName = "Checkbox";
FS.inheritAttrs = !1;
const xK = "__cascader_fix_label__";
function VS(e) {
  let {
    prefixCls: t,
    multiple: n,
    options: o,
    activeValue: l,
    prevValuePath: r,
    onToggleOpen: a,
    onSelect: i,
    onActive: s,
    checkedSet: c,
    halfCheckedSet: u,
    loadingKeys: d,
    isSelectable: f
  } = e;
  var p, m, v, h, g, y;
  const b = `${t}-menu`, C = `${t}-menu-item`, {
    fieldNames: w,
    changeOnSelect: x,
    expandTrigger: E,
    expandIcon: I,
    loadingIcon: T,
    dropdownMenuColumnStyle: P,
    customSlots: k
  } = BS(), N = (p = I.value) !== null && p !== void 0 ? p : (v = (m = k.value).expandIcon) === null || v === void 0 ? void 0 : v.call(m), R = (h = T.value) !== null && h !== void 0 ? h : (y = (g = k.value).loadingIcon) === null || y === void 0 ? void 0 : y.call(g), z = E.value === "hover";
  return $("ul", {
    class: b,
    role: "menu"
  }, [o.map((D) => {
    var F;
    const {
      disabled: M
    } = D, A = D[Vv], L = (F = D[xK]) !== null && F !== void 0 ? F : D[w.value.label], B = D[w.value.value], V = yv(D, w.value), j = A ? A.map((q) => q[w.value.value]) : [...r, B], W = dc(j), Y = d.includes(W), U = c.has(W), te = u.has(W), J = () => {
      !M && (!z || !V) && s(j);
    }, re = () => {
      f(D) && i(j, V);
    };
    let oe;
    return typeof D.title == "string" ? oe = D.title : typeof L == "string" && (oe = L), $("li", {
      key: W,
      class: [C, {
        [`${C}-expand`]: !V,
        [`${C}-active`]: l === B,
        [`${C}-disabled`]: M,
        [`${C}-loading`]: Y
      }],
      style: P.value,
      role: "menuitemcheckbox",
      title: oe,
      "aria-checked": U,
      "data-path-key": W,
      onClick: () => {
        J(), (!n || V) && re();
      },
      onDblclick: () => {
        x.value && a(!1);
      },
      onMouseenter: () => {
        z && J();
      },
      onMousedown: (q) => {
        q.preventDefault();
      }
    }, [n && $(FS, {
      prefixCls: `${t}-checkbox`,
      checked: U,
      halfChecked: te,
      disabled: M,
      onClick: (q) => {
        q.stopPropagation(), re();
      }
    }, null), $("div", {
      class: `${C}-content`
    }, [L]), !Y && N && !V && $("div", {
      class: `${C}-expand-icon`
    }, [_n(N)]), Y && R && $("div", {
      class: `${C}-loading-icon`
    }, [_n(R)])]);
  })]);
}
VS.props = ["prefixCls", "multiple", "options", "activeValue", "prevValuePath", "onToggleOpen", "onSelect", "onActive", "checkedSet", "halfCheckedSet", "loadingKeys", "isSelectable"];
VS.displayName = "Column";
VS.inheritAttrs = !1;
const tBe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: !1,
  setup(e, t) {
    const {
      attrs: n,
      slots: o
    } = t, l = Oh(), r = /* @__PURE__ */ H(), a = O(() => l.direction === "rtl"), {
      options: i,
      values: s,
      halfValues: c,
      fieldNames: u,
      changeOnSelect: d,
      onSelect: f,
      searchOptions: p,
      dropdownPrefixCls: m,
      loadData: v,
      expandTrigger: h,
      customSlots: g
    } = BS(), y = O(() => m.value || l.prefixCls), b = /* @__PURE__ */ Ce([]), C = (F) => {
      if (!v.value || l.searchValue)
        return;
      const A = Hm(F, i.value, u.value).map((B) => {
        let {
          option: V
        } = B;
        return V;
      }), L = A[A.length - 1];
      if (L && !yv(L, u.value)) {
        const B = dc(F);
        b.value = [...b.value, B], v.value(A);
      }
    };
    Ot(() => {
      b.value.length && b.value.forEach((F) => {
        const M = OLe(F), A = Hm(M, i.value, u.value, !0).map((B) => {
          let {
            option: V
          } = B;
          return V;
        }), L = A[A.length - 1];
        (!L || L[u.value.children] || yv(L, u.value)) && (b.value = b.value.filter((B) => B !== F));
      });
    });
    const w = O(() => new Set(ef(s.value))), x = O(() => new Set(ef(c.value))), [E, I] = QLe(), T = (F) => {
      I(F), C(F);
    }, P = (F) => {
      const {
        disabled: M
      } = F, A = yv(F, u.value);
      return !M && (A || d.value || l.multiple);
    }, k = function(F, M) {
      let A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      f(F), !l.multiple && (M || d.value && (h.value === "hover" || A)) && l.toggleOpen(!1);
    }, N = O(() => l.searchValue ? p.value : i.value), R = O(() => {
      const F = [{
        options: N.value
      }];
      let M = N.value;
      for (let A = 0; A < E.value.length; A += 1) {
        const L = E.value[A], B = M.find((j) => j[u.value.value] === L), V = B == null ? void 0 : B[u.value.children];
        if (!(V != null && V.length))
          break;
        M = V, F.push({
          options: V
        });
      }
      return F;
    });
    eBe(t, N, u, E, T, (F, M) => {
      P(M) && k(F, yv(M, u.value), !0);
    });
    const D = (F) => {
      F.preventDefault();
    };
    return nt(() => {
      pe(E, (F) => {
        var M;
        for (let A = 0; A < F.length; A += 1) {
          const L = F.slice(0, A + 1), B = dc(L), V = (M = r.value) === null || M === void 0 ? void 0 : M.querySelector(`li[data-path-key="${B.replace(/\\{0,2}"/g, '\\"')}"]`);
          V && ILe(V);
        }
      }, {
        flush: "post",
        immediate: !0
      });
    }), () => {
      var F, M, A, L, B;
      const {
        notFoundContent: V = ((F = o.notFoundContent) === null || F === void 0 ? void 0 : F.call(o)) || ((A = (M = g.value).notFoundContent) === null || A === void 0 ? void 0 : A.call(M)),
        multiple: j,
        toggleOpen: W
      } = l, Y = !(!((B = (L = R.value[0]) === null || L === void 0 ? void 0 : L.options) === null || B === void 0) && B.length), U = [{
        [u.value.value]: "__EMPTY__",
        [xK]: V,
        disabled: !0
      }], te = _(_({}, n), {
        multiple: !Y && j,
        onSelect: k,
        onActive: T,
        onToggleOpen: W,
        checkedSet: w.value,
        halfCheckedSet: x.value,
        loadingKeys: b.value,
        isSelectable: P
      }), re = (Y ? [{
        options: U
      }] : R.value).map((oe, q) => {
        const K = E.value.slice(0, q), se = E.value[q];
        return $(VS, Q(Q({
          key: q
        }, te), {}, {
          prefixCls: y.value,
          options: oe.options,
          prevValuePath: K,
          activeValue: se
        }), null);
      });
      return $("div", {
        class: [`${y.value}-menus`, {
          [`${y.value}-menu-empty`]: Y,
          [`${y.value}-rtl`]: a.value
        }],
        onMousedown: D,
        ref: r
      }, [re]);
    };
  }
});
function zS(e) {
  const t = /* @__PURE__ */ H(0), n = /* @__PURE__ */ Ce();
  return Ot(() => {
    const o = /* @__PURE__ */ new Map();
    let l = 0;
    const r = e.value || {};
    for (const a in r)
      if (Object.prototype.hasOwnProperty.call(r, a)) {
        const i = r[a], {
          level: s
        } = i;
        let c = o.get(s);
        c || (c = /* @__PURE__ */ new Set(), o.set(s, c)), c.add(i), l = Math.max(l, s);
      }
    t.value = l, n.value = o;
  }), {
    maxLevel: t,
    levelEntities: n
  };
}
function nBe() {
  return _(_({}, pn(hS(), ["tokenSeparators", "mode", "showSearch"])), {
    // MISC
    id: String,
    prefixCls: String,
    fieldNames: Nt(),
    children: Array,
    // Value
    value: {
      type: [String, Number, Array]
    },
    defaultValue: {
      type: [String, Number, Array]
    },
    changeOnSelect: {
      type: Boolean,
      default: void 0
    },
    displayRender: Function,
    checkable: {
      type: Boolean,
      default: void 0
    },
    showCheckedStrategy: {
      type: String,
      default: vK
    },
    // Search
    showSearch: {
      type: [Boolean, Object],
      default: void 0
    },
    searchValue: String,
    onSearch: Function,
    // Trigger
    expandTrigger: String,
    // Options
    options: Array,
    /** @private Internal usage. Do not use in your production. */
    dropdownPrefixCls: String,
    loadData: Function,
    // Open
    /** @deprecated Use `open` instead */
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownMenuColumnStyle: {
      type: Object,
      default: void 0
    },
    /** @deprecated Use `dropdownStyle` instead */
    popupStyle: {
      type: Object,
      default: void 0
    },
    dropdownStyle: {
      type: Object,
      default: void 0
    },
    /** @deprecated Use `placement` instead */
    popupPlacement: String,
    placement: String,
    /** @deprecated Use `onDropdownVisibleChange` instead */
    onPopupVisibleChange: Function,
    onDropdownVisibleChange: Function,
    // Icon
    expandIcon: de.any,
    loadingIcon: de.any
  });
}
function EK() {
  return _(_({}, nBe()), {
    onChange: Function,
    customSlots: Object
  });
}
function oBe(e) {
  return Array.isArray(e) && Array.isArray(e[0]);
}
function G6(e) {
  return e ? oBe(e) ? e : (e.length === 0 ? [] : [e]).map((t) => Array.isArray(t) ? t : [t]) : [];
}
const lBe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Cascader",
  inheritAttrs: !1,
  props: sn(EK(), {}),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: l
    } = t;
    const r = NI(/* @__PURE__ */ ft(e, "id")), a = O(() => !!e.checkable), [i, s] = ro(e.defaultValue, {
      value: O(() => e.value),
      postState: G6
    }), c = O(() => _Le(e.fieldNames)), u = O(() => e.options || []), d = HLe(u, c), f = (q) => {
      const K = d.value;
      return q.map((se) => {
        const {
          nodes: Z
        } = K[se];
        return Z.map((ee) => ee[c.value.value]);
      });
    }, [p, m] = ro("", {
      value: O(() => e.searchValue),
      postState: (q) => q || ""
    }), v = (q, K) => {
      m(q), K.source !== "blur" && e.onSearch && e.onSearch(q);
    }, {
      showSearch: h,
      searchConfig: g
    } = jLe(/* @__PURE__ */ ft(e, "showSearch")), y = ULe(p, u, c, O(() => e.dropdownPrefixCls || e.prefixCls), g, /* @__PURE__ */ ft(e, "changeOnSelect")), b = GLe(u, c, i), [C, w, x] = [/* @__PURE__ */ H([]), /* @__PURE__ */ H([]), /* @__PURE__ */ H([])], {
      maxLevel: E,
      levelEntities: I
    } = zS(d);
    Ot(() => {
      const [q, K] = b.value;
      if (!a.value || !i.value.length) {
        [C.value, w.value, x.value] = [q, [], K];
        return;
      }
      const se = ef(q), Z = d.value, {
        checkedKeys: ee,
        halfCheckedKeys: fe
      } = oa(se, !0, Z, E.value, I.value);
      [C.value, w.value, x.value] = [f(ee), f(fe), K];
    });
    const T = O(() => {
      const q = ef(C.value), K = U6(q, d.value, e.showCheckedStrategy);
      return [...x.value, ...f(K)];
    }), P = JLe(T, u, c, a, /* @__PURE__ */ ft(e, "displayRender")), k = (q) => {
      if (s(q), e.onChange) {
        const K = G6(q), se = K.map((fe) => Hm(fe, u.value, c.value).map((me) => me.option)), Z = a.value ? K : K[0], ee = a.value ? se : se[0];
        e.onChange(Z, ee);
      }
    }, N = (q) => {
      if (m(""), !a.value)
        k(q);
      else {
        const K = dc(q), se = ef(C.value), Z = ef(w.value), ee = se.includes(K), fe = x.value.some((he) => dc(he) === K);
        let me = C.value, ge = x.value;
        if (fe && !ee)
          ge = x.value.filter((he) => dc(he) !== K);
        else {
          const he = ee ? se.filter((ae) => ae !== K) : [...se, K];
          let $e;
          ee ? {
            checkedKeys: $e
          } = oa(he, {
            halfCheckedKeys: Z
          }, d.value, E.value, I.value) : {
            checkedKeys: $e
          } = oa(he, !0, d.value, E.value, I.value);
          const ne = U6($e, d.value, e.showCheckedStrategy);
          me = f(ne);
        }
        k([...ge, ...me]);
      }
    }, R = (q, K) => {
      if (K.type === "clear") {
        k([]);
        return;
      }
      const {
        valueCells: se
      } = K.values[0];
      N(se);
    };
    process.env.NODE_ENV !== "production" && Ot(() => {
      un(!e.onPopupVisibleChange, "Cascader", "`popupVisibleChange` is deprecated. Please use `dropdownVisibleChange` instead."), un(e.popupVisible === void 0, "Cascader", "`popupVisible` is deprecated. Please use `open` instead."), un(e.popupPlacement === void 0, "Cascader", "`popupPlacement` is deprecated. Please use `placement` instead."), un(e.popupStyle === void 0, "Cascader", "`popupStyle` is deprecated. Please use `dropdownStyle` instead.");
    });
    const z = O(() => e.open !== void 0 ? e.open : e.popupVisible), D = O(() => e.dropdownStyle || e.popupStyle || {}), F = O(() => e.placement || e.popupPlacement), M = (q) => {
      var K, se;
      (K = e.onDropdownVisibleChange) === null || K === void 0 || K.call(e, q), (se = e.onPopupVisibleChange) === null || se === void 0 || se.call(e, q);
    }, {
      changeOnSelect: A,
      checkable: L,
      dropdownPrefixCls: B,
      loadData: V,
      expandTrigger: j,
      expandIcon: W,
      loadingIcon: Y,
      dropdownMenuColumnStyle: U,
      customSlots: te,
      dropdownClassName: J
    } = /* @__PURE__ */ to(e);
    ZLe({
      options: u,
      fieldNames: c,
      values: C,
      halfValues: w,
      changeOnSelect: A,
      onSelect: N,
      checkable: L,
      searchOptions: y,
      dropdownPrefixCls: B,
      loadData: V,
      expandTrigger: j,
      expandIcon: W,
      loadingIcon: Y,
      dropdownMenuColumnStyle: U,
      customSlots: te
    });
    const re = /* @__PURE__ */ H();
    o({
      focus() {
        var q;
        (q = re.value) === null || q === void 0 || q.focus();
      },
      blur() {
        var q;
        (q = re.value) === null || q === void 0 || q.blur();
      },
      scrollTo(q) {
        var K;
        (K = re.value) === null || K === void 0 || K.scrollTo(q);
      }
    });
    const oe = O(() => pn(e, [
      "id",
      "prefixCls",
      "fieldNames",
      // Value
      "defaultValue",
      "value",
      "changeOnSelect",
      "onChange",
      "displayRender",
      "checkable",
      // Search
      "searchValue",
      "onSearch",
      "showSearch",
      // Trigger
      "expandTrigger",
      // Options
      "options",
      "dropdownPrefixCls",
      "loadData",
      // Open
      "popupVisible",
      "open",
      "dropdownClassName",
      "dropdownMenuColumnStyle",
      "popupPlacement",
      "placement",
      "onDropdownVisibleChange",
      "onPopupVisibleChange",
      // Icon
      "expandIcon",
      "loadingIcon",
      "customSlots",
      "showCheckedStrategy",
      // Children
      "children"
    ]));
    return () => {
      const q = !(p.value ? y.value : u.value).length, {
        dropdownMatchSelectWidth: K = !1
      } = e, se = (
        // Search to match width
        p.value && g.value.matchInputWidth || // Empty keep the width
        q ? {} : {
          minWidth: "auto"
        }
      );
      return $(TI, Q(Q(Q({}, oe.value), n), {}, {
        ref: re,
        id: r,
        prefixCls: e.prefixCls,
        dropdownMatchSelectWidth: K,
        dropdownStyle: _(_({}, D.value), se),
        displayValues: P.value,
        onDisplayValuesChange: R,
        mode: a.value ? "multiple" : void 0,
        searchValue: p.value,
        onSearch: v,
        showSearch: h.value,
        OptionList: tBe,
        emptyOptions: q,
        open: z.value,
        dropdownClassName: J.value,
        placement: F.value,
        onDropdownVisibleChange: M,
        getRawInputElement: () => {
          var Z;
          return (Z = l.default) === null || Z === void 0 ? void 0 : Z.call(l);
        }
      }), l);
    };
  }
});
var rBe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, name: "left", theme: "outlined" };
function Y6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      aBe(e, l, n[l]);
    });
  }
  return e;
}
function aBe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Ii = function(t, n) {
  var o = Y6({}, t, n.attrs);
  return $(cn, Y6({}, o, {
    icon: rBe
  }), null);
};
Ii.displayName = "LeftOutlined";
Ii.inheritAttrs = !1;
const OK = () => Fl() && window.document.documentElement, _K = (e) => {
  if (Fl() && window.document.documentElement) {
    const t = Array.isArray(e) ? e : [e], {
      documentElement: n
    } = window.document;
    return t.some((o) => o in n.style);
  }
  return !1;
}, iBe = (e, t) => {
  if (!_K(e))
    return !1;
  const n = document.createElement("div"), o = n.style[e];
  return n.style[e] = t, n.style[e] !== o;
};
function FT(e, t) {
  return !Array.isArray(e) && t !== void 0 ? iBe(e, t) : _K(e);
}
let Vg;
const sBe = () => {
  if (!OK())
    return !1;
  if (Vg !== void 0)
    return Vg;
  const e = document.createElement("div");
  return e.style.display = "flex", e.style.flexDirection = "column", e.style.rowGap = "1px", e.appendChild(document.createElement("div")), e.appendChild(document.createElement("div")), document.body.appendChild(e), Vg = e.scrollHeight === 1, document.body.removeChild(e), Vg;
}, IK = () => {
  const e = /* @__PURE__ */ Ce(!1);
  return nt(() => {
    e.value = sBe();
  }), e;
}, TK = Symbol("rowContextKey"), cBe = (e) => {
  at(TK, e);
}, uBe = () => ze(TK, {
  gutter: O(() => {
  }),
  wrap: O(() => {
  }),
  supportFlexGap: O(() => {
  })
}), dBe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // Grid system
    [t]: {
      display: "flex",
      flexFlow: "row wrap",
      minWidth: 0,
      "&::before, &::after": {
        display: "flex"
      },
      "&-no-wrap": {
        flexWrap: "nowrap"
      },
      // The origin of the X-axis
      "&-start": {
        justifyContent: "flex-start"
      },
      // The center of the X-axis
      "&-center": {
        justifyContent: "center"
      },
      // The opposite of the X-axis
      "&-end": {
        justifyContent: "flex-end"
      },
      "&-space-between": {
        justifyContent: "space-between"
      },
      "&-space-around ": {
        justifyContent: "space-around"
      },
      "&-space-evenly ": {
        justifyContent: "space-evenly"
      },
      // Align at the top
      "&-top": {
        alignItems: "flex-start"
      },
      // Align at the center
      "&-middle": {
        alignItems: "center"
      },
      "&-bottom": {
        alignItems: "flex-end"
      }
    }
  };
}, fBe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // Grid system
    [t]: {
      position: "relative",
      maxWidth: "100%",
      // Prevent columns from collapsing when empty
      minHeight: 1
    }
  };
}, pBe = (e, t) => {
  const {
    componentCls: n,
    gridColumns: o
  } = e, l = {};
  for (let r = o; r >= 0; r--)
    r === 0 ? (l[`${n}${t}-${r}`] = {
      display: "none"
    }, l[`${n}-push-${r}`] = {
      insetInlineStart: "auto"
    }, l[`${n}-pull-${r}`] = {
      insetInlineEnd: "auto"
    }, l[`${n}${t}-push-${r}`] = {
      insetInlineStart: "auto"
    }, l[`${n}${t}-pull-${r}`] = {
      insetInlineEnd: "auto"
    }, l[`${n}${t}-offset-${r}`] = {
      marginInlineEnd: 0
    }, l[`${n}${t}-order-${r}`] = {
      order: 0
    }) : (l[`${n}${t}-${r}`] = {
      display: "block",
      flex: `0 0 ${r / o * 100}%`,
      maxWidth: `${r / o * 100}%`
    }, l[`${n}${t}-push-${r}`] = {
      insetInlineStart: `${r / o * 100}%`
    }, l[`${n}${t}-pull-${r}`] = {
      insetInlineEnd: `${r / o * 100}%`
    }, l[`${n}${t}-offset-${r}`] = {
      marginInlineStart: `${r / o * 100}%`
    }, l[`${n}${t}-order-${r}`] = {
      order: r
    });
  return l;
}, W2 = (e, t) => pBe(e, t), vBe = (e, t, n) => ({
  [`@media (min-width: ${t}px)`]: _({}, W2(e, n))
}), mBe = Zt("Grid", (e) => [dBe(e)]), hBe = Zt("Grid", (e) => {
  const t = Vt(e, {
    gridColumns: 24
    // Row is divided into 24 parts in Grid
  }), n = {
    "-sm": t.screenSMMin,
    "-md": t.screenMDMin,
    "-lg": t.screenLGMin,
    "-xl": t.screenXLMin,
    "-xxl": t.screenXXLMin
  };
  return [fBe(t), W2(t, ""), W2(t, "-xs"), Object.keys(n).map((o) => vBe(t, n[o], o)).reduce((o, l) => _(_({}, o), l), {})];
}), gBe = () => ({
  align: zt([String, Object]),
  justify: zt([String, Object]),
  prefixCls: String,
  gutter: zt([Number, Array, Object], 0),
  wrap: {
    type: Boolean,
    default: void 0
  }
}), VT = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ARow",
  inheritAttrs: !1,
  props: gBe(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("row", e), [a, i] = mBe(l);
    let s;
    const c = jI(), u = /* @__PURE__ */ H({
      xs: !0,
      sm: !0,
      md: !0,
      lg: !0,
      xl: !0,
      xxl: !0
    }), d = /* @__PURE__ */ H({
      xs: !1,
      sm: !1,
      md: !1,
      lg: !1,
      xl: !1,
      xxl: !1
    }), f = (b) => O(() => {
      if (typeof e[b] == "string")
        return e[b];
      if (typeof e[b] != "object")
        return "";
      for (let C = 0; C < rs.length; C++) {
        const w = rs[C];
        if (!d.value[w]) continue;
        const x = e[b][w];
        if (x !== void 0)
          return x;
      }
      return "";
    }), p = f("align"), m = f("justify"), v = IK();
    nt(() => {
      s = c.value.subscribe((b) => {
        d.value = b;
        const C = e.gutter || 0;
        (!Array.isArray(C) && typeof C == "object" || Array.isArray(C) && (typeof C[0] == "object" || typeof C[1] == "object")) && (u.value = b);
      });
    }), yt(() => {
      c.value.unsubscribe(s);
    });
    const h = O(() => {
      const b = [void 0, void 0], {
        gutter: C = 0
      } = e;
      return (Array.isArray(C) ? C : [C, void 0]).forEach((x, E) => {
        if (typeof x == "object")
          for (let I = 0; I < rs.length; I++) {
            const T = rs[I];
            if (u.value[T] && x[T] !== void 0) {
              b[E] = x[T];
              break;
            }
          }
        else
          b[E] = x;
      }), b;
    });
    cBe({
      gutter: h,
      supportFlexGap: v,
      wrap: O(() => e.wrap)
    });
    const g = O(() => ke(l.value, {
      [`${l.value}-no-wrap`]: e.wrap === !1,
      [`${l.value}-${m.value}`]: m.value,
      [`${l.value}-${p.value}`]: p.value,
      [`${l.value}-rtl`]: r.value === "rtl"
    }, o.class, i.value)), y = O(() => {
      const b = h.value, C = {}, w = b[0] != null && b[0] > 0 ? `${b[0] / -2}px` : void 0, x = b[1] != null && b[1] > 0 ? `${b[1] / -2}px` : void 0;
      return w && (C.marginLeft = w, C.marginRight = w), v.value ? C.rowGap = `${b[1]}px` : x && (C.marginTop = x, C.marginBottom = x), C;
    });
    return () => {
      var b;
      return a($("div", Q(Q({}, o), {}, {
        class: g.value,
        style: _(_({}, y.value), o.style)
      }), [(b = n.default) === null || b === void 0 ? void 0 : b.call(n)]));
    };
  }
});
function fc(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function PK(e, t) {
  let n = e;
  for (let o = 0; o < t.length; o += 1) {
    if (n == null)
      return;
    n = n[t[o]];
  }
  return n;
}
function kK(e, t, n, o) {
  if (!t.length)
    return n;
  const [l, ...r] = t;
  let a;
  return !e && typeof l == "number" ? a = [] : Array.isArray(e) ? a = [...e] : a = _({}, e), o && n === void 0 && r.length === 1 ? delete a[l][r[0]] : a[l] = kK(a[l], r, n, o), a;
}
function bBe(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return t.length && o && n === void 0 && !PK(e, t.slice(0, -1)) ? e : kK(e, t, n, o);
}
function K2(e) {
  return fc(e);
}
function yBe(e, t) {
  return PK(e, t);
}
function SBe(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return bBe(e, t, n, o);
}
function CBe(e, t) {
  return e && e.some((n) => $Be(n, t));
}
function X6(e) {
  return typeof e == "object" && e !== null && Object.getPrototypeOf(e) === Object.prototype;
}
function NK(e, t) {
  const n = Array.isArray(e) ? [...e] : _({}, e);
  return t && Object.keys(t).forEach((o) => {
    const l = n[o], r = t[o], a = X6(l) && X6(r);
    n[o] = a ? NK(l, r || {}) : r;
  }), n;
}
function wBe(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o];
  return n.reduce((l, r) => NK(l, r), e);
}
function q6(e, t) {
  let n = {};
  return t.forEach((o) => {
    const l = yBe(e, o);
    n = SBe(n, o, l);
  }), n;
}
function $Be(e, t) {
  return !e || !t || e.length !== t.length ? !1 : e.every((n, o) => t[o] === n);
}
const Er = "'${name}' is not a valid ${type}", HS = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: Er,
    method: Er,
    array: Er,
    object: Er,
    number: Er,
    date: Er,
    boolean: Er,
    integer: Er,
    float: Er,
    regexp: Er,
    email: Er,
    url: Er,
    hex: Er
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
};
var jS = function(e, t, n, o) {
  function l(r) {
    return r instanceof n ? r : new n(function(a) {
      a(r);
    });
  }
  return new (n || (n = Promise))(function(r, a) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (d) {
        a(d);
      }
    }
    function s(u) {
      try {
        c(o.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? r(u.value) : l(u.value).then(i, s);
    }
    c((o = o.apply(e, t || [])).next());
  });
};
const xBe = Op;
function EBe(e, t) {
  return e.replace(/\$\{\w+\}/g, (n) => {
    const o = n.slice(2, -1);
    return t[o];
  });
}
function U2(e, t, n, o, l) {
  return jS(this, void 0, void 0, function* () {
    const r = _({}, n);
    delete r.ruleIndex, delete r.trigger;
    let a = null;
    r && r.type === "array" && r.defaultField && (a = r.defaultField, delete r.defaultField);
    const i = new xBe({
      [e]: [r]
    }), s = wBe({}, HS, o.validateMessages);
    i.messages(s);
    let c = [];
    try {
      yield Promise.resolve(i.validate({
        [e]: t
      }, _({}, o)));
    } catch (f) {
      f.errors ? c = f.errors.map((p, m) => {
        let {
          message: v
        } = p;
        return (
          // Wrap VueNode with `key`
          Io(v) ? No(v, {
            key: `error_${m}`
          }) : v
        );
      }) : (console.error(f), c = [s.default()]);
    }
    if (!c.length && a)
      return (yield Promise.all(t.map((p, m) => U2(`${e}.${m}`, p, a, o, l)))).reduce((p, m) => [...p, ...m], []);
    const u = _(_(_({}, n), {
      name: e,
      enum: (n.enum || []).join(", ")
    }), l);
    return c.map((f) => typeof f == "string" ? EBe(f, u) : f);
  });
}
function MK(e, t, n, o, l, r) {
  const a = e.join("."), i = n.map((c, u) => {
    const d = c.validator, f = _(_({}, c), {
      ruleIndex: u
    });
    return d && (f.validator = (p, m, v) => {
      let h = !1;
      const y = d(p, m, function() {
        for (var b = arguments.length, C = new Array(b), w = 0; w < b; w++)
          C[w] = arguments[w];
        Promise.resolve().then(() => {
          bn(!h, "Your validator function has already return a promise. `callback` will be ignored."), h || v(...C);
        });
      });
      h = y && typeof y.then == "function" && typeof y.catch == "function", bn(h, "`callback` is deprecated. Please return a promise instead."), h && y.then(() => {
        v();
      }).catch((b) => {
        v(b || " ");
      });
    }), f;
  }).sort((c, u) => {
    let {
      warningOnly: d,
      ruleIndex: f
    } = c, {
      warningOnly: p,
      ruleIndex: m
    } = u;
    return !!d == !!p ? f - m : d ? 1 : -1;
  });
  let s;
  if (l === !0)
    s = new Promise((c, u) => jS(this, void 0, void 0, function* () {
      for (let d = 0; d < i.length; d += 1) {
        const f = i[d], p = yield U2(a, t, f, o, r);
        if (p.length) {
          u([{
            errors: p,
            rule: f
          }]);
          return;
        }
      }
      c([]);
    }));
  else {
    const c = i.map((u) => U2(a, t, u, o, r).then((d) => ({
      errors: d,
      rule: u
    })));
    s = (l ? _Be(c) : OBe(c)).then((u) => Promise.reject(u));
  }
  return s.catch((c) => c), s;
}
function OBe(e) {
  return jS(this, void 0, void 0, function* () {
    return Promise.all(e).then((t) => [].concat(...t));
  });
}
function _Be(e) {
  return jS(this, void 0, void 0, function* () {
    let t = 0;
    return new Promise((n) => {
      e.forEach((o) => {
        o.then((l) => {
          l.errors.length && n([l]), t += 1, t === e.length && n([]);
        });
      });
    });
  });
}
const AK = Symbol("formContextKey"), RK = (e) => {
  at(AK, e);
}, zT = () => ze(AK, {
  name: O(() => {
  }),
  labelAlign: O(() => "right"),
  vertical: O(() => !1),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  addField: (e, t) => {
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeField: (e) => {
  },
  model: O(() => {
  }),
  rules: O(() => {
  }),
  colon: O(() => {
  }),
  labelWrap: O(() => {
  }),
  labelCol: O(() => {
  }),
  requiredMark: O(() => !1),
  validateTrigger: O(() => {
  }),
  onValidate: () => {
  },
  validateMessages: O(() => HS)
}), DK = Symbol("formItemPrefixContextKey"), IBe = (e) => {
  at(DK, e);
}, TBe = () => ze(DK, {
  prefixCls: O(() => "")
});
function PBe(e) {
  return typeof e == "number" ? `${e} ${e} auto` : /^\d+(\.\d+)?(px|em|rem|%)$/.test(e) ? `0 0 ${e}` : e;
}
const kBe = () => ({
  span: [String, Number],
  order: [String, Number],
  offset: [String, Number],
  push: [String, Number],
  pull: [String, Number],
  xs: {
    type: [String, Number, Object],
    default: void 0
  },
  sm: {
    type: [String, Number, Object],
    default: void 0
  },
  md: {
    type: [String, Number, Object],
    default: void 0
  },
  lg: {
    type: [String, Number, Object],
    default: void 0
  },
  xl: {
    type: [String, Number, Object],
    default: void 0
  },
  xxl: {
    type: [String, Number, Object],
    default: void 0
  },
  prefixCls: String,
  flex: [String, Number]
}), NBe = ["xs", "sm", "md", "lg", "xl", "xxl"], WS = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ACol",
  inheritAttrs: !1,
  props: kBe(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      gutter: l,
      supportFlexGap: r,
      wrap: a
    } = uBe(), {
      prefixCls: i,
      direction: s
    } = bt("col", e), [c, u] = hBe(i), d = O(() => {
      const {
        span: p,
        order: m,
        offset: v,
        push: h,
        pull: g
      } = e, y = i.value;
      let b = {};
      return NBe.forEach((C) => {
        let w = {};
        const x = e[C];
        typeof x == "number" ? w.span = x : typeof x == "object" && (w = x || {}), b = _(_({}, b), {
          [`${y}-${C}-${w.span}`]: w.span !== void 0,
          [`${y}-${C}-order-${w.order}`]: w.order || w.order === 0,
          [`${y}-${C}-offset-${w.offset}`]: w.offset || w.offset === 0,
          [`${y}-${C}-push-${w.push}`]: w.push || w.push === 0,
          [`${y}-${C}-pull-${w.pull}`]: w.pull || w.pull === 0,
          [`${y}-rtl`]: s.value === "rtl"
        });
      }), ke(y, {
        [`${y}-${p}`]: p !== void 0,
        [`${y}-order-${m}`]: m,
        [`${y}-offset-${v}`]: v,
        [`${y}-push-${h}`]: h,
        [`${y}-pull-${g}`]: g
      }, b, o.class, u.value);
    }), f = O(() => {
      const {
        flex: p
      } = e, m = l.value, v = {};
      if (m && m[0] > 0) {
        const h = `${m[0] / 2}px`;
        v.paddingLeft = h, v.paddingRight = h;
      }
      if (m && m[1] > 0 && !r.value) {
        const h = `${m[1] / 2}px`;
        v.paddingTop = h, v.paddingBottom = h;
      }
      return p && (v.flex = PBe(p), a.value === !1 && !v.minWidth && (v.minWidth = 0)), v;
    });
    return () => {
      var p;
      return c($("div", Q(Q({}, o), {}, {
        class: d.value,
        style: [f.value, o.style]
      }), [(p = n.default) === null || p === void 0 ? void 0 : p.call(n)]));
    };
  }
});
var MBe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, name: "question-circle", theme: "outlined" };
function J6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      ABe(e, l, n[l]);
    });
  }
  return e;
}
function ABe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var HT = function(t, n) {
  var o = J6({}, t, n.attrs);
  return $(cn, J6({}, o, {
    icon: MBe
  }), null);
};
HT.displayName = "QuestionCircleOutlined";
HT.inheritAttrs = !1;
const jT = (e, t) => {
  let {
    slots: n,
    emit: o,
    attrs: l
  } = t;
  var r, a, i, s, c;
  const {
    prefixCls: u,
    htmlFor: d,
    labelCol: f,
    labelAlign: p,
    colon: m,
    required: v,
    requiredMark: h
  } = _(_({}, e), l), [g] = fa("Form"), y = (r = e.label) !== null && r !== void 0 ? r : (a = n.label) === null || a === void 0 ? void 0 : a.call(n);
  if (!y) return null;
  const {
    vertical: b,
    labelAlign: C,
    labelCol: w,
    labelWrap: x,
    colon: E
  } = zT(), I = f || (w == null ? void 0 : w.value) || {}, T = p || (C == null ? void 0 : C.value), P = `${u}-item-label`, k = ke(P, T === "left" && `${P}-left`, I.class, {
    [`${P}-wrap`]: !!x.value
  });
  let N = y;
  const R = m === !0 || (E == null ? void 0 : E.value) !== !1 && m !== !1;
  if (R && !b.value && typeof y == "string" && y.trim() !== "" && (N = y.replace(/[:|]\s*$/, "")), e.tooltip || n.tooltip) {
    const F = $("span", {
      class: `${u}-item-tooltip`
    }, [$(Sr, {
      title: e.tooltip
    }, {
      default: () => [$(HT, null, null)]
    })]);
    N = $(Ge, null, [N, n.tooltip ? (i = n.tooltip) === null || i === void 0 ? void 0 : i.call(n, {
      class: `${u}-item-tooltip`
    }) : F]);
  }
  h === "optional" && !v && (N = $(Ge, null, [N, $("span", {
    class: `${u}-item-optional`
  }, [((s = g.value) === null || s === void 0 ? void 0 : s.optional) || ((c = rr.Form) === null || c === void 0 ? void 0 : c.optional)])]));
  const D = ke({
    [`${u}-item-required`]: v,
    [`${u}-item-required-mark-optional`]: h === "optional",
    [`${u}-item-no-colon`]: !R
  });
  return $(WS, Q(Q({}, I), {}, {
    class: k
  }), {
    default: () => [$("label", {
      for: d,
      class: D,
      title: typeof y == "string" ? y : "",
      onClick: (F) => o("click", F)
    }, [N])]
  });
};
jT.displayName = "FormItemLabel";
jT.inheritAttrs = !1;
const RBe = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-show-help`, o = `${t}-show-help-item`;
  return {
    [n]: {
      // Explain holder
      transition: `opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`,
      "&-appear, &-enter": {
        opacity: 0,
        "&-active": {
          opacity: 1
        }
      },
      "&-leave": {
        opacity: 1,
        "&-active": {
          opacity: 0
        }
      },
      // Explain
      [o]: {
        overflow: "hidden",
        transition: `height ${e.motionDurationSlow} ${e.motionEaseInOut},
                     opacity ${e.motionDurationSlow} ${e.motionEaseInOut},
                     transform ${e.motionDurationSlow} ${e.motionEaseInOut} !important`,
        [`&${o}-appear, &${o}-enter`]: {
          transform: "translateY(-5px)",
          opacity: 0,
          "&-active": {
            transform: "translateY(0)",
            opacity: 1
          }
        },
        [`&${o}-leave-active`]: {
          transform: "translateY(-5px)"
        }
      }
    }
  };
}, DBe = (e) => ({
  legend: {
    display: "block",
    width: "100%",
    marginBottom: e.marginLG,
    padding: 0,
    color: e.colorTextDescription,
    fontSize: e.fontSizeLG,
    lineHeight: "inherit",
    border: 0,
    borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`
  },
  label: {
    fontSize: e.fontSize
  },
  'input[type="search"]': {
    boxSizing: "border-box"
  },
  // Position radios and checkboxes better
  'input[type="radio"], input[type="checkbox"]': {
    lineHeight: "normal"
  },
  'input[type="file"]': {
    display: "block"
  },
  // Make range inputs behave like textual form controls
  'input[type="range"]': {
    display: "block",
    width: "100%"
  },
  // Make multiple select elements height not fixed
  "select[multiple], select[size]": {
    height: "auto"
  },
  // Focus for file, radio, and checkbox
  "input[type='file']:focus,\n  input[type='radio']:focus,\n  input[type='checkbox']:focus": {
    outline: 0,
    boxShadow: `0 0 0 ${e.controlOutlineWidth}px ${e.controlOutline}`
  },
  // Adjust output element
  output: {
    display: "block",
    paddingTop: 15,
    color: e.colorText,
    fontSize: e.fontSize,
    lineHeight: e.lineHeight
  }
}), Z6 = (e, t) => {
  const {
    formItemCls: n
  } = e;
  return {
    [n]: {
      [`${n}-label > label`]: {
        height: t
      },
      [`${n}-control-input`]: {
        minHeight: t
      }
    }
  };
}, LBe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [e.componentCls]: _(_(_({}, nn(e)), DBe(e)), {
      [`${t}-text`]: {
        display: "inline-block",
        paddingInlineEnd: e.paddingSM
      },
      // ================================================================
      // =                             Size                             =
      // ================================================================
      "&-small": _({}, Z6(e, e.controlHeightSM)),
      "&-large": _({}, Z6(e, e.controlHeightLG))
    })
  };
}, BBe = (e) => {
  const {
    formItemCls: t,
    iconCls: n,
    componentCls: o,
    rootPrefixCls: l
  } = e;
  return {
    [t]: _(_({}, nn(e)), {
      marginBottom: e.marginLG,
      verticalAlign: "top",
      "&-with-help": {
        transition: "none"
      },
      [`&-hidden,
        &-hidden.${l}-row`]: {
        // https://github.com/ant-design/ant-design/issues/26141
        display: "none"
      },
      "&-has-warning": {
        [`${t}-split`]: {
          color: e.colorError
        }
      },
      "&-has-error": {
        [`${t}-split`]: {
          color: e.colorWarning
        }
      },
      // ==============================================================
      // =                            Label                           =
      // ==============================================================
      [`${t}-label`]: {
        display: "inline-block",
        flexGrow: 0,
        overflow: "hidden",
        whiteSpace: "nowrap",
        textAlign: "end",
        verticalAlign: "middle",
        "&-left": {
          textAlign: "start"
        },
        "&-wrap": {
          overflow: "unset",
          lineHeight: `${e.lineHeight} - 0.25em`,
          whiteSpace: "unset"
        },
        "> label": {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          maxWidth: "100%",
          height: e.controlHeight,
          color: e.colorTextHeading,
          fontSize: e.fontSize,
          [`> ${n}`]: {
            fontSize: e.fontSize,
            verticalAlign: "top"
          },
          // Required mark
          [`&${t}-required:not(${t}-required-mark-optional)::before`]: {
            display: "inline-block",
            marginInlineEnd: e.marginXXS,
            color: e.colorError,
            fontSize: e.fontSize,
            fontFamily: "SimSun, sans-serif",
            lineHeight: 1,
            content: '"*"',
            [`${o}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${t}-optional`]: {
            display: "inline-block",
            marginInlineStart: e.marginXXS,
            color: e.colorTextDescription,
            [`${o}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${t}-tooltip`]: {
            color: e.colorTextDescription,
            cursor: "help",
            writingMode: "horizontal-tb",
            marginInlineStart: e.marginXXS
          },
          "&::after": {
            content: '":"',
            position: "relative",
            marginBlock: 0,
            marginInlineStart: e.marginXXS / 2,
            marginInlineEnd: e.marginXS
          },
          [`&${t}-no-colon::after`]: {
            content: '" "'
          }
        }
      },
      // ==============================================================
      // =                            Input                           =
      // ==============================================================
      [`${t}-control`]: {
        display: "flex",
        flexDirection: "column",
        flexGrow: 1,
        [`&:first-child:not([class^="'${l}-col-'"]):not([class*="' ${l}-col-'"])`]: {
          width: "100%"
        },
        "&-input": {
          position: "relative",
          display: "flex",
          alignItems: "center",
          minHeight: e.controlHeight,
          "&-content": {
            flex: "auto",
            maxWidth: "100%"
          }
        }
      },
      // ==============================================================
      // =                           Explain                          =
      // ==============================================================
      [t]: {
        "&-explain, &-extra": {
          clear: "both",
          color: e.colorTextDescription,
          fontSize: e.fontSize,
          lineHeight: e.lineHeight
        },
        "&-explain-connected": {
          width: "100%"
        },
        "&-extra": {
          minHeight: e.controlHeightSM,
          transition: `color ${e.motionDurationMid} ${e.motionEaseOut}`
          // sync input color transition
        },
        "&-explain": {
          "&-error": {
            color: e.colorError
          },
          "&-warning": {
            color: e.colorWarning
          }
        }
      },
      [`&-with-help ${t}-explain`]: {
        height: "auto",
        opacity: 1
      },
      // ==============================================================
      // =                        Feedback Icon                       =
      // ==============================================================
      [`${t}-feedback-icon`]: {
        fontSize: e.fontSize,
        textAlign: "center",
        visibility: "visible",
        animationName: zI,
        animationDuration: e.motionDurationMid,
        animationTimingFunction: e.motionEaseOutBack,
        pointerEvents: "none",
        "&-success": {
          color: e.colorSuccess
        },
        "&-error": {
          color: e.colorError
        },
        "&-warning": {
          color: e.colorWarning
        },
        "&-validating": {
          color: e.colorPrimary
        }
      }
    })
  };
}, FBe = (e) => {
  const {
    componentCls: t,
    formItemCls: n,
    rootPrefixCls: o
  } = e;
  return {
    [`${t}-horizontal`]: {
      [`${n}-label`]: {
        flexGrow: 0
      },
      [`${n}-control`]: {
        flex: "1 1 0",
        // https://github.com/ant-design/ant-design/issues/32777
        // https://github.com/ant-design/ant-design/issues/33773
        minWidth: 0
      },
      // https://github.com/ant-design/ant-design/issues/32980
      [`${n}-label.${o}-col-24 + ${n}-control`]: {
        minWidth: "unset"
      }
    }
  };
}, VBe = (e) => {
  const {
    componentCls: t,
    formItemCls: n
  } = e;
  return {
    [`${t}-inline`]: {
      display: "flex",
      flexWrap: "wrap",
      [n]: {
        flex: "none",
        flexWrap: "nowrap",
        marginInlineEnd: e.margin,
        marginBottom: 0,
        "&-with-help": {
          marginBottom: e.marginLG
        },
        [`> ${n}-label,
        > ${n}-control`]: {
          display: "inline-block",
          verticalAlign: "top"
        },
        [`> ${n}-label`]: {
          flex: "none"
        },
        [`${t}-text`]: {
          display: "inline-block"
        },
        [`${n}-has-feedback`]: {
          display: "inline-block"
        }
      }
    }
  };
}, Kd = (e) => ({
  margin: 0,
  padding: `0 0 ${e.paddingXS}px`,
  whiteSpace: "initial",
  textAlign: "start",
  "> label": {
    margin: 0,
    "&::after": {
      display: "none"
    }
  }
}), zBe = (e) => {
  const {
    componentCls: t,
    formItemCls: n
  } = e;
  return {
    [`${n} ${n}-label`]: Kd(e),
    [t]: {
      [n]: {
        flexWrap: "wrap",
        [`${n}-label,
          ${n}-control`]: {
          flex: "0 0 100%",
          maxWidth: "100%"
        }
      }
    }
  };
}, HBe = (e) => {
  const {
    componentCls: t,
    formItemCls: n,
    rootPrefixCls: o
  } = e;
  return {
    [`${t}-vertical`]: {
      [n]: {
        "&-row": {
          flexDirection: "column"
        },
        "&-label > label": {
          height: "auto"
        },
        [`${t}-item-control`]: {
          width: "100%"
        }
      }
    },
    [`${t}-vertical ${n}-label,
      .${o}-col-24${n}-label,
      .${o}-col-xl-24${n}-label`]: Kd(e),
    [`@media (max-width: ${e.screenXSMax}px)`]: [zBe(e), {
      [t]: {
        [`.${o}-col-xs-24${n}-label`]: Kd(e)
      }
    }],
    [`@media (max-width: ${e.screenSMMax}px)`]: {
      [t]: {
        [`.${o}-col-sm-24${n}-label`]: Kd(e)
      }
    },
    [`@media (max-width: ${e.screenMDMax}px)`]: {
      [t]: {
        [`.${o}-col-md-24${n}-label`]: Kd(e)
      }
    },
    [`@media (max-width: ${e.screenLGMax}px)`]: {
      [t]: {
        [`.${o}-col-lg-24${n}-label`]: Kd(e)
      }
    }
  };
}, WT = Zt("Form", (e, t) => {
  let {
    rootPrefixCls: n
  } = t;
  const o = Vt(e, {
    formItemCls: `${e.componentCls}-item`,
    rootPrefixCls: n
  });
  return [LBe(o), BBe(o), RBe(o), FBe(o), VBe(o), HBe(o), Ih(o), zI];
}), jBe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ErrorList",
  inheritAttrs: !1,
  props: ["errors", "help", "onErrorVisibleChanged", "helpStatus", "warnings"],
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const {
      prefixCls: o,
      status: l
    } = TBe(), r = O(() => `${o.value}-item-explain`), a = O(() => !!(e.errors && e.errors.length)), i = /* @__PURE__ */ H(l.value), [, s] = WT(o);
    return pe([a, l], () => {
      a.value && (i.value = l.value);
    }), () => {
      var c, u;
      const d = Ph(`${o.value}-show-help-item`), f = vS(`${o.value}-show-help-item`, d);
      return f.role = "alert", f.class = [s.value, r.value, n.class, `${o.value}-show-help`], $(Vn, Q(Q({}, da(`${o.value}-show-help`)), {}, {
        onAfterEnter: () => e.onErrorVisibleChanged(!0),
        onAfterLeave: () => e.onErrorVisibleChanged(!1)
      }), {
        default: () => [_t($(mp, Q(Q({}, f), {}, {
          tag: "div"
        }), {
          default: () => [(u = e.errors) === null || u === void 0 ? void 0 : u.map((p, m) => $("div", {
            key: m,
            class: i.value ? `${r.value}-${i.value}` : ""
          }, [p]))]
        }), [[Jt, !!(!((c = e.errors) === null || c === void 0) && c.length)]])]
      });
    };
  }
}), WBe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  slots: Object,
  inheritAttrs: !1,
  props: ["prefixCls", "errors", "hasFeedback", "onDomErrorVisibleChange", "wrapperCol", "help", "extra", "status", "marginBottom", "onErrorVisibleChanged"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = zT(), {
      wrapperCol: l
    } = o, r = _({}, o);
    return delete r.labelCol, delete r.wrapperCol, RK(r), IBe({
      prefixCls: O(() => e.prefixCls),
      status: O(() => e.status)
    }), () => {
      var a, i, s;
      const {
        prefixCls: c,
        wrapperCol: u,
        marginBottom: d,
        onErrorVisibleChanged: f,
        help: p = (a = n.help) === null || a === void 0 ? void 0 : a.call(n),
        errors: m = mo((i = n.errors) === null || i === void 0 ? void 0 : i.call(n)),
        // hasFeedback,
        // status,
        extra: v = (s = n.extra) === null || s === void 0 ? void 0 : s.call(n)
      } = e, h = `${c}-item`, g = u || (l == null ? void 0 : l.value) || {}, y = ke(`${h}-control`, g.class);
      return $(WS, Q(Q({}, g), {}, {
        class: y
      }), {
        default: () => {
          var b;
          return $(Ge, null, [$("div", {
            class: `${h}-control-input`
          }, [$("div", {
            class: `${h}-control-input-content`
          }, [(b = n.default) === null || b === void 0 ? void 0 : b.call(n)])]), d !== null || m.length ? $("div", {
            style: {
              display: "flex",
              flexWrap: "nowrap"
            }
          }, [$(jBe, {
            errors: m,
            help: p,
            class: `${h}-explain-connected`,
            onErrorVisibleChanged: f
          }, null), !!d && $("div", {
            style: {
              width: 0,
              height: `${d}px`
            }
          }, null)]) : null, v ? $("div", {
            class: `${h}-extra`
          }, [v]) : null]);
        }
      });
    };
  }
});
function KBe(e) {
  const t = /* @__PURE__ */ Ce(e.value.slice());
  let n = null;
  return Ot(() => {
    clearTimeout(n), n = setTimeout(() => {
      t.value = e.value;
    }, e.value.length ? 0 : 10);
  }), t;
}
$l("success", "warning", "error", "validating", "");
const UBe = {
  success: Za,
  warning: Qa,
  error: jl,
  validating: ar
};
function jw(e, t, n) {
  let o = e;
  const l = t;
  let r = 0;
  try {
    for (let a = l.length; r < a - 1 && !(!o && !n); ++r) {
      const i = l[r];
      if (i in o)
        o = o[i];
      else {
        if (n)
          throw Error("please transfer a valid name path to form item!");
        break;
      }
    }
    if (n && !o)
      throw Error("please transfer a valid name path to form item!");
  } catch (a) {
    console.error("please transfer a valid name path to form item!");
  }
  return {
    o,
    k: l[r],
    v: o ? o[l[r]] : void 0
  };
}
const GBe = () => ({
  htmlFor: String,
  prefixCls: String,
  label: de.any,
  help: de.any,
  extra: de.any,
  labelCol: {
    type: Object
  },
  wrapperCol: {
    type: Object
  },
  hasFeedback: {
    type: Boolean,
    default: !1
  },
  colon: {
    type: Boolean,
    default: void 0
  },
  labelAlign: String,
  prop: {
    type: [String, Number, Array]
  },
  name: {
    type: [String, Number, Array]
  },
  rules: [Array, Object],
  autoLink: {
    type: Boolean,
    default: !0
  },
  required: {
    type: Boolean,
    default: void 0
  },
  validateFirst: {
    type: Boolean,
    default: void 0
  },
  validateStatus: de.oneOf($l("", "success", "warning", "error", "validating")),
  validateTrigger: {
    type: [String, Array]
  },
  messageVariables: {
    type: Object
  },
  hidden: Boolean,
  noStyle: Boolean,
  tooltip: String
});
let YBe = 0;
const XBe = "form_item", LK = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AFormItem",
  inheritAttrs: !1,
  __ANT_NEW_FORM_ITEM: !0,
  props: GBe(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: l
    } = t;
    bn(e.prop === void 0, "`prop` is deprecated. Please use `name` instead.");
    const r = `form-item-${++YBe}`, {
      prefixCls: a
    } = bt("form", e), [i, s] = WT(a), c = /* @__PURE__ */ Ce(), u = zT(), d = O(() => e.name || e.prop), f = /* @__PURE__ */ Ce([]), p = /* @__PURE__ */ Ce(!1), m = /* @__PURE__ */ Ce(), v = O(() => {
      const U = d.value;
      return K2(U);
    }), h = O(() => {
      if (v.value.length) {
        const U = u.name.value, te = v.value.join("_");
        return U ? `${U}_${te}` : `${XBe}_${te}`;
      } else
        return;
    }), g = () => {
      const U = u.model.value;
      if (!(!U || !d.value))
        return jw(U, v.value, !0).v;
    }, y = O(() => g()), b = /* @__PURE__ */ Ce(sc(y.value)), C = O(() => {
      let U = e.validateTrigger !== void 0 ? e.validateTrigger : u.validateTrigger.value;
      return U = U === void 0 ? "change" : U, fc(U);
    }), w = O(() => {
      let U = u.rules.value;
      const te = e.rules, J = e.required !== void 0 ? {
        required: !!e.required,
        trigger: C.value
      } : [], re = jw(U, v.value);
      U = U ? re.o[re.k] || re.v : [];
      const oe = [].concat(te || U || []);
      return iae(oe, (q) => q.required) ? oe : oe.concat(J);
    }), x = O(() => {
      const U = w.value;
      let te = !1;
      return U && U.length && U.every((J) => J.required ? (te = !0, !1) : !0), te || e.required;
    }), E = /* @__PURE__ */ Ce();
    Ot(() => {
      E.value = e.validateStatus;
    });
    const I = O(() => {
      let U = {};
      return typeof e.label == "string" ? U.label = e.label : e.name && (U.label = String(e.name)), e.messageVariables && (U = _(_({}, U), e.messageVariables)), U;
    }), T = (U) => {
      if (v.value.length === 0)
        return;
      const {
        validateFirst: te = !1
      } = e, {
        triggerName: J
      } = U || {};
      let re = w.value;
      if (J && (re = re.filter((q) => {
        const {
          trigger: K
        } = q;
        return !K && !C.value.length ? !0 : fc(K || C.value).includes(J);
      })), !re.length)
        return Promise.resolve();
      const oe = MK(v.value, y.value, re, _({
        validateMessages: u.validateMessages.value
      }, U), te, I.value);
      return E.value = "validating", f.value = [], oe.catch((q) => q).then(function() {
        let q = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (E.value === "validating") {
          const K = q.filter((se) => se && se.errors.length);
          E.value = K.length ? "error" : "success", f.value = K.map((se) => se.errors), u.onValidate(d.value, !f.value.length, f.value.length ? /* @__PURE__ */ Wt(f.value[0]) : null);
        }
      }), oe;
    }, P = () => {
      T({
        triggerName: "blur"
      });
    }, k = () => {
      if (p.value) {
        p.value = !1;
        return;
      }
      T({
        triggerName: "change"
      });
    }, N = () => {
      E.value = e.validateStatus, p.value = !1, f.value = [];
    }, R = () => {
      var U;
      E.value = e.validateStatus, p.value = !0, f.value = [];
      const te = u.model.value || {}, J = y.value, re = jw(te, v.value, !0);
      Array.isArray(J) ? re.o[re.k] = [].concat((U = b.value) !== null && U !== void 0 ? U : []) : re.o[re.k] = b.value, Ke(() => {
        p.value = !1;
      });
    }, z = O(() => e.htmlFor === void 0 ? h.value : e.htmlFor), D = () => {
      const U = z.value;
      if (!U || !m.value)
        return;
      const te = m.value.$el.querySelector(`[id="${U}"]`);
      te && te.focus && te.focus();
    };
    l({
      onFieldBlur: P,
      onFieldChange: k,
      clearValidate: N,
      resetField: R
    }), QMe({
      id: h,
      onFieldBlur: () => {
        e.autoLink && P();
      },
      onFieldChange: () => {
        e.autoLink && k();
      },
      clearValidate: N
    }, O(() => !!(e.autoLink && u.model.value && d.value)));
    let F = !1;
    pe(d, (U) => {
      U ? F || (F = !0, u.addField(r, {
        fieldValue: y,
        fieldId: h,
        fieldName: d,
        resetField: R,
        clearValidate: N,
        namePath: v,
        validateRules: T,
        rules: w
      })) : (F = !1, u.removeField(r));
    }, {
      immediate: !0
    }), yt(() => {
      u.removeField(r);
    });
    const M = KBe(f), A = O(() => e.validateStatus !== void 0 ? e.validateStatus : M.value.length ? "error" : E.value), L = O(() => ({
      [`${a.value}-item`]: !0,
      [s.value]: !0,
      // Status
      [`${a.value}-item-has-feedback`]: A.value && e.hasFeedback,
      [`${a.value}-item-has-success`]: A.value === "success",
      [`${a.value}-item-has-warning`]: A.value === "warning",
      [`${a.value}-item-has-error`]: A.value === "error",
      [`${a.value}-item-is-validating`]: A.value === "validating",
      [`${a.value}-item-hidden`]: e.hidden
    })), B = /* @__PURE__ */ kt({});
    sl.useProvide(B), Ot(() => {
      let U;
      if (e.hasFeedback) {
        const te = A.value && UBe[A.value];
        U = te ? $("span", {
          class: ke(`${a.value}-item-feedback-icon`, `${a.value}-item-feedback-icon-${A.value}`)
        }, [$(te, null, null)]) : null;
      }
      _(B, {
        status: A.value,
        hasFeedback: e.hasFeedback,
        feedbackIcon: U,
        isFormItemInput: !0
      });
    });
    const V = /* @__PURE__ */ Ce(null), j = /* @__PURE__ */ Ce(!1), W = () => {
      if (c.value) {
        const U = getComputedStyle(c.value);
        V.value = parseInt(U.marginBottom, 10);
      }
    };
    nt(() => {
      pe(j, () => {
        j.value && W();
      }, {
        flush: "post",
        immediate: !0
      });
    });
    const Y = (U) => {
      U || (V.value = null);
    };
    return () => {
      var U, te;
      if (e.noStyle) return (U = n.default) === null || U === void 0 ? void 0 : U.call(n);
      const J = (te = e.help) !== null && te !== void 0 ? te : n.help ? mo(n.help()) : null, re = !!(J != null && Array.isArray(J) && J.length || M.value.length);
      return j.value = re, i($("div", {
        class: [L.value, re ? `${a.value}-item-with-help` : "", o.class],
        ref: c
      }, [$(VT, Q(Q({}, o), {}, {
        class: `${a.value}-item-row`,
        key: "row"
      }), {
        default: () => {
          var oe, q;
          return $(Ge, null, [$(jT, Q(Q({}, e), {}, {
            htmlFor: z.value,
            required: x.value,
            requiredMark: u.requiredMark.value,
            prefixCls: a.value,
            onClick: D,
            label: e.label
          }), {
            label: n.label,
            tooltip: n.tooltip
          }), $(WBe, Q(Q({}, e), {}, {
            errors: J != null ? fc(J) : M.value,
            marginBottom: V.value,
            prefixCls: a.value,
            status: A.value,
            ref: m,
            help: J,
            extra: (oe = e.extra) !== null && oe !== void 0 ? oe : (q = n.extra) === null || q === void 0 ? void 0 : q.call(n),
            onErrorVisibleChanged: Y
          }), {
            default: n.default
          })]);
        }
      }), !!V.value && $("div", {
        class: `${a.value}-margin-offset`,
        style: {
          marginBottom: `-${V.value}px`
        }
      }, null)]));
    };
  }
});
function BK(e) {
  let t = !1, n = e.length;
  const o = [];
  return e.length ? new Promise((l, r) => {
    e.forEach((a, i) => {
      a.catch((s) => (t = !0, s)).then((s) => {
        n -= 1, o[i] = s, !(n > 0) && (t && r(o), l(o));
      });
    });
  }) : Promise.resolve([]);
}
function Q6(e) {
  let t = !1;
  return e && e.length && e.every((n) => n.required ? (t = !0, !1) : !0), t;
}
function eA(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function Ww(e, t, n) {
  let o = e;
  t = t.replace(/\[(\w+)\]/g, ".$1"), t = t.replace(/^\./, "");
  const l = t.split(".");
  let r = 0;
  for (let a = l.length; r < a - 1 && !(!o && !n); ++r) {
    const i = l[r];
    if (i in o)
      o = o[i];
    else {
      if (n)
        throw new Error("please transfer a valid name path to validate!");
      break;
    }
  }
  return {
    o,
    k: l[r],
    v: o ? o[l[r]] : null,
    isValid: o && l[r] in o
  };
}
function qBe(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ H({}), n = arguments.length > 2 ? arguments[2] : void 0;
  const o = sc(S(e)), l = /* @__PURE__ */ kt({}), r = /* @__PURE__ */ Ce([]), a = (b) => {
    _(S(e), _(_({}, sc(o)), b)), Ke(() => {
      Object.keys(l).forEach((C) => {
        l[C] = {
          autoLink: !1,
          required: Q6(S(t)[C])
        };
      });
    });
  }, i = function() {
    let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], C = arguments.length > 1 ? arguments[1] : void 0;
    return C.length ? b.filter((w) => {
      const x = eA(w.trigger || "change");
      return yae(x, C).length;
    }) : b;
  };
  let s = null;
  const c = function(b) {
    let C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, w = arguments.length > 2 ? arguments[2] : void 0;
    const x = [], E = {};
    for (let P = 0; P < b.length; P++) {
      const k = b[P], N = Ww(S(e), k, w);
      if (!N.isValid) continue;
      E[k] = N.v;
      const R = i(S(t)[k], eA(C && C.trigger));
      R.length && x.push(u(k, N.v, R, C || {}).then(() => ({
        name: k,
        errors: [],
        warnings: []
      })).catch((z) => {
        const D = [], F = [];
        return z.forEach((M) => {
          let {
            rule: {
              warningOnly: A
            },
            errors: L
          } = M;
          A ? F.push(...L) : D.push(...L);
        }), D.length ? Promise.reject({
          name: k,
          errors: D,
          warnings: F
        }) : {
          name: k,
          errors: D,
          warnings: F
        };
      }));
    }
    const I = BK(x);
    s = I;
    const T = I.then(() => s === I ? Promise.resolve(E) : Promise.reject([])).catch((P) => {
      const k = P.filter((N) => N && N.errors.length);
      return k.length ? Promise.reject({
        values: E,
        errorFields: k,
        outOfDate: s !== I
      }) : Promise.resolve(E);
    });
    return T.catch((P) => P), T;
  }, u = function(b, C, w) {
    let x = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const E = MK([b], C, w, _({
      validateMessages: HS
    }, x), !!x.validateFirst);
    return l[b] ? (l[b].validateStatus = "validating", E.catch((I) => I).then(function() {
      let I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var T;
      if (l[b].validateStatus === "validating") {
        const P = I.filter((k) => k && k.errors.length);
        l[b].validateStatus = P.length ? "error" : "success", l[b].help = P.length ? P.map((k) => k.errors) : null, (T = n == null ? void 0 : n.onValidate) === null || T === void 0 || T.call(n, b, !P.length, P.length ? /* @__PURE__ */ Wt(l[b].help[0]) : null);
      }
    }), E) : E.catch((I) => I);
  }, d = (b, C) => {
    let w = [], x = !0;
    b ? Array.isArray(b) ? w = b : w = [b] : (x = !1, w = r.value);
    const E = c(w, C || {}, x);
    return E.catch((I) => I), E;
  }, f = (b) => {
    let C = [];
    b ? Array.isArray(b) ? C = b : C = [b] : C = r.value, C.forEach((w) => {
      l[w] && _(l[w], {
        validateStatus: "",
        help: null
      });
    });
  }, p = (b) => {
    const C = {
      autoLink: !1
    }, w = [], x = Array.isArray(b) ? b : [b];
    for (let E = 0; E < x.length; E++) {
      const I = x[E];
      (I == null ? void 0 : I.validateStatus) === "error" && (C.validateStatus = "error", I.help && w.push(I.help)), C.required = C.required || (I == null ? void 0 : I.required);
    }
    return C.help = w, C;
  };
  let m = o, v = !0;
  const h = (b) => {
    const C = [];
    r.value.forEach((w) => {
      const x = Ww(b, w, !1), E = Ww(m, w, !1);
      (v && (n == null ? void 0 : n.immediate) && x.isValid || !Jn(x.v, E.v)) && C.push(w);
    }), d(C, {
      trigger: "change"
    }), v = !1, m = sc(/* @__PURE__ */ Wt(b));
  }, g = n == null ? void 0 : n.debounce;
  let y = !0;
  return pe(t, () => {
    r.value = t ? Object.keys(S(t)) : [], !y && n && n.validateOnRuleChange && d(), y = !1;
  }, {
    deep: !0,
    immediate: !0
  }), pe(r, () => {
    const b = {};
    r.value.forEach((C) => {
      b[C] = _({}, l[C], {
        autoLink: !1,
        required: Q6(S(t)[C])
      }), delete l[C];
    });
    for (const C in l)
      Object.prototype.hasOwnProperty.call(l, C) && delete l[C];
    _(l, b);
  }, {
    immediate: !0
  }), pe(e, g && g.wait ? Dr(h, g.wait, Cp(g, ["wait"])) : h, {
    immediate: n && !!n.immediate,
    deep: !0
  }), {
    modelRef: e,
    rulesRef: t,
    initialModel: o,
    validateInfos: l,
    resetFields: a,
    validate: d,
    validateField: u,
    mergeValidateInfo: p,
    clearValidate: f
  };
}
const JBe = () => ({
  layout: de.oneOf($l("horizontal", "inline", "vertical")),
  labelCol: Nt(),
  wrapperCol: Nt(),
  colon: Qe(),
  labelAlign: At(),
  labelWrap: Qe(),
  prefixCls: String,
  requiredMark: zt([String, Boolean]),
  /** @deprecated Will warning in future branch. Pls use `requiredMark` instead. */
  hideRequiredMark: Qe(),
  model: de.object,
  rules: Nt(),
  validateMessages: Nt(),
  validateOnRuleChange: Qe(),
  // 
  scrollToFirstError: Wn(),
  onSubmit: Fe(),
  name: String,
  validateTrigger: zt([String, Array]),
  size: At(),
  disabled: Qe(),
  onValuesChange: Fe(),
  onFieldsChange: Fe(),
  onFinish: Fe(),
  onFinishFailed: Fe(),
  onValidate: Fe()
});
function ZBe(e, t) {
  return Jn(fc(e), fc(t));
}
const Js = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AForm",
  inheritAttrs: !1,
  props: sn(JBe(), {
    layout: "horizontal",
    hideRequiredMark: !1,
    colon: !0
  }),
  Item: LK,
  useForm: qBe,
  // emits: ['finishFailed', 'submit', 'finish', 'validate'],
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      expose: l,
      attrs: r
    } = t;
    const {
      prefixCls: a,
      direction: i,
      form: s,
      size: c,
      disabled: u
    } = bt("form", e), d = O(() => e.requiredMark === "" || e.requiredMark), f = O(() => {
      var M;
      return d.value !== void 0 ? d.value : s && ((M = s.value) === null || M === void 0 ? void 0 : M.requiredMark) !== void 0 ? s.value.requiredMark : !e.hideRequiredMark;
    });
    HH(c), aH(u);
    const p = O(() => {
      var M, A;
      return (M = e.colon) !== null && M !== void 0 ? M : (A = s.value) === null || A === void 0 ? void 0 : A.colon;
    }), {
      validateMessages: m
    } = APe(), v = O(() => _(_(_({}, HS), m.value), e.validateMessages)), [h, g] = WT(a), y = O(() => ke(a.value, {
      [`${a.value}-${e.layout}`]: !0,
      [`${a.value}-hide-required-mark`]: f.value === !1,
      [`${a.value}-rtl`]: i.value === "rtl",
      [`${a.value}-${c.value}`]: c.value
    }, g.value)), b = /* @__PURE__ */ H(), C = {}, w = (M, A) => {
      C[M] = A;
    }, x = (M) => {
      delete C[M];
    }, E = (M) => {
      const A = !!M, L = A ? fc(M).map(K2) : [];
      return A ? Object.values(C).filter((B) => L.findIndex((V) => ZBe(V, B.fieldName.value)) > -1) : Object.values(C);
    }, I = (M) => {
      if (!e.model) {
        Hn(!1, "Form", "model is required for resetFields to work.");
        return;
      }
      E(M).forEach((A) => {
        A.resetField();
      });
    }, T = (M) => {
      E(M).forEach((A) => {
        A.clearValidate();
      });
    }, P = (M) => {
      const {
        scrollToFirstError: A
      } = e;
      if (n("finishFailed", M), A && M.errorFields.length) {
        let L = {};
        typeof A == "object" && (L = A), N(M.errorFields[0].name, L);
      }
    }, k = function() {
      return D(...arguments);
    }, N = function(M) {
      let A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const L = E(M ? [M] : void 0);
      if (L.length) {
        const B = L[0].fieldId.value, V = B ? document.getElementById(B) : null;
        V && KH(V, _({
          scrollMode: "if-needed",
          block: "nearest"
        }, A));
      }
    }, R = function() {
      let M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      if (M === !0) {
        const A = [];
        return Object.values(C).forEach((L) => {
          let {
            namePath: B
          } = L;
          A.push(B.value);
        }), q6(e.model, A);
      } else
        return q6(e.model, M);
    }, z = (M, A) => {
      if (Hn(!(M instanceof Function), "Form", "validateFields/validateField/validate not support callback, please use promise instead"), !e.model)
        return Hn(!1, "Form", "model is required for validateFields to work."), Promise.reject("Form `model` is required for validateFields to work.");
      const L = !!M, B = L ? fc(M).map(K2) : [], V = [];
      Object.values(C).forEach((Y) => {
        var U;
        if (L || B.push(Y.namePath.value), !(!((U = Y.rules) === null || U === void 0) && U.value.length))
          return;
        const te = Y.namePath.value;
        if (!L || CBe(B, te)) {
          const J = Y.validateRules(_({
            validateMessages: v.value
          }, A));
          V.push(J.then(() => ({
            name: te,
            errors: [],
            warnings: []
          })).catch((re) => {
            const oe = [], q = [];
            return re.forEach((K) => {
              let {
                rule: {
                  warningOnly: se
                },
                errors: Z
              } = K;
              se ? q.push(...Z) : oe.push(...Z);
            }), oe.length ? Promise.reject({
              name: te,
              errors: oe,
              warnings: q
            }) : {
              name: te,
              errors: oe,
              warnings: q
            };
          }));
        }
      });
      const j = BK(V);
      b.value = j;
      const W = j.then(() => b.value === j ? Promise.resolve(R(B)) : Promise.reject([])).catch((Y) => {
        const U = Y.filter((te) => te && te.errors.length);
        return Promise.reject({
          values: R(B),
          errorFields: U,
          outOfDate: b.value !== j
        });
      });
      return W.catch((Y) => Y), W;
    }, D = function() {
      return z(...arguments);
    }, F = (M) => {
      M.preventDefault(), M.stopPropagation(), n("submit", M), e.model && z().then((L) => {
        n("finish", L);
      }).catch((L) => {
        P(L);
      });
    };
    return l({
      resetFields: I,
      clearValidate: T,
      validateFields: z,
      getFieldsValue: R,
      validate: k,
      scrollToField: N
    }), RK({
      model: O(() => e.model),
      name: O(() => e.name),
      labelAlign: O(() => e.labelAlign),
      labelCol: O(() => e.labelCol),
      labelWrap: O(() => e.labelWrap),
      wrapperCol: O(() => e.wrapperCol),
      vertical: O(() => e.layout === "vertical"),
      colon: p,
      requiredMark: f,
      validateTrigger: O(() => e.validateTrigger),
      rules: O(() => e.rules),
      addField: w,
      removeField: x,
      onValidate: (M, A, L) => {
        n("validate", M, A, L);
      },
      validateMessages: v
    }), pe(() => e.rules, () => {
      e.validateOnRuleChange && z();
    }), () => {
      var M;
      return h($("form", Q(Q({}, r), {}, {
        onSubmit: F,
        class: [y.value, r.class]
      }), [(M = o.default) === null || M === void 0 ? void 0 : M.call(o)]));
    };
  }
});
Js.useInjectFormItemContext = Ko;
Js.ItemRest = py;
Js.install = function(e) {
  return e.component(Js.name, Js), e.component(Js.Item.name, Js.Item), e.component(py.name, py), e;
};
const QBe = new mn("antCheckboxEffect", {
  "0%": {
    transform: "scale(1)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(1.6)",
    opacity: 0
  }
}), e7e = (e) => {
  const {
    checkboxCls: t
  } = e, n = `${t}-wrapper`;
  return [
    // ===================== Basic =====================
    {
      // Group
      [`${t}-group`]: _(_({}, nn(e)), {
        display: "inline-flex",
        flexWrap: "wrap",
        columnGap: e.marginXS,
        // Group > Grid
        [`> ${e.antCls}-row`]: {
          flex: 1
        }
      }),
      // Wrapper
      [n]: _(_({}, nn(e)), {
        display: "inline-flex",
        alignItems: "baseline",
        cursor: "pointer",
        // Fix checkbox & radio in flex align #30260
        "&:after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: "'\\a0'"
        },
        // Checkbox near checkbox
        [`& + ${n}`]: {
          marginInlineStart: 0
        },
        [`&${n}-in-form-item`]: {
          'input[type="checkbox"]': {
            width: 14,
            height: 14
            // FIXME: magic
          }
        }
      }),
      // Wrapper > Checkbox
      [t]: _(_({}, nn(e)), {
        position: "relative",
        whiteSpace: "nowrap",
        lineHeight: 1,
        cursor: "pointer",
        // To make alignment right when `controlHeight` is changed
        // Ref: https://github.com/ant-design/ant-design/issues/41564
        alignSelf: "center",
        // Wrapper > Checkbox > input
        [`${t}-input`]: {
          position: "absolute",
          // Since baseline align will get additional space offset,
          // we need to move input to top to make it align with text.
          // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0,
          margin: 0,
          [`&:focus-visible + ${t}-inner`]: _({}, bs(e))
        },
        // Wrapper > Checkbox > inner
        [`${t}-inner`]: {
          boxSizing: "border-box",
          position: "relative",
          top: 0,
          insetInlineStart: 0,
          display: "block",
          width: e.checkboxSize,
          height: e.checkboxSize,
          direction: "ltr",
          backgroundColor: e.colorBgContainer,
          border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
          borderRadius: e.borderRadiusSM,
          borderCollapse: "separate",
          transition: `all ${e.motionDurationSlow}`,
          "&:after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "21.5%",
            display: "table",
            width: e.checkboxSize / 14 * 5,
            height: e.checkboxSize / 14 * 8,
            border: `${e.lineWidthBold}px solid ${e.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${e.motionDurationFast} ${e.motionEaseInBack}, opacity ${e.motionDurationFast}`
          }
        },
        // Wrapper > Checkbox + Text
        "& + span": {
          paddingInlineStart: e.paddingXS,
          paddingInlineEnd: e.paddingXS
        }
      })
    },
    // ================= Indeterminate =================
    {
      [t]: {
        "&-indeterminate": {
          // Wrapper > Checkbox > inner
          [`${t}-inner`]: {
            "&:after": {
              top: "50%",
              insetInlineStart: "50%",
              width: e.fontSizeLG / 2,
              height: e.fontSizeLG / 2,
              backgroundColor: e.colorPrimary,
              border: 0,
              transform: "translate(-50%, -50%) scale(1)",
              opacity: 1,
              content: '""'
            }
          }
        }
      }
    },
    // ===================== Hover =====================
    {
      // Wrapper
      [`${n}:hover ${t}:after`]: {
        visibility: "visible"
      },
      // Wrapper & Wrapper > Checkbox
      [`
        ${n}:not(${n}-disabled),
        ${t}:not(${t}-disabled)
      `]: {
        [`&:hover ${t}-inner`]: {
          borderColor: e.colorPrimary
        }
      },
      [`${n}:not(${n}-disabled)`]: {
        [`&:hover ${t}-checked:not(${t}-disabled) ${t}-inner`]: {
          backgroundColor: e.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${t}-checked:not(${t}-disabled):after`]: {
          borderColor: e.colorPrimaryHover
        }
      }
    },
    // ==================== Checked ====================
    {
      // Wrapper > Checkbox
      [`${t}-checked`]: {
        [`${t}-inner`]: {
          backgroundColor: e.colorPrimary,
          borderColor: e.colorPrimary,
          "&:after": {
            opacity: 1,
            transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
            transition: `all ${e.motionDurationMid} ${e.motionEaseOutBack} ${e.motionDurationFast}`
          }
        },
        // Checked Effect
        "&:after": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          width: "100%",
          height: "100%",
          borderRadius: e.borderRadiusSM,
          visibility: "hidden",
          border: `${e.lineWidthBold}px solid ${e.colorPrimary}`,
          animationName: QBe,
          animationDuration: e.motionDurationSlow,
          animationTimingFunction: "ease-in-out",
          animationFillMode: "backwards",
          content: '""',
          transition: `all ${e.motionDurationSlow}`
        }
      },
      [`
        ${n}-checked:not(${n}-disabled),
        ${t}-checked:not(${t}-disabled)
      `]: {
        [`&:hover ${t}-inner`]: {
          backgroundColor: e.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${t}:after`]: {
          borderColor: e.colorPrimaryHover
        }
      }
    },
    // ==================== Disable ====================
    {
      // Wrapper
      [`${n}-disabled`]: {
        cursor: "not-allowed"
      },
      // Wrapper > Checkbox
      [`${t}-disabled`]: {
        // Wrapper > Checkbox > input
        [`&, ${t}-input`]: {
          cursor: "not-allowed",
          // Disabled for native input to enable Tooltip event handler
          // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
          pointerEvents: "none"
        },
        // Wrapper > Checkbox > inner
        [`${t}-inner`]: {
          background: e.colorBgContainerDisabled,
          borderColor: e.colorBorder,
          "&:after": {
            borderColor: e.colorTextDisabled
          }
        },
        "&:after": {
          display: "none"
        },
        "& + span": {
          color: e.colorTextDisabled
        },
        [`&${t}-indeterminate ${t}-inner::after`]: {
          background: e.colorTextDisabled
        }
      }
    }
  ];
};
function KS(e, t) {
  const n = Vt(t, {
    checkboxCls: `.${e}`,
    checkboxSize: t.controlInteractiveSize
  });
  return [e7e(n)];
}
const FK = Zt("Checkbox", (e, t) => {
  let {
    prefixCls: n
  } = t;
  return [KS(n, e)];
}), t7e = (e) => {
  const {
    prefixCls: t,
    componentCls: n,
    antCls: o
  } = e, l = `${n}-menu-item`, r = `
    &${l}-expand ${l}-expand-icon,
    ${l}-loading-icon
  `, a = Math.round((e.controlHeight - e.fontSize * e.lineHeight) / 2);
  return [
    // =====================================================
    // ==                     Control                     ==
    // =====================================================
    {
      [n]: {
        width: e.controlWidth
      }
    },
    // =====================================================
    // ==                      Popup                      ==
    // =====================================================
    {
      [`${n}-dropdown`]: [
        // ==================== Checkbox ====================
        KS(`${t}-checkbox`, e),
        {
          [`&${o}-select-dropdown`]: {
            padding: 0
          }
        },
        {
          [n]: {
            // ================== Checkbox ==================
            "&-checkbox": {
              top: 0,
              marginInlineEnd: e.paddingXS
            },
            // ==================== Menu ====================
            // >>> Menus
            "&-menus": {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "flex-start",
              [`&${n}-menu-empty`]: {
                [`${n}-menu`]: {
                  width: "100%",
                  height: "auto",
                  [l]: {
                    color: e.colorTextDisabled
                  }
                }
              }
            },
            // >>> Menu
            "&-menu": {
              flexGrow: 1,
              minWidth: e.controlItemWidth,
              height: e.dropdownHeight,
              margin: 0,
              padding: e.paddingXXS,
              overflow: "auto",
              verticalAlign: "top",
              listStyle: "none",
              "-ms-overflow-style": "-ms-autohiding-scrollbar",
              "&:not(:last-child)": {
                borderInlineEnd: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`
              },
              "&-item": _(_({}, Fo), {
                display: "flex",
                flexWrap: "nowrap",
                alignItems: "center",
                padding: `${a}px ${e.paddingSM}px`,
                lineHeight: e.lineHeight,
                cursor: "pointer",
                transition: `all ${e.motionDurationMid}`,
                borderRadius: e.borderRadiusSM,
                "&:hover": {
                  background: e.controlItemBgHover
                },
                "&-disabled": {
                  color: e.colorTextDisabled,
                  cursor: "not-allowed",
                  "&:hover": {
                    background: "transparent"
                  },
                  [r]: {
                    color: e.colorTextDisabled
                  }
                },
                [`&-active:not(${l}-disabled)`]: {
                  "&, &:hover": {
                    fontWeight: e.fontWeightStrong,
                    backgroundColor: e.controlItemBgActive
                  }
                },
                "&-content": {
                  flex: "auto"
                },
                [r]: {
                  marginInlineStart: e.paddingXXS,
                  color: e.colorTextDescription,
                  fontSize: e.fontSizeIcon
                },
                "&-keyword": {
                  color: e.colorHighlight
                }
              })
            }
          }
        }
      ]
    },
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${n}-dropdown-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    Rp(e)
  ];
}, n7e = Zt("Cascader", (e) => [t7e(e)], {
  controlWidth: 184,
  controlItemWidth: 111,
  dropdownHeight: 180
});
var o7e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function l7e(e, t, n) {
  const o = e.toLowerCase().split(t).reduce((a, i, s) => s === 0 ? [i] : [...a, t, i], []), l = [];
  let r = 0;
  return o.forEach((a, i) => {
    const s = r + a.length;
    let c = e.slice(r, s);
    r = s, i % 2 === 1 && (c = $("span", {
      class: `${n}-menu-item-keyword`,
      key: "seperator"
    }, [c])), l.push(c);
  }), l;
}
const r7e = (e) => {
  let {
    inputValue: t,
    path: n,
    prefixCls: o,
    fieldNames: l
  } = e;
  const r = [], a = t.toLowerCase();
  return n.forEach((i, s) => {
    s !== 0 && r.push(" / ");
    let c = i[l.label];
    const u = typeof c;
    (u === "string" || u === "number") && (c = l7e(String(c), a, o)), r.push(c);
  }), r;
};
function a7e() {
  return _(_({}, pn(EK(), ["customSlots", "checkable", "options"])), {
    multiple: {
      type: Boolean,
      default: void 0
    },
    size: String,
    bordered: {
      type: Boolean,
      default: void 0
    },
    placement: {
      type: String
    },
    suffixIcon: de.any,
    status: String,
    options: Array,
    popupClassName: String,
    /** @deprecated Please use `popupClassName` instead */
    dropdownClassName: String,
    "onUpdate:value": Function
  });
}
const i7e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ACascader",
  inheritAttrs: !1,
  props: sn(a7e(), {
    bordered: !0,
    choiceTransitionName: "",
    allowClear: !0
  }),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: l,
      emit: r
    } = t;
    process.env.NODE_ENV !== "production" && un(!e.dropdownClassName, "Cascader", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
    const a = Ko(), i = sl.useInject(), s = O(() => Ja(i.status, e.status)), {
      prefixCls: c,
      rootPrefixCls: u,
      getPrefixCls: d,
      direction: f,
      getPopupContainer: p,
      renderEmpty: m,
      size: v,
      disabled: h
    } = bt("cascader", e), g = O(() => d("select", e.prefixCls)), {
      compactSize: y,
      compactItemClassnames: b
    } = Rc(g, f), C = O(() => y.value || v.value), w = Cr(), x = O(() => {
      var A;
      return (A = h.value) !== null && A !== void 0 ? A : w.value;
    }), [E, I] = HI(g), [T] = n7e(c), P = O(() => f.value === "rtl");
    process.env.NODE_ENV !== "production" && Ot(() => {
      un(!e.multiple || !e.displayRender || !l.displayRender, "Cascader", "`displayRender` not work on `multiple`. Please use `tagRender` instead.");
    });
    const k = O(() => {
      if (!e.showSearch)
        return e.showSearch;
      let A = {
        render: r7e
      };
      return typeof e.showSearch == "object" && (A = _(_({}, A), e.showSearch)), A;
    }), N = O(() => ke(e.popupClassName || e.dropdownClassName, `${c.value}-dropdown`, {
      [`${c.value}-dropdown-rtl`]: P.value
    }, I.value)), R = /* @__PURE__ */ H();
    o({
      focus() {
        var A;
        (A = R.value) === null || A === void 0 || A.focus();
      },
      blur() {
        var A;
        (A = R.value) === null || A === void 0 || A.blur();
      }
    });
    const z = function() {
      for (var A = arguments.length, L = new Array(A), B = 0; B < A; B++)
        L[B] = arguments[B];
      r("update:value", L[0]), r("change", ...L), a.onFieldChange();
    }, D = function() {
      for (var A = arguments.length, L = new Array(A), B = 0; B < A; B++)
        L[B] = arguments[B];
      r("blur", ...L), a.onFieldBlur();
    }, F = O(() => e.showArrow !== void 0 ? e.showArrow : e.loading || !e.multiple), M = O(() => e.placement !== void 0 ? e.placement : f.value === "rtl" ? "bottomRight" : "bottomLeft");
    return () => {
      var A, L;
      const {
        notFoundContent: B = (A = l.notFoundContent) === null || A === void 0 ? void 0 : A.call(l),
        expandIcon: V = (L = l.expandIcon) === null || L === void 0 ? void 0 : L.call(l),
        multiple: j,
        bordered: W,
        allowClear: Y,
        choiceTransitionName: U,
        transitionName: te,
        id: J = a.id.value
      } = e, re = o7e(e, ["notFoundContent", "expandIcon", "multiple", "bordered", "allowClear", "choiceTransitionName", "transitionName", "id"]), oe = B || m("Cascader");
      let q = V;
      V || (q = P.value ? $(Ii, null, null) : $(Br, null, null));
      const K = $("span", {
        class: `${g.value}-menu-item-loading-icon`
      }, [$(ar, {
        spin: !0
      }, null)]), {
        suffixIcon: se,
        removeIcon: Z,
        clearIcon: ee
      } = BI(_(_({}, e), {
        hasFeedback: i.hasFeedback,
        feedbackIcon: i.feedbackIcon,
        multiple: j,
        prefixCls: g.value,
        showArrow: F.value
      }), l);
      return T(E($(lBe, Q(Q(Q({}, re), n), {}, {
        id: J,
        prefixCls: g.value,
        class: [c.value, {
          [`${g.value}-lg`]: C.value === "large",
          [`${g.value}-sm`]: C.value === "small",
          [`${g.value}-rtl`]: P.value,
          [`${g.value}-borderless`]: !W,
          [`${g.value}-in-form-item`]: i.isFormItemInput
        }, Ll(g.value, s.value, i.hasFeedback), b.value, n.class, I.value],
        disabled: x.value,
        direction: f.value,
        placement: M.value,
        notFoundContent: oe,
        allowClear: Y,
        showSearch: k.value,
        expandIcon: q,
        inputIcon: se,
        removeIcon: Z,
        clearIcon: ee,
        loadingIcon: K,
        checkable: !!j,
        dropdownClassName: N.value,
        dropdownPrefixCls: c.value,
        choiceTransitionName: Vl(u.value, "", U),
        transitionName: Vl(u.value, xI(M.value), te),
        getPopupContainer: p == null ? void 0 : p.value,
        customSlots: _(_({}, l), {
          checkable: () => $("span", {
            class: `${c.value}-checkbox-inner`
          }, null)
        }),
        tagRender: e.tagRender || l.tagRender,
        displayRender: e.displayRender || l.displayRender,
        maxTagPlaceholder: e.maxTagPlaceholder || l.maxTagPlaceholder,
        showArrow: i.hasFeedback || e.showArrow,
        onChange: z,
        onBlur: D,
        ref: R
      }), l)));
    };
  }
}), s7e = po(_(i7e, {
  SHOW_CHILD: mK,
  SHOW_PARENT: vK
})), c7e = () => ({
  name: String,
  prefixCls: String,
  options: $n([]),
  disabled: Boolean,
  id: String
}), u7e = () => _(_({}, c7e()), {
  defaultValue: $n(),
  value: $n(),
  onChange: Fe(),
  "onUpdate:value": Fe()
}), d7e = () => ({
  prefixCls: String,
  defaultChecked: Qe(),
  checked: Qe(),
  disabled: Qe(),
  isGroup: Qe(),
  value: de.any,
  name: String,
  id: String,
  indeterminate: Qe(),
  type: At("checkbox"),
  autofocus: Qe(),
  onChange: Fe(),
  "onUpdate:checked": Fe(),
  onClick: Fe(),
  skipGroup: Qe(!1)
}), f7e = () => _(_({}, d7e()), {
  indeterminate: Qe(!1)
}), VK = Symbol("CheckboxGroupContext");
var tA = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const la = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckbox",
  inheritAttrs: !1,
  __ANT_CHECKBOX: !0,
  props: f7e(),
  // emits: ['change', 'update:checked'],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      slots: l,
      expose: r
    } = t;
    const a = Ko(), i = sl.useInject(), {
      prefixCls: s,
      direction: c,
      disabled: u
    } = bt("checkbox", e), d = Cr(), [f, p] = FK(s), m = ze(VK, void 0), v = Symbol("checkboxUniId"), h = O(() => (m == null ? void 0 : m.disabled.value) || u.value);
    Ot(() => {
      !e.skipGroup && m && m.registerValue(v, e.value);
    }), yt(() => {
      m && m.cancelValue(v);
    }), nt(() => {
      Hn(!!(e.checked !== void 0 || m || e.value === void 0), "Checkbox", "`value` is not validate prop, do you mean `checked`?");
    });
    const g = (w) => {
      const x = w.target.checked;
      n("update:checked", x), n("change", w), a.onFieldChange();
    }, y = /* @__PURE__ */ H();
    return r({
      focus: () => {
        var w;
        (w = y.value) === null || w === void 0 || w.focus();
      },
      blur: () => {
        var w;
        (w = y.value) === null || w === void 0 || w.blur();
      }
    }), () => {
      var w;
      const x = Fn((w = l.default) === null || w === void 0 ? void 0 : w.call(l)), {
        indeterminate: E,
        skipGroup: I,
        id: T = a.id.value
      } = e, P = tA(e, ["indeterminate", "skipGroup", "id"]), {
        onMouseenter: k,
        onMouseleave: N,
        onInput: R,
        class: z,
        style: D
      } = o, F = tA(o, ["onMouseenter", "onMouseleave", "onInput", "class", "style"]), M = _(_(_(_({}, P), {
        id: T,
        prefixCls: s.value
      }), F), {
        disabled: h.value
      });
      m && !I ? (M.onChange = function() {
        for (var V = arguments.length, j = new Array(V), W = 0; W < V; W++)
          j[W] = arguments[W];
        n("change", ...j), m.toggleOption({
          label: x,
          value: e.value
        });
      }, M.name = m.name.value, M.checked = m.mergedValue.value.includes(e.value), M.disabled = h.value || d.value, M.indeterminate = E) : M.onChange = g;
      const A = ke({
        [`${s.value}-wrapper`]: !0,
        [`${s.value}-rtl`]: c.value === "rtl",
        [`${s.value}-wrapper-checked`]: M.checked,
        [`${s.value}-wrapper-disabled`]: M.disabled,
        [`${s.value}-wrapper-in-form-item`]: i.isFormItemInput
      }, z, p.value), L = ke({
        [`${s.value}-indeterminate`]: E
      }, p.value);
      return f($("label", {
        class: A,
        style: D,
        onMouseenter: k,
        onMouseleave: N
      }, [$(FW, Q(Q({
        "aria-checked": E ? "mixed" : void 0
      }, M), {}, {
        class: L,
        ref: y
      }), null), x.length ? $("span", null, [x]) : null]));
    };
  }
}), Ry = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckboxGroup",
  inheritAttrs: !1,
  props: u7e(),
  // emits: ['change', 'update:value'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: l,
      expose: r
    } = t;
    const a = Ko(), {
      prefixCls: i,
      direction: s
    } = bt("checkbox", e), c = O(() => `${i.value}-group`), [u, d] = FK(c), f = /* @__PURE__ */ H((e.value === void 0 ? e.defaultValue : e.value) || []);
    pe(() => e.value, () => {
      f.value = e.value || [];
    });
    const p = O(() => e.options.map((C) => typeof C == "string" || typeof C == "number" ? {
      label: C,
      value: C
    } : C)), m = /* @__PURE__ */ H(Symbol()), v = /* @__PURE__ */ H(/* @__PURE__ */ new Map()), h = (C) => {
      v.value.delete(C), m.value = Symbol();
    }, g = (C, w) => {
      v.value.set(C, w), m.value = Symbol();
    }, y = /* @__PURE__ */ H(/* @__PURE__ */ new Map());
    return pe(m, () => {
      const C = /* @__PURE__ */ new Map();
      for (const w of v.value.values())
        C.set(w, !0);
      y.value = C;
    }), at(VK, {
      cancelValue: h,
      registerValue: g,
      toggleOption: (C) => {
        const w = f.value.indexOf(C.value), x = [...f.value];
        w === -1 ? x.push(C.value) : x.splice(w, 1), e.value === void 0 && (f.value = x);
        const E = x.filter((I) => y.value.has(I)).sort((I, T) => {
          const P = p.value.findIndex((N) => N.value === I), k = p.value.findIndex((N) => N.value === T);
          return P - k;
        });
        l("update:value", E), l("change", E), a.onFieldChange();
      },
      mergedValue: f,
      name: O(() => e.name),
      disabled: O(() => e.disabled)
    }), r({
      mergedValue: f
    }), () => {
      var C;
      const {
        id: w = a.id.value
      } = e;
      let x = null;
      return p.value && p.value.length > 0 && (x = p.value.map((E) => {
        var I;
        return $(la, {
          prefixCls: i.value,
          key: E.value.toString(),
          disabled: "disabled" in E ? E.disabled : e.disabled,
          indeterminate: E.indeterminate,
          value: E.value,
          checked: f.value.indexOf(E.value) !== -1,
          onChange: E.onChange,
          class: `${c.value}-item`
        }, {
          default: () => [n.label !== void 0 ? (I = n.label) === null || I === void 0 ? void 0 : I.call(n, E) : E.label]
        });
      })), u($("div", Q(Q({}, o), {}, {
        class: [c.value, {
          [`${c.value}-rtl`]: s.value === "rtl"
        }, o.class, d.value],
        id: w
      }), [x || ((C = n.default) === null || C === void 0 ? void 0 : C.call(n))]));
    };
  }
});
la.Group = Ry;
la.install = function(e) {
  return e.component(la.name, la), e.component(Ry.name, Ry), e;
};
const p7e = {
  useBreakpoint: Dp
}, v7e = po(WS), m7e = (e) => {
  const {
    componentCls: t,
    commentBg: n,
    commentPaddingBase: o,
    commentNestIndent: l,
    commentFontSizeBase: r,
    commentFontSizeSm: a,
    commentAuthorNameColor: i,
    commentAuthorTimeColor: s,
    commentActionColor: c,
    commentActionHoverColor: u,
    commentActionsMarginBottom: d,
    commentActionsMarginTop: f,
    commentContentDetailPMarginBottom: p
  } = e;
  return {
    [t]: {
      position: "relative",
      backgroundColor: n,
      [`${t}-inner`]: {
        display: "flex",
        padding: o
      },
      [`${t}-avatar`]: {
        position: "relative",
        flexShrink: 0,
        marginRight: e.marginSM,
        cursor: "pointer",
        img: {
          width: "32px",
          height: "32px",
          borderRadius: "50%"
        }
      },
      [`${t}-content`]: {
        position: "relative",
        flex: "1 1 auto",
        minWidth: "1px",
        fontSize: r,
        wordWrap: "break-word",
        "&-author": {
          display: "flex",
          flexWrap: "wrap",
          justifyContent: "flex-start",
          marginBottom: e.marginXXS,
          fontSize: r,
          "& > a,& > span": {
            paddingRight: e.paddingXS,
            fontSize: a,
            lineHeight: "18px"
          },
          "&-name": {
            color: i,
            fontSize: r,
            transition: `color ${e.motionDurationSlow}`,
            "> *": {
              color: i,
              "&:hover": {
                color: i
              }
            }
          },
          "&-time": {
            color: s,
            whiteSpace: "nowrap",
            cursor: "auto"
          }
        },
        "&-detail p": {
          marginBottom: p,
          whiteSpace: "pre-wrap"
        }
      },
      [`${t}-actions`]: {
        marginTop: f,
        marginBottom: d,
        paddingLeft: 0,
        "> li": {
          display: "inline-block",
          color: c,
          "> span": {
            marginRight: "10px",
            color: c,
            fontSize: a,
            cursor: "pointer",
            transition: `color ${e.motionDurationSlow}`,
            userSelect: "none",
            "&:hover": {
              color: u
            }
          }
        }
      },
      [`${t}-nested`]: {
        marginLeft: l
      },
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
}, h7e = Zt("Comment", (e) => {
  const t = Vt(e, {
    commentBg: "inherit",
    commentPaddingBase: `${e.paddingMD}px 0`,
    commentNestIndent: "44px",
    commentFontSizeBase: e.fontSize,
    commentFontSizeSm: e.fontSizeSM,
    commentAuthorNameColor: e.colorTextTertiary,
    commentAuthorTimeColor: e.colorTextPlaceholder,
    commentActionColor: e.colorTextTertiary,
    commentActionHoverColor: e.colorTextSecondary,
    commentActionsMarginBottom: "inherit",
    commentActionsMarginTop: e.marginSM,
    commentContentDetailPMarginBottom: "inherit"
  });
  return [m7e(t)];
}), g7e = () => ({
  actions: Array,
  /** The element to display as the comment author. */
  author: de.any,
  /** The element to display as the comment avatar - generally an antd Avatar */
  avatar: de.any,
  /** The main content of the comment */
  content: de.any,
  /** Comment prefix defaults to '.ant-comment' */
  prefixCls: String,
  /** A datetime element containing the time to be displayed */
  datetime: de.any
}), b7e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AComment",
  inheritAttrs: !1,
  props: g7e(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("comment", e), [a, i] = h7e(l), s = (u, d) => $("div", {
      class: `${u}-nested`
    }, [d]), c = (u) => !u || !u.length ? null : u.map((f, p) => $("li", {
      key: `action-${p}`
    }, [f]));
    return () => {
      var u, d, f, p, m, v, h, g, y, b, C;
      const w = l.value, x = (u = e.actions) !== null && u !== void 0 ? u : (d = n.actions) === null || d === void 0 ? void 0 : d.call(n), E = (f = e.author) !== null && f !== void 0 ? f : (p = n.author) === null || p === void 0 ? void 0 : p.call(n), I = (m = e.avatar) !== null && m !== void 0 ? m : (v = n.avatar) === null || v === void 0 ? void 0 : v.call(n), T = (h = e.content) !== null && h !== void 0 ? h : (g = n.content) === null || g === void 0 ? void 0 : g.call(n), P = (y = e.datetime) !== null && y !== void 0 ? y : (b = n.datetime) === null || b === void 0 ? void 0 : b.call(n), k = $("div", {
        class: `${w}-avatar`
      }, [typeof I == "string" ? $("img", {
        src: I,
        alt: "comment-avatar"
      }, null) : I]), N = x ? $("ul", {
        class: `${w}-actions`
      }, [c(Array.isArray(x) ? x : [x])]) : null, R = $("div", {
        class: `${w}-content-author`
      }, [E && $("span", {
        class: `${w}-content-author-name`
      }, [E]), P && $("span", {
        class: `${w}-content-author-time`
      }, [P])]), z = $("div", {
        class: `${w}-content`
      }, [R, $("div", {
        class: `${w}-content-detail`
      }, [T]), N]), D = $("div", {
        class: `${w}-inner`
      }, [k, z]), F = Fn((C = n.default) === null || C === void 0 ? void 0 : C.call(n));
      return a($("div", Q(Q({}, o), {}, {
        class: [w, {
          [`${w}-rtl`]: r.value === "rtl"
        }, o.class, i.value]
      }), [D, F && F.length ? s(w, F) : null]));
    };
  }
}), y7e = po(b7e);
let Bb = _({}, rr.Modal);
function S7e(e) {
  e ? Bb = _(_({}, Bb), e) : Bb = _({}, rr.Modal);
}
function C7e() {
  return Bb;
}
const G2 = "internalMark", Fb = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ALocaleProvider",
  props: {
    locale: {
      type: Object
    },
    ANT_MARK__: String
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    Hn(e.ANT_MARK__ === G2, "LocaleProvider", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead");
    const o = /* @__PURE__ */ kt({
      antLocale: _(_({}, e.locale), {
        exist: !0
      }),
      ANT_MARK__: G2
    });
    return at("localeData", o), pe(() => e.locale, (l) => {
      S7e(l && l.Modal), o.antLocale = _(_({}, l), {
        exist: !0
      });
    }, {
      immediate: !0
    }), () => {
      var l;
      return (l = n.default) === null || l === void 0 ? void 0 : l.call(n);
    };
  }
});
Fb.install = function(e) {
  return e.component(Fb.name, Fb), e;
};
const zK = po(Fb), HK = /* @__PURE__ */ le({
  name: "Notice",
  inheritAttrs: !1,
  props: ["prefixCls", "duration", "updateMark", "noticeKey", "closeIcon", "closable", "props", "onClick", "onClose", "holder", "visible"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t, l, r = !1;
    const a = O(() => e.duration === void 0 ? 4.5 : e.duration), i = () => {
      a.value && !r && (l = setTimeout(() => {
        c();
      }, a.value * 1e3));
    }, s = () => {
      l && (clearTimeout(l), l = null);
    }, c = (d) => {
      d && d.stopPropagation(), s();
      const {
        onClose: f,
        noticeKey: p
      } = e;
      f && f(p);
    }, u = () => {
      s(), i();
    };
    return nt(() => {
      i();
    }), Uo(() => {
      r = !0, s();
    }), pe([a, () => e.updateMark, () => e.visible], (d, f) => {
      let [p, m, v] = d, [h, g, y] = f;
      (p !== h || m !== g || v !== y && y) && u();
    }, {
      flush: "post"
    }), () => {
      var d, f;
      const {
        prefixCls: p,
        closable: m,
        closeIcon: v = (d = o.closeIcon) === null || d === void 0 ? void 0 : d.call(o),
        onClick: h,
        holder: g
      } = e, {
        class: y,
        style: b
      } = n, C = `${p}-notice`, w = Object.keys(n).reduce((E, I) => ((I.startsWith("data-") || I.startsWith("aria-") || I === "role") && (E[I] = n[I]), E), {}), x = $("div", Q({
        class: ke(C, y, {
          [`${C}-closable`]: m
        }),
        style: b,
        onMouseenter: s,
        onMouseleave: i,
        onClick: h
      }, w), [$("div", {
        class: `${C}-content`
      }, [(f = o.default) === null || f === void 0 ? void 0 : f.call(o)]), m ? $("a", {
        tabindex: 0,
        onClick: c,
        class: `${C}-close`
      }, [v || $("span", {
        class: `${C}-close-x`
      }, null)]) : null]);
      return g ? $(a1, {
        to: g
      }, {
        default: () => x
      }) : x;
    };
  }
});
var w7e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
let nA = 0;
const $7e = Date.now();
function oA() {
  const e = nA;
  return nA += 1, `rcNotification_${$7e}_${e}`;
}
const Dy = /* @__PURE__ */ le({
  name: "Notification",
  inheritAttrs: !1,
  props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId"],
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: l
    } = t;
    const r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ H([]), i = O(() => {
      const {
        prefixCls: u,
        animation: d = "fade"
      } = e;
      let f = e.transitionName;
      return !f && d && (f = `${u}-${d}`), vS(f);
    }), s = (u, d) => {
      const f = u.key || oA(), p = _(_({}, u), {
        key: f
      }), {
        maxCount: m
      } = e, v = a.value.map((g) => g.notice.key).indexOf(f), h = a.value.concat();
      v !== -1 ? h.splice(v, 1, {
        notice: p,
        holderCallback: d
      }) : (m && a.value.length >= m && (p.key = h[0].notice.key, p.updateMark = oA(), p.userPassKey = f, h.shift()), h.push({
        notice: p,
        holderCallback: d
      })), a.value = h;
    }, c = (u) => {
      a.value = (/* @__PURE__ */ Wt(a.value)).filter((d) => {
        let {
          notice: {
            key: f,
            userPassKey: p
          }
        } = d;
        return (p || f) !== u;
      });
    };
    return o({
      add: s,
      remove: c,
      notices: a
    }), () => {
      var u;
      const {
        prefixCls: d,
        closeIcon: f = (u = l.closeIcon) === null || u === void 0 ? void 0 : u.call(l, {
          prefixCls: d
        })
      } = e, p = a.value.map((v, h) => {
        let {
          notice: g,
          holderCallback: y
        } = v;
        const b = h === a.value.length - 1 ? g.updateMark : void 0, {
          key: C,
          userPassKey: w
        } = g, {
          content: x
        } = g, E = _(_(_({
          prefixCls: d,
          closeIcon: typeof f == "function" ? f({
            prefixCls: d
          }) : f
        }, g), g.props), {
          key: C,
          noticeKey: w || C,
          updateMark: b,
          onClose: (I) => {
            var T;
            c(I), (T = g.onClose) === null || T === void 0 || T.call(g);
          },
          onClick: g.onClick
        });
        return y ? $("div", {
          key: C,
          class: `${d}-hook-holder`,
          ref: (I) => {
            typeof C != "undefined" && (I ? (r.set(C, I), y(I, E)) : r.delete(C));
          }
        }, null) : $(HK, Q(Q({}, E), {}, {
          class: ke(E.class, e.hashId)
        }), {
          default: () => [typeof x == "function" ? x({
            prefixCls: d
          }) : x]
        });
      }), m = {
        [d]: 1,
        [n.class]: !!n.class,
        [e.hashId]: !0
      };
      return $("div", {
        class: m,
        style: n.style || {
          top: "65px",
          left: "50%"
        }
      }, [$(mp, Q({
        tag: "div"
      }, i.value), {
        default: () => [p]
      })]);
    };
  }
});
Dy.newInstance = function(t, n) {
  const o = t || {}, {
    name: l = "notification",
    getContainer: r,
    appContext: a,
    prefixCls: i,
    rootPrefixCls: s,
    transitionName: c,
    hasTransitionName: u,
    useStyle: d
  } = o, f = w7e(o, ["name", "getContainer", "appContext", "prefixCls", "rootPrefixCls", "transitionName", "hasTransitionName", "useStyle"]), p = document.createElement("div");
  r ? r().appendChild(p) : document.body.appendChild(p);
  const v = $(/* @__PURE__ */ le({
    compatConfig: {
      MODE: 3
    },
    name: "NotificationWrapper",
    setup(h, g) {
      let {
        attrs: y
      } = g;
      const b = /* @__PURE__ */ Ce(), C = O(() => gl.getPrefixCls(l, i)), [, w] = d(C);
      return nt(() => {
        n({
          notice(x) {
            var E;
            (E = b.value) === null || E === void 0 || E.add(x);
          },
          removeNotice(x) {
            var E;
            (E = b.value) === null || E === void 0 || E.remove(x);
          },
          destroy() {
            Bl(null, p), p.parentNode && p.parentNode.removeChild(p);
          },
          component: b
        });
      }), () => {
        const x = gl, E = x.getRootPrefixCls(s, C.value), I = u ? c : `${C.value}-${c}`;
        return $(Mu, Q(Q({}, x), {}, {
          prefixCls: E
        }), {
          default: () => [$(Dy, Q(Q({
            ref: b
          }, y), {}, {
            prefixCls: C.value,
            transitionName: I,
            hashId: w.value
          }), null)]
        });
      };
    }
  }), f);
  v.appContext = a || v.appContext, Bl(v, p);
};
let lA = 0;
const x7e = Date.now();
function rA() {
  const e = lA;
  return lA += 1, `rcNotification_${x7e}_${e}`;
}
const E7e = /* @__PURE__ */ le({
  name: "HookNotification",
  inheritAttrs: !1,
  props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId", "remove", "notices", "getStyles", "getClassName", "onAllRemoved", "getContainer"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const l = /* @__PURE__ */ new Map(), r = O(() => e.notices), a = O(() => {
      let u = e.transitionName;
      if (!u && e.animation)
        switch (typeof e.animation) {
          case "string":
            u = e.animation;
            break;
          case "function":
            u = e.animation().name;
            break;
          case "object":
            u = e.animation.name;
            break;
          default:
            u = `${e.prefixCls}-fade`;
            break;
        }
      return vS(u);
    }), i = (u) => e.remove(u), s = /* @__PURE__ */ H({});
    pe(r, () => {
      const u = {};
      Object.keys(s.value).forEach((d) => {
        u[d] = [];
      }), e.notices.forEach((d) => {
        const {
          placement: f = "topRight"
        } = d.notice;
        f && (u[f] = u[f] || [], u[f].push(d));
      }), s.value = u;
    });
    const c = O(() => Object.keys(s.value));
    return () => {
      var u;
      const {
        prefixCls: d,
        closeIcon: f = (u = o.closeIcon) === null || u === void 0 ? void 0 : u.call(o, {
          prefixCls: d
        })
      } = e, p = c.value.map((m) => {
        var v, h;
        const g = s.value[m], y = (v = e.getClassName) === null || v === void 0 ? void 0 : v.call(e, m), b = (h = e.getStyles) === null || h === void 0 ? void 0 : h.call(e, m), C = g.map((E, I) => {
          let {
            notice: T,
            holderCallback: P
          } = E;
          const k = I === r.value.length - 1 ? T.updateMark : void 0, {
            key: N,
            userPassKey: R
          } = T, {
            content: z
          } = T, D = _(_(_({
            prefixCls: d,
            closeIcon: typeof f == "function" ? f({
              prefixCls: d
            }) : f
          }, T), T.props), {
            key: N,
            noticeKey: R || N,
            updateMark: k,
            onClose: (F) => {
              var M;
              i(F), (M = T.onClose) === null || M === void 0 || M.call(T);
            },
            onClick: T.onClick
          });
          return P ? $("div", {
            key: N,
            class: `${d}-hook-holder`,
            ref: (F) => {
              typeof N != "undefined" && (F ? (l.set(N, F), P(F, D)) : l.delete(N));
            }
          }, null) : $(HK, Q(Q({}, D), {}, {
            class: ke(D.class, e.hashId)
          }), {
            default: () => [typeof z == "function" ? z({
              prefixCls: d
            }) : z]
          });
        }), w = {
          [d]: 1,
          [`${d}-${m}`]: 1,
          [n.class]: !!n.class,
          [e.hashId]: !0,
          [y]: !!y
        };
        function x() {
          var E;
          g.length > 0 || (Reflect.deleteProperty(s.value, m), (E = e.onAllRemoved) === null || E === void 0 || E.call(e));
        }
        return $("div", {
          key: m,
          class: w,
          style: n.style || b || {
            top: "65px",
            left: "50%"
          }
        }, [$(mp, Q(Q({
          tag: "div"
        }, a.value), {}, {
          onAfterLeave: x
        }), {
          default: () => [C]
        })]);
      });
      return $(gj, {
        getContainer: e.getContainer
      }, {
        default: () => [p]
      });
    };
  }
});
var O7e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const _7e = () => document.body;
let aA = 0;
function I7e() {
  const e = {};
  for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++)
    n[o] = arguments[o];
  return n.forEach((l) => {
    l && Object.keys(l).forEach((r) => {
      const a = l[r];
      a !== void 0 && (e[r] = a);
    });
  }), e;
}
function jK() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    getContainer: t = _7e,
    motion: n,
    prefixCls: o,
    maxCount: l,
    getClassName: r,
    getStyles: a,
    onAllRemoved: i
  } = e, s = O7e(e, ["getContainer", "motion", "prefixCls", "maxCount", "getClassName", "getStyles", "onAllRemoved"]), c = /* @__PURE__ */ Ce([]), u = /* @__PURE__ */ Ce(), d = (g, y) => {
    const b = g.key || rA(), C = _(_({}, g), {
      key: b
    }), w = c.value.map((E) => E.notice.key).indexOf(b), x = c.value.concat();
    w !== -1 ? x.splice(w, 1, {
      notice: C,
      holderCallback: y
    }) : (l && c.value.length >= l && (C.key = x[0].notice.key, C.updateMark = rA(), C.userPassKey = b, x.shift()), x.push({
      notice: C,
      holderCallback: y
    })), c.value = x;
  }, f = (g) => {
    c.value = c.value.filter((y) => {
      let {
        notice: {
          key: b,
          userPassKey: C
        }
      } = y;
      return (C || b) !== g;
    });
  }, p = () => {
    c.value = [];
  }, m = () => $(E7e, {
    ref: u,
    prefixCls: o,
    maxCount: l,
    notices: c.value,
    remove: f,
    getClassName: r,
    getStyles: a,
    animation: n,
    hashId: e.hashId,
    onAllRemoved: i,
    getContainer: t
  }, null), v = /* @__PURE__ */ Ce([]), h = {
    open: (g) => {
      const y = I7e(s, g);
      (y.key === null || y.key === void 0) && (y.key = `vc-notification-${aA}`, aA += 1), v.value = [...v.value, {
        type: "open",
        config: y
      }];
    },
    close: (g) => {
      v.value = [...v.value, {
        type: "close",
        key: g
      }];
    },
    destroy: () => {
      v.value = [...v.value, {
        type: "destroy"
      }];
    }
  };
  return pe(v, () => {
    v.value.length && (v.value.forEach((g) => {
      switch (g.type) {
        case "open":
          d(g.config);
          break;
        case "close":
          f(g.key);
          break;
        case "destroy":
          p();
          break;
      }
    }), v.value = []);
  }), [h, m];
}
const T7e = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    boxShadowSecondary: o,
    colorBgElevated: l,
    colorSuccess: r,
    colorError: a,
    colorWarning: i,
    colorInfo: s,
    fontSizeLG: c,
    motionEaseInOutCirc: u,
    motionDurationSlow: d,
    marginXS: f,
    paddingXS: p,
    borderRadiusLG: m,
    zIndexPopup: v,
    // Custom token
    messageNoticeContentPadding: h
  } = e, g = new mn("MessageMoveIn", {
    "0%": {
      padding: 0,
      transform: "translateY(-100%)",
      opacity: 0
    },
    "100%": {
      padding: p,
      transform: "translateY(0)",
      opacity: 1
    }
  }), y = new mn("MessageMoveOut", {
    "0%": {
      maxHeight: e.height,
      padding: p,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      padding: 0,
      opacity: 0
    }
  });
  return [
    // ============================ Holder ============================
    {
      [t]: _(_({}, nn(e)), {
        position: "fixed",
        top: f,
        left: "50%",
        transform: "translateX(-50%)",
        width: "100%",
        pointerEvents: "none",
        zIndex: v,
        [`${t}-move-up`]: {
          animationFillMode: "forwards"
        },
        [`
        ${t}-move-up-appear,
        ${t}-move-up-enter
      `]: {
          animationName: g,
          animationDuration: d,
          animationPlayState: "paused",
          animationTimingFunction: u
        },
        [`
        ${t}-move-up-appear${t}-move-up-appear-active,
        ${t}-move-up-enter${t}-move-up-enter-active
      `]: {
          animationPlayState: "running"
        },
        [`${t}-move-up-leave`]: {
          animationName: y,
          animationDuration: d,
          animationPlayState: "paused",
          animationTimingFunction: u
        },
        [`${t}-move-up-leave${t}-move-up-leave-active`]: {
          animationPlayState: "running"
        },
        "&-rtl": {
          direction: "rtl",
          span: {
            direction: "rtl"
          }
        }
      })
    },
    // ============================ Notice ============================
    {
      [`${t}-notice`]: {
        padding: p,
        textAlign: "center",
        [n]: {
          verticalAlign: "text-bottom",
          marginInlineEnd: f,
          fontSize: c
        },
        [`${t}-notice-content`]: {
          display: "inline-block",
          padding: h,
          background: l,
          borderRadius: m,
          boxShadow: o,
          pointerEvents: "all"
        },
        [`${t}-success ${n}`]: {
          color: r
        },
        [`${t}-error ${n}`]: {
          color: a
        },
        [`${t}-warning ${n}`]: {
          color: i
        },
        [`
        ${t}-info ${n},
        ${t}-loading ${n}`]: {
          color: s
        }
      }
    },
    // ============================= Pure =============================
    {
      [`${t}-notice-pure-panel`]: {
        padding: 0,
        textAlign: "start"
      }
    }
  ];
}, WK = Zt("Message", (e) => {
  const t = Vt(e, {
    messageNoticeContentPadding: `${(e.controlHeightLG - e.fontSize * e.lineHeight) / 2}px ${e.paddingSM}px`
  });
  return [T7e(t)];
}, (e) => ({
  height: 150,
  zIndexPopup: e.zIndexPopupBase + 10
})), P7e = {
  info: $(Dc, null, null),
  success: $(Za, null, null),
  error: $(jl, null, null),
  warning: $(Qa, null, null),
  loading: $(ar, null, null)
}, k7e = /* @__PURE__ */ le({
  name: "PureContent",
  inheritAttrs: !1,
  props: ["prefixCls", "type", "icon"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      var o;
      return $("div", {
        class: ke(`${e.prefixCls}-custom-content`, `${e.prefixCls}-${e.type}`)
      }, [e.icon || P7e[e.type], $("span", null, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)])]);
    };
  }
});
var N7e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const M7e = 8, A7e = 3, R7e = /* @__PURE__ */ le({
  name: "Holder",
  inheritAttrs: !1,
  props: ["top", "prefixCls", "getContainer", "maxCount", "duration", "rtl", "transitionName", "onAllRemoved", "animation", "staticGetContainer"],
  setup(e, t) {
    let {
      expose: n
    } = t;
    var o, l;
    const {
      getPrefixCls: r,
      getPopupContainer: a
    } = bt("message", e), i = O(() => r("message", e.prefixCls)), [, s] = WK(i), c = () => {
      var v;
      const h = (v = e.top) !== null && v !== void 0 ? v : M7e;
      return {
        left: "50%",
        transform: "translateX(-50%)",
        top: typeof h == "number" ? `${h}px` : h
      };
    }, u = () => ke(s.value, e.rtl ? `${i.value}-rtl` : ""), d = () => {
      var v;
      return bI({
        prefixCls: i.value,
        animation: (v = e.animation) !== null && v !== void 0 ? v : "move-up",
        transitionName: e.transitionName
      });
    }, f = $("span", {
      class: `${i.value}-close-x`
    }, [$(Hl, {
      class: `${i.value}-close-icon`
    }, null)]), [p, m] = jK({
      //@ts-ignore
      getStyles: c,
      prefixCls: i.value,
      getClassName: u,
      motion: d,
      closable: !1,
      closeIcon: f,
      duration: (o = e.duration) !== null && o !== void 0 ? o : A7e,
      getContainer: (l = e.staticGetContainer) !== null && l !== void 0 ? l : a.value,
      maxCount: e.maxCount,
      onAllRemoved: e.onAllRemoved
    });
    return n(_(_({}, p), {
      prefixCls: i,
      hashId: s
    })), m;
  }
});
let iA = 0;
function D7e(e) {
  const t = /* @__PURE__ */ Ce(null), n = Symbol("messageHolderKey"), o = (s) => {
    var c;
    (c = t.value) === null || c === void 0 || c.close(s);
  }, l = (s) => {
    if (!t.value) {
      const w = () => {
      };
      return w.then = () => {
      }, w;
    }
    const {
      open: c,
      prefixCls: u,
      hashId: d
    } = t.value, f = `${u}-notice`, {
      content: p,
      icon: m,
      type: v,
      key: h,
      class: g,
      onClose: y
    } = s, b = N7e(s, ["content", "icon", "type", "key", "class", "onClose"]);
    let C = h;
    return C == null && (iA += 1, C = `antd-message-${iA}`), cPe((w) => (c(_(_({}, b), {
      key: C,
      content: () => $(k7e, {
        prefixCls: u,
        type: v,
        icon: typeof m == "function" ? m() : m
      }, {
        default: () => [typeof p == "function" ? p() : p]
      }),
      placement: "top",
      // @ts-ignore
      class: ke(v && `${f}-${v}`, d, g),
      onClose: () => {
        y == null || y(), w();
      }
    })), () => {
      o(C);
    }));
  }, a = {
    open: l,
    destroy: (s) => {
      var c;
      s !== void 0 ? o(s) : (c = t.value) === null || c === void 0 || c.destroy();
    }
  };
  return ["info", "success", "warning", "error", "loading"].forEach((s) => {
    const c = (u, d, f) => {
      let p;
      u && typeof u == "object" && "content" in u ? p = u : p = {
        content: u
      };
      let m, v;
      typeof d == "function" ? v = d : (m = d, v = f);
      const h = _(_({
        onClose: v,
        duration: m
      }, p), {
        type: s
      });
      return l(h);
    };
    a[s] = c;
  }), [a, () => $(R7e, Q(Q({
    key: n
  }, e), {}, {
    ref: t
  }), null)];
}
function KK(e) {
  return D7e(e);
}
let UK = 3, GK, er, L7e = 1, YK = "", XK = "move-up", qK = !1, JK = () => document.body, ZK, QK = !1;
function B7e() {
  return L7e++;
}
function F7e(e) {
  e.top !== void 0 && (GK = e.top, er = null), e.duration !== void 0 && (UK = e.duration), e.prefixCls !== void 0 && (YK = e.prefixCls), e.getContainer !== void 0 && (JK = e.getContainer, er = null), e.transitionName !== void 0 && (XK = e.transitionName, er = null, qK = !0), e.maxCount !== void 0 && (ZK = e.maxCount, er = null), e.rtl !== void 0 && (QK = e.rtl);
}
function V7e(e, t) {
  if (er) {
    t(er);
    return;
  }
  Dy.newInstance({
    appContext: e.appContext,
    prefixCls: e.prefixCls || YK,
    rootPrefixCls: e.rootPrefixCls,
    transitionName: XK,
    hasTransitionName: qK,
    style: {
      top: GK
    },
    getContainer: JK || e.getPopupContainer,
    maxCount: ZK,
    name: "message",
    useStyle: WK
  }, (n) => {
    if (er) {
      t(er);
      return;
    }
    er = n, t(n);
  });
}
const eU = {
  info: Dc,
  success: Za,
  error: jl,
  warning: Qa,
  loading: ar
}, z7e = Object.keys(eU);
function H7e(e) {
  const t = e.duration !== void 0 ? e.duration : UK, n = e.key || B7e(), o = new Promise((r) => {
    const a = () => (typeof e.onClose == "function" && e.onClose(), r(!0));
    V7e(e, (i) => {
      i.notice({
        key: n,
        duration: t,
        style: e.style || {},
        class: e.class,
        content: (s) => {
          let {
            prefixCls: c
          } = s;
          const u = eU[e.type], d = u ? $(u, null, null) : "", f = ke(`${c}-custom-content`, {
            [`${c}-${e.type}`]: e.type,
            [`${c}-rtl`]: QK === !0
          });
          return $("div", {
            class: f
          }, [typeof e.icon == "function" ? e.icon() : e.icon || d, $("span", null, [typeof e.content == "function" ? e.content() : e.content])]);
        },
        onClose: a,
        onClick: e.onClick
      });
    });
  }), l = () => {
    er && er.removeNotice(n);
  };
  return l.then = (r, a) => o.then(r, a), l.promise = o, l;
}
function j7e(e) {
  return Object.prototype.toString.call(e) === "[object Object]" && !!e.content;
}
const Qu = {
  open: H7e,
  config: F7e,
  destroy(e) {
    if (er)
      if (e) {
        const {
          removeNotice: t
        } = er;
        t(e);
      } else {
        const {
          destroy: t
        } = er;
        t(), er = null;
      }
  }
};
function W7e(e, t) {
  e[t] = (n, o, l) => j7e(n) ? e.open(_(_({}, n), {
    type: t
  })) : (typeof o == "function" && (l = o, o = void 0), e.open({
    content: n,
    duration: o,
    type: t,
    onClose: l
  }));
}
z7e.forEach((e) => W7e(Qu, e));
Qu.warn = Qu.warning;
Qu.useMessage = KK;
const K7e = (e) => {
  const {
    componentCls: t,
    width: n,
    notificationMarginEdge: o
  } = e, l = new mn("antNotificationTopFadeIn", {
    "0%": {
      marginTop: "-100%",
      opacity: 0
    },
    "100%": {
      marginTop: 0,
      opacity: 1
    }
  }), r = new mn("antNotificationBottomFadeIn", {
    "0%": {
      marginBottom: "-100%",
      opacity: 0
    },
    "100%": {
      marginBottom: 0,
      opacity: 1
    }
  }), a = new mn("antNotificationLeftFadeIn", {
    "0%": {
      right: {
        _skip_check_: !0,
        value: n
      },
      opacity: 0
    },
    "100%": {
      right: {
        _skip_check_: !0,
        value: 0
      },
      opacity: 1
    }
  });
  return {
    [`&${t}-top, &${t}-bottom`]: {
      marginInline: 0
    },
    [`&${t}-top`]: {
      [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
        animationName: l
      }
    },
    [`&${t}-bottom`]: {
      [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
        animationName: r
      }
    },
    [`&${t}-topLeft, &${t}-bottomLeft`]: {
      marginInlineEnd: 0,
      marginInlineStart: o,
      [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
        animationName: a
      }
    }
  };
}, U7e = (e) => {
  const {
    iconCls: t,
    componentCls: n,
    // .ant-notification
    boxShadowSecondary: o,
    fontSizeLG: l,
    notificationMarginBottom: r,
    borderRadiusLG: a,
    colorSuccess: i,
    colorInfo: s,
    colorWarning: c,
    colorError: u,
    colorTextHeading: d,
    notificationBg: f,
    notificationPadding: p,
    notificationMarginEdge: m,
    motionDurationMid: v,
    motionEaseInOut: h,
    fontSize: g,
    lineHeight: y,
    width: b,
    notificationIconSize: C
  } = e, w = `${n}-notice`, x = new mn("antNotificationFadeIn", {
    "0%": {
      left: {
        _skip_check_: !0,
        value: b
      },
      opacity: 0
    },
    "100%": {
      left: {
        _skip_check_: !0,
        value: 0
      },
      opacity: 1
    }
  }), E = new mn("antNotificationFadeOut", {
    "0%": {
      maxHeight: e.animationMaxHeight,
      marginBottom: r,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      marginBottom: 0,
      paddingTop: 0,
      paddingBottom: 0,
      opacity: 0
    }
  });
  return [
    // ============================ Holder ============================
    {
      [n]: _(_(_(_({}, nn(e)), {
        position: "fixed",
        zIndex: e.zIndexPopup,
        marginInlineEnd: m,
        [`${n}-hook-holder`]: {
          position: "relative"
        },
        [`&${n}-top, &${n}-bottom`]: {
          [`${n}-notice`]: {
            marginInline: "auto auto"
          }
        },
        [`&${n}-topLeft, &${n}-bottomLeft`]: {
          [`${n}-notice`]: {
            marginInlineEnd: "auto",
            marginInlineStart: 0
          }
        },
        //  animation
        [`${n}-fade-enter, ${n}-fade-appear`]: {
          animationDuration: e.motionDurationMid,
          animationTimingFunction: h,
          animationFillMode: "both",
          opacity: 0,
          animationPlayState: "paused"
        },
        [`${n}-fade-leave`]: {
          animationTimingFunction: h,
          animationFillMode: "both",
          animationDuration: v,
          animationPlayState: "paused"
        },
        [`${n}-fade-enter${n}-fade-enter-active, ${n}-fade-appear${n}-fade-appear-active`]: {
          animationName: x,
          animationPlayState: "running"
        },
        [`${n}-fade-leave${n}-fade-leave-active`]: {
          animationName: E,
          animationPlayState: "running"
        }
      }), K7e(e)), {
        // RTL
        "&-rtl": {
          direction: "rtl",
          [`${n}-notice-btn`]: {
            float: "left"
          }
        }
      })
    },
    // ============================ Notice ============================
    {
      [w]: {
        position: "relative",
        width: b,
        maxWidth: `calc(100vw - ${m * 2}px)`,
        marginBottom: r,
        marginInlineStart: "auto",
        padding: p,
        overflow: "hidden",
        lineHeight: y,
        wordWrap: "break-word",
        background: f,
        borderRadius: a,
        boxShadow: o,
        [`${n}-close-icon`]: {
          fontSize: g,
          cursor: "pointer"
        },
        [`${w}-message`]: {
          marginBottom: e.marginXS,
          color: d,
          fontSize: l,
          lineHeight: e.lineHeightLG
        },
        [`${w}-description`]: {
          fontSize: g
        },
        [`&${w}-closable ${w}-message`]: {
          paddingInlineEnd: e.paddingLG
        },
        [`${w}-with-icon ${w}-message`]: {
          marginBottom: e.marginXS,
          marginInlineStart: e.marginSM + C,
          fontSize: l
        },
        [`${w}-with-icon ${w}-description`]: {
          marginInlineStart: e.marginSM + C,
          fontSize: g
        },
        // Icon & color style in different selector level
        // https://github.com/ant-design/ant-design/issues/16503
        // https://github.com/ant-design/ant-design/issues/15512
        [`${w}-icon`]: {
          position: "absolute",
          fontSize: C,
          lineHeight: 0,
          // icon-font
          [`&-success${t}`]: {
            color: i
          },
          [`&-info${t}`]: {
            color: s
          },
          [`&-warning${t}`]: {
            color: c
          },
          [`&-error${t}`]: {
            color: u
          }
        },
        [`${w}-close`]: {
          position: "absolute",
          top: e.notificationPaddingVertical,
          insetInlineEnd: e.notificationPaddingHorizontal,
          color: e.colorIcon,
          outline: "none",
          width: e.notificationCloseButtonSize,
          height: e.notificationCloseButtonSize,
          borderRadius: e.borderRadiusSM,
          transition: `background-color ${e.motionDurationMid}, color ${e.motionDurationMid}`,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          "&:hover": {
            color: e.colorIconHover,
            backgroundColor: e.wireframe ? "transparent" : e.colorFillContent
          }
        },
        [`${w}-btn`]: {
          float: "right",
          marginTop: e.marginSM
        }
      }
    },
    // ============================= Pure =============================
    {
      [`${w}-pure-panel`]: {
        margin: 0
      }
    }
  ];
}, tU = Zt("Notification", (e) => {
  const t = e.paddingMD, n = e.paddingLG, o = Vt(e, {
    // default.less variables
    notificationBg: e.colorBgElevated,
    notificationPaddingVertical: t,
    notificationPaddingHorizontal: n,
    // index.less variables
    notificationPadding: `${e.paddingMD}px ${e.paddingContentHorizontalLG}px`,
    notificationMarginBottom: e.margin,
    notificationMarginEdge: e.marginLG,
    animationMaxHeight: 150,
    notificationIconSize: e.fontSizeLG * e.lineHeightLG,
    notificationCloseButtonSize: e.controlHeightLG * 0.55
  });
  return [U7e(o)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 50,
  width: 384
}));
function G7e(e, t) {
  return t || $("span", {
    class: `${e}-close-x`
  }, [$(Hl, {
    class: `${e}-close-icon`
  }, null)]);
}
$(Dc, null, null), $(Za, null, null), $(jl, null, null), $(Qa, null, null), $(ar, null, null);
const Y7e = {
  success: Za,
  info: Dc,
  error: jl,
  warning: Qa
};
function X7e(e) {
  let {
    prefixCls: t,
    icon: n,
    type: o,
    message: l,
    description: r,
    btn: a
  } = e, i = null;
  if (n)
    i = $("span", {
      class: `${t}-icon`
    }, [Jd(n)]);
  else if (o) {
    const s = Y7e[o];
    i = $(s, {
      class: `${t}-icon ${t}-icon-${o}`
    }, null);
  }
  return $("div", {
    class: ke({
      [`${t}-with-icon`]: i
    }),
    role: "alert"
  }, [i, $("div", {
    class: `${t}-message`
  }, [l]), $("div", {
    class: `${t}-description`
  }, [r]), a && $("div", {
    class: `${t}-btn`
  }, [a])]);
}
function nU(e, t, n) {
  let o;
  switch (t = typeof t == "number" ? `${t}px` : t, n = typeof n == "number" ? `${n}px` : n, e) {
    case "top":
      o = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: t,
        bottom: "auto"
      };
      break;
    case "topLeft":
      o = {
        left: 0,
        top: t,
        bottom: "auto"
      };
      break;
    case "topRight":
      o = {
        right: 0,
        top: t,
        bottom: "auto"
      };
      break;
    case "bottom":
      o = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: "auto",
        bottom: n
      };
      break;
    case "bottomLeft":
      o = {
        left: 0,
        top: "auto",
        bottom: n
      };
      break;
    default:
      o = {
        right: 0,
        top: "auto",
        bottom: n
      };
      break;
  }
  return o;
}
function q7e(e) {
  return {
    name: `${e}-fade`
  };
}
var J7e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const sA = 24, Z7e = 4.5, Q7e = /* @__PURE__ */ le({
  name: "Holder",
  inheritAttrs: !1,
  props: ["prefixCls", "class", "type", "icon", "content", "onAllRemoved"],
  setup(e, t) {
    let {
      expose: n
    } = t;
    const {
      getPrefixCls: o,
      getPopupContainer: l
    } = bt("notification", e), r = O(() => e.prefixCls || o("notification")), a = (f) => {
      var p, m;
      return nU(f, (p = e.top) !== null && p !== void 0 ? p : sA, (m = e.bottom) !== null && m !== void 0 ? m : sA);
    }, [, i] = tU(r), s = () => ke(i.value, {
      [`${r.value}-rtl`]: e.rtl
    }), c = () => q7e(r.value), [u, d] = jK({
      prefixCls: r.value,
      getStyles: a,
      getClassName: s,
      motion: c,
      closable: !0,
      closeIcon: G7e(r.value),
      duration: Z7e,
      getContainer: () => {
        var f, p;
        return ((f = e.getPopupContainer) === null || f === void 0 ? void 0 : f.call(e)) || ((p = l.value) === null || p === void 0 ? void 0 : p.call(l)) || document.body;
      },
      maxCount: e.maxCount,
      hashId: i.value,
      onAllRemoved: e.onAllRemoved
    });
    return n(_(_({}, u), {
      prefixCls: r.value,
      hashId: i
    })), d;
  }
});
function eFe(e) {
  const t = /* @__PURE__ */ Ce(null), n = Symbol("notificationHolderKey"), o = (i) => {
    if (!t.value)
      return;
    const {
      open: s,
      prefixCls: c,
      hashId: u
    } = t.value, d = `${c}-notice`, {
      message: f,
      description: p,
      icon: m,
      type: v,
      btn: h,
      class: g
    } = i, y = J7e(i, ["message", "description", "icon", "type", "btn", "class"]);
    return s(_(_({
      placement: "topRight"
    }, y), {
      content: () => $(X7e, {
        prefixCls: d,
        icon: typeof m == "function" ? m() : m,
        type: v,
        message: typeof f == "function" ? f() : f,
        description: typeof p == "function" ? p() : p,
        btn: typeof h == "function" ? h() : h
      }, null),
      // @ts-ignore
      class: ke(v && `${d}-${v}`, u, g)
    }));
  }, r = {
    open: o,
    destroy: (i) => {
      var s, c;
      i !== void 0 ? (s = t.value) === null || s === void 0 || s.close(i) : (c = t.value) === null || c === void 0 || c.destroy();
    }
  };
  return ["success", "info", "warning", "error"].forEach((i) => {
    r[i] = (s) => o(_(_({}, s), {
      type: i
    }));
  }), [r, () => $(Q7e, Q(Q({
    key: n
  }, e), {}, {
    ref: t
  }), null)];
}
function oU(e) {
  return eFe(e);
}
const su = {};
let lU = 4.5, rU = "24px", aU = "24px", Y2 = "", iU = "topRight", sU = () => document.body, cU = null, X2 = !1, uU;
function tFe(e) {
  const {
    duration: t,
    placement: n,
    bottom: o,
    top: l,
    getContainer: r,
    closeIcon: a,
    prefixCls: i
  } = e;
  i !== void 0 && (Y2 = i), t !== void 0 && (lU = t), n !== void 0 && (iU = n), o !== void 0 && (aU = typeof o == "number" ? `${o}px` : o), l !== void 0 && (rU = typeof l == "number" ? `${l}px` : l), r !== void 0 && (sU = r), a !== void 0 && (cU = a), e.rtl !== void 0 && (X2 = e.rtl), e.maxCount !== void 0 && (uU = e.maxCount);
}
function nFe(e, t) {
  let {
    prefixCls: n,
    placement: o = iU,
    getContainer: l = sU,
    top: r,
    bottom: a,
    closeIcon: i = cU,
    appContext: s
  } = e;
  const {
    getPrefixCls: c
  } = vFe(), u = c("notification", n || Y2), d = `${u}-${o}-${X2}`, f = su[d];
  if (f) {
    Promise.resolve(f).then((m) => {
      t(m);
    });
    return;
  }
  const p = ke(`${u}-${o}`, {
    [`${u}-rtl`]: X2 === !0
  });
  Dy.newInstance({
    name: "notification",
    prefixCls: n || Y2,
    useStyle: tU,
    class: p,
    style: nU(o, r != null ? r : rU, a != null ? a : aU),
    appContext: s,
    getContainer: l,
    closeIcon: (m) => {
      let {
        prefixCls: v
      } = m;
      return $("span", {
        class: `${v}-close-x`
      }, [Jd(i, {}, $(Hl, {
        class: `${v}-close-icon`
      }, null))]);
    },
    maxCount: uU,
    hasTransitionName: !0
  }, (m) => {
    su[d] = m, t(m);
  });
}
const oFe = {
  success: xS,
  info: OS,
  error: _S,
  warning: ES
};
function lFe(e) {
  const {
    icon: t,
    type: n,
    description: o,
    message: l,
    btn: r
  } = e, a = e.duration === void 0 ? lU : e.duration;
  nFe(e, (i) => {
    i.notice({
      content: (s) => {
        let {
          prefixCls: c
        } = s;
        const u = `${c}-notice`;
        let d = null;
        if (t)
          d = () => $("span", {
            class: `${u}-icon`
          }, [Jd(t)]);
        else if (n) {
          const f = oFe[n];
          d = () => $(f, {
            class: `${u}-icon ${u}-icon-${n}`
          }, null);
        }
        return $("div", {
          class: d ? `${u}-with-icon` : ""
        }, [d && d(), $("div", {
          class: `${u}-message`
        }, [!o && d ? $("span", {
          class: `${u}-message-single-line-auto-margin`
        }, null) : null, Jd(l)]), $("div", {
          class: `${u}-description`
        }, [Jd(o)]), r ? $("span", {
          class: `${u}-btn`
        }, [Jd(r)]) : null]);
      },
      duration: a,
      closable: !0,
      onClose: e.onClose,
      onClick: e.onClick,
      key: e.key,
      style: e.style || {},
      class: e.class
    });
  });
}
const Ec = {
  open: lFe,
  close(e) {
    Object.keys(su).forEach((t) => Promise.resolve(su[t]).then((n) => {
      n.removeNotice(e);
    }));
  },
  config: tFe,
  destroy() {
    Object.keys(su).forEach((e) => {
      Promise.resolve(su[e]).then((t) => {
        t.destroy();
      }), delete su[e];
    });
  }
}, rFe = ["success", "info", "warning", "error"];
rFe.forEach((e) => {
  Ec[e] = (t) => Ec.open(_(_({}, t), {
    type: e
  }));
});
Ec.warn = Ec.warning;
Ec.useNotification = oU;
const aFe = `-ant-${Date.now()}-${Math.random()}`;
function iFe(e, t) {
  const n = {}, o = (a, i) => {
    let s = a.clone();
    return s = (i == null ? void 0 : i(s)) || s, s.toRgbString();
  }, l = (a, i) => {
    const s = new xn(a), c = Xu(s.toRgbString());
    n[`${i}-color`] = o(s), n[`${i}-color-disabled`] = c[1], n[`${i}-color-hover`] = c[4], n[`${i}-color-active`] = c[6], n[`${i}-color-outline`] = s.clone().setAlpha(0.2).toRgbString(), n[`${i}-color-deprecated-bg`] = c[0], n[`${i}-color-deprecated-border`] = c[2];
  };
  if (t.primaryColor) {
    l(t.primaryColor, "primary");
    const a = new xn(t.primaryColor), i = Xu(a.toRgbString());
    i.forEach((c, u) => {
      n[`primary-${u + 1}`] = c;
    }), n["primary-color-deprecated-l-35"] = o(a, (c) => c.lighten(35)), n["primary-color-deprecated-l-20"] = o(a, (c) => c.lighten(20)), n["primary-color-deprecated-t-20"] = o(a, (c) => c.tint(20)), n["primary-color-deprecated-t-50"] = o(a, (c) => c.tint(50)), n["primary-color-deprecated-f-12"] = o(a, (c) => c.setAlpha(c.getAlpha() * 0.12));
    const s = new xn(i[0]);
    n["primary-color-active-deprecated-f-30"] = o(s, (c) => c.setAlpha(c.getAlpha() * 0.3)), n["primary-color-active-deprecated-d-02"] = o(s, (c) => c.darken(2));
  }
  return t.successColor && l(t.successColor, "success"), t.warningColor && l(t.warningColor, "warning"), t.errorColor && l(t.errorColor, "error"), t.infoColor && l(t.infoColor, "info"), `
  :root {
    ${Object.keys(n).map((a) => `--${e}-${a}: ${n[a]};`).join(`
`)}
  }
  `.trim();
}
function sFe(e, t) {
  const n = iFe(e, t);
  Fl() ? Tm(n, `${aFe}-dynamic-theme`) : Hn(!1, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
}
const cFe = (e) => {
  const [t, n] = _s();
  return m2(O(() => ({
    theme: t.value,
    token: n.value,
    hashId: "",
    path: ["ant-design-icons", e.value]
  })), () => [{
    [`.${e.value}`]: _(_({}, cd()), {
      [`.${e.value} .${e.value}-icon`]: {
        display: "block"
      }
    })
  }]);
};
function uFe(e, t) {
  const n = O(() => (e == null ? void 0 : e.value) || {}), o = O(() => n.value.inherit === !1 || !(t != null && t.value) ? LH : t.value);
  return O(() => {
    if (!(e != null && e.value))
      return t == null ? void 0 : t.value;
    const r = _({}, o.value.components);
    return Object.keys(e.value.components || {}).forEach((a) => {
      r[a] = _(_({}, r[a]), e.value.components[a]);
    }), _(_(_({}, o.value), n.value), {
      token: _(_({}, o.value.token), n.value.token),
      components: r
    });
  });
}
var dFe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const fFe = "ant";
function _f() {
  return gl.prefixCls || fFe;
}
function dU() {
  return gl.iconPrefixCls || lI;
}
const KT = /* @__PURE__ */ kt({}), gl = /* @__PURE__ */ kt({});
Ot(() => {
  _(gl, KT), gl.prefixCls = _f(), gl.iconPrefixCls = dU(), gl.getPrefixCls = (e, t) => t || (e ? `${gl.prefixCls}-${e}` : gl.prefixCls), gl.getRootPrefixCls = () => gl.prefixCls ? gl.prefixCls : _f();
});
let Kw;
const pFe = (e) => {
  Kw && Kw(), Kw = Ot(() => {
    _(KT, /* @__PURE__ */ kt(e)), _(gl, /* @__PURE__ */ kt(e));
  }), e.theme && sFe(_f(), e.theme);
}, vFe = () => ({
  getPrefixCls: (e, t) => t || (e ? `${_f()}-${e}` : _f()),
  getIconPrefixCls: dU,
  getRootPrefixCls: () => gl.prefixCls ? gl.prefixCls : _f()
}), Mu = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AConfigProvider",
  inheritAttrs: !1,
  props: RPe(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = oS(), l = (D, F) => {
      const {
        prefixCls: M = "ant"
      } = e;
      if (F) return F;
      const A = M || o.getPrefixCls("");
      return D ? `${A}-${D}` : A;
    }, r = O(() => e.iconPrefixCls || o.iconPrefixCls.value || lI), a = O(() => r.value !== o.iconPrefixCls.value), i = O(() => {
      var D;
      return e.csp || ((D = o.csp) === null || D === void 0 ? void 0 : D.value);
    }), s = cFe(r), c = uFe(O(() => e.theme), O(() => {
      var D;
      return (D = o.theme) === null || D === void 0 ? void 0 : D.value;
    })), u = (D) => (e.renderEmpty || n.renderEmpty || o.renderEmpty || m4e)(D), d = O(() => {
      var D, F;
      return (D = e.autoInsertSpaceInButton) !== null && D !== void 0 ? D : (F = o.autoInsertSpaceInButton) === null || F === void 0 ? void 0 : F.value;
    }), f = O(() => {
      var D;
      return e.locale || ((D = o.locale) === null || D === void 0 ? void 0 : D.value);
    });
    pe(f, () => {
      KT.locale = f.value;
    }, {
      immediate: !0
    });
    const p = O(() => {
      var D;
      return e.direction || ((D = o.direction) === null || D === void 0 ? void 0 : D.value);
    }), m = O(() => {
      var D, F;
      return (D = e.space) !== null && D !== void 0 ? D : (F = o.space) === null || F === void 0 ? void 0 : F.value;
    }), v = O(() => {
      var D, F;
      return (D = e.virtual) !== null && D !== void 0 ? D : (F = o.virtual) === null || F === void 0 ? void 0 : F.value;
    }), h = O(() => {
      var D, F;
      return (D = e.dropdownMatchSelectWidth) !== null && D !== void 0 ? D : (F = o.dropdownMatchSelectWidth) === null || F === void 0 ? void 0 : F.value;
    }), g = O(() => {
      var D;
      return e.getTargetContainer !== void 0 ? e.getTargetContainer : (D = o.getTargetContainer) === null || D === void 0 ? void 0 : D.value;
    }), y = O(() => {
      var D;
      return e.getPopupContainer !== void 0 ? e.getPopupContainer : (D = o.getPopupContainer) === null || D === void 0 ? void 0 : D.value;
    }), b = O(() => {
      var D;
      return e.pageHeader !== void 0 ? e.pageHeader : (D = o.pageHeader) === null || D === void 0 ? void 0 : D.value;
    }), C = O(() => {
      var D;
      return e.input !== void 0 ? e.input : (D = o.input) === null || D === void 0 ? void 0 : D.value;
    }), w = O(() => {
      var D;
      return e.pagination !== void 0 ? e.pagination : (D = o.pagination) === null || D === void 0 ? void 0 : D.value;
    }), x = O(() => {
      var D;
      return e.form !== void 0 ? e.form : (D = o.form) === null || D === void 0 ? void 0 : D.value;
    }), E = O(() => {
      var D;
      return e.select !== void 0 ? e.select : (D = o.select) === null || D === void 0 ? void 0 : D.value;
    }), I = O(() => e.componentSize), T = O(() => e.componentDisabled), P = O(() => {
      var D, F;
      return (D = e.wave) !== null && D !== void 0 ? D : (F = o.wave) === null || F === void 0 ? void 0 : F.value;
    }), k = {
      csp: i,
      autoInsertSpaceInButton: d,
      locale: f,
      direction: p,
      space: m,
      virtual: v,
      dropdownMatchSelectWidth: h,
      getPrefixCls: l,
      iconPrefixCls: r,
      theme: O(() => {
        var D, F;
        return (D = c.value) !== null && D !== void 0 ? D : (F = o.theme) === null || F === void 0 ? void 0 : F.value;
      }),
      renderEmpty: u,
      getTargetContainer: g,
      getPopupContainer: y,
      pageHeader: b,
      input: C,
      pagination: w,
      form: x,
      select: E,
      componentSize: I,
      componentDisabled: T,
      transformCellText: O(() => e.transformCellText),
      wave: P
    }, N = O(() => {
      const D = c.value || {}, {
        algorithm: F,
        token: M
      } = D, A = dFe(D, ["algorithm", "token"]), L = F && (!Array.isArray(F) || F.length > 0) ? SH(F) : void 0;
      return _(_({}, A), {
        theme: L,
        token: _(_({}, sS), M)
      });
    }), R = O(() => {
      var D, F;
      let M = {};
      return f.value && (M = ((D = f.value.Form) === null || D === void 0 ? void 0 : D.defaultValidateMessages) || ((F = rr.Form) === null || F === void 0 ? void 0 : F.defaultValidateMessages) || {}), e.form && e.form.validateMessages && (M = _(_({}, M), e.form.validateMessages)), M;
    });
    DPe(k), MPe({
      validateMessages: R
    }), HH(I), aH(T);
    const z = (D) => {
      var F, M;
      let A = a.value ? s((F = n.default) === null || F === void 0 ? void 0 : F.call(n)) : (M = n.default) === null || M === void 0 ? void 0 : M.call(n);
      if (e.theme) {
        const L = /* @__PURE__ */ function() {
          return A;
        }();
        A = $(u4e, {
          value: N.value
        }, {
          default: () => [L]
        });
      }
      return $(zK, {
        locale: f.value || D,
        ANT_MARK__: G2
      }, {
        default: () => [A]
      });
    };
    return Ot(() => {
      p.value && (Qu.config({
        rtl: p.value === "rtl"
      }), Ec.config({
        rtl: p.value === "rtl"
      }));
    }), () => $(sd, {
      children: (D, F, M) => z(M)
    }, null);
  }
});
Mu.config = pFe;
Mu.install = function(e) {
  e.component(Mu.name, Mu);
};
const mFe = (e, t) => {
  let {
    attrs: n,
    slots: o
  } = t;
  return $(ko, Q(Q({
    size: "small",
    type: "primary"
  }, e), n), o);
}, zg = (e, t, n) => {
  const o = rPe(n);
  return {
    [`${e.componentCls}-${t}`]: {
      color: e[`color${n}`],
      background: e[`color${o}Bg`],
      borderColor: e[`color${o}Border`],
      [`&${e.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
}, hFe = (e) => ry(e, (t, n) => {
  let {
    textColor: o,
    lightBorderColor: l,
    lightColor: r,
    darkColor: a
  } = n;
  return {
    [`${e.componentCls}-${t}`]: {
      color: o,
      background: r,
      borderColor: l,
      // Inverse color
      "&-inverse": {
        color: e.colorTextLightSolid,
        background: a,
        borderColor: a
      },
      [`&${e.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
}), gFe = (e) => {
  const {
    paddingXXS: t,
    lineWidth: n,
    tagPaddingHorizontal: o,
    componentCls: l
  } = e, r = o - n, a = t - n;
  return {
    // Result
    [l]: _(_({}, nn(e)), {
      display: "inline-block",
      height: "auto",
      marginInlineEnd: e.marginXS,
      paddingInline: r,
      fontSize: e.tagFontSize,
      lineHeight: `${e.tagLineHeight}px`,
      whiteSpace: "nowrap",
      background: e.tagDefaultBg,
      border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
      borderRadius: e.borderRadiusSM,
      opacity: 1,
      transition: `all ${e.motionDurationMid}`,
      textAlign: "start",
      // RTL
      [`&${l}-rtl`]: {
        direction: "rtl"
      },
      "&, a, a:hover": {
        color: e.tagDefaultColor
      },
      [`${l}-close-icon`]: {
        marginInlineStart: a,
        color: e.colorTextDescription,
        fontSize: e.tagIconSize,
        cursor: "pointer",
        transition: `all ${e.motionDurationMid}`,
        "&:hover": {
          color: e.colorTextHeading
        }
      },
      [`&${l}-has-color`]: {
        borderColor: "transparent",
        [`&, a, a:hover, ${e.iconCls}-close, ${e.iconCls}-close:hover`]: {
          color: e.colorTextLightSolid
        }
      },
      "&-checkable": {
        backgroundColor: "transparent",
        borderColor: "transparent",
        cursor: "pointer",
        [`&:not(${l}-checkable-checked):hover`]: {
          color: e.colorPrimary,
          backgroundColor: e.colorFillSecondary
        },
        "&:active, &-checked": {
          color: e.colorTextLightSolid
        },
        "&-checked": {
          backgroundColor: e.colorPrimary,
          "&:hover": {
            backgroundColor: e.colorPrimaryHover
          }
        },
        "&:active": {
          backgroundColor: e.colorPrimaryActive
        }
      },
      "&-hidden": {
        display: "none"
      },
      // To ensure that a space will be placed between character and `Icon`.
      [`> ${e.iconCls} + span, > span + ${e.iconCls}`]: {
        marginInlineStart: r
      }
    }),
    [`${l}-borderless`]: {
      borderColor: "transparent",
      background: e.tagBorderlessBg
    }
  };
}, fU = Zt("Tag", (e) => {
  const {
    fontSize: t,
    lineHeight: n,
    lineWidth: o,
    fontSizeIcon: l
  } = e, r = Math.round(t * n), a = e.fontSizeSM, i = r - o * 2, s = e.colorFillAlter, c = e.colorText, u = Vt(e, {
    tagFontSize: a,
    tagLineHeight: i,
    tagDefaultBg: s,
    tagDefaultColor: c,
    tagIconSize: l - 2 * o,
    tagPaddingHorizontal: 8,
    tagBorderlessBg: e.colorFillTertiary
  });
  return [gFe(u), hFe(u), zg(u, "success", "Success"), zg(u, "processing", "Info"), zg(u, "error", "Error"), zg(u, "warning", "Warning")];
}), bFe = () => ({
  prefixCls: String,
  checked: {
    type: Boolean,
    default: void 0
  },
  onChange: {
    type: Function
  },
  onClick: {
    type: Function
  },
  "onUpdate:checked": Function
}), Ly = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckableTag",
  inheritAttrs: !1,
  props: bFe(),
  // emits: ['update:checked', 'change', 'click'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: l
    } = t;
    const {
      prefixCls: r
    } = bt("tag", e), [a, i] = fU(r), s = (u) => {
      const {
        checked: d
      } = e;
      o("update:checked", !d), o("change", !d), o("click", u);
    }, c = O(() => ke(r.value, i.value, {
      [`${r.value}-checkable`]: !0,
      [`${r.value}-checkable-checked`]: e.checked
    }));
    return () => {
      var u;
      return a($("span", Q(Q({}, l), {}, {
        class: [c.value, l.class],
        onClick: s
      }), [(u = n.default) === null || u === void 0 ? void 0 : u.call(n)]));
    };
  }
}), yFe = () => ({
  prefixCls: String,
  color: {
    type: String
  },
  closable: {
    type: Boolean,
    default: !1
  },
  closeIcon: de.any,
  /** @deprecated `visible` will be removed in next major version. */
  visible: {
    type: Boolean,
    default: void 0
  },
  onClose: {
    type: Function
  },
  onClick: Yu(),
  "onUpdate:visible": Function,
  icon: de.any,
  bordered: {
    type: Boolean,
    default: !0
  }
}), If = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ATag",
  inheritAttrs: !1,
  props: yFe(),
  // emits: ['update:visible', 'close'],
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: l
    } = t;
    const {
      prefixCls: r,
      direction: a
    } = bt("tag", e), [i, s] = fU(r), c = /* @__PURE__ */ Ce(!0);
    process.env.NODE_ENV !== "production" && Hn(e.visible === void 0, "Tag", '`visible` is deprecated, please use `<Tag v-show="visible" />` instead.'), Ot(() => {
      e.visible !== void 0 && (c.value = e.visible);
    });
    const u = (m) => {
      m.stopPropagation(), o("update:visible", !1), o("close", m), !m.defaultPrevented && e.visible === void 0 && (c.value = !1);
    }, d = O(() => IS(e.color) || A6e(e.color)), f = O(() => ke(r.value, s.value, {
      [`${r.value}-${e.color}`]: d.value,
      [`${r.value}-has-color`]: e.color && !d.value,
      [`${r.value}-hidden`]: !c.value,
      [`${r.value}-rtl`]: a.value === "rtl",
      [`${r.value}-borderless`]: !e.bordered
    })), p = (m) => {
      o("click", m);
    };
    return () => {
      var m, v, h;
      const {
        icon: g = (m = n.icon) === null || m === void 0 ? void 0 : m.call(n),
        color: y,
        closeIcon: b = (v = n.closeIcon) === null || v === void 0 ? void 0 : v.call(n),
        closable: C = !1
      } = e, w = () => C ? b ? $("span", {
        class: `${r.value}-close-icon`,
        onClick: u
      }, [b]) : $(Hl, {
        class: `${r.value}-close-icon`,
        onClick: u
      }, null) : null, x = {
        backgroundColor: y && !d.value ? y : void 0
      }, E = g || null, I = (h = n.default) === null || h === void 0 ? void 0 : h.call(n), T = E ? $(Ge, null, [E, $("span", null, [I])]) : I, P = e.onClick !== void 0, k = $("span", Q(Q({}, l), {}, {
        onClick: p,
        class: [f.value, l.class],
        style: [x, l.style]
      }), [T, w()]);
      return i(P ? $(XI, null, {
        default: () => [k]
      }) : k);
    };
  }
});
If.CheckableTag = Ly;
If.install = function(e) {
  return e.component(If.name, If), e.component(Ly.name, Ly), e;
};
function SFe(e, t) {
  let {
    slots: n,
    attrs: o
  } = t;
  return $(If, Q(Q({
    color: "blue"
  }, e), o), n);
}
var CFe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" } }] }, name: "calendar", theme: "outlined" };
function cA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      wFe(e, l, n[l]);
    });
  }
  return e;
}
function wFe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var US = function(t, n) {
  var o = cA({}, t, n.attrs);
  return $(cn, cA({}, o, {
    icon: CFe
  }), null);
};
US.displayName = "CalendarOutlined";
US.inheritAttrs = !1;
var $Fe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] }, name: "clock-circle", theme: "outlined" };
function uA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      xFe(e, l, n[l]);
    });
  }
  return e;
}
function xFe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var GS = function(t, n) {
  var o = uA({}, t, n.attrs);
  return $(cn, uA({}, o, {
    icon: $Fe
  }), null);
};
GS.displayName = "ClockCircleOutlined";
GS.inheritAttrs = !1;
function EFe(e, t, n) {
  return n !== void 0 ? n : t === "year" && e.lang.yearPlaceholder ? e.lang.yearPlaceholder : t === "quarter" && e.lang.quarterPlaceholder ? e.lang.quarterPlaceholder : t === "month" && e.lang.monthPlaceholder ? e.lang.monthPlaceholder : t === "week" && e.lang.weekPlaceholder ? e.lang.weekPlaceholder : t === "time" && e.timePickerLocale.placeholder ? e.timePickerLocale.placeholder : e.lang.placeholder;
}
function OFe(e, t, n) {
  return n !== void 0 ? n : t === "year" && e.lang.yearPlaceholder ? e.lang.rangeYearPlaceholder : t === "month" && e.lang.monthPlaceholder ? e.lang.rangeMonthPlaceholder : t === "week" && e.lang.weekPlaceholder ? e.lang.rangeWeekPlaceholder : t === "time" && e.timePickerLocale.placeholder ? e.timePickerLocale.rangePlaceholder : e.lang.rangePlaceholder;
}
function pU(e, t) {
  const n = {
    adjustX: 1,
    adjustY: 1
  };
  switch (t) {
    case "bottomLeft":
      return {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow: n
      };
    case "bottomRight":
      return {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow: n
      };
    case "topLeft":
      return {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow: n
      };
    case "topRight":
      return {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow: n
      };
    default:
      return {
        points: e === "rtl" ? ["tr", "br"] : ["tl", "bl"],
        offset: [0, 4],
        overflow: n
      };
  }
}
function By() {
  return {
    id: String,
    /**
     * @deprecated `dropdownClassName` is deprecated which will be removed in next major
     *   version.Please use `popupClassName` instead.
     */
    dropdownClassName: String,
    popupClassName: String,
    popupStyle: Nt(),
    transitionName: String,
    placeholder: String,
    allowClear: Qe(),
    autofocus: Qe(),
    disabled: Qe(),
    tabindex: Number,
    open: Qe(),
    defaultOpen: Qe(),
    /** Make input readOnly to avoid popup keyboard in mobile */
    inputReadOnly: Qe(),
    format: zt([String, Function, Array]),
    // Value
    // format:  string | CustomFormat<DateType> | (string | CustomFormat<DateType>)[];
    // Render
    // suffixIcon?: VueNode;
    // clearIcon?: VueNode;
    // prevIcon?: VueNode;
    // nextIcon?: VueNode;
    // superPrevIcon?: VueNode;
    // superNextIcon?: VueNode;
    getPopupContainer: Fe(),
    panelRender: Fe(),
    // // Events
    onChange: Fe(),
    "onUpdate:value": Fe(),
    onOk: Fe(),
    onOpenChange: Fe(),
    "onUpdate:open": Fe(),
    onFocus: Fe(),
    onBlur: Fe(),
    onMousedown: Fe(),
    onMouseup: Fe(),
    onMouseenter: Fe(),
    onMouseleave: Fe(),
    onClick: Fe(),
    onContextmenu: Fe(),
    onKeydown: Fe(),
    // WAI-ARIA
    role: String,
    name: String,
    autocomplete: String,
    direction: At(),
    showToday: Qe(),
    showTime: zt([Boolean, Object]),
    locale: Nt(),
    size: At(),
    bordered: Qe(),
    dateRender: Fe(),
    disabledDate: Fe(),
    mode: At(),
    picker: At(),
    valueFormat: String,
    placement: At(),
    status: At(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledHours: Fe(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledMinutes: Fe(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledSeconds: Fe()
  };
}
function vU() {
  return {
    defaultPickerValue: zt([Object, String]),
    defaultValue: zt([Object, String]),
    value: zt([Object, String]),
    presets: $n(),
    disabledTime: Fe(),
    renderExtraFooter: Fe(),
    showNow: Qe(),
    monthCellRender: Fe(),
    // deprecated  Please use `monthCellRender"` instead.',
    monthCellContentRender: Fe()
  };
}
function mU() {
  return {
    allowEmpty: $n(),
    dateRender: Fe(),
    defaultPickerValue: $n(),
    defaultValue: $n(),
    value: $n(),
    presets: $n(),
    disabledTime: Fe(),
    disabled: zt([Boolean, Array]),
    renderExtraFooter: Fe(),
    separator: {
      type: String
    },
    showTime: zt([Boolean, Object]),
    ranges: Nt(),
    placeholder: $n(),
    mode: $n(),
    onChange: Fe(),
    "onUpdate:value": Fe(),
    onCalendarChange: Fe(),
    onPanelChange: Fe(),
    onOk: Fe()
  };
}
var _Fe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function IFe(e, t) {
  function n(c, u) {
    const d = _(_(_({}, By()), vU()), t);
    return /* @__PURE__ */ le({
      compatConfig: {
        MODE: 3
      },
      name: u,
      inheritAttrs: !1,
      props: d,
      slots: Object,
      setup(f, p) {
        let {
          slots: m,
          expose: v,
          attrs: h,
          emit: g
        } = p;
        const y = f, b = Ko(), C = sl.useInject();
        process.env.NODE_ENV !== "production" && (un(c !== "quarter", u || "DatePicker", `DatePicker.${u} is legacy usage. Please use DatePicker[picker='${c}'] directly.`), un(!y.dropdownClassName, u || "DatePicker", "`dropdownClassName` is deprecated. Please use `popupClassName` instead."), un(!(y.monthCellContentRender || m.monthCellContentRender), u || "DatePicker", '`monthCellContentRender` is deprecated. Please use `monthCellRender"` instead.'), un(!h.getCalendarContainer, u || "DatePicker", '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.'));
        const {
          prefixCls: w,
          direction: x,
          getPopupContainer: E,
          size: I,
          rootPrefixCls: T,
          disabled: P
        } = bt("picker", y), {
          compactSize: k,
          compactItemClassnames: N
        } = Rc(w, x), R = O(() => k.value || I.value), [z, D] = JW(w), F = /* @__PURE__ */ H();
        v({
          focus: () => {
            var re;
            (re = F.value) === null || re === void 0 || re.focus();
          },
          blur: () => {
            var re;
            (re = F.value) === null || re === void 0 || re.blur();
          }
        });
        const M = (re) => y.valueFormat ? e.toString(re, y.valueFormat) : re, A = (re, oe) => {
          const q = M(re);
          g("update:value", q), g("change", q, oe), b.onFieldChange();
        }, L = (re) => {
          g("update:open", re), g("openChange", re);
        }, B = (re) => {
          g("focus", re);
        }, V = (re) => {
          g("blur", re), b.onFieldBlur();
        }, j = (re, oe) => {
          const q = M(re);
          g("panelChange", q, oe);
        }, W = (re) => {
          const oe = M(re);
          g("ok", oe);
        }, [Y] = fa("DatePicker", _m), U = O(() => y.value ? y.valueFormat ? e.toDate(y.value, y.valueFormat) : y.value : y.value === "" ? void 0 : y.value), te = O(() => y.defaultValue ? y.valueFormat ? e.toDate(y.defaultValue, y.valueFormat) : y.defaultValue : y.defaultValue === "" ? void 0 : y.defaultValue), J = O(() => y.defaultPickerValue ? y.valueFormat ? e.toDate(y.defaultPickerValue, y.valueFormat) : y.defaultPickerValue : y.defaultPickerValue === "" ? void 0 : y.defaultPickerValue);
        return () => {
          var re, oe, q, K, se, Z;
          const ee = _(_({}, Y.value), y.locale), fe = _(_({}, y), h), {
            bordered: me = !0,
            placeholder: ge,
            suffixIcon: he = (re = m.suffixIcon) === null || re === void 0 ? void 0 : re.call(m),
            showToday: $e = !0,
            transitionName: ne,
            allowClear: ae = !0,
            dateRender: ce = m.dateRender,
            renderExtraFooter: xe = m.renderExtraFooter,
            monthCellRender: Te = m.monthCellRender || y.monthCellContentRender || m.monthCellContentRender,
            clearIcon: Se = (oe = m.clearIcon) === null || oe === void 0 ? void 0 : oe.call(m),
            id: be = b.id.value
          } = fe, ie = _Fe(fe, ["bordered", "placeholder", "suffixIcon", "showToday", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "monthCellRender", "clearIcon", "id"]), we = fe.showTime === "" ? !0 : fe.showTime, {
            format: Ne
          } = fe;
          let tt = {};
          c && (tt.picker = c);
          const Pe = c || fe.picker || "date";
          tt = _(_(_({}, tt), we ? Fy(_({
            format: Ne,
            picker: Pe
          }, typeof we == "object" ? we : {})) : {}), Pe === "time" ? Fy(_(_({
            format: Ne
          }, ie), {
            picker: Pe
          })) : {});
          const Re = w.value, Le = $(Ge, null, [he || $(c === "time" ? GS : US, null, null), C.hasFeedback && C.feedbackIcon]);
          return z($(eDe, Q(Q(Q({
            monthCellRender: Te,
            dateRender: ce,
            renderExtraFooter: xe,
            ref: F,
            placeholder: EFe(ee, Pe, ge),
            suffixIcon: Le,
            dropdownAlign: pU(x.value, y.placement),
            clearIcon: Se || $(jl, null, null),
            allowClear: ae,
            transitionName: ne || `${T.value}-slide-up`
          }, ie), tt), {}, {
            id: be,
            picker: Pe,
            value: U.value,
            defaultValue: te.value,
            defaultPickerValue: J.value,
            showToday: $e,
            locale: ee.lang,
            class: ke({
              [`${Re}-${R.value}`]: R.value,
              [`${Re}-borderless`]: !me
            }, Ll(Re, Ja(C.status, y.status), C.hasFeedback), h.class, D.value, N.value),
            disabled: P.value,
            prefixCls: Re,
            getPopupContainer: h.getCalendarContainer || E.value,
            generateConfig: e,
            prevIcon: ((q = m.prevIcon) === null || q === void 0 ? void 0 : q.call(m)) || $("span", {
              class: `${Re}-prev-icon`
            }, null),
            nextIcon: ((K = m.nextIcon) === null || K === void 0 ? void 0 : K.call(m)) || $("span", {
              class: `${Re}-next-icon`
            }, null),
            superPrevIcon: ((se = m.superPrevIcon) === null || se === void 0 ? void 0 : se.call(m)) || $("span", {
              class: `${Re}-super-prev-icon`
            }, null),
            superNextIcon: ((Z = m.superNextIcon) === null || Z === void 0 ? void 0 : Z.call(m)) || $("span", {
              class: `${Re}-super-next-icon`
            }, null),
            components: hU,
            direction: x.value,
            dropdownClassName: ke(D.value, y.popupClassName, y.dropdownClassName),
            onChange: A,
            onOpenChange: L,
            onFocus: B,
            onBlur: V,
            onPanelChange: j,
            onOk: W
          }), null));
        };
      }
    });
  }
  const o = n(void 0, "ADatePicker"), l = n("week", "AWeekPicker"), r = n("month", "AMonthPicker"), a = n("year", "AYearPicker"), i = n("time", "TimePicker"), s = n("quarter", "AQuarterPicker");
  return {
    DatePicker: o,
    WeekPicker: l,
    MonthPicker: r,
    YearPicker: a,
    TimePicker: i,
    QuarterPicker: s
  };
}
var TFe = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" } }] }, name: "swap-right", theme: "outlined" };
function dA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      PFe(e, l, n[l]);
    });
  }
  return e;
}
function PFe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var UT = function(t, n) {
  var o = dA({}, t, n.attrs);
  return $(cn, dA({}, o, {
    icon: TFe
  }), null);
};
UT.displayName = "SwapRightOutlined";
UT.inheritAttrs = !1;
var kFe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function NFe(e, t) {
  return /* @__PURE__ */ le({
    compatConfig: {
      MODE: 3
    },
    name: "ARangePicker",
    inheritAttrs: !1,
    props: _(_(_({}, By()), mU()), t),
    slots: Object,
    setup(o, l) {
      let {
        expose: r,
        slots: a,
        attrs: i,
        emit: s
      } = l;
      const c = o, u = Ko(), d = sl.useInject();
      process.env.NODE_ENV !== "production" && (un(!c.dropdownClassName, "RangePicker", "`dropdownClassName` is deprecated. Please use `popupClassName` instead."), un(!i.getCalendarContainer, "DatePicker", '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.'));
      const {
        prefixCls: f,
        direction: p,
        getPopupContainer: m,
        size: v,
        rootPrefixCls: h,
        disabled: g
      } = bt("picker", c), {
        compactSize: y,
        compactItemClassnames: b
      } = Rc(f, p), C = O(() => y.value || v.value), [w, x] = JW(f), E = /* @__PURE__ */ H();
      r({
        focus: () => {
          var B;
          (B = E.value) === null || B === void 0 || B.focus();
        },
        blur: () => {
          var B;
          (B = E.value) === null || B === void 0 || B.blur();
        }
      });
      const I = (B) => c.valueFormat ? e.toString(B, c.valueFormat) : B, T = (B, V) => {
        const j = I(B);
        s("update:value", j), s("change", j, V), u.onFieldChange();
      }, P = (B) => {
        s("update:open", B), s("openChange", B);
      }, k = (B) => {
        s("focus", B);
      }, N = (B) => {
        s("blur", B), u.onFieldBlur();
      }, R = (B, V) => {
        const j = I(B);
        s("panelChange", j, V);
      }, z = (B) => {
        const V = I(B);
        s("ok", V);
      }, D = (B, V, j) => {
        const W = I(B);
        s("calendarChange", W, V, j);
      }, [F] = fa("DatePicker", _m), M = O(() => c.value && c.valueFormat ? e.toDate(c.value, c.valueFormat) : c.value), A = O(() => c.defaultValue && c.valueFormat ? e.toDate(c.defaultValue, c.valueFormat) : c.defaultValue), L = O(() => c.defaultPickerValue && c.valueFormat ? e.toDate(c.defaultPickerValue, c.valueFormat) : c.defaultPickerValue);
      return () => {
        var B, V, j, W, Y, U, te;
        const J = _(_({}, F.value), c.locale), re = _(_({}, c), i), {
          prefixCls: oe,
          bordered: q = !0,
          placeholder: K,
          suffixIcon: se = (B = a.suffixIcon) === null || B === void 0 ? void 0 : B.call(a),
          picker: Z = "date",
          transitionName: ee,
          allowClear: fe = !0,
          dateRender: me = a.dateRender,
          renderExtraFooter: ge = a.renderExtraFooter,
          separator: he = (V = a.separator) === null || V === void 0 ? void 0 : V.call(a),
          clearIcon: $e = (j = a.clearIcon) === null || j === void 0 ? void 0 : j.call(a),
          id: ne = u.id.value
        } = re, ae = kFe(re, ["prefixCls", "bordered", "placeholder", "suffixIcon", "picker", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "separator", "clearIcon", "id"]);
        delete ae["onUpdate:value"], delete ae["onUpdate:open"];
        const {
          format: ce,
          showTime: xe
        } = re;
        let Te = {};
        Te = _(_(_({}, Te), xe ? Fy(_({
          format: ce,
          picker: Z
        }, xe)) : {}), Z === "time" ? Fy(_(_({
          format: ce
        }, pn(ae, ["disabledTime"])), {
          picker: Z
        })) : {});
        const Se = f.value, be = $(Ge, null, [se || $(Z === "time" ? GS : US, null, null), d.hasFeedback && d.feedbackIcon]);
        return w($(uDe, Q(Q(Q({
          dateRender: me,
          renderExtraFooter: ge,
          separator: he || $("span", {
            "aria-label": "to",
            class: `${Se}-separator`
          }, [$(UT, null, null)]),
          ref: E,
          dropdownAlign: pU(p.value, c.placement),
          placeholder: OFe(J, Z, K),
          suffixIcon: be,
          clearIcon: $e || $(jl, null, null),
          allowClear: fe,
          transitionName: ee || `${h.value}-slide-up`
        }, ae), Te), {}, {
          disabled: g.value,
          id: ne,
          value: M.value,
          defaultValue: A.value,
          defaultPickerValue: L.value,
          picker: Z,
          class: ke({
            [`${Se}-${C.value}`]: C.value,
            [`${Se}-borderless`]: !q
          }, Ll(Se, Ja(d.status, c.status), d.hasFeedback), i.class, x.value, b.value),
          locale: J.lang,
          prefixCls: Se,
          getPopupContainer: i.getCalendarContainer || m.value,
          generateConfig: e,
          prevIcon: ((W = a.prevIcon) === null || W === void 0 ? void 0 : W.call(a)) || $("span", {
            class: `${Se}-prev-icon`
          }, null),
          nextIcon: ((Y = a.nextIcon) === null || Y === void 0 ? void 0 : Y.call(a)) || $("span", {
            class: `${Se}-next-icon`
          }, null),
          superPrevIcon: ((U = a.superPrevIcon) === null || U === void 0 ? void 0 : U.call(a)) || $("span", {
            class: `${Se}-super-prev-icon`
          }, null),
          superNextIcon: ((te = a.superNextIcon) === null || te === void 0 ? void 0 : te.call(a)) || $("span", {
            class: `${Se}-super-next-icon`
          }, null),
          components: hU,
          direction: p.value,
          dropdownClassName: ke(x.value, c.popupClassName, c.dropdownClassName),
          onChange: T,
          onOpenChange: P,
          onFocus: k,
          onBlur: N,
          onPanelChange: R,
          onOk: z,
          onCalendarChange: D
        }), null));
      };
    }
  });
}
const hU = {
  button: mFe,
  rangeItem: SFe
};
function MFe(e) {
  return e ? Array.isArray(e) ? e : [e] : [];
}
function Fy(e) {
  const {
    format: t,
    picker: n,
    showHour: o,
    showMinute: l,
    showSecond: r,
    use12Hours: a
  } = e, i = MFe(t)[0], s = _({}, e);
  return i && typeof i == "string" && (!i.includes("s") && r === void 0 && (s.showSecond = !1), !i.includes("m") && l === void 0 && (s.showMinute = !1), !i.includes("H") && !i.includes("h") && o === void 0 && (s.showHour = !1), (i.includes("a") || i.includes("A")) && a === void 0 && (s.use12Hours = !0)), n === "time" ? s : (typeof i == "function" && delete s.format, {
    showTime: s
  });
}
function gU(e, t) {
  const {
    DatePicker: n,
    WeekPicker: o,
    MonthPicker: l,
    YearPicker: r,
    TimePicker: a,
    QuarterPicker: i
  } = IFe(e, t), s = NFe(e, t);
  return {
    DatePicker: n,
    WeekPicker: o,
    MonthPicker: l,
    YearPicker: r,
    TimePicker: a,
    QuarterPicker: i,
    RangePicker: s
  };
}
const {
  DatePicker: Uw,
  WeekPicker: Vb,
  MonthPicker: zb,
  YearPicker: AFe,
  TimePicker: RFe,
  QuarterPicker: Hb,
  RangePicker: jb
} = gU(nT), DFe = _(Uw, {
  WeekPicker: Vb,
  MonthPicker: zb,
  YearPicker: AFe,
  RangePicker: jb,
  TimePicker: RFe,
  QuarterPicker: Hb,
  install: (e) => (e.component(Uw.name, Uw), e.component(jb.name, jb), e.component(zb.name, zb), e.component(Vb.name, Vb), e.component(Hb.name, Hb), e)
});
function Hg(e) {
  return e != null;
}
const Gw = (e) => {
  const {
    itemPrefixCls: t,
    component: n,
    span: o,
    labelStyle: l,
    contentStyle: r,
    bordered: a,
    label: i,
    content: s,
    colon: c
  } = e, u = n;
  return a ? $(u, {
    class: [{
      [`${t}-item-label`]: Hg(i),
      [`${t}-item-content`]: Hg(s)
    }],
    colSpan: o
  }, {
    default: () => [Hg(i) && $("span", {
      style: l
    }, [i]), Hg(s) && $("span", {
      style: r
    }, [s])]
  }) : $(u, {
    class: [`${t}-item`],
    colSpan: o
  }, {
    default: () => [$("div", {
      class: `${t}-item-container`
    }, [(i || i === 0) && $("span", {
      class: [`${t}-item-label`, {
        [`${t}-item-no-colon`]: !c
      }],
      style: l
    }, [i]), (s || s === 0) && $("span", {
      class: `${t}-item-content`,
      style: r
    }, [s])])]
  });
}, LFe = (e) => {
  const t = (c, u, d) => {
    let {
      colon: f,
      prefixCls: p,
      bordered: m
    } = u, {
      component: v,
      type: h,
      showLabel: g,
      showContent: y,
      labelStyle: b,
      contentStyle: C
    } = d;
    return c.map((w, x) => {
      var E, I;
      const T = w.props || {}, {
        prefixCls: P = p,
        span: k = 1,
        labelStyle: N = T["label-style"],
        contentStyle: R = T["content-style"],
        label: z = (I = (E = w.children) === null || E === void 0 ? void 0 : E.label) === null || I === void 0 ? void 0 : I.call(E)
      } = T, D = nS(w), F = IPe(w), M = Zz(w), {
        key: A
      } = w;
      return typeof v == "string" ? $(Gw, {
        key: `${h}-${String(A) || x}`,
        class: F,
        style: M,
        labelStyle: _(_({}, b), N),
        contentStyle: _(_({}, C), R),
        span: k,
        colon: f,
        component: v,
        itemPrefixCls: P,
        bordered: m,
        label: g ? z : null,
        content: y ? D : null
      }, null) : [$(Gw, {
        key: `label-${String(A) || x}`,
        class: F,
        style: _(_(_({}, b), M), N),
        span: 1,
        colon: f,
        component: v[0],
        itemPrefixCls: P,
        bordered: m,
        label: z
      }, null), $(Gw, {
        key: `content-${String(A) || x}`,
        class: F,
        style: _(_(_({}, C), M), R),
        span: k * 2 - 1,
        component: v[1],
        itemPrefixCls: P,
        bordered: m,
        content: D
      }, null)];
    });
  }, {
    prefixCls: n,
    vertical: o,
    row: l,
    index: r,
    bordered: a
  } = e, {
    labelStyle: i,
    contentStyle: s
  } = ze(SU, {
    labelStyle: /* @__PURE__ */ H({}),
    contentStyle: /* @__PURE__ */ H({})
  });
  return o ? $(Ge, null, [$("tr", {
    key: `label-${r}`,
    class: `${n}-row`
  }, [t(l, e, {
    component: "th",
    type: "label",
    showLabel: !0,
    labelStyle: i.value,
    contentStyle: s.value
  })]), $("tr", {
    key: `content-${r}`,
    class: `${n}-row`
  }, [t(l, e, {
    component: "td",
    type: "content",
    showContent: !0,
    labelStyle: i.value,
    contentStyle: s.value
  })])]) : $("tr", {
    key: r,
    class: `${n}-row`
  }, [t(l, e, {
    component: a ? ["th", "td"] : "td",
    type: "item",
    showLabel: !0,
    showContent: !0,
    labelStyle: i.value,
    contentStyle: s.value
  })]);
}, BFe = (e) => {
  const {
    componentCls: t,
    descriptionsSmallPadding: n,
    descriptionsDefaultPadding: o,
    descriptionsMiddlePadding: l,
    descriptionsBg: r
  } = e;
  return {
    [`&${t}-bordered`]: {
      [`${t}-view`]: {
        border: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`,
        "> table": {
          tableLayout: "auto",
          borderCollapse: "collapse"
        }
      },
      [`${t}-item-label, ${t}-item-content`]: {
        padding: o,
        borderInlineEnd: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`,
        "&:last-child": {
          borderInlineEnd: "none"
        }
      },
      [`${t}-item-label`]: {
        backgroundColor: r,
        "&::after": {
          display: "none"
        }
      },
      [`${t}-row`]: {
        borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`,
        "&:last-child": {
          borderBottom: "none"
        }
      },
      [`&${t}-middle`]: {
        [`${t}-item-label, ${t}-item-content`]: {
          padding: l
        }
      },
      [`&${t}-small`]: {
        [`${t}-item-label, ${t}-item-content`]: {
          padding: n
        }
      }
    }
  };
}, FFe = (e) => {
  const {
    componentCls: t,
    descriptionsExtraColor: n,
    descriptionItemPaddingBottom: o,
    descriptionsItemLabelColonMarginRight: l,
    descriptionsItemLabelColonMarginLeft: r,
    descriptionsTitleMarginBottom: a
  } = e;
  return {
    [t]: _(_(_({}, nn(e)), BFe(e)), {
      "&-rtl": {
        direction: "rtl"
      },
      [`${t}-header`]: {
        display: "flex",
        alignItems: "center",
        marginBottom: a
      },
      [`${t}-title`]: _(_({}, Fo), {
        flex: "auto",
        color: e.colorText,
        fontWeight: e.fontWeightStrong,
        fontSize: e.fontSizeLG,
        lineHeight: e.lineHeightLG
      }),
      [`${t}-extra`]: {
        marginInlineStart: "auto",
        color: n,
        fontSize: e.fontSize
      },
      [`${t}-view`]: {
        width: "100%",
        borderRadius: e.borderRadiusLG,
        table: {
          width: "100%",
          tableLayout: "fixed"
        }
      },
      [`${t}-row`]: {
        "> th, > td": {
          paddingBottom: o
        },
        "&:last-child": {
          borderBottom: "none"
        }
      },
      [`${t}-item-label`]: {
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.fontSize,
        lineHeight: e.lineHeight,
        textAlign: "start",
        "&::after": {
          content: '":"',
          position: "relative",
          top: -0.5,
          marginInline: `${r}px ${l}px`
        },
        [`&${t}-item-no-colon::after`]: {
          content: '""'
        }
      },
      [`${t}-item-no-label`]: {
        "&::after": {
          margin: 0,
          content: '""'
        }
      },
      [`${t}-item-content`]: {
        display: "table-cell",
        flex: 1,
        color: e.colorText,
        fontSize: e.fontSize,
        lineHeight: e.lineHeight,
        wordBreak: "break-word",
        overflowWrap: "break-word"
      },
      [`${t}-item`]: {
        paddingBottom: 0,
        verticalAlign: "top",
        "&-container": {
          display: "flex",
          [`${t}-item-label`]: {
            display: "inline-flex",
            alignItems: "baseline"
          },
          [`${t}-item-content`]: {
            display: "inline-flex",
            alignItems: "baseline"
          }
        }
      },
      "&-middle": {
        [`${t}-row`]: {
          "> th, > td": {
            paddingBottom: e.paddingSM
          }
        }
      },
      "&-small": {
        [`${t}-row`]: {
          "> th, > td": {
            paddingBottom: e.paddingXS
          }
        }
      }
    })
  };
}, VFe = Zt("Descriptions", (e) => {
  const t = e.colorFillAlter, n = e.fontSizeSM * e.lineHeightSM, o = e.colorText, l = `${e.paddingXS}px ${e.padding}px`, r = `${e.padding}px ${e.paddingLG}px`, a = `${e.paddingSM}px ${e.paddingLG}px`, i = e.padding, s = e.marginXS, c = e.marginXXS / 2, u = Vt(e, {
    descriptionsBg: t,
    descriptionsTitleMarginBottom: n,
    descriptionsExtraColor: o,
    descriptionItemPaddingBottom: i,
    descriptionsSmallPadding: l,
    descriptionsDefaultPadding: r,
    descriptionsMiddlePadding: a,
    descriptionsItemLabelColonMarginRight: s,
    descriptionsItemLabelColonMarginLeft: c
  });
  return [FFe(u)];
});
de.any;
const zFe = () => ({
  prefixCls: String,
  label: de.any,
  labelStyle: {
    type: Object,
    default: void 0
  },
  contentStyle: {
    type: Object,
    default: void 0
  },
  span: {
    type: Number,
    default: 1
  }
}), bU = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ADescriptionsItem",
  props: zFe(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), yU = {
  xxxl: 3,
  xxl: 3,
  xl: 3,
  lg: 3,
  md: 3,
  sm: 2,
  xs: 1
};
function HFe(e, t) {
  if (typeof e == "number")
    return e;
  if (typeof e == "object")
    for (let n = 0; n < rs.length; n++) {
      const o = rs[n];
      if (t[o] && e[o] !== void 0)
        return e[o] || yU[o];
    }
  return 3;
}
function fA(e, t, n) {
  let o = e;
  return (n === void 0 || n > t) && (o = _n(e, {
    span: t
  }), Hn(n === void 0, "Descriptions", "Sum of column `span` in a line not match `column` of Descriptions.")), o;
}
function jFe(e, t) {
  const n = Fn(e), o = [];
  let l = [], r = t;
  return n.forEach((a, i) => {
    var s;
    const c = (s = a.props) === null || s === void 0 ? void 0 : s.span, u = c || 1;
    if (i === n.length - 1) {
      l.push(fA(a, r, c)), o.push(l);
      return;
    }
    u < r ? (r -= u, l.push(a)) : (l.push(fA(a, r, u)), o.push(l), r = t, l = []);
  }), o;
}
const WFe = () => ({
  prefixCls: String,
  bordered: {
    type: Boolean,
    default: void 0
  },
  size: {
    type: String,
    default: "default"
  },
  title: de.any,
  extra: de.any,
  column: {
    type: [Number, Object],
    default: () => yU
  },
  layout: String,
  colon: {
    type: Boolean,
    default: void 0
  },
  labelStyle: {
    type: Object,
    default: void 0
  },
  contentStyle: {
    type: Object,
    default: void 0
  }
}), SU = Symbol("descriptionsContext"), Ud = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ADescriptions",
  inheritAttrs: !1,
  props: WFe(),
  slots: Object,
  Item: bU,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("descriptions", e);
    let a;
    const i = /* @__PURE__ */ H({}), [s, c] = VFe(l), u = jI();
    _c(() => {
      a = u.value.subscribe((f) => {
        typeof e.column == "object" && (i.value = f);
      });
    }), yt(() => {
      u.value.unsubscribe(a);
    }), at(SU, {
      labelStyle: /* @__PURE__ */ ft(e, "labelStyle"),
      contentStyle: /* @__PURE__ */ ft(e, "contentStyle")
    });
    const d = O(() => HFe(e.column, i.value));
    return () => {
      var f, p, m;
      const {
        size: v,
        bordered: h = !1,
        layout: g = "horizontal",
        colon: y = !0,
        title: b = (f = n.title) === null || f === void 0 ? void 0 : f.call(n),
        extra: C = (p = n.extra) === null || p === void 0 ? void 0 : p.call(n)
      } = e, w = (m = n.default) === null || m === void 0 ? void 0 : m.call(n), x = jFe(w, d.value);
      return s($("div", Q(Q({}, o), {}, {
        class: [l.value, {
          [`${l.value}-${v}`]: v !== "default",
          [`${l.value}-bordered`]: !!h,
          [`${l.value}-rtl`]: r.value === "rtl"
        }, o.class, c.value]
      }), [(b || C) && $("div", {
        class: `${l.value}-header`
      }, [b && $("div", {
        class: `${l.value}-title`
      }, [b]), C && $("div", {
        class: `${l.value}-extra`
      }, [C])]), $("div", {
        class: `${l.value}-view`
      }, [$("table", null, [$("tbody", null, [x.map((E, I) => $(LFe, {
        key: I,
        index: I,
        colon: y,
        prefixCls: l.value,
        vertical: g === "vertical",
        bordered: h,
        row: E
      }, null))])])])]));
    };
  }
});
Ud.install = function(e) {
  return e.component(Ud.name, Ud), e.component(Ud.Item.name, Ud.Item), e;
};
const KFe = (e) => {
  const {
    componentCls: t,
    sizePaddingEdgeHorizontal: n,
    colorSplit: o,
    lineWidth: l
  } = e;
  return {
    [t]: _(_({}, nn(e)), {
      borderBlockStart: `${l}px solid ${o}`,
      // vertical
      "&-vertical": {
        position: "relative",
        top: "-0.06em",
        display: "inline-block",
        height: "0.9em",
        margin: `0 ${e.dividerVerticalGutterMargin}px`,
        verticalAlign: "middle",
        borderTop: 0,
        borderInlineStart: `${l}px solid ${o}`
      },
      "&-horizontal": {
        display: "flex",
        clear: "both",
        width: "100%",
        minWidth: "100%",
        margin: `${e.dividerHorizontalGutterMargin}px 0`
      },
      [`&-horizontal${t}-with-text`]: {
        display: "flex",
        alignItems: "center",
        margin: `${e.dividerHorizontalWithTextGutterMargin}px 0`,
        color: e.colorTextHeading,
        fontWeight: 500,
        fontSize: e.fontSizeLG,
        whiteSpace: "nowrap",
        textAlign: "center",
        borderBlockStart: `0 ${o}`,
        "&::before, &::after": {
          position: "relative",
          width: "50%",
          borderBlockStart: `${l}px solid transparent`,
          // Chrome not accept `inherit` in `border-top`
          borderBlockStartColor: "inherit",
          borderBlockEnd: 0,
          transform: "translateY(50%)",
          content: "''"
        }
      },
      [`&-horizontal${t}-with-text-left`]: {
        "&::before": {
          width: "5%"
        },
        "&::after": {
          width: "95%"
        }
      },
      [`&-horizontal${t}-with-text-right`]: {
        "&::before": {
          width: "95%"
        },
        "&::after": {
          width: "5%"
        }
      },
      [`${t}-inner-text`]: {
        display: "inline-block",
        padding: "0 1em"
      },
      "&-dashed": {
        background: "none",
        borderColor: o,
        borderStyle: "dashed",
        borderWidth: `${l}px 0 0`
      },
      [`&-horizontal${t}-with-text${t}-dashed`]: {
        "&::before, &::after": {
          borderStyle: "dashed none none"
        }
      },
      [`&-vertical${t}-dashed`]: {
        borderInlineStartWidth: l,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      [`&-plain${t}-with-text`]: {
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.fontSize
      },
      [`&-horizontal${t}-with-text-left${t}-no-default-orientation-margin-left`]: {
        "&::before": {
          width: 0
        },
        "&::after": {
          width: "100%"
        },
        [`${t}-inner-text`]: {
          paddingInlineStart: n
        }
      },
      [`&-horizontal${t}-with-text-right${t}-no-default-orientation-margin-right`]: {
        "&::before": {
          width: "100%"
        },
        "&::after": {
          width: 0
        },
        [`${t}-inner-text`]: {
          paddingInlineEnd: n
        }
      }
    })
  };
}, UFe = Zt("Divider", (e) => {
  const t = Vt(e, {
    dividerVerticalGutterMargin: e.marginXS,
    dividerHorizontalWithTextGutterMargin: e.margin,
    dividerHorizontalGutterMargin: e.marginLG
  });
  return [KFe(t)];
}, {
  sizePaddingEdgeHorizontal: 0
}), GFe = () => ({
  prefixCls: String,
  type: {
    type: String,
    default: "horizontal"
  },
  dashed: {
    type: Boolean,
    default: !1
  },
  orientation: {
    type: String,
    default: "center"
  },
  plain: {
    type: Boolean,
    default: !1
  },
  orientationMargin: [String, Number]
}), YFe = /* @__PURE__ */ le({
  name: "ADivider",
  inheritAttrs: !1,
  compatConfig: {
    MODE: 3
  },
  props: GFe(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("divider", e), [a, i] = UFe(l), s = O(() => e.orientation === "left" && e.orientationMargin != null), c = O(() => e.orientation === "right" && e.orientationMargin != null), u = O(() => {
      const {
        type: p,
        dashed: m,
        plain: v
      } = e, h = l.value;
      return {
        [h]: !0,
        [i.value]: !!i.value,
        [`${h}-${p}`]: !0,
        [`${h}-dashed`]: !!m,
        [`${h}-plain`]: !!v,
        [`${h}-rtl`]: r.value === "rtl",
        [`${h}-no-default-orientation-margin-left`]: s.value,
        [`${h}-no-default-orientation-margin-right`]: c.value
      };
    }), d = O(() => {
      const p = typeof e.orientationMargin == "number" ? `${e.orientationMargin}px` : e.orientationMargin;
      return _(_({}, s.value && {
        marginLeft: p
      }), c.value && {
        marginRight: p
      });
    }), f = O(() => e.orientation.length > 0 ? "-" + e.orientation : e.orientation);
    return () => {
      var p;
      const m = Fn((p = n.default) === null || p === void 0 ? void 0 : p.call(n));
      return a($("div", Q(Q({}, o), {}, {
        class: [u.value, m.length ? `${l.value}-with-text ${l.value}-with-text${f.value}` : "", o.class],
        role: "separator"
      }), [m.length ? $("span", {
        class: `${l.value}-inner-text`,
        style: d.value
      }, [m]) : null]));
    };
  }
}), XFe = po(YFe);
Ia.Button = Dm;
Ia.install = function(e) {
  return e.component(Ia.name, Ia), e.component(Dm.name, Dm), e;
};
const CU = () => ({
  prefixCls: String,
  width: de.oneOfType([de.string, de.number]),
  height: de.oneOfType([de.string, de.number]),
  style: {
    type: Object,
    default: void 0
  },
  class: String,
  rootClassName: String,
  rootStyle: Nt(),
  placement: {
    type: String
  },
  wrapperClassName: String,
  level: {
    type: [String, Array]
  },
  levelMove: {
    type: [Number, Function, Array]
  },
  duration: String,
  ease: String,
  showMask: {
    type: Boolean,
    default: void 0
  },
  maskClosable: {
    type: Boolean,
    default: void 0
  },
  maskStyle: {
    type: Object,
    default: void 0
  },
  afterVisibleChange: Function,
  keyboard: {
    type: Boolean,
    default: void 0
  },
  contentWrapperStyle: $n(),
  autofocus: {
    type: Boolean,
    default: void 0
  },
  open: {
    type: Boolean,
    default: void 0
  },
  // Motion
  motion: Fe(),
  maskMotion: Nt()
}), qFe = () => _(_({}, CU()), {
  forceRender: {
    type: Boolean,
    default: void 0
  },
  getContainer: de.oneOfType([de.string, de.func, de.object, de.looseBool])
}), JFe = () => _(_({}, CU()), {
  getContainer: Function,
  getOpenCount: Function,
  scrollLocker: de.any,
  inline: Boolean
});
function ZFe(e) {
  return Array.isArray(e) ? e : [e];
}
const QFe = {
  transition: "transitionend",
  WebkitTransition: "webkitTransitionEnd",
  MozTransition: "transitionend",
  OTransition: "oTransitionEnd otransitionend"
};
Object.keys(QFe).filter((e) => {
  if (typeof document == "undefined")
    return !1;
  const t = document.getElementsByTagName("html")[0];
  return e in (t ? t.style : {});
})[0];
const e9e = !(typeof window != "undefined" && window.document && window.document.createElement);
var t9e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const pA = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: JFe(),
  emits: ["close", "handleClick", "change"],
  setup(e, t) {
    let {
      emit: n,
      slots: o
    } = t;
    const l = /* @__PURE__ */ Ce(), r = /* @__PURE__ */ Ce(), a = /* @__PURE__ */ Ce(), i = /* @__PURE__ */ Ce(), s = /* @__PURE__ */ Ce();
    let c = [];
    `${Number((Date.now() + Math.random()).toString().replace(".", Math.round(Math.random() * 9).toString())).toString(16)}`, nt(() => {
      Ke(() => {
        var g;
        const {
          open: y,
          getContainer: b,
          showMask: C,
          autofocus: w
        } = e, x = b == null ? void 0 : b();
        m(e), y && (x && (x.parentNode, document.body), Ke(() => {
          w && u();
        }), C && ((g = e.scrollLocker) === null || g === void 0 || g.lock()));
      });
    }), pe(() => e.level, () => {
      m(e);
    }, {
      flush: "post"
    }), pe(() => e.open, () => {
      const {
        open: g,
        getContainer: y,
        scrollLocker: b,
        showMask: C,
        autofocus: w
      } = e, x = y == null ? void 0 : y();
      x && (x.parentNode, document.body), g ? (w && u(), C && (b == null || b.lock())) : b == null || b.unLock();
    }, {
      flush: "post"
    }), Uo(() => {
      var g;
      const {
        open: y
      } = e;
      y && (document.body.style.touchAction = ""), (g = e.scrollLocker) === null || g === void 0 || g.unLock();
    }), pe(() => e.placement, (g) => {
      g && (s.value = null);
    });
    const u = () => {
      var g, y;
      (y = (g = r.value) === null || g === void 0 ? void 0 : g.focus) === null || y === void 0 || y.call(g);
    }, d = (g) => {
      n("close", g);
    }, f = (g) => {
      g.keyCode === ot.ESC && (g.stopPropagation(), d(g));
    }, p = () => {
      const {
        open: g,
        afterVisibleChange: y
      } = e;
      y && y(!!g);
    }, m = (g) => {
      let {
        level: y,
        getContainer: b
      } = g;
      if (e9e)
        return;
      const C = b == null ? void 0 : b(), w = C ? C.parentNode : null;
      c = [], y === "all" ? (w ? Array.prototype.slice.call(w.children) : []).forEach((E) => {
        E.nodeName !== "SCRIPT" && E.nodeName !== "STYLE" && E.nodeName !== "LINK" && E !== C && c.push(E);
      }) : y && ZFe(y).forEach((x) => {
        document.querySelectorAll(x).forEach((E) => {
          c.push(E);
        });
      });
    }, v = (g) => {
      n("handleClick", g);
    }, h = /* @__PURE__ */ Ce(!1);
    return pe(r, () => {
      Ke(() => {
        h.value = !0;
      });
    }), () => {
      var g, y;
      const {
        width: b,
        height: C,
        open: w,
        prefixCls: x,
        placement: E,
        level: I,
        levelMove: T,
        ease: P,
        duration: k,
        getContainer: N,
        onChange: R,
        afterVisibleChange: z,
        showMask: D,
        maskClosable: F,
        maskStyle: M,
        keyboard: A,
        getOpenCount: L,
        scrollLocker: B,
        contentWrapperStyle: V,
        style: j,
        class: W,
        rootClassName: Y,
        rootStyle: U,
        maskMotion: te,
        motion: J,
        inline: re
      } = e, oe = t9e(e, ["width", "height", "open", "prefixCls", "placement", "level", "levelMove", "ease", "duration", "getContainer", "onChange", "afterVisibleChange", "showMask", "maskClosable", "maskStyle", "keyboard", "getOpenCount", "scrollLocker", "contentWrapperStyle", "style", "class", "rootClassName", "rootStyle", "maskMotion", "motion", "inline"]), q = w && h.value, K = ke(x, {
        [`${x}-${E}`]: !0,
        [`${x}-open`]: q,
        [`${x}-inline`]: re,
        "no-mask": !D,
        [Y]: !0
      }), se = typeof J == "function" ? J(E) : J;
      return $("div", Q(Q({}, pn(oe, ["autofocus"])), {}, {
        tabindex: -1,
        class: K,
        style: U,
        ref: r,
        onKeydown: q && A ? f : void 0
      }), [$(Vn, te, {
        default: () => [D && _t($("div", {
          class: `${x}-mask`,
          onClick: F ? d : void 0,
          style: M,
          ref: a
        }, null), [[Jt, q]])]
      }), $(Vn, Q(Q({}, se), {}, {
        onAfterEnter: p,
        onAfterLeave: p
      }), {
        default: () => [_t($("div", {
          class: `${x}-content-wrapper`,
          style: [V],
          ref: l
        }, [$("div", {
          class: [`${x}-content`, W],
          style: j,
          ref: s
        }, [(g = o.default) === null || g === void 0 ? void 0 : g.call(o)]), o.handler ? $("div", {
          onClick: v,
          ref: i
        }, [(y = o.handler) === null || y === void 0 ? void 0 : y.call(o)]) : null]), [[Jt, q]])]
      })]);
    };
  }
});
var vA = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const n9e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: sn(qFe(), {
    prefixCls: "drawer",
    placement: "left",
    getContainer: "body",
    level: "all",
    duration: ".3s",
    ease: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    afterVisibleChange: () => {
    },
    showMask: !0,
    maskClosable: !0,
    maskStyle: {},
    wrapperClassName: "",
    keyboard: !0,
    forceRender: !1,
    autofocus: !0
  }),
  emits: ["handleClick", "close"],
  setup(e, t) {
    let {
      emit: n,
      slots: o
    } = t;
    const l = /* @__PURE__ */ H(null), r = (i) => {
      n("handleClick", i);
    }, a = (i) => {
      n("close", i);
    };
    return () => {
      const {
        getContainer: i,
        wrapperClassName: s,
        rootClassName: c,
        rootStyle: u,
        forceRender: d
      } = e, f = vA(e, ["getContainer", "wrapperClassName", "rootClassName", "rootStyle", "forceRender"]);
      let p = null;
      if (!i)
        return $(pA, Q(Q({}, f), {}, {
          rootClassName: c,
          rootStyle: u,
          open: e.open,
          onClose: a,
          onHandleClick: r,
          inline: !0
        }), o);
      const m = !!o.handler || d;
      return (m || e.open || l.value) && (p = $(Eh, {
        autoLock: !0,
        visible: e.open,
        forceRender: m,
        getContainer: i,
        wrapperClassName: s
      }, {
        default: (v) => {
          var {
            visible: h,
            afterClose: g
          } = v, y = vA(v, ["visible", "afterClose"]);
          return $(pA, Q(Q(Q({
            ref: l
          }, f), y), {}, {
            rootClassName: c,
            rootStyle: u,
            open: h !== void 0 ? h : e.open,
            afterVisibleChange: g !== void 0 ? g : e.afterVisibleChange,
            onClose: a,
            onHandleClick: r
          }), o);
        }
      })), p;
    };
  }
}), o9e = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n
  } = e, o = {
    "&-enter, &-appear, &-leave": {
      "&-start": {
        transition: "none"
      },
      "&-active": {
        transition: `all ${n}`
      }
    }
  };
  return {
    [t]: {
      // ======================== Mask ========================
      [`${t}-mask-motion`]: {
        "&-enter, &-appear, &-leave": {
          "&-active": {
            transition: `all ${n}`
          }
        },
        "&-enter, &-appear": {
          opacity: 0,
          "&-active": {
            opacity: 1
          }
        },
        "&-leave": {
          opacity: 1,
          "&-active": {
            opacity: 0
          }
        }
      },
      // ======================= Panel ========================
      [`${t}-panel-motion`]: {
        // Left
        "&-left": [o, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateX(-100%) !important"
            },
            "&-active": {
              transform: "translateX(0)"
            }
          },
          "&-leave": {
            transform: "translateX(0)",
            "&-active": {
              transform: "translateX(-100%)"
            }
          }
        }],
        // Right
        "&-right": [o, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateX(100%) !important"
            },
            "&-active": {
              transform: "translateX(0)"
            }
          },
          "&-leave": {
            transform: "translateX(0)",
            "&-active": {
              transform: "translateX(100%)"
            }
          }
        }],
        // Top
        "&-top": [o, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateY(-100%) !important"
            },
            "&-active": {
              transform: "translateY(0)"
            }
          },
          "&-leave": {
            transform: "translateY(0)",
            "&-active": {
              transform: "translateY(-100%)"
            }
          }
        }],
        // Bottom
        "&-bottom": [o, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateY(100%) !important"
            },
            "&-active": {
              transform: "translateY(0)"
            }
          },
          "&-leave": {
            transform: "translateY(0)",
            "&-active": {
              transform: "translateY(100%)"
            }
          }
        }]
      }
    }
  };
}, l9e = (e) => {
  const {
    componentCls: t,
    zIndexPopup: n,
    colorBgMask: o,
    colorBgElevated: l,
    motionDurationSlow: r,
    motionDurationMid: a,
    padding: i,
    paddingLG: s,
    fontSizeLG: c,
    lineHeightLG: u,
    lineWidth: d,
    lineType: f,
    colorSplit: p,
    marginSM: m,
    colorIcon: v,
    colorIconHover: h,
    colorText: g,
    fontWeightStrong: y,
    drawerFooterPaddingVertical: b,
    drawerFooterPaddingHorizontal: C
  } = e, w = `${t}-content-wrapper`;
  return {
    [t]: {
      position: "fixed",
      inset: 0,
      zIndex: n,
      pointerEvents: "none",
      "&-pure": {
        position: "relative",
        background: l,
        [`&${t}-left`]: {
          boxShadow: e.boxShadowDrawerLeft
        },
        [`&${t}-right`]: {
          boxShadow: e.boxShadowDrawerRight
        },
        [`&${t}-top`]: {
          boxShadow: e.boxShadowDrawerUp
        },
        [`&${t}-bottom`]: {
          boxShadow: e.boxShadowDrawerDown
        }
      },
      "&-inline": {
        position: "absolute"
      },
      // ====================== Mask ======================
      [`${t}-mask`]: {
        position: "absolute",
        inset: 0,
        zIndex: n,
        background: o,
        pointerEvents: "auto"
      },
      // ==================== Content =====================
      [w]: {
        position: "absolute",
        zIndex: n,
        transition: `all ${r}`,
        "&-hidden": {
          display: "none"
        }
      },
      // Placement
      [`&-left > ${w}`]: {
        top: 0,
        bottom: 0,
        left: {
          _skip_check_: !0,
          value: 0
        },
        boxShadow: e.boxShadowDrawerLeft
      },
      [`&-right > ${w}`]: {
        top: 0,
        right: {
          _skip_check_: !0,
          value: 0
        },
        bottom: 0,
        boxShadow: e.boxShadowDrawerRight
      },
      [`&-top > ${w}`]: {
        top: 0,
        insetInline: 0,
        boxShadow: e.boxShadowDrawerUp
      },
      [`&-bottom > ${w}`]: {
        bottom: 0,
        insetInline: 0,
        boxShadow: e.boxShadowDrawerDown
      },
      [`${t}-content`]: {
        width: "100%",
        height: "100%",
        overflow: "auto",
        background: l,
        pointerEvents: "auto"
      },
      // ===================== Panel ======================
      [`${t}-wrapper-body`]: {
        display: "flex",
        flexDirection: "column",
        width: "100%",
        height: "100%"
      },
      // Header
      [`${t}-header`]: {
        display: "flex",
        flex: 0,
        alignItems: "center",
        padding: `${i}px ${s}px`,
        fontSize: c,
        lineHeight: u,
        borderBottom: `${d}px ${f} ${p}`,
        "&-title": {
          display: "flex",
          flex: 1,
          alignItems: "center",
          minWidth: 0,
          minHeight: 0
        }
      },
      [`${t}-extra`]: {
        flex: "none"
      },
      [`${t}-close`]: {
        display: "inline-block",
        marginInlineEnd: m,
        color: v,
        fontWeight: y,
        fontSize: c,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        textDecoration: "none",
        background: "transparent",
        border: 0,
        outline: 0,
        cursor: "pointer",
        transition: `color ${a}`,
        textRendering: "auto",
        "&:focus, &:hover": {
          color: h,
          textDecoration: "none"
        }
      },
      [`${t}-title`]: {
        flex: 1,
        margin: 0,
        color: g,
        fontWeight: e.fontWeightStrong,
        fontSize: c,
        lineHeight: u
      },
      // Body
      [`${t}-body`]: {
        flex: 1,
        minWidth: 0,
        minHeight: 0,
        padding: s,
        overflow: "auto"
      },
      // Footer
      [`${t}-footer`]: {
        flexShrink: 0,
        padding: `${b}px ${C}px`,
        borderTop: `${d}px ${f} ${p}`
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
}, r9e = Zt("Drawer", (e) => {
  const t = Vt(e, {
    drawerFooterPaddingVertical: e.paddingXS,
    drawerFooterPaddingHorizontal: e.padding
  });
  return [l9e(t), o9e(t)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase
}));
var a9e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const i9e = ["top", "right", "bottom", "left"], mA = {
  distance: 180
}, s9e = () => ({
  autofocus: {
    type: Boolean,
    default: void 0
  },
  closable: {
    type: Boolean,
    default: void 0
  },
  closeIcon: de.any,
  destroyOnClose: {
    type: Boolean,
    default: void 0
  },
  forceRender: {
    type: Boolean,
    default: void 0
  },
  getContainer: {
    type: [String, Function, Boolean, Object],
    default: void 0
  },
  maskClosable: {
    type: Boolean,
    default: void 0
  },
  mask: {
    type: Boolean,
    default: void 0
  },
  maskStyle: Nt(),
  rootClassName: String,
  rootStyle: Nt(),
  size: {
    type: String
  },
  drawerStyle: Nt(),
  headerStyle: Nt(),
  bodyStyle: Nt(),
  contentWrapperStyle: {
    type: Object,
    default: void 0
  },
  title: de.any,
  /** @deprecated Please use `open` instead */
  visible: {
    type: Boolean,
    default: void 0
  },
  open: {
    type: Boolean,
    default: void 0
  },
  width: de.oneOfType([de.string, de.number]),
  height: de.oneOfType([de.string, de.number]),
  zIndex: Number,
  prefixCls: String,
  push: de.oneOfType([de.looseBool, {
    type: Object
  }]),
  placement: de.oneOf(i9e),
  keyboard: {
    type: Boolean,
    default: void 0
  },
  extra: de.any,
  footer: de.any,
  footerStyle: Nt(),
  level: de.any,
  levelMove: {
    type: [Number, Array, Function]
  },
  handle: de.any,
  /** @deprecated Use `@afterVisibleChange` instead */
  afterVisibleChange: Function,
  /** @deprecated Please use `@afterOpenChange` instead */
  onAfterVisibleChange: Function,
  onAfterOpenChange: Function,
  /** @deprecated Please use `onUpdate:open` instead */
  "onUpdate:visible": Function,
  "onUpdate:open": Function,
  onClose: Function
}), c9e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ADrawer",
  inheritAttrs: !1,
  props: sn(s9e(), {
    closable: !0,
    placement: "right",
    maskClosable: !0,
    mask: !0,
    level: null,
    keyboard: !0,
    push: mA
  }),
  slots: Object,
  // emits: ['update:visible', 'close', 'afterVisibleChange'],
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      attrs: l
    } = t;
    const r = /* @__PURE__ */ Ce(!1), a = /* @__PURE__ */ Ce(!1), i = /* @__PURE__ */ Ce(null), s = /* @__PURE__ */ Ce(!1), c = /* @__PURE__ */ Ce(!1), u = O(() => {
      var L;
      return (L = e.open) !== null && L !== void 0 ? L : e.visible;
    });
    pe(u, () => {
      u.value ? s.value = !0 : c.value = !1;
    }, {
      immediate: !0
    }), pe([u, s], () => {
      u.value && s.value && (c.value = !0);
    }, {
      immediate: !0
    });
    const d = ze("parentDrawerOpts", null), {
      prefixCls: f,
      getPopupContainer: p,
      direction: m
    } = bt("drawer", e), [v, h] = r9e(f), g = O(() => (
      //  false
      e.getContainer === void 0 && (p != null && p.value) ? () => p.value(document.body) : e.getContainer
    ));
    un(!e.afterVisibleChange, "Drawer", "`afterVisibleChange` prop is deprecated, please use `@afterVisibleChange` event instead"), process.env.NODE_ENV !== "production" && [["visible", "open"], ["onUpdate:visible", "onUpdate:open"], ["onAfterVisibleChange", "onAfterOpenChange"]].forEach((L) => {
      let [B, V] = L;
      un(!e[B], "Drawer", `\`${B}\` is deprecated, please use \`${V}\` instead.`);
    }), at("parentDrawerOpts", {
      setPush: () => {
        r.value = !0;
      },
      setPull: () => {
        r.value = !1, Ke(() => {
          C();
        });
      }
    }), nt(() => {
      u.value && d && d.setPush();
    }), Uo(() => {
      d && d.setPull();
    }), pe(c, () => {
      d && (c.value ? d.setPush() : d.setPull());
    }, {
      flush: "post"
    });
    const C = () => {
      var L, B;
      (B = (L = i.value) === null || L === void 0 ? void 0 : L.domFocus) === null || B === void 0 || B.call(L);
    }, w = (L) => {
      n("update:visible", !1), n("update:open", !1), n("close", L);
    }, x = (L) => {
      var B;
      L || (a.value === !1 && (a.value = !0), e.destroyOnClose && (s.value = !1)), (B = e.afterVisibleChange) === null || B === void 0 || B.call(e, L), n("afterVisibleChange", L), n("afterOpenChange", L);
    }, E = O(() => {
      const {
        push: L,
        placement: B
      } = e;
      let V;
      return typeof L == "boolean" ? V = L ? mA.distance : 0 : V = L.distance, V = parseFloat(String(V || 0)), B === "left" || B === "right" ? `translateX(${B === "left" ? V : -V}px)` : B === "top" || B === "bottom" ? `translateY(${B === "top" ? V : -V}px)` : null;
    }), I = O(() => {
      var L;
      return (L = e.width) !== null && L !== void 0 ? L : e.size === "large" ? 736 : 378;
    }), T = O(() => {
      var L;
      return (L = e.height) !== null && L !== void 0 ? L : e.size === "large" ? 736 : 378;
    }), P = O(() => {
      const {
        mask: L,
        placement: B
      } = e;
      if (!c.value && !L)
        return {};
      const V = {};
      return B === "left" || B === "right" ? V.width = yy(I.value) ? `${I.value}px` : I.value : V.height = yy(T.value) ? `${T.value}px` : T.value, V;
    }), k = O(() => {
      const {
        zIndex: L,
        contentWrapperStyle: B
      } = e, V = P.value;
      return [{
        zIndex: L,
        transform: r.value ? E.value : void 0
      }, _({}, B), V];
    }), N = (L) => {
      const {
        closable: B,
        headerStyle: V
      } = e, j = Wo(o, e, "extra"), W = Wo(o, e, "title");
      return !W && !B ? null : $("div", {
        class: ke(`${L}-header`, {
          [`${L}-header-close-only`]: B && !W && !j
        }),
        style: V
      }, [$("div", {
        class: `${L}-header-title`
      }, [R(L), W && $("div", {
        class: `${L}-title`
      }, [W])]), j && $("div", {
        class: `${L}-extra`
      }, [j])]);
    }, R = (L) => {
      var B;
      const {
        closable: V
      } = e, j = o.closeIcon ? (B = o.closeIcon) === null || B === void 0 ? void 0 : B.call(o) : e.closeIcon;
      return V && $("button", {
        key: "closer",
        onClick: w,
        "aria-label": "Close",
        class: `${L}-close`
      }, [j === void 0 ? $(Hl, null, null) : j]);
    }, z = (L) => {
      var B;
      if (a.value && !e.forceRender && !s.value)
        return null;
      const {
        bodyStyle: V,
        drawerStyle: j
      } = e;
      return $("div", {
        class: `${L}-wrapper-body`,
        style: j
      }, [N(L), $("div", {
        key: "body",
        class: `${L}-body`,
        style: V
      }, [(B = o.default) === null || B === void 0 ? void 0 : B.call(o)]), D(L)]);
    }, D = (L) => {
      const B = Wo(o, e, "footer");
      if (!B)
        return null;
      const V = `${L}-footer`;
      return $("div", {
        class: V,
        style: e.footerStyle
      }, [B]);
    }, F = O(() => ke({
      "no-mask": !e.mask,
      [`${f.value}-rtl`]: m.value === "rtl"
    }, e.rootClassName, h.value)), M = O(() => da(Vl(f.value, "mask-motion"))), A = (L) => da(Vl(f.value, `panel-motion-${L}`));
    return () => {
      const {
        width: L,
        height: B,
        placement: V,
        mask: j,
        forceRender: W
      } = e, Y = a9e(e, ["width", "height", "placement", "mask", "forceRender"]), U = _(_(_({}, l), pn(Y, ["size", "closeIcon", "closable", "destroyOnClose", "drawerStyle", "headerStyle", "bodyStyle", "title", "push", "onAfterVisibleChange", "onClose", "onUpdate:visible", "onUpdate:open", "visible"])), {
        forceRender: W,
        onClose: w,
        afterVisibleChange: x,
        handler: !1,
        prefixCls: f.value,
        open: c.value,
        showMask: j,
        placement: V,
        ref: i
      });
      return v($(Rm, null, {
        default: () => [$(n9e, Q(Q({}, U), {}, {
          maskMotion: M.value,
          motion: A,
          width: I.value,
          height: T.value,
          getContainer: g.value,
          rootClassName: F.value,
          rootStyle: e.rootStyle,
          contentWrapperStyle: k.value
        }), {
          handler: e.handle ? () => e.handle : o.handle,
          default: () => z(f.value)
        })]
      }));
    };
  }
}), u9e = po(c9e);
var d9e = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM504 618H320c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM312 490v48c0 4.4 3.6 8 8 8h384c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H320c-4.4 0-8 3.6-8 8z" } }] }, name: "file-text", theme: "outlined" };
function hA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      f9e(e, l, n[l]);
    });
  }
  return e;
}
function f9e(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var YS = function(t, n) {
  var o = hA({}, t, n.attrs);
  return $(cn, hA({}, o, {
    icon: d9e
  }), null);
};
YS.displayName = "FileTextOutlined";
YS.inheritAttrs = !1;
const GT = () => ({
  prefixCls: String,
  description: de.any,
  type: At("default"),
  shape: At("circle"),
  tooltip: de.any,
  href: String,
  target: String,
  badge: Nt(),
  onClick: Fe()
}), p9e = () => ({
  prefixCls: At()
}), v9e = () => _(_({}, GT()), {
  //  Float Button
  //  (
  trigger: At(),
  // 
  open: Qe(),
  // 
  onOpenChange: Fe(),
  "onUpdate:open": Fe()
}), m9e = () => _(_({}, GT()), {
  prefixCls: String,
  duration: Number,
  target: Fe(),
  visibilityHeight: Number,
  onClick: Fe()
}), h9e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AFloatButtonContent",
  inheritAttrs: !1,
  props: p9e(),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    return () => {
      var l;
      const {
        prefixCls: r
      } = e, a = mo((l = o.description) === null || l === void 0 ? void 0 : l.call(o));
      return $("div", Q(Q({}, n), {}, {
        class: [n.class, `${r}-content`]
      }), [o.icon || a.length ? $(Ge, null, [o.icon && $("div", {
        class: `${r}-icon`
      }, [o.icon()]), a.length ? $("div", {
        class: `${r}-description`
      }, [a]) : null]) : $("div", {
        class: `${r}-icon`
      }, [$(YS, null, null)])]);
    };
  }
}), wU = Symbol("floatButtonGroupContext"), g9e = (e) => (at(wU, e), e), $U = () => ze(wU, {
  shape: /* @__PURE__ */ H()
}), gA = (e) => e === 0 ? 0 : e - Math.sqrt(Math.pow(e, 2) / 2), b9e = (e) => {
  const {
    componentCls: t,
    floatButtonSize: n,
    motionDurationSlow: o,
    motionEaseInOutCirc: l
  } = e, r = `${t}-group`, a = new mn("antFloatButtonMoveDownIn", {
    "0%": {
      transform: `translate3d(0, ${n}px, 0)`,
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  }), i = new mn("antFloatButtonMoveDownOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: `translate3d(0, ${n}px, 0)`,
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  return [{
    [`${r}-wrap`]: _({}, _h(`${r}-wrap`, a, i, o, !0))
  }, {
    [`${r}-wrap`]: {
      [`
          &${r}-wrap-enter,
          &${r}-wrap-appear
        `]: {
        opacity: 0,
        animationTimingFunction: l
      },
      [`&${r}-wrap-leave`]: {
        animationTimingFunction: l
      }
    }
  }];
}, y9e = (e) => {
  const {
    antCls: t,
    componentCls: n,
    floatButtonSize: o,
    margin: l,
    borderRadiusLG: r,
    borderRadiusSM: a,
    badgeOffset: i,
    floatButtonBodyPadding: s
  } = e, c = `${n}-group`;
  return {
    [c]: _(_({}, nn(e)), {
      zIndex: 99,
      display: "block",
      border: "none",
      position: "fixed",
      width: o,
      height: "auto",
      boxShadow: "none",
      minHeight: o,
      insetInlineEnd: e.floatButtonInsetInlineEnd,
      insetBlockEnd: e.floatButtonInsetBlockEnd,
      borderRadius: r,
      [`${c}-wrap`]: {
        zIndex: -1,
        display: "block",
        position: "relative",
        marginBottom: l
      },
      [`&${c}-rtl`]: {
        direction: "rtl"
      },
      [n]: {
        position: "static"
      }
    }),
    [`${c}-circle`]: {
      [`${n}-circle:not(:last-child)`]: {
        marginBottom: e.margin,
        [`${n}-body`]: {
          width: o,
          height: o,
          borderRadius: "50%"
        }
      }
    },
    [`${c}-square`]: {
      [`${n}-square`]: {
        borderRadius: 0,
        padding: 0,
        "&:first-child": {
          borderStartStartRadius: r,
          borderStartEndRadius: r
        },
        "&:last-child": {
          borderEndStartRadius: r,
          borderEndEndRadius: r
        },
        "&:not(:last-child)": {
          borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`
        },
        [`${t}-badge`]: {
          [`${t}-badge-count`]: {
            top: -(s + i),
            insetInlineEnd: -(s + i)
          }
        }
      },
      [`${c}-wrap`]: {
        display: "block",
        borderRadius: r,
        boxShadow: e.boxShadowSecondary,
        [`${n}-square`]: {
          boxShadow: "none",
          marginTop: 0,
          borderRadius: 0,
          padding: s,
          "&:first-child": {
            borderStartStartRadius: r,
            borderStartEndRadius: r
          },
          "&:last-child": {
            borderEndStartRadius: r,
            borderEndEndRadius: r
          },
          "&:not(:last-child)": {
            borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`
          },
          [`${n}-body`]: {
            width: e.floatButtonBodySize,
            height: e.floatButtonBodySize
          }
        }
      }
    },
    [`${c}-circle-shadow`]: {
      boxShadow: "none"
    },
    [`${c}-square-shadow`]: {
      boxShadow: e.boxShadowSecondary,
      [`${n}-square`]: {
        boxShadow: "none",
        padding: s,
        [`${n}-body`]: {
          width: e.floatButtonBodySize,
          height: e.floatButtonBodySize,
          borderRadius: a
        }
      }
    }
  };
}, S9e = (e) => {
  const {
    antCls: t,
    componentCls: n,
    floatButtonBodyPadding: o,
    floatButtonIconSize: l,
    floatButtonSize: r,
    borderRadiusLG: a,
    badgeOffset: i,
    dotOffsetInSquare: s,
    dotOffsetInCircle: c
  } = e;
  return {
    [n]: _(_({}, nn(e)), {
      border: "none",
      position: "fixed",
      cursor: "pointer",
      zIndex: 99,
      display: "block",
      justifyContent: "center",
      alignItems: "center",
      width: r,
      height: r,
      insetInlineEnd: e.floatButtonInsetInlineEnd,
      insetBlockEnd: e.floatButtonInsetBlockEnd,
      boxShadow: e.boxShadowSecondary,
      // Pure Panel
      "&-pure": {
        position: "relative",
        inset: "auto"
      },
      "&:empty": {
        display: "none"
      },
      [`${t}-badge`]: {
        width: "100%",
        height: "100%",
        [`${t}-badge-count`]: {
          transform: "translate(0, 0)",
          transformOrigin: "center",
          top: -i,
          insetInlineEnd: -i
        }
      },
      [`${n}-body`]: {
        width: "100%",
        height: "100%",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        transition: `all ${e.motionDurationMid}`,
        [`${n}-content`]: {
          overflow: "hidden",
          textAlign: "center",
          minHeight: r,
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          padding: `${o / 2}px ${o}px`,
          [`${n}-icon`]: {
            textAlign: "center",
            margin: "auto",
            width: l,
            fontSize: l,
            lineHeight: 1
          }
        }
      }
    }),
    [`${n}-rtl`]: {
      direction: "rtl"
    },
    [`${n}-circle`]: {
      height: r,
      borderRadius: "50%",
      [`${t}-badge`]: {
        [`${t}-badge-dot`]: {
          top: c,
          insetInlineEnd: c
        }
      },
      [`${n}-body`]: {
        borderRadius: "50%"
      }
    },
    [`${n}-square`]: {
      height: "auto",
      minHeight: r,
      borderRadius: a,
      [`${t}-badge`]: {
        [`${t}-badge-dot`]: {
          top: s,
          insetInlineEnd: s
        }
      },
      [`${n}-body`]: {
        height: "auto",
        borderRadius: a
      }
    },
    [`${n}-default`]: {
      backgroundColor: e.floatButtonBackgroundColor,
      transition: `background-color ${e.motionDurationMid}`,
      [`${n}-body`]: {
        backgroundColor: e.floatButtonBackgroundColor,
        transition: `background-color ${e.motionDurationMid}`,
        "&:hover": {
          backgroundColor: e.colorFillContent
        },
        [`${n}-content`]: {
          [`${n}-icon`]: {
            color: e.colorText
          },
          [`${n}-description`]: {
            display: "flex",
            alignItems: "center",
            lineHeight: `${e.fontSizeLG}px`,
            color: e.colorText,
            fontSize: e.fontSizeSM
          }
        }
      }
    },
    [`${n}-primary`]: {
      backgroundColor: e.colorPrimary,
      [`${n}-body`]: {
        backgroundColor: e.colorPrimary,
        transition: `background-color ${e.motionDurationMid}`,
        "&:hover": {
          backgroundColor: e.colorPrimaryHover
        },
        [`${n}-content`]: {
          [`${n}-icon`]: {
            color: e.colorTextLightSolid
          },
          [`${n}-description`]: {
            display: "flex",
            alignItems: "center",
            lineHeight: `${e.fontSizeLG}px`,
            color: e.colorTextLightSolid,
            fontSize: e.fontSizeSM
          }
        }
      }
    }
  };
}, YT = Zt("FloatButton", (e) => {
  const {
    colorTextLightSolid: t,
    colorBgElevated: n,
    controlHeightLG: o,
    marginXXL: l,
    marginLG: r,
    fontSize: a,
    fontSizeIcon: i,
    controlItemBgHover: s,
    paddingXXS: c,
    borderRadiusLG: u
  } = e, d = Vt(e, {
    floatButtonBackgroundColor: n,
    floatButtonColor: t,
    floatButtonHoverBackgroundColor: s,
    floatButtonFontSize: a,
    floatButtonIconSize: i * 1.5,
    floatButtonSize: o,
    floatButtonInsetBlockEnd: l,
    floatButtonInsetInlineEnd: r,
    floatButtonBodySize: o - c * 2,
    //  paddingXXS  (controlHeightLG - (controlHeightLG - paddingXXS * 2)) / 2,
    floatButtonBodyPadding: c,
    badgeOffset: c * 1.5,
    dotOffsetInCircle: gA(o / 2),
    dotOffsetInSquare: gA(u)
  });
  return [y9e(d), S9e(d), VI(e), b9e(d)];
});
var C9e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const XT = "float-btn", pc = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AFloatButton",
  inheritAttrs: !1,
  props: sn(GT(), {
    type: "default",
    shape: "circle"
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt(XT, e), [a, i] = YT(l), {
      shape: s
    } = $U(), c = /* @__PURE__ */ H(null), u = O(() => (s == null ? void 0 : s.value) || e.shape);
    return () => {
      var d;
      const {
        prefixCls: f,
        type: p = "default",
        shape: m = "circle",
        description: v = (d = o.description) === null || d === void 0 ? void 0 : d.call(o),
        tooltip: h,
        badge: g = {}
      } = e, y = C9e(e, ["prefixCls", "type", "shape", "description", "tooltip", "badge"]), b = ke(l.value, `${l.value}-${p}`, `${l.value}-${u.value}`, {
        [`${l.value}-rtl`]: r.value === "rtl"
      }, n.class, i.value), C = $(Sr, {
        placement: "left"
      }, {
        title: o.tooltip || h ? () => o.tooltip && o.tooltip() || h : void 0,
        default: () => $(Lv, g, {
          default: () => [$("div", {
            class: `${l.value}-body`
          }, [$(h9e, {
            prefixCls: l.value
          }, {
            icon: o.icon,
            description: () => v
          })])]
        })
      });
      return process.env.NODE_ENV !== "production" && Hn(!(m === "circle" && v), "FloatButton", "supported only when `shape` is `square`. Due to narrow space for text, short sentence is recommended."), a(e.href ? $("a", Q(Q(Q({
        ref: c
      }, n), y), {}, {
        class: b
      }), [C]) : $("button", Q(Q(Q({
        ref: c
      }, n), y), {}, {
        class: b,
        type: "button"
      }), [C]));
    };
  }
}), Vy = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AFloatButtonGroup",
  inheritAttrs: !1,
  props: sn(v9e(), {
    type: "default",
    shape: "circle"
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: l
    } = t;
    const {
      prefixCls: r,
      direction: a
    } = bt(XT, e), [i, s] = YT(r), [c, u] = ro(!1, {
      value: O(() => e.open)
    }), d = /* @__PURE__ */ H(null), f = /* @__PURE__ */ H(null);
    g9e({
      shape: O(() => e.shape)
    });
    const p = {
      onMouseenter() {
        var g;
        u(!0), l("update:open", !0), (g = e.onOpenChange) === null || g === void 0 || g.call(e, !0);
      },
      onMouseleave() {
        var g;
        u(!1), l("update:open", !1), (g = e.onOpenChange) === null || g === void 0 || g.call(e, !1);
      }
    }, m = O(() => e.trigger === "hover" ? p : {}), v = () => {
      var g;
      const y = !c.value;
      l("update:open", y), (g = e.onOpenChange) === null || g === void 0 || g.call(e, y), u(y);
    }, h = (g) => {
      var y, b, C;
      if (!((y = d.value) === null || y === void 0) && y.contains(g.target)) {
        !((b = nr(f.value)) === null || b === void 0) && b.contains(g.target) && v();
        return;
      }
      u(!1), l("update:open", !1), (C = e.onOpenChange) === null || C === void 0 || C.call(e, !1);
    };
    return pe(O(() => e.trigger), (g) => {
      Fl() && (document.removeEventListener("click", h), g === "click" && document.addEventListener("click", h));
    }, {
      immediate: !0
    }), yt(() => {
      document.removeEventListener("click", h);
    }), () => {
      var g;
      const {
        shape: y = "circle",
        type: b = "default",
        tooltip: C,
        description: w,
        trigger: x
      } = e, E = `${r.value}-group`, I = ke(E, s.value, n.class, {
        [`${E}-rtl`]: a.value === "rtl",
        [`${E}-${y}`]: y,
        [`${E}-${y}-shadow`]: !x
      }), T = ke(s.value, `${E}-wrap`), P = da(`${E}-wrap`);
      return i($("div", Q(Q({
        ref: d
      }, n), {}, {
        class: I
      }, m.value), [x && ["click", "hover"].includes(x) ? $(Ge, null, [$(Vn, P, {
        default: () => [_t($("div", {
          class: T
        }, [o.default && o.default()]), [[Jt, c.value]])]
      }), $(pc, {
        ref: f,
        type: b,
        shape: y,
        tooltip: C,
        description: w
      }, {
        icon: () => {
          var k, N;
          return c.value ? ((k = o.closeIcon) === null || k === void 0 ? void 0 : k.call(o)) || $(Hl, null, null) : ((N = o.icon) === null || N === void 0 ? void 0 : N.call(o)) || $(YS, null, null);
        },
        tooltip: o.tooltip,
        description: o.description
      })]) : (g = o.default) === null || g === void 0 ? void 0 : g.call(o)]));
    };
  }
});
var w9e = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M859.9 168H164.1c-4.5 0-8.1 3.6-8.1 8v60c0 4.4 3.6 8 8.1 8h695.8c4.5 0 8.1-3.6 8.1-8v-60c0-4.4-3.6-8-8.1-8zM518.3 355a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V848c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V509.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 355z" } }] }, name: "vertical-align-top", theme: "outlined" };
function bA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      $9e(e, l, n[l]);
    });
  }
  return e;
}
function $9e(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var qT = function(t, n) {
  var o = bA({}, t, n.attrs);
  return $(cn, bA({}, o, {
    icon: w9e
  }), null);
};
qT.displayName = "VerticalAlignTopOutlined";
qT.inheritAttrs = !1;
const zy = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ABackTop",
  inheritAttrs: !1,
  props: sn(m9e(), {
    visibilityHeight: 400,
    target: () => window,
    duration: 450,
    type: "default",
    shape: "circle"
  }),
  // emits: ['click'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: l
    } = t;
    const {
      prefixCls: r,
      direction: a
    } = bt(XT, e), [i] = YT(r), s = /* @__PURE__ */ H(), c = /* @__PURE__ */ kt({
      visible: e.visibilityHeight === 0,
      scrollEvent: null
    }), u = () => s.value && s.value.ownerDocument ? s.value.ownerDocument : window, d = (h) => {
      const {
        target: g = u,
        duration: y
      } = e;
      vI(0, {
        getContainer: g,
        duration: y
      }), l("click", h);
    }, f = a2((h) => {
      const {
        visibilityHeight: g
      } = e, y = pI(h.target);
      c.visible = y >= g;
    }), p = () => {
      const {
        target: h
      } = e, y = (h || u)();
      f({
        target: y
      }), y == null || y.addEventListener("scroll", f);
    }, m = () => {
      const {
        target: h
      } = e, y = (h || u)();
      f.cancel(), y == null || y.removeEventListener("scroll", f);
    };
    pe(() => e.target, () => {
      m(), Ke(() => {
        p();
      });
    }), nt(() => {
      Ke(() => {
        p();
      });
    }), nd(() => {
      Ke(() => {
        p();
      });
    }), WE(() => {
      m();
    }), yt(() => {
      m();
    });
    const v = $U();
    return () => {
      const {
        description: h,
        type: g,
        shape: y,
        tooltip: b,
        badge: C
      } = e, w = _(_({}, o), {
        shape: (v == null ? void 0 : v.shape.value) || y,
        onClick: d,
        class: {
          [`${r.value}`]: !0,
          [`${o.class}`]: o.class,
          [`${r.value}-rtl`]: a.value === "rtl"
        },
        description: h,
        type: g,
        tooltip: b,
        badge: C
      }), x = da("fade");
      return i($(Vn, x, {
        default: () => [_t($(pc, Q(Q({}, w), {}, {
          ref: s
        }), {
          icon: () => {
            var E;
            return ((E = n.icon) === null || E === void 0 ? void 0 : E.call(n)) || $(qT, null, null);
          }
        }), [[Jt, c.visible]])]
      }));
    };
  }
});
pc.Group = Vy;
pc.BackTop = zy;
pc.install = function(e) {
  return e.component(pc.name, pc), e.component(Vy.name, Vy), e.component(zy.name, zy), e;
};
const zv = (e) => e != null && (Array.isArray(e) ? mo(e).length : !0);
function JT(e) {
  return zv(e.prefix) || zv(e.suffix) || zv(e.allowClear);
}
function Wb(e) {
  return zv(e.addonBefore) || zv(e.addonAfter);
}
function q2(e) {
  return typeof e == "undefined" || e === null ? "" : String(e);
}
function Hv(e, t, n, o) {
  if (!n)
    return;
  const l = t;
  if (t.type === "click") {
    Object.defineProperty(l, "target", {
      writable: !0
    }), Object.defineProperty(l, "currentTarget", {
      writable: !0
    });
    const r = e.cloneNode(!0);
    l.target = r, l.currentTarget = r, r.value = "", n(l);
    return;
  }
  if (o !== void 0) {
    Object.defineProperty(l, "target", {
      writable: !0
    }), Object.defineProperty(l, "currentTarget", {
      writable: !0
    }), l.target = e, l.currentTarget = e, e.value = o, n(l);
    return;
  }
  n(l);
}
function xU(e, t) {
  if (!e) return;
  e.focus(t);
  const {
    cursor: n
  } = t || {};
  if (n) {
    const o = e.value.length;
    switch (n) {
      case "start":
        e.setSelectionRange(0, 0);
        break;
      case "end":
        e.setSelectionRange(o, o);
        break;
      default:
        e.setSelectionRange(0, o);
    }
  }
}
const x9e = () => ({
  addonBefore: de.any,
  addonAfter: de.any,
  prefix: de.any,
  suffix: de.any,
  clearIcon: de.any,
  affixWrapperClassName: String,
  groupClassName: String,
  wrapperClassName: String,
  inputClassName: String,
  allowClear: {
    type: Boolean,
    default: void 0
  }
}), EU = () => _(_({}, x9e()), {
  value: {
    type: [String, Number, Symbol],
    default: void 0
  },
  defaultValue: {
    type: [String, Number, Symbol],
    default: void 0
  },
  inputElement: de.any,
  prefixCls: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  focused: {
    type: Boolean,
    default: void 0
  },
  triggerFocus: Function,
  readonly: {
    type: Boolean,
    default: void 0
  },
  handleReset: Function,
  hidden: {
    type: Boolean,
    default: void 0
  }
}), OU = () => _(_({}, EU()), {
  id: String,
  placeholder: {
    type: [String, Number]
  },
  autocomplete: String,
  type: At("text"),
  name: String,
  size: {
    type: String
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  lazy: {
    type: Boolean,
    default: !0
  },
  maxlength: Number,
  loading: {
    type: Boolean,
    default: void 0
  },
  bordered: {
    type: Boolean,
    default: void 0
  },
  showCount: {
    type: [Boolean, Object]
  },
  htmlSize: Number,
  onPressEnter: Function,
  onKeydown: Function,
  onKeyup: Function,
  onFocus: Function,
  onBlur: Function,
  onChange: Function,
  onInput: Function,
  "onUpdate:value": Function,
  onCompositionstart: Function,
  onCompositionend: Function,
  valueModifiers: Object,
  hidden: {
    type: Boolean,
    default: void 0
  },
  status: String
}), E9e = /* @__PURE__ */ le({
  name: "BaseInput",
  inheritAttrs: !1,
  props: EU(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const l = /* @__PURE__ */ H(), r = (i) => {
      var s;
      if (!((s = l.value) === null || s === void 0) && s.contains(i.target)) {
        const {
          triggerFocus: c
        } = e;
        c == null || c();
      }
    }, a = () => {
      var i;
      const {
        allowClear: s,
        value: c,
        disabled: u,
        readonly: d,
        handleReset: f,
        suffix: p = n.suffix,
        prefixCls: m
      } = e;
      if (!s)
        return null;
      const v = !u && !d && c, h = `${m}-clear-icon`, g = ((i = n.clearIcon) === null || i === void 0 ? void 0 : i.call(n)) || "*";
      return $("span", {
        onClick: f,
        onMousedown: (y) => y.preventDefault(),
        class: ke({
          [`${h}-hidden`]: !v,
          [`${h}-has-suffix`]: !!p
        }, h),
        role: "button",
        tabindex: -1
      }, [g]);
    };
    return () => {
      var i, s;
      const {
        focused: c,
        value: u,
        disabled: d,
        allowClear: f,
        readonly: p,
        hidden: m,
        prefixCls: v,
        prefix: h = (i = n.prefix) === null || i === void 0 ? void 0 : i.call(n),
        suffix: g = (s = n.suffix) === null || s === void 0 ? void 0 : s.call(n),
        addonAfter: y = n.addonAfter,
        addonBefore: b = n.addonBefore,
        inputElement: C,
        affixWrapperClassName: w,
        wrapperClassName: x,
        groupClassName: E
      } = e;
      let I = _n(C, {
        value: u,
        hidden: m
      });
      if (JT({
        prefix: h,
        suffix: g,
        allowClear: f
      })) {
        const T = `${v}-affix-wrapper`, P = ke(T, {
          [`${T}-disabled`]: d,
          [`${T}-focused`]: c,
          [`${T}-readonly`]: p,
          [`${T}-input-with-clear-btn`]: g && f && u
        }, !Wb({
          addonAfter: y,
          addonBefore: b
        }) && o.class, w), k = (g || f) && $("span", {
          class: `${v}-suffix`
        }, [a(), g]);
        I = $("span", {
          class: P,
          style: o.style,
          hidden: !Wb({
            addonAfter: y,
            addonBefore: b
          }) && m,
          onMousedown: r,
          ref: l
        }, [h && $("span", {
          class: `${v}-prefix`
        }, [h]), _n(C, {
          style: null,
          value: u,
          hidden: null
        }), k]);
      }
      if (Wb({
        addonAfter: y,
        addonBefore: b
      })) {
        const T = `${v}-group`, P = `${T}-addon`, k = ke(`${v}-wrapper`, T, x), N = ke(`${v}-group-wrapper`, o.class, E);
        return $("span", {
          class: N,
          style: o.style,
          hidden: m
        }, [$("span", {
          class: k
        }, [b && $("span", {
          class: P
        }, [b]), _n(I, {
          style: null,
          hidden: null
        }), y && $("span", {
          class: P
        }, [y])])]);
      }
      return I;
    };
  }
});
var O9e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const _9e = /* @__PURE__ */ le({
  name: "VCInput",
  inheritAttrs: !1,
  props: OU(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: l,
      emit: r
    } = t;
    const a = /* @__PURE__ */ Ce(e.value === void 0 ? e.defaultValue : e.value), i = /* @__PURE__ */ Ce(!1), s = /* @__PURE__ */ Ce(), c = /* @__PURE__ */ Ce();
    pe(() => e.value, () => {
      a.value = e.value;
    }), pe(() => e.disabled, () => {
      e.disabled && (i.value = !1);
    });
    const u = (E) => {
      s.value && xU(s.value.input, E);
    }, d = () => {
      var E;
      (E = s.value.input) === null || E === void 0 || E.blur();
    }, f = (E, I, T) => {
      var P;
      (P = s.value.input) === null || P === void 0 || P.setSelectionRange(E, I, T);
    }, p = () => {
      var E;
      (E = s.value.input) === null || E === void 0 || E.select();
    };
    l({
      focus: u,
      blur: d,
      input: O(() => {
        var E;
        return (E = s.value.input) === null || E === void 0 ? void 0 : E.input;
      }),
      stateValue: a,
      setSelectionRange: f,
      select: p
    });
    const m = (E) => {
      r("change", E);
    }, v = (E, I) => {
      a.value !== E && (e.value === void 0 ? a.value = E : Ke(() => {
        var T;
        s.value.input.value !== a.value && ((T = c.value) === null || T === void 0 || T.$forceUpdate());
      }), Ke(() => {
        I && I();
      }));
    }, h = (E) => {
      const {
        value: I
      } = E.target;
      if (a.value === I) return;
      const T = E.target.value;
      Hv(s.value.input, E, m), v(T);
    }, g = (E) => {
      E.keyCode === 13 && r("pressEnter", E), r("keydown", E);
    }, y = (E) => {
      i.value = !0, r("focus", E);
    }, b = (E) => {
      i.value = !1, r("blur", E);
    }, C = (E) => {
      Hv(s.value.input, E, m), v("", () => {
        u();
      });
    }, w = () => {
      var E, I;
      const {
        addonBefore: T = n.addonBefore,
        addonAfter: P = n.addonAfter,
        disabled: k,
        valueModifiers: N = {},
        htmlSize: R,
        autocomplete: z,
        prefixCls: D,
        inputClassName: F,
        prefix: M = (E = n.prefix) === null || E === void 0 ? void 0 : E.call(n),
        suffix: A = (I = n.suffix) === null || I === void 0 ? void 0 : I.call(n),
        allowClear: L,
        type: B = "text"
      } = e, V = pn(e, [
        "prefixCls",
        "onPressEnter",
        "addonBefore",
        "addonAfter",
        "prefix",
        "suffix",
        "allowClear",
        // Input elements must be either controlled or uncontrolled,
        // specify either the value prop, or the defaultValue prop, but not both.
        "defaultValue",
        "size",
        "bordered",
        "htmlSize",
        "lazy",
        "showCount",
        "valueModifiers",
        "showCount",
        "affixWrapperClassName",
        "groupClassName",
        "inputClassName",
        "wrapperClassName"
      ]), j = _(_(_({}, V), o), {
        autocomplete: z,
        onChange: h,
        onInput: h,
        onFocus: y,
        onBlur: b,
        onKeydown: g,
        class: ke(D, {
          [`${D}-disabled`]: k
        }, F, !Wb({
          addonAfter: P,
          addonBefore: T
        }) && !JT({
          prefix: M,
          suffix: A,
          allowClear: L
        }) && o.class),
        ref: s,
        key: "ant-input",
        size: R,
        type: B,
        lazy: e.lazy
      });
      return N.lazy && delete j.onInput, j.autofocus || delete j.autofocus, $(kp, pn(j, ["size"]), null);
    }, x = () => {
      var E;
      const {
        maxlength: I,
        suffix: T = (E = n.suffix) === null || E === void 0 ? void 0 : E.call(n),
        showCount: P,
        prefixCls: k
      } = e, N = Number(I) > 0;
      if (T || P) {
        const R = [...q2(a.value)].length, z = typeof P == "object" ? P.formatter({
          count: R,
          maxlength: I
        }) : `${R}${N ? ` / ${I}` : ""}`;
        return $(Ge, null, [!!P && $("span", {
          class: ke(`${k}-show-count-suffix`, {
            [`${k}-show-count-has-suffix`]: !!T
          })
        }, [z]), T]);
      }
      return null;
    };
    return nt(() => {
      process.env.NODE_ENV === "test" && e.autofocus && u();
    }), () => {
      const {
        prefixCls: E,
        disabled: I
      } = e, T = O9e(e, ["prefixCls", "disabled"]);
      return $(E9e, Q(Q(Q({}, T), o), {}, {
        ref: c,
        prefixCls: E,
        inputElement: w(),
        handleReset: C,
        value: q2(a.value),
        focused: i.value,
        triggerFocus: u,
        suffix: x(),
        disabled: I
      }), n);
    };
  }
}), XS = () => pn(OU(), ["wrapperClassName", "groupClassName", "inputClassName", "affixWrapperClassName"]), _U = () => _(_({}, pn(XS(), ["prefix", "addonBefore", "addonAfter", "suffix"])), {
  rows: Number,
  autosize: {
    type: [Boolean, Object],
    default: void 0
  },
  autoSize: {
    type: [Boolean, Object],
    default: void 0
  },
  onResize: {
    type: Function
  },
  onCompositionstart: Yu(),
  onCompositionend: Yu(),
  valueModifiers: Object
});
var I9e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const Yo = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AInput",
  inheritAttrs: !1,
  props: XS(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: l,
      emit: r
    } = t;
    const a = /* @__PURE__ */ H(), i = Ko(), s = sl.useInject(), c = O(() => Ja(s.status, e.status)), {
      direction: u,
      prefixCls: d,
      size: f,
      autocomplete: p
    } = bt("input", e), {
      compactSize: m,
      compactItemClassnames: v
    } = Rc(d, u), h = O(() => m.value || f.value), [g, y] = _T(d), b = Cr();
    l({
      focus: (R) => {
        var z;
        (z = a.value) === null || z === void 0 || z.focus(R);
      },
      blur: () => {
        var R;
        (R = a.value) === null || R === void 0 || R.blur();
      },
      input: a,
      setSelectionRange: (R, z, D) => {
        var F;
        (F = a.value) === null || F === void 0 || F.setSelectionRange(R, z, D);
      },
      select: () => {
        var R;
        (R = a.value) === null || R === void 0 || R.select();
      }
    });
    const I = /* @__PURE__ */ H([]), T = () => {
      I.value.push(setTimeout(() => {
        var R, z, D, F;
        !((R = a.value) === null || R === void 0) && R.input && ((z = a.value) === null || z === void 0 ? void 0 : z.input.getAttribute("type")) === "password" && (!((D = a.value) === null || D === void 0) && D.input.hasAttribute("value")) && ((F = a.value) === null || F === void 0 || F.input.removeAttribute("value"));
      }));
    };
    nt(() => {
      T();
    }), vp(() => {
      I.value.forEach((R) => clearTimeout(R));
    }), yt(() => {
      I.value.forEach((R) => clearTimeout(R));
    });
    const P = (R) => {
      T(), r("blur", R), i.onFieldBlur();
    }, k = (R) => {
      T(), r("focus", R);
    }, N = (R) => {
      r("update:value", R.target.value), r("change", R), r("input", R), i.onFieldChange();
    };
    return () => {
      var R, z, D, F, M, A;
      const {
        hasFeedback: L,
        feedbackIcon: B
      } = s, {
        allowClear: V,
        bordered: j = !0,
        prefix: W = (R = n.prefix) === null || R === void 0 ? void 0 : R.call(n),
        suffix: Y = (z = n.suffix) === null || z === void 0 ? void 0 : z.call(n),
        addonAfter: U = (D = n.addonAfter) === null || D === void 0 ? void 0 : D.call(n),
        addonBefore: te = (F = n.addonBefore) === null || F === void 0 ? void 0 : F.call(n),
        id: J = (M = i.id) === null || M === void 0 ? void 0 : M.value
      } = e, re = I9e(e, ["allowClear", "bordered", "prefix", "suffix", "addonAfter", "addonBefore", "id"]), oe = (L || Y) && $(Ge, null, [Y, L && B]), q = d.value, K = JT({
        prefix: W,
        suffix: Y
      }) || !!L, se = n.clearIcon || (() => $(jl, null, null));
      return g($(_9e, Q(Q(Q({}, o), pn(re, ["onUpdate:value", "onChange", "onInput"])), {}, {
        onChange: N,
        id: J,
        disabled: (A = e.disabled) !== null && A !== void 0 ? A : b.value,
        ref: a,
        prefixCls: q,
        autocomplete: p.value,
        onBlur: P,
        onFocus: k,
        prefix: W,
        suffix: oe,
        allowClear: V,
        addonAfter: U && $(Rm, null, {
          default: () => [$(vy, null, {
            default: () => [U]
          })]
        }),
        addonBefore: te && $(Rm, null, {
          default: () => [$(vy, null, {
            default: () => [te]
          })]
        }),
        class: [o.class, v.value],
        inputClassName: ke({
          [`${q}-sm`]: h.value === "small",
          [`${q}-lg`]: h.value === "large",
          [`${q}-rtl`]: u.value === "rtl",
          [`${q}-borderless`]: !j
        }, !K && Ll(q, c.value), y.value),
        affixWrapperClassName: ke({
          [`${q}-affix-wrapper-sm`]: h.value === "small",
          [`${q}-affix-wrapper-lg`]: h.value === "large",
          [`${q}-affix-wrapper-rtl`]: u.value === "rtl",
          [`${q}-affix-wrapper-borderless`]: !j
        }, Ll(`${q}-affix-wrapper`, c.value, L), y.value),
        wrapperClassName: ke({
          [`${q}-group-rtl`]: u.value === "rtl"
        }, y.value),
        groupClassName: ke({
          [`${q}-group-wrapper-sm`]: h.value === "small",
          [`${q}-group-wrapper-lg`]: h.value === "large",
          [`${q}-group-wrapper-rtl`]: u.value === "rtl"
        }, Ll(`${q}-group-wrapper`, c.value, L), y.value)
      }), _(_({}, n), {
        clearIcon: se
      })));
    };
  }
}), IU = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AInputGroup",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    size: {
      type: String
    },
    compact: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r,
      getPrefixCls: a
    } = bt("input-group", e), i = sl.useInject();
    sl.useProvide(i, {
      isFormItemInput: !1
    });
    const s = O(() => a("input")), [c, u] = _T(s), d = O(() => {
      const f = l.value;
      return {
        [`${f}`]: !0,
        [u.value]: !0,
        [`${f}-lg`]: e.size === "large",
        [`${f}-sm`]: e.size === "small",
        [`${f}-compact`]: e.compact,
        [`${f}-rtl`]: r.value === "rtl"
      };
    });
    return () => {
      var f;
      return c($("span", Q(Q({}, o), {}, {
        class: ke(d.value, o.class)
      }), [(f = n.default) === null || f === void 0 ? void 0 : f.call(n)]));
    };
  }
});
var T9e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const TU = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AInputSearch",
  inheritAttrs: !1,
  props: _(_({}, XS()), {
    inputPrefixCls: String,
    //  https://github.com/vueComponent/ant-design-vue/issues/1916
    enterButton: de.any,
    onSearch: {
      type: Function
    }
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: l,
      emit: r
    } = t;
    const a = /* @__PURE__ */ Ce(), i = /* @__PURE__ */ Ce(!1);
    l({
      focus: () => {
        var w;
        (w = a.value) === null || w === void 0 || w.focus();
      },
      blur: () => {
        var w;
        (w = a.value) === null || w === void 0 || w.blur();
      }
    });
    const u = (w) => {
      r("update:value", w.target.value), w && w.target && w.type === "click" && r("search", w.target.value, w), r("change", w);
    }, d = (w) => {
      var x;
      document.activeElement === ((x = a.value) === null || x === void 0 ? void 0 : x.input) && w.preventDefault();
    }, f = (w) => {
      var x, E;
      r("search", (E = (x = a.value) === null || x === void 0 ? void 0 : x.input) === null || E === void 0 ? void 0 : E.stateValue, w);
    }, p = (w) => {
      i.value || e.loading || f(w);
    }, m = (w) => {
      i.value = !0, r("compositionstart", w);
    }, v = (w) => {
      i.value = !1, r("compositionend", w);
    }, {
      prefixCls: h,
      getPrefixCls: g,
      direction: y,
      size: b
    } = bt("input-search", e), C = O(() => g("input", e.inputPrefixCls));
    return () => {
      var w, x, E, I;
      const {
        disabled: T,
        loading: P,
        addonAfter: k = (w = n.addonAfter) === null || w === void 0 ? void 0 : w.call(n),
        suffix: N = (x = n.suffix) === null || x === void 0 ? void 0 : x.call(n)
      } = e, R = T9e(e, ["disabled", "loading", "addonAfter", "suffix"]);
      let {
        enterButton: z = (I = (E = n.enterButton) === null || E === void 0 ? void 0 : E.call(n)) !== null && I !== void 0 ? I : !1
      } = e;
      z = z || z === "";
      const D = typeof z == "boolean" ? $(Mp, null, null) : null, F = `${h.value}-button`, M = Array.isArray(z) ? z[0] : z;
      let A;
      const L = M.type && I1(M.type) && M.type.__ANT_BUTTON;
      if (L || M.tagName === "button")
        A = _n(M, _({
          onMousedown: d,
          onClick: f,
          key: "enterButton"
        }, L ? {
          class: F,
          size: b.value
        } : {}), !1);
      else {
        const V = D && !z;
        A = $(ko, {
          class: F,
          type: z ? "primary" : void 0,
          size: b.value,
          disabled: T,
          key: "enterButton",
          onMousedown: d,
          onClick: f,
          loading: P,
          icon: V ? D : null
        }, {
          default: () => [V ? null : D || z]
        });
      }
      k && (A = [A, k]);
      const B = ke(h.value, {
        [`${h.value}-rtl`]: y.value === "rtl",
        [`${h.value}-${b.value}`]: !!b.value,
        [`${h.value}-with-button`]: !!z
      }, o.class);
      return $(Yo, Q(Q(Q({
        ref: a
      }, pn(R, ["onUpdate:value", "onSearch", "enterButton"])), o), {}, {
        onPressEnter: p,
        onCompositionstart: m,
        onCompositionend: v,
        size: b.value,
        prefixCls: C.value,
        addonAfter: A,
        suffix: N,
        onChange: u,
        class: B,
        disabled: T
      }), n);
    };
  }
}), yA = (e) => e != null && (Array.isArray(e) ? mo(e).length : !0);
function P9e(e) {
  return yA(e.addonBefore) || yA(e.addonAfter);
}
const k9e = ["text", "input"], N9e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ClearableLabeledInput",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    inputType: de.oneOf($l("text", "input")),
    value: Wn(),
    defaultValue: Wn(),
    allowClear: {
      type: Boolean,
      default: void 0
    },
    element: Wn(),
    handleReset: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String
    },
    size: {
      type: String
    },
    suffix: Wn(),
    prefix: Wn(),
    addonBefore: Wn(),
    addonAfter: Wn(),
    readonly: {
      type: Boolean,
      default: void 0
    },
    focused: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: !0
    },
    triggerFocus: {
      type: Function
    },
    hidden: Boolean,
    status: String,
    hashId: String
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const l = sl.useInject(), r = (i) => {
      const {
        value: s,
        disabled: c,
        readonly: u,
        handleReset: d,
        suffix: f = n.suffix
      } = e, p = !c && !u && s, m = `${i}-clear-icon`;
      return $(jl, {
        onClick: d,
        onMousedown: (v) => v.preventDefault(),
        class: ke({
          [`${m}-hidden`]: !p,
          [`${m}-has-suffix`]: !!f
        }, m),
        role: "button"
      }, null);
    }, a = (i, s) => {
      const {
        value: c,
        allowClear: u,
        direction: d,
        bordered: f,
        hidden: p,
        status: m,
        addonAfter: v = n.addonAfter,
        addonBefore: h = n.addonBefore,
        hashId: g
      } = e, {
        status: y,
        hasFeedback: b
      } = l;
      if (!u)
        return _n(s, {
          value: c,
          disabled: e.disabled
        });
      const C = ke(`${i}-affix-wrapper`, `${i}-affix-wrapper-textarea-with-clear-btn`, Ll(`${i}-affix-wrapper`, Ja(y, m), b), {
        [`${i}-affix-wrapper-rtl`]: d === "rtl",
        [`${i}-affix-wrapper-borderless`]: !f,
        // className will go to addon wrapper
        [`${o.class}`]: !P9e({
          addonAfter: v,
          addonBefore: h
        }) && o.class
      }, g);
      return $("span", {
        class: C,
        style: o.style,
        hidden: p
      }, [_n(s, {
        style: null,
        value: c,
        disabled: e.disabled
      }), r(i)]);
    };
    return () => {
      var i;
      const {
        prefixCls: s,
        inputType: c,
        element: u = (i = n.element) === null || i === void 0 ? void 0 : i.call(n)
      } = e;
      return c === k9e[0] ? a(s, u) : null;
    };
  }
}), M9e = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`, A9e = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"], Yw = {};
let Ur;
function R9e(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const n = e.getAttribute("id") || e.getAttribute("data-reactid") || e.getAttribute("name");
  if (t && Yw[n])
    return Yw[n];
  const o = window.getComputedStyle(e), l = o.getPropertyValue("box-sizing") || o.getPropertyValue("-moz-box-sizing") || o.getPropertyValue("-webkit-box-sizing"), r = parseFloat(o.getPropertyValue("padding-bottom")) + parseFloat(o.getPropertyValue("padding-top")), a = parseFloat(o.getPropertyValue("border-bottom-width")) + parseFloat(o.getPropertyValue("border-top-width")), s = {
    sizingStyle: A9e.map((c) => `${c}:${o.getPropertyValue(c)}`).join(";"),
    paddingSize: r,
    borderSize: a,
    boxSizing: l
  };
  return t && n && (Yw[n] = s), s;
}
function D9e(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  Ur || (Ur = document.createElement("textarea"), Ur.setAttribute("tab-index", "-1"), Ur.setAttribute("aria-hidden", "true"), document.body.appendChild(Ur)), e.getAttribute("wrap") ? Ur.setAttribute("wrap", e.getAttribute("wrap")) : Ur.removeAttribute("wrap");
  const {
    paddingSize: l,
    borderSize: r,
    boxSizing: a,
    sizingStyle: i
  } = R9e(e, t);
  Ur.setAttribute("style", `${i};${M9e}`), Ur.value = e.value || e.placeholder || "";
  let s, c, u, d = Ur.scrollHeight;
  if (a === "border-box" ? d += r : a === "content-box" && (d -= l), n !== null || o !== null) {
    Ur.value = " ";
    const p = Ur.scrollHeight - l;
    n !== null && (s = p * n, a === "border-box" && (s = s + l + r), d = Math.max(s, d)), o !== null && (c = p * o, a === "border-box" && (c = c + l + r), u = d > c ? "" : "hidden", d = Math.min(c, d));
  }
  const f = {
    height: `${d}px`,
    overflowY: u,
    resize: "none"
  };
  return s && (f.minHeight = `${s}px`), c && (f.maxHeight = `${c}px`), f;
}
const Xw = 0, qw = 1, Jw = 2, L9e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ResizableTextArea",
  inheritAttrs: !1,
  props: _U(),
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      expose: l
    } = t, r, a;
    const i = /* @__PURE__ */ H(), s = /* @__PURE__ */ H({}), c = /* @__PURE__ */ H(Jw);
    yt(() => {
      rn.cancel(r), rn.cancel(a);
    });
    const u = () => {
      try {
        if (i.value && document.activeElement === i.value.input) {
          const x = i.value.getSelectionStart(), E = i.value.getSelectionEnd(), I = i.value.getScrollTop();
          i.value.setSelectionRange(x, E), i.value.setScrollTop(I);
        }
      } catch (x) {
      }
    }, d = /* @__PURE__ */ H(), f = /* @__PURE__ */ H();
    Ot(() => {
      const x = e.autoSize || e.autosize;
      x ? (d.value = x.minRows, f.value = x.maxRows) : (d.value = void 0, f.value = void 0);
    });
    const p = O(() => !!(e.autoSize || e.autosize)), m = () => {
      c.value = Xw;
    };
    pe([() => e.value, d, f, p], () => {
      p.value && m();
    }, {
      immediate: !0
    });
    const v = /* @__PURE__ */ H();
    pe([c, i], () => {
      if (i.value)
        if (c.value === Xw)
          c.value = qw;
        else if (c.value === qw) {
          const x = D9e(i.value.input, !1, d.value, f.value);
          c.value = Jw, v.value = x;
        } else
          u();
    }, {
      immediate: !0,
      flush: "post"
    });
    const h = xt(), g = /* @__PURE__ */ H(), y = () => {
      rn.cancel(g.value);
    }, b = (x) => {
      c.value === Jw && (o("resize", x), p.value && (y(), g.value = rn(() => {
        m();
      })));
    };
    yt(() => {
      y();
    }), l({
      resizeTextarea: () => {
        m();
      },
      textArea: O(() => {
        var x;
        return (x = i.value) === null || x === void 0 ? void 0 : x.input;
      }),
      instance: h
    }), Hn(e.autosize === void 0, "Input.TextArea", "autosize is deprecated, please use autoSize instead.");
    const w = () => {
      const {
        prefixCls: x,
        disabled: E
      } = e, I = pn(e, ["prefixCls", "onPressEnter", "autoSize", "autosize", "defaultValue", "allowClear", "type", "maxlength", "valueModifiers"]), T = ke(x, n.class, {
        [`${x}-disabled`]: E
      }), P = p.value ? v.value : null, k = [n.style, s.value, P], N = _(_(_({}, I), n), {
        style: k,
        class: T
      });
      return (c.value === Xw || c.value === qw) && k.push({
        overflowX: "hidden",
        overflowY: "hidden"
      }), N.autofocus || delete N.autofocus, N.rows === 0 && delete N.rows, $(ca, {
        onResize: b,
        disabled: !p.value
      }, {
        default: () => [$(kp, Q(Q({}, N), {}, {
          ref: i,
          tag: "textarea"
        }), null)]
      });
    };
    return () => w();
  }
});
function PU(e, t) {
  return [...e || ""].slice(0, t).join("");
}
function SA(e, t, n, o) {
  let l = n;
  return e ? l = PU(n, o) : [...t || ""].length < n.length && [...n || ""].length > o && (l = t), l;
}
const ZT = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ATextarea",
  inheritAttrs: !1,
  props: _U(),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      emit: l
    } = t;
    var r;
    const a = Ko(), i = sl.useInject(), s = O(() => Ja(i.status, e.status)), c = /* @__PURE__ */ Ce((r = e.value) !== null && r !== void 0 ? r : e.defaultValue), u = /* @__PURE__ */ Ce(), d = /* @__PURE__ */ Ce(""), {
      prefixCls: f,
      size: p,
      direction: m
    } = bt("input", e), [v, h] = _T(f), g = Cr(), y = O(() => e.showCount === "" || e.showCount || !1), b = O(() => Number(e.maxlength) > 0), C = /* @__PURE__ */ Ce(!1), w = /* @__PURE__ */ Ce(), x = /* @__PURE__ */ Ce(0), E = (L) => {
      C.value = !0, w.value = d.value, x.value = L.currentTarget.selectionStart, l("compositionstart", L);
    }, I = (L) => {
      var B;
      C.value = !1;
      let V = L.currentTarget.value;
      if (b.value) {
        const j = x.value >= e.maxlength + 1 || x.value === ((B = w.value) === null || B === void 0 ? void 0 : B.length);
        V = SA(j, w.value, V, e.maxlength);
      }
      V !== d.value && (N(V), Hv(L.currentTarget, L, D, V)), l("compositionend", L);
    }, T = xt();
    pe(() => e.value, () => {
      var L;
      "value" in T.vnode.props, c.value = (L = e.value) !== null && L !== void 0 ? L : "";
    });
    const P = (L) => {
      var B;
      xU((B = u.value) === null || B === void 0 ? void 0 : B.textArea, L);
    }, k = () => {
      var L, B;
      (B = (L = u.value) === null || L === void 0 ? void 0 : L.textArea) === null || B === void 0 || B.blur();
    }, N = (L, B) => {
      c.value !== L && (e.value === void 0 ? c.value = L : Ke(() => {
        var V, j, W;
        u.value.textArea.value !== d.value && ((W = (V = u.value) === null || V === void 0 ? void 0 : (j = V.instance).update) === null || W === void 0 || W.call(j));
      }), Ke(() => {
        B && B();
      }));
    }, R = (L) => {
      L.keyCode === 13 && l("pressEnter", L), l("keydown", L);
    }, z = (L) => {
      const {
        onBlur: B
      } = e;
      B == null || B(L), a.onFieldBlur();
    }, D = (L) => {
      l("update:value", L.target.value), l("change", L), l("input", L), a.onFieldChange();
    }, F = (L) => {
      Hv(u.value.textArea, L, D), N("", () => {
        P();
      });
    }, M = (L) => {
      let B = L.target.value;
      if (c.value !== B) {
        if (b.value) {
          const V = L.target, j = V.selectionStart >= e.maxlength + 1 || V.selectionStart === B.length || !V.selectionStart;
          B = SA(j, d.value, B, e.maxlength);
        }
        Hv(L.currentTarget, L, D, B), N(B);
      }
    }, A = () => {
      var L, B;
      const {
        class: V
      } = n, {
        bordered: j = !0
      } = e, W = _(_(_({}, pn(e, ["allowClear"])), n), {
        class: [{
          [`${f.value}-borderless`]: !j,
          [`${V}`]: V && !y.value,
          [`${f.value}-sm`]: p.value === "small",
          [`${f.value}-lg`]: p.value === "large"
        }, Ll(f.value, s.value), h.value],
        disabled: g.value,
        showCount: null,
        prefixCls: f.value,
        onInput: M,
        onChange: M,
        onBlur: z,
        onKeydown: R,
        onCompositionstart: E,
        onCompositionend: I
      });
      return !((L = e.valueModifiers) === null || L === void 0) && L.lazy && delete W.onInput, $(L9e, Q(Q({}, W), {}, {
        id: (B = W == null ? void 0 : W.id) !== null && B !== void 0 ? B : a.id.value,
        ref: u,
        maxlength: e.maxlength,
        lazy: e.lazy
      }), null);
    };
    return o({
      focus: P,
      blur: k,
      resizableTextArea: u
    }), Ot(() => {
      let L = q2(c.value);
      !C.value && b.value && (e.value === null || e.value === void 0) && (L = PU(L, e.maxlength)), d.value = L;
    }), () => {
      var L;
      const {
        maxlength: B,
        bordered: V = !0,
        hidden: j
      } = e, {
        style: W,
        class: Y
      } = n, U = _(_(_({}, e), n), {
        prefixCls: f.value,
        inputType: "text",
        handleReset: F,
        direction: m.value,
        bordered: V,
        style: y.value ? void 0 : W,
        hashId: h.value,
        disabled: (L = e.disabled) !== null && L !== void 0 ? L : g.value
      });
      let te = $(N9e, Q(Q({}, U), {}, {
        value: d.value,
        status: e.status
      }), {
        element: A
      });
      if (y.value || i.hasFeedback) {
        const J = [...d.value].length;
        let re = "";
        typeof y.value == "object" ? re = y.value.formatter({
          value: d.value,
          count: J,
          maxlength: B
        }) : re = `${J}${b.value ? ` / ${B}` : ""}`, te = $("div", {
          hidden: j,
          class: ke(`${f.value}-textarea`, {
            [`${f.value}-textarea-rtl`]: m.value === "rtl",
            [`${f.value}-textarea-show-count`]: y.value,
            [`${f.value}-textarea-in-form-item`]: i.isFormItemInput
          }, `${f.value}-textarea-show-count`, Y, h.value),
          style: W,
          "data-count": typeof re != "object" ? re : void 0
        }, [te, i.hasFeedback && $("span", {
          class: `${f.value}-textarea-suffix`
        }, [i.feedbackIcon])]);
      }
      return v(te);
    };
  }
});
var B9e = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, name: "eye", theme: "outlined" };
function CA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      F9e(e, l, n[l]);
    });
  }
  return e;
}
function F9e(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Bh = function(t, n) {
  var o = CA({}, t, n.attrs);
  return $(cn, CA({}, o, {
    icon: B9e
  }), null);
};
Bh.displayName = "EyeOutlined";
Bh.inheritAttrs = !1;
var V9e = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { tag: "path", attrs: { d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, name: "eye-invisible", theme: "outlined" };
function wA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      z9e(e, l, n[l]);
    });
  }
  return e;
}
function z9e(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var QT = function(t, n) {
  var o = wA({}, t, n.attrs);
  return $(cn, wA({}, o, {
    icon: V9e
  }), null);
};
QT.displayName = "EyeInvisibleOutlined";
QT.inheritAttrs = !1;
var H9e = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const j9e = {
  click: "onClick",
  hover: "onMouseover"
}, W9e = (e) => $(e ? Bh : QT, null, null), kU = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AInputPassword",
  inheritAttrs: !1,
  props: _(_({}, XS()), {
    prefixCls: String,
    inputPrefixCls: String,
    action: {
      type: String,
      default: "click"
    },
    visibilityToggle: {
      type: Boolean,
      default: !0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    "onUpdate:visible": Function,
    iconRender: Function
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: l,
      emit: r
    } = t;
    const a = /* @__PURE__ */ Ce(!1), i = () => {
      const {
        disabled: h
      } = e;
      h || (a.value = !a.value, r("update:visible", a.value));
    };
    Ot(() => {
      e.visible !== void 0 && (a.value = !!e.visible);
    });
    const s = /* @__PURE__ */ Ce();
    l({
      focus: () => {
        var h;
        (h = s.value) === null || h === void 0 || h.focus();
      },
      blur: () => {
        var h;
        (h = s.value) === null || h === void 0 || h.blur();
      }
    });
    const d = (h) => {
      const {
        action: g,
        iconRender: y = n.iconRender || W9e
      } = e, b = j9e[g] || "", C = y(a.value), w = {
        [b]: i,
        class: `${h}-icon`,
        key: "passwordIcon",
        onMousedown: (x) => {
          x.preventDefault();
        },
        onMouseup: (x) => {
          x.preventDefault();
        }
      };
      return _n(Io(C) ? C : $("span", null, [C]), w);
    }, {
      prefixCls: f,
      getPrefixCls: p
    } = bt("input-password", e), m = O(() => p("input", e.inputPrefixCls)), v = () => {
      const {
        size: h,
        visibilityToggle: g
      } = e, y = H9e(e, ["size", "visibilityToggle"]), b = g && d(f.value), C = ke(f.value, o.class, {
        [`${f.value}-${h}`]: !!h
      }), w = _(_(_({}, pn(y, ["suffix", "iconRender", "action"])), o), {
        type: a.value ? "text" : "password",
        class: C,
        prefixCls: m.value,
        suffix: b
      });
      return h && (w.size = h), $(Yo, Q({
        ref: s
      }, w), n);
    };
    return () => v();
  }
});
Yo.Group = IU;
Yo.Search = TU;
Yo.TextArea = ZT;
Yo.Password = kU;
Yo.install = function(e) {
  return e.component(Yo.name, Yo), e.component(Yo.Group.name, Yo.Group), e.component(Yo.Search.name, Yo.Search), e.component(Yo.TextArea.name, Yo.TextArea), e.component(Yo.Password.name, Yo.Password), e;
};
function qS() {
  return {
    keyboard: {
      type: Boolean,
      default: void 0
    },
    mask: {
      type: Boolean,
      default: void 0
    },
    afterClose: Function,
    closable: {
      type: Boolean,
      default: void 0
    },
    maskClosable: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    destroyOnClose: {
      type: Boolean,
      default: void 0
    },
    mousePosition: de.shape({
      x: Number,
      y: Number
    }).loose,
    title: de.any,
    footer: de.any,
    transitionName: String,
    maskTransitionName: String,
    animation: de.any,
    maskAnimation: de.any,
    wrapStyle: {
      type: Object,
      default: void 0
    },
    bodyStyle: {
      type: Object,
      default: void 0
    },
    maskStyle: {
      type: Object,
      default: void 0
    },
    prefixCls: String,
    wrapClassName: String,
    rootClassName: String,
    width: [String, Number],
    height: [String, Number],
    zIndex: Number,
    bodyProps: de.any,
    maskProps: de.any,
    wrapProps: de.any,
    getContainer: de.any,
    dialogStyle: {
      type: Object,
      default: void 0
    },
    dialogClass: String,
    closeIcon: de.any,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getOpenCount: Function,
    // https://github.com/ant-design/ant-design/issues/19771
    // https://github.com/react-component/dialog/issues/95
    focusTriggerAfterClose: {
      type: Boolean,
      default: void 0
    },
    onClose: Function,
    modalRender: Function
  };
}
function $A(e, t, n) {
  let o = t;
  return !o && n && (o = `${e}-${n}`), o;
}
let xA = -1;
function K9e() {
  return xA += 1, xA;
}
function EA(e, t) {
  let n = e[`page${t ? "Y" : "X"}Offset`];
  const o = `scroll${t ? "Top" : "Left"}`;
  if (typeof n != "number") {
    const l = e.document;
    n = l.documentElement[o], typeof n != "number" && (n = l.body[o]);
  }
  return n;
}
function U9e(e) {
  const t = e.getBoundingClientRect(), n = {
    left: t.left,
    top: t.top
  }, o = e.ownerDocument, l = o.defaultView || o.parentWindow;
  return n.left += EA(l), n.top += EA(l, !0), n;
}
const G9e = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
}, Y9e = {
  outline: "none"
}, X9e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "DialogContent",
  inheritAttrs: !1,
  props: _(_({}, qS()), {
    motionName: String,
    ariaId: String,
    onVisibleChanged: Function,
    onMousedown: Function,
    onMouseup: Function
  }),
  setup(e, t) {
    let {
      expose: n,
      slots: o,
      attrs: l
    } = t;
    const r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H(), i = /* @__PURE__ */ H();
    n({
      focus: () => {
        var f;
        (f = r.value) === null || f === void 0 || f.focus({
          preventScroll: !0
        });
      },
      changeActive: (f) => {
        const {
          activeElement: p
        } = document;
        f && p === a.value ? r.value.focus({
          preventScroll: !0
        }) : !f && p === r.value && a.value.focus({
          preventScroll: !0
        });
      }
    });
    const s = /* @__PURE__ */ H(), c = O(() => {
      const {
        width: f,
        height: p
      } = e, m = {};
      return f !== void 0 && (m.width = typeof f == "number" ? `${f}px` : f), p !== void 0 && (m.height = typeof p == "number" ? `${p}px` : p), s.value && (m.transformOrigin = s.value), m;
    }), u = () => {
      Ke(() => {
        if (i.value) {
          const f = U9e(i.value);
          s.value = e.mousePosition ? `${e.mousePosition.x - f.left}px ${e.mousePosition.y - f.top}px` : "";
        }
      });
    }, d = (f) => {
      e.onVisibleChanged(f);
    };
    return () => {
      var f, p, m, v;
      const {
        prefixCls: h,
        footer: g = (f = o.footer) === null || f === void 0 ? void 0 : f.call(o),
        title: y = (p = o.title) === null || p === void 0 ? void 0 : p.call(o),
        ariaId: b,
        closable: C,
        closeIcon: w = (m = o.closeIcon) === null || m === void 0 ? void 0 : m.call(o),
        onClose: x,
        bodyStyle: E,
        bodyProps: I,
        onMousedown: T,
        onMouseup: P,
        visible: k,
        modalRender: N = o.modalRender,
        destroyOnClose: R,
        motionName: z
      } = e;
      let D;
      g && (D = $("div", {
        class: `${h}-footer`
      }, [g]));
      let F;
      y && (F = $("div", {
        class: `${h}-header`
      }, [$("div", {
        class: `${h}-title`,
        id: b
      }, [y])]));
      let M;
      C && (M = $("button", {
        type: "button",
        onClick: x,
        "aria-label": "Close",
        class: `${h}-close`
      }, [w || $("span", {
        class: `${h}-close-x`
      }, null)]));
      const A = $("div", {
        class: `${h}-content`
      }, [M, F, $("div", Q({
        class: `${h}-body`,
        style: E
      }, I), [(v = o.default) === null || v === void 0 ? void 0 : v.call(o)]), D]), L = da(z);
      return $(Vn, Q(Q({}, L), {}, {
        onBeforeEnter: u,
        onAfterEnter: () => d(!0),
        onAfterLeave: () => d(!1)
      }), {
        default: () => [k || !R ? _t($("div", Q(Q({}, l), {}, {
          ref: i,
          key: "dialog-element",
          role: "document",
          style: [c.value, l.style],
          class: [h, l.class],
          onMousedown: T,
          onMouseup: P
        }), [$("div", {
          tabindex: 0,
          ref: r,
          style: Y9e
        }, [N ? N({
          originVNode: A
        }) : A]), $("div", {
          tabindex: 0,
          ref: a,
          style: G9e
        }, null)]), [[Jt, k]]) : null]
      });
    };
  }
}), q9e = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "DialogMask",
  props: {
    prefixCls: String,
    visible: Boolean,
    motionName: String,
    maskProps: Object
  },
  setup(e, t) {
    return () => {
      const {
        prefixCls: n,
        visible: o,
        maskProps: l,
        motionName: r
      } = e, a = da(r);
      return $(Vn, a, {
        default: () => [_t($("div", Q({
          class: `${n}-mask`
        }, l), null), [[Jt, o]])]
      });
    };
  }
}), OA = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "VcDialog",
  inheritAttrs: !1,
  props: sn(_(_({}, qS()), {
    getOpenCount: Function,
    scrollLocker: Object
  }), {
    mask: !0,
    visible: !1,
    keyboard: !0,
    closable: !0,
    maskClosable: !0,
    destroyOnClose: !1,
    prefixCls: "rc-dialog",
    getOpenCount: () => null,
    focusTriggerAfterClose: !0
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const l = /* @__PURE__ */ Ce(), r = /* @__PURE__ */ Ce(), a = /* @__PURE__ */ Ce(), i = /* @__PURE__ */ Ce(e.visible), s = /* @__PURE__ */ Ce(`vcDialogTitle${K9e()}`), c = (g) => {
      var y, b;
      if (g)
        Xs(r.value, document.activeElement) || (l.value = document.activeElement, (y = a.value) === null || y === void 0 || y.focus());
      else {
        const C = i.value;
        if (i.value = !1, e.mask && l.value && e.focusTriggerAfterClose) {
          try {
            l.value.focus({
              preventScroll: !0
            });
          } catch (w) {
          }
          l.value = null;
        }
        C && ((b = e.afterClose) === null || b === void 0 || b.call(e));
      }
    }, u = (g) => {
      var y;
      (y = e.onClose) === null || y === void 0 || y.call(e, g);
    }, d = /* @__PURE__ */ Ce(!1), f = /* @__PURE__ */ Ce(), p = () => {
      clearTimeout(f.value), d.value = !0;
    }, m = () => {
      f.value = setTimeout(() => {
        d.value = !1;
      });
    }, v = (g) => {
      if (!e.maskClosable) return null;
      d.value ? d.value = !1 : r.value === g.target && u(g);
    }, h = (g) => {
      if (e.keyboard && g.keyCode === ot.ESC) {
        g.stopPropagation(), u(g);
        return;
      }
      e.visible && g.keyCode === ot.TAB && a.value.changeActive(!g.shiftKey);
    };
    return pe(() => e.visible, () => {
      e.visible && (i.value = !0);
    }, {
      flush: "post"
    }), yt(() => {
      var g;
      clearTimeout(f.value), (g = e.scrollLocker) === null || g === void 0 || g.unLock();
    }), Ot(() => {
      var g, y;
      (g = e.scrollLocker) === null || g === void 0 || g.unLock(), i.value && ((y = e.scrollLocker) === null || y === void 0 || y.lock());
    }), () => {
      const {
        prefixCls: g,
        mask: y,
        visible: b,
        maskTransitionName: C,
        maskAnimation: w,
        zIndex: x,
        wrapClassName: E,
        rootClassName: I,
        wrapStyle: T,
        closable: P,
        maskProps: k,
        maskStyle: N,
        transitionName: R,
        animation: z,
        wrapProps: D,
        title: F = o.title
      } = e, {
        style: M,
        class: A
      } = n;
      return $("div", Q({
        class: [`${g}-root`, I]
      }, Mc(e, {
        data: !0
      })), [$(q9e, {
        prefixCls: g,
        visible: y && b,
        motionName: $A(g, C, w),
        style: _({
          zIndex: x
        }, N),
        maskProps: k
      }, null), $("div", Q({
        tabIndex: -1,
        onKeydown: h,
        class: ke(`${g}-wrap`, E),
        ref: r,
        onClick: v,
        role: "dialog",
        "aria-labelledby": F ? s.value : null,
        style: _(_({
          zIndex: x
        }, T), {
          display: i.value ? null : "none"
        })
      }, D), [$(X9e, Q(Q({}, pn(e, ["scrollLocker"])), {}, {
        style: M,
        class: A,
        onMousedown: p,
        onMouseup: m,
        ref: a,
        closable: P,
        ariaId: s.value,
        prefixCls: g,
        visible: b,
        onClose: u,
        onVisibleChanged: c,
        motionName: $A(g, R, z)
      }), o)])]);
    };
  }
}), J9e = qS(), NU = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "DialogWrap",
  inheritAttrs: !1,
  props: sn(J9e, {
    visible: !1
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const l = /* @__PURE__ */ H(e.visible);
    return EI({}, {
      inTriggerContext: !1
    }), pe(() => e.visible, () => {
      e.visible && (l.value = !0);
    }, {
      flush: "post"
    }), () => {
      const {
        visible: r,
        getContainer: a,
        forceRender: i,
        destroyOnClose: s = !1,
        afterClose: c
      } = e;
      let u = _(_(_({}, e), n), {
        ref: "_component",
        key: "dialog"
      });
      return a === !1 ? $(OA, Q(Q({}, u), {}, {
        getOpenCount: () => 2
      }), o) : !i && s && !l.value ? null : $(Eh, {
        autoLock: !0,
        visible: r,
        forceRender: i,
        getContainer: a
      }, {
        default: (d) => (u = _(_(_({}, u), d), {
          afterClose: () => {
            c == null || c(), l.value = !1;
          }
        }), $(OA, u, o))
      });
    };
  }
});
function Z9e(e) {
  const t = /* @__PURE__ */ H(null), n = /* @__PURE__ */ kt(_({}, e)), o = /* @__PURE__ */ H([]), l = (r) => {
    t.value === null && (o.value = [], t.value = rn(() => {
      let a;
      o.value.forEach((i) => {
        a = _(_({}, a), i);
      }), _(n, a), t.value = null;
    })), o.value.push(r);
  };
  return nt(() => {
    t.value && rn.cancel(t.value);
  }), [n, l];
}
function _A(e, t, n, o) {
  const l = t + n, r = (n - o) / 2;
  if (n > o) {
    if (t > 0)
      return {
        [e]: r
      };
    if (t < 0 && l < o)
      return {
        [e]: -r
      };
  } else if (t < 0 || l > o)
    return {
      [e]: t < 0 ? r : -r
    };
  return {};
}
function Q9e(e, t, n, o) {
  const {
    width: l,
    height: r
  } = oNe();
  let a = null;
  return e <= l && t <= r ? a = {
    x: 0,
    y: 0
  } : (e > l || t > r) && (a = _(_({}, _A("x", n, e, l)), _A("y", o, t, r))), a;
}
var eVe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const IA = Symbol("previewGroupContext"), eP = {
  provide: (e) => {
    at(IA, e);
  },
  inject: () => ze(IA, {
    isPreviewGroup: /* @__PURE__ */ Ce(!1),
    previewUrls: O(() => /* @__PURE__ */ new Map()),
    setPreviewUrls: () => {
    },
    current: /* @__PURE__ */ H(null),
    setCurrent: () => {
    },
    setShowPreview: () => {
    },
    setMousePosition: () => {
    },
    registerImage: null,
    rootClassName: ""
  })
}, tVe = () => ({
  previewPrefixCls: String,
  preview: {
    type: [Boolean, Object],
    default: !0
  },
  icons: {
    type: Object,
    default: () => ({})
  }
}), MU = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "PreviewGroup",
  inheritAttrs: !1,
  props: tVe(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = O(() => {
      const w = {
        visible: void 0,
        onVisibleChange: () => {
        },
        getContainer: void 0,
        current: 0
      };
      return typeof e.preview == "object" ? DU(e.preview, w) : w;
    }), l = /* @__PURE__ */ kt(/* @__PURE__ */ new Map()), r = /* @__PURE__ */ H(), a = O(() => o.value.visible), i = O(() => o.value.getContainer), s = (w, x) => {
      var E, I;
      (I = (E = o.value).onVisibleChange) === null || I === void 0 || I.call(E, w, x);
    }, [c, u] = ro(!!a.value, {
      value: a,
      onChange: s
    }), d = /* @__PURE__ */ H(null), f = O(() => a.value !== void 0), p = O(() => Array.from(l.keys())), m = O(() => p.value[o.value.current]), v = O(() => new Map(Array.from(l).filter((w) => {
      let [, {
        canPreview: x
      }] = w;
      return !!x;
    }).map((w) => {
      let [x, {
        url: E
      }] = w;
      return [x, E];
    }))), h = function(w, x) {
      let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
      l.set(w, {
        url: x,
        canPreview: E
      });
    }, g = (w) => {
      r.value = w;
    }, y = (w) => {
      d.value = w;
    }, b = function(w, x) {
      let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
      const I = () => {
        l.delete(w);
      };
      return l.set(w, {
        url: x,
        canPreview: E
      }), I;
    }, C = (w) => {
      w == null || w.stopPropagation(), u(!1), y(null);
    };
    return pe(m, (w) => {
      g(w);
    }, {
      immediate: !0,
      flush: "post"
    }), Ot(() => {
      c.value && f.value && g(m.value);
    }, {
      flush: "post"
    }), eP.provide({
      isPreviewGroup: /* @__PURE__ */ Ce(!0),
      previewUrls: v,
      setPreviewUrls: h,
      current: r,
      setCurrent: g,
      setShowPreview: u,
      setMousePosition: y,
      registerImage: b
    }), () => {
      const w = eVe(o.value, []);
      return $(Ge, null, [n.default && n.default(), $(AU, Q(Q({}, w), {}, {
        "ria-hidden": !c.value,
        visible: c.value,
        prefixCls: e.previewPrefixCls,
        onClose: C,
        mousePosition: d.value,
        src: v.value.get(r.value),
        icons: e.icons,
        getContainer: i.value
      }), null)]);
    };
  }
}), Yc = {
  x: 0,
  y: 0
}, nVe = _(_({}, qS()), {
  src: String,
  alt: String,
  rootClassName: String,
  icons: {
    type: Object,
    default: () => ({})
  }
}), AU = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Preview",
  inheritAttrs: !1,
  props: nVe,
  emits: ["close", "afterClose"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o
    } = t;
    const {
      rotateLeft: l,
      rotateRight: r,
      zoomIn: a,
      zoomOut: i,
      close: s,
      left: c,
      right: u,
      flipX: d,
      flipY: f
    } = /* @__PURE__ */ kt(e.icons), p = /* @__PURE__ */ Ce(1), m = /* @__PURE__ */ Ce(0), v = /* @__PURE__ */ kt({
      x: 1,
      y: 1
    }), [h, g] = Z9e(Yc), y = () => n("close"), b = /* @__PURE__ */ Ce(), C = /* @__PURE__ */ kt({
      originX: 0,
      originY: 0,
      deltaX: 0,
      deltaY: 0
    }), w = /* @__PURE__ */ Ce(!1), x = eP.inject(), {
      previewUrls: E,
      current: I,
      isPreviewGroup: T,
      setCurrent: P
    } = x, k = O(() => E.value.size), N = O(() => Array.from(E.value.keys())), R = O(() => N.value.indexOf(I.value)), z = O(() => T.value ? E.value.get(I.value) : e.src), D = O(() => T.value && k.value > 1), F = /* @__PURE__ */ Ce({
      wheelDirection: 0
    }), M = () => {
      p.value = 1, m.value = 0, v.x = 1, v.y = 1, g(Yc), n("afterClose");
    }, A = (ge) => {
      ge ? p.value += 0.5 : p.value++, g(Yc);
    }, L = (ge) => {
      p.value > 1 && (ge ? p.value -= 0.5 : p.value--), g(Yc);
    }, B = () => {
      m.value += 90;
    }, V = () => {
      m.value -= 90;
    }, j = () => {
      v.x = -v.x;
    }, W = () => {
      v.y = -v.y;
    }, Y = (ge) => {
      ge.preventDefault(), ge.stopPropagation(), R.value > 0 && P(N.value[R.value - 1]);
    }, U = (ge) => {
      ge.preventDefault(), ge.stopPropagation(), R.value < k.value - 1 && P(N.value[R.value + 1]);
    }, te = ke({
      [`${e.prefixCls}-moving`]: w.value
    }), J = `${e.prefixCls}-operations-operation`, re = `${e.prefixCls}-operations-icon`, oe = [{
      icon: s,
      onClick: y,
      type: "close"
    }, {
      icon: a,
      onClick: () => A(),
      type: "zoomIn"
    }, {
      icon: i,
      onClick: () => L(),
      type: "zoomOut",
      disabled: O(() => p.value === 1)
    }, {
      icon: r,
      onClick: B,
      type: "rotateRight"
    }, {
      icon: l,
      onClick: V,
      type: "rotateLeft"
    }, {
      icon: d,
      onClick: j,
      type: "flipX"
    }, {
      icon: f,
      onClick: W,
      type: "flipY"
    }], q = () => {
      if (e.visible && w.value) {
        const ge = b.value.offsetWidth * p.value, he = b.value.offsetHeight * p.value, {
          left: $e,
          top: ne
        } = cy(b.value), ae = m.value % 180 !== 0;
        w.value = !1;
        const ce = Q9e(ae ? he : ge, ae ? ge : he, $e, ne);
        ce && g(_({}, ce));
      }
    }, K = (ge) => {
      ge.button === 0 && (ge.preventDefault(), ge.stopPropagation(), C.deltaX = ge.pageX - h.x, C.deltaY = ge.pageY - h.y, C.originX = h.x, C.originY = h.y, w.value = !0);
    }, se = (ge) => {
      e.visible && w.value && g({
        x: ge.pageX - C.deltaX,
        y: ge.pageY - C.deltaY
      });
    }, Z = (ge) => {
      if (!e.visible) return;
      ge.preventDefault();
      const he = ge.deltaY;
      F.value = {
        wheelDirection: he
      };
    }, ee = (ge) => {
      !e.visible || !D.value || (ge.preventDefault(), ge.keyCode === ot.LEFT ? R.value > 0 && P(N.value[R.value - 1]) : ge.keyCode === ot.RIGHT && R.value < k.value - 1 && P(N.value[R.value + 1]));
    }, fe = () => {
      e.visible && (p.value !== 1 && (p.value = 1), (h.x !== Yc.x || h.y !== Yc.y) && g(Yc));
    };
    let me = () => {
    };
    return nt(() => {
      pe([() => e.visible, w], () => {
        me();
        let ge, he;
        const $e = vo(window, "mouseup", q, !1), ne = vo(window, "mousemove", se, !1), ae = vo(window, "wheel", Z, {
          passive: !1
        }), ce = vo(window, "keydown", ee, !1);
        try {
          window.top !== window.self && (ge = vo(window.top, "mouseup", q, !1), he = vo(window.top, "mousemove", se, !1));
        } catch (xe) {
          bn(!1, `[vc-image] ${xe}`);
        }
        me = () => {
          $e.remove(), ne.remove(), ae.remove(), ce.remove(), ge && ge.remove(), he && he.remove();
        };
      }, {
        flush: "post",
        immediate: !0
      }), pe([F], () => {
        const {
          wheelDirection: ge
        } = F.value;
        ge > 0 ? L(!0) : ge < 0 && A(!0);
      });
    }), Uo(() => {
      me();
    }), () => {
      const {
        visible: ge,
        prefixCls: he,
        rootClassName: $e
      } = e;
      return $(NU, Q(Q({}, o), {}, {
        transitionName: e.transitionName,
        maskTransitionName: e.maskTransitionName,
        closable: !1,
        keyboard: !0,
        prefixCls: he,
        onClose: y,
        afterClose: M,
        visible: ge,
        wrapClassName: te,
        rootClassName: $e,
        getContainer: e.getContainer
      }), {
        default: () => [$("div", {
          class: [`${e.prefixCls}-operations-wrapper`, $e]
        }, [$("ul", {
          class: `${e.prefixCls}-operations`
        }, [oe.map((ne) => {
          let {
            icon: ae,
            onClick: ce,
            type: xe,
            disabled: Te
          } = ne;
          return $("li", {
            class: ke(J, {
              [`${e.prefixCls}-operations-operation-disabled`]: Te && (Te == null ? void 0 : Te.value)
            }),
            onClick: ce,
            key: xe
          }, [No(ae, {
            class: re
          })]);
        })])]), $("div", {
          class: `${e.prefixCls}-img-wrapper`,
          style: {
            transform: `translate3d(${h.x}px, ${h.y}px, 0)`
          }
        }, [$("img", {
          onMousedown: K,
          onDblclick: fe,
          ref: b,
          class: `${e.prefixCls}-img`,
          src: z.value,
          alt: e.alt,
          style: {
            transform: `scale3d(${v.x * p.value}, ${v.y * p.value}, 1) rotate(${m.value}deg)`
          }
        }, null)]), D.value && $("div", {
          class: ke(`${e.prefixCls}-switch-left`, {
            [`${e.prefixCls}-switch-left-disabled`]: R.value <= 0
          }),
          onClick: Y
        }, [c]), D.value && $("div", {
          class: ke(`${e.prefixCls}-switch-right`, {
            [`${e.prefixCls}-switch-right-disabled`]: R.value >= k.value - 1
          }),
          onClick: U
        }, [u])]
      });
    };
  }
});
var oVe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const RU = () => ({
  src: String,
  wrapperClassName: String,
  wrapperStyle: {
    type: Object,
    default: void 0
  },
  rootClassName: String,
  prefixCls: String,
  previewPrefixCls: String,
  width: [Number, String],
  height: [Number, String],
  previewMask: {
    type: [Boolean, Function],
    default: void 0
  },
  placeholder: de.any,
  fallback: String,
  preview: {
    type: [Boolean, Object],
    default: !0
  },
  onClick: {
    type: Function
  },
  onError: {
    type: Function
  }
}), DU = (e, t) => {
  const n = _({}, e);
  return Object.keys(t).forEach((o) => {
    e[o] === void 0 && (n[o] = t[o]);
  }), n;
};
let lVe = 0;
const LU = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "VcImage",
  inheritAttrs: !1,
  props: RU(),
  emits: ["click", "error"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: l
    } = t;
    const r = O(() => e.prefixCls), a = O(() => `${r.value}-preview`), i = O(() => {
      const A = {
        visible: void 0,
        onVisibleChange: () => {
        },
        getContainer: void 0
      };
      return typeof e.preview == "object" ? DU(e.preview, A) : A;
    }), s = O(() => {
      var A;
      return (A = i.value.src) !== null && A !== void 0 ? A : e.src;
    }), c = O(() => e.placeholder && e.placeholder !== !0 || o.placeholder), u = O(() => i.value.visible), d = O(() => i.value.getContainer), f = O(() => u.value !== void 0), p = (A, L) => {
      var B, V;
      (V = (B = i.value).onVisibleChange) === null || V === void 0 || V.call(B, A, L);
    }, [m, v] = ro(!!u.value, {
      value: u,
      onChange: p
    }), h = /* @__PURE__ */ H(c.value ? "loading" : "normal");
    pe(() => e.src, () => {
      h.value = c.value ? "loading" : "normal";
    });
    const g = /* @__PURE__ */ H(null), y = O(() => h.value === "error"), b = eP.inject(), {
      isPreviewGroup: C,
      setCurrent: w,
      setShowPreview: x,
      setMousePosition: E,
      registerImage: I
    } = b, T = /* @__PURE__ */ H(lVe++), P = O(() => e.preview && !y.value), k = () => {
      h.value = "normal";
    }, N = (A) => {
      h.value = "error", l("error", A);
    }, R = (A) => {
      if (!f.value) {
        const {
          left: L,
          top: B
        } = cy(A.target);
        C.value ? (w(T.value), E({
          x: L,
          y: B
        })) : g.value = {
          x: L,
          y: B
        };
      }
      C.value ? x(!0) : v(!0), l("click", A);
    }, z = () => {
      v(!1), f.value || (g.value = null);
    }, D = /* @__PURE__ */ H(null);
    pe(() => D, () => {
      h.value === "loading" && D.value.complete && (D.value.naturalWidth || D.value.naturalHeight) && k();
    });
    let F = () => {
    };
    nt(() => {
      pe([s, P], () => {
        if (F(), !C.value)
          return () => {
          };
        F = I(T.value, s.value, P.value), P.value || F();
      }, {
        flush: "post",
        immediate: !0
      });
    }), Uo(() => {
      F();
    });
    const M = (A) => Oae(A) ? A + "px" : A;
    return () => {
      const {
        prefixCls: A,
        wrapperClassName: L,
        fallback: B,
        src: V,
        placeholder: j,
        wrapperStyle: W,
        rootClassName: Y,
        width: U,
        height: te,
        crossorigin: J,
        decoding: re,
        alt: oe,
        sizes: q,
        srcset: K,
        usemap: se,
        class: Z,
        style: ee
      } = _(_({}, e), n), fe = i.value, {
        icons: me,
        maskClassName: ge
      } = fe, he = oVe(fe, ["icons", "maskClassName"]), $e = ke(A, L, Y, {
        [`${A}-error`]: y.value
      }), ne = y.value && B ? B : s.value, ae = {
        crossorigin: J,
        decoding: re,
        alt: oe,
        sizes: q,
        srcset: K,
        usemap: se,
        width: U,
        height: te,
        class: ke(`${A}-img`, {
          [`${A}-img-placeholder`]: j === !0
        }, Z),
        style: _({
          height: M(te)
        }, ee)
      };
      return $(Ge, null, [$("div", {
        class: $e,
        onClick: P.value ? R : (ce) => {
          l("click", ce);
        },
        style: _({
          width: M(U),
          height: M(te)
        }, W)
      }, [$("img", Q(Q(Q({}, ae), y.value && B ? {
        src: B
      } : {
        onLoad: k,
        onError: N,
        src: V
      }), {}, {
        ref: D
      }), null), h.value === "loading" && $("div", {
        "aria-hidden": "true",
        class: `${A}-placeholder`
      }, [j || o.placeholder && o.placeholder()]), o.previewMask && P.value && $("div", {
        class: [`${A}-mask`, ge]
      }, [o.previewMask()])]), !C.value && P.value && $(AU, Q(Q({}, he), {}, {
        "aria-hidden": !m.value,
        visible: m.value,
        prefixCls: a.value,
        onClose: z,
        mousePosition: g.value,
        src: ne,
        alt: oe,
        getContainer: d.value,
        icons: me,
        rootClassName: Y
      }), null)]);
    };
  }
});
LU.PreviewGroup = MU;
var rVe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H188V494h440v326z" } }, { tag: "path", attrs: { d: "M819.3 328.5c-78.8-100.7-196-153.6-314.6-154.2l-.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7.4 12.6-6.1v-63.9c12.9.1 25.9.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8a325.95 325.95 0 016.5 140.9h74.9c14.8-103.6-11.3-213-81-302.3z" } }] }, name: "rotate-left", theme: "outlined" };
function TA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      aVe(e, l, n[l]);
    });
  }
  return e;
}
function aVe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var tP = function(t, n) {
  var o = TA({}, t, n.attrs);
  return $(cn, TA({}, o, {
    icon: rVe
  }), null);
};
tP.displayName = "RotateLeftOutlined";
tP.inheritAttrs = !1;
var iVe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-.4-12.6 6.1l-.2 64c-118.6.5-235.8 53.4-314.6 154.2A399.75 399.75 0 00123.5 631h74.9c-.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8z" } }, { tag: "path", attrs: { d: "M880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H396V494h440v326z" } }] }, name: "rotate-right", theme: "outlined" };
function PA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      sVe(e, l, n[l]);
    });
  }
  return e;
}
function sVe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var nP = function(t, n) {
  var o = PA({}, t, n.attrs);
  return $(cn, PA({}, o, {
    icon: iVe
  }), null);
};
nP.displayName = "RotateRightOutlined";
nP.inheritAttrs = !1;
var cVe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, name: "zoom-in", theme: "outlined" };
function kA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      uVe(e, l, n[l]);
    });
  }
  return e;
}
function uVe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var oP = function(t, n) {
  var o = kA({}, t, n.attrs);
  return $(cn, kA({}, o, {
    icon: cVe
  }), null);
};
oP.displayName = "ZoomInOutlined";
oP.inheritAttrs = !1;
var dVe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, name: "zoom-out", theme: "outlined" };
function NA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      fVe(e, l, n[l]);
    });
  }
  return e;
}
function fVe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var lP = function(t, n) {
  var o = NA({}, t, n.attrs);
  return $(cn, NA({}, o, {
    icon: dVe
  }), null);
};
lP.displayName = "ZoomOutOutlined";
lP.inheritAttrs = !1;
var pVe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M847.9 592H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h605.2L612.9 851c-4.1 5.2-.4 13 6.3 13h72.5c4.9 0 9.5-2.2 12.6-6.1l168.8-214.1c16.5-21 1.6-51.8-25.2-51.8zM872 356H266.8l144.3-183c4.1-5.2.4-13-6.3-13h-72.5c-4.9 0-9.5 2.2-12.6 6.1L150.9 380.2c-16.5 21-1.6 51.8 25.1 51.8h696c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, name: "swap", theme: "outlined" };
function MA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      vVe(e, l, n[l]);
    });
  }
  return e;
}
function vVe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Hy = function(t, n) {
  var o = MA({}, t, n.attrs);
  return $(cn, MA({}, o, {
    icon: pVe
  }), null);
};
Hy.displayName = "SwapOutlined";
Hy.inheritAttrs = !1;
function AA(e) {
  return {
    position: e,
    top: 0,
    insetInlineEnd: 0,
    bottom: 0,
    insetInlineStart: 0
  };
}
const BU = (e) => {
  const {
    componentCls: t
  } = e;
  return [{
    [`${t}-root`]: {
      [`${t}${e.antCls}-zoom-enter, ${t}${e.antCls}-zoom-appear`]: {
        // reset scale avoid mousePosition bug
        transform: "none",
        opacity: 0,
        animationDuration: e.motionDurationSlow,
        // https://github.com/ant-design/ant-design/issues/11777
        userSelect: "none"
      },
      [`${t}${e.antCls}-zoom-leave ${t}-content`]: {
        pointerEvents: "none"
      },
      [`${t}-mask`]: _(_({}, AA("fixed")), {
        zIndex: e.zIndexPopupBase,
        height: "100%",
        backgroundColor: e.colorBgMask,
        [`${t}-hidden`]: {
          display: "none"
        }
      }),
      [`${t}-wrap`]: _(_({}, AA("fixed")), {
        overflow: "auto",
        outline: 0,
        WebkitOverflowScrolling: "touch"
      })
    }
  }, {
    [`${t}-root`]: VI(e)
  }];
}, mVe = (e) => {
  const {
    componentCls: t
  } = e;
  return [
    // ======================== Root =========================
    {
      [`${t}-root`]: {
        [`${t}-wrap`]: {
          zIndex: e.zIndexPopupBase,
          position: "fixed",
          inset: 0,
          overflow: "auto",
          outline: 0,
          WebkitOverflowScrolling: "touch"
        },
        [`${t}-wrap-rtl`]: {
          direction: "rtl"
        },
        [`${t}-centered`]: {
          textAlign: "center",
          "&::before": {
            display: "inline-block",
            width: 0,
            height: "100%",
            verticalAlign: "middle",
            content: '""'
          },
          [t]: {
            top: 0,
            display: "inline-block",
            paddingBottom: 0,
            textAlign: "start",
            verticalAlign: "middle"
          }
        },
        [`@media (max-width: ${e.screenSMMax})`]: {
          [t]: {
            maxWidth: "calc(100vw - 16px)",
            margin: `${e.marginXS} auto`
          },
          [`${t}-centered`]: {
            [t]: {
              flex: 1
            }
          }
        }
      }
    },
    // ======================== Modal ========================
    {
      [t]: _(_({}, nn(e)), {
        pointerEvents: "none",
        position: "relative",
        top: 100,
        width: "auto",
        maxWidth: `calc(100vw - ${e.margin * 2}px)`,
        margin: "0 auto",
        paddingBottom: e.paddingLG,
        [`${t}-title`]: {
          margin: 0,
          color: e.modalHeadingColor,
          fontWeight: e.fontWeightStrong,
          fontSize: e.modalHeaderTitleFontSize,
          lineHeight: e.modalHeaderTitleLineHeight,
          wordWrap: "break-word"
        },
        [`${t}-content`]: {
          position: "relative",
          backgroundColor: e.modalContentBg,
          backgroundClip: "padding-box",
          border: 0,
          borderRadius: e.borderRadiusLG,
          boxShadow: e.boxShadowSecondary,
          pointerEvents: "auto",
          padding: `${e.paddingMD}px ${e.paddingContentHorizontalLG}px`
        },
        [`${t}-close`]: _({
          position: "absolute",
          top: (e.modalHeaderCloseSize - e.modalCloseBtnSize) / 2,
          insetInlineEnd: (e.modalHeaderCloseSize - e.modalCloseBtnSize) / 2,
          zIndex: e.zIndexPopupBase + 10,
          padding: 0,
          color: e.modalCloseColor,
          fontWeight: e.fontWeightStrong,
          lineHeight: 1,
          textDecoration: "none",
          background: "transparent",
          borderRadius: e.borderRadiusSM,
          width: e.modalConfirmIconSize,
          height: e.modalConfirmIconSize,
          border: 0,
          outline: 0,
          cursor: "pointer",
          transition: `color ${e.motionDurationMid}, background-color ${e.motionDurationMid}`,
          "&-x": {
            display: "block",
            fontSize: e.fontSizeLG,
            fontStyle: "normal",
            lineHeight: `${e.modalCloseBtnSize}px`,
            textAlign: "center",
            textTransform: "none",
            textRendering: "auto"
          },
          "&:hover": {
            color: e.modalIconHoverColor,
            backgroundColor: e.wireframe ? "transparent" : e.colorFillContent,
            textDecoration: "none"
          },
          "&:active": {
            backgroundColor: e.wireframe ? "transparent" : e.colorFillContentHover
          }
        }, ys(e)),
        [`${t}-header`]: {
          color: e.colorText,
          background: e.modalHeaderBg,
          borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`,
          marginBottom: e.marginXS
        },
        [`${t}-body`]: {
          fontSize: e.fontSize,
          lineHeight: e.lineHeight,
          wordWrap: "break-word"
        },
        [`${t}-footer`]: {
          textAlign: "end",
          background: e.modalFooterBg,
          marginTop: e.marginSM,
          [`${e.antCls}-btn + ${e.antCls}-btn:not(${e.antCls}-dropdown-trigger)`]: {
            marginBottom: 0,
            marginInlineStart: e.marginXS
          }
        },
        [`${t}-open`]: {
          overflow: "hidden"
        }
      })
    },
    // ======================== Pure =========================
    {
      [`${t}-pure-panel`]: {
        top: "auto",
        padding: 0,
        display: "flex",
        flexDirection: "column",
        [`${t}-content,
          ${t}-body,
          ${t}-confirm-body-wrapper`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto"
        },
        [`${t}-confirm-body`]: {
          marginBottom: "auto"
        }
      }
    }
  ];
}, hVe = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-confirm`;
  return {
    [n]: {
      "&-rtl": {
        direction: "rtl"
      },
      [`${e.antCls}-modal-header`]: {
        display: "none"
      },
      [`${n}-body-wrapper`]: _({}, ja()),
      [`${n}-body`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        [`${n}-title`]: {
          flex: "0 0 100%",
          display: "block",
          // create BFC to avoid
          // https://user-images.githubusercontent.com/507615/37702510-ba844e06-2d2d-11e8-9b67-8e19be57f445.png
          overflow: "hidden",
          color: e.colorTextHeading,
          fontWeight: e.fontWeightStrong,
          fontSize: e.modalHeaderTitleFontSize,
          lineHeight: e.modalHeaderTitleLineHeight,
          [`+ ${n}-content`]: {
            marginBlockStart: e.marginXS,
            flexBasis: "100%",
            maxWidth: `calc(100% - ${e.modalConfirmIconSize + e.marginSM}px)`
          }
        },
        [`${n}-content`]: {
          color: e.colorText,
          fontSize: e.fontSize
        },
        [`> ${e.iconCls}`]: {
          flex: "none",
          marginInlineEnd: e.marginSM,
          fontSize: e.modalConfirmIconSize,
          [`+ ${n}-title`]: {
            flex: 1
          },
          // `content` after `icon` should set marginLeft
          [`+ ${n}-title + ${n}-content`]: {
            marginInlineStart: e.modalConfirmIconSize + e.marginSM
          }
        }
      },
      [`${n}-btns`]: {
        textAlign: "end",
        marginTop: e.marginSM,
        [`${e.antCls}-btn + ${e.antCls}-btn`]: {
          marginBottom: 0,
          marginInlineStart: e.marginXS
        }
      }
    },
    [`${n}-error ${n}-body > ${e.iconCls}`]: {
      color: e.colorError
    },
    [`${n}-warning ${n}-body > ${e.iconCls},
        ${n}-confirm ${n}-body > ${e.iconCls}`]: {
      color: e.colorWarning
    },
    [`${n}-info ${n}-body > ${e.iconCls}`]: {
      color: e.colorInfo
    },
    [`${n}-success ${n}-body > ${e.iconCls}`]: {
      color: e.colorSuccess
    },
    // https://github.com/ant-design/ant-design/issues/37329
    [`${t}-zoom-leave ${t}-btns`]: {
      pointerEvents: "none"
    }
  };
}, gVe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-root`]: {
      [`${t}-wrap-rtl`]: {
        direction: "rtl",
        [`${t}-confirm-body`]: {
          direction: "rtl"
        }
      }
    }
  };
}, bVe = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e, o = `${t}-confirm`;
  return {
    [t]: {
      [`${t}-content`]: {
        padding: 0
      },
      [`${t}-header`]: {
        padding: e.modalHeaderPadding,
        borderBottom: `${e.modalHeaderBorderWidth}px ${e.modalHeaderBorderStyle} ${e.modalHeaderBorderColorSplit}`,
        marginBottom: 0
      },
      [`${t}-body`]: {
        padding: e.modalBodyPadding
      },
      [`${t}-footer`]: {
        padding: `${e.modalFooterPaddingVertical}px ${e.modalFooterPaddingHorizontal}px`,
        borderTop: `${e.modalFooterBorderWidth}px ${e.modalFooterBorderStyle} ${e.modalFooterBorderColorSplit}`,
        borderRadius: `0 0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px`,
        marginTop: 0
      }
    },
    [o]: {
      [`${n}-modal-body`]: {
        padding: `${e.padding * 2}px ${e.padding * 2}px ${e.paddingLG}px`
      },
      [`${o}-body`]: {
        [`> ${e.iconCls}`]: {
          marginInlineEnd: e.margin,
          // `content` after `icon` should set marginLeft
          [`+ ${o}-title + ${o}-content`]: {
            marginInlineStart: e.modalConfirmIconSize + e.margin
          }
        }
      },
      [`${o}-btns`]: {
        marginTop: e.marginLG
      }
    }
  };
}, yVe = Zt("Modal", (e) => {
  const t = e.padding, n = e.fontSizeHeading5, o = e.lineHeightHeading5, l = Vt(e, {
    modalBodyPadding: e.paddingLG,
    modalHeaderBg: e.colorBgElevated,
    modalHeaderPadding: `${t}px ${e.paddingLG}px`,
    modalHeaderBorderWidth: e.lineWidth,
    modalHeaderBorderStyle: e.lineType,
    modalHeaderTitleLineHeight: o,
    modalHeaderTitleFontSize: n,
    modalHeaderBorderColorSplit: e.colorSplit,
    modalHeaderCloseSize: o * n + t * 2,
    modalContentBg: e.colorBgElevated,
    modalHeadingColor: e.colorTextHeading,
    modalCloseColor: e.colorTextDescription,
    modalFooterBg: "transparent",
    modalFooterBorderColorSplit: e.colorSplit,
    modalFooterBorderStyle: e.lineType,
    modalFooterPaddingVertical: e.paddingXS,
    modalFooterPaddingHorizontal: e.padding,
    modalFooterBorderWidth: e.lineWidth,
    modalConfirmTitleFontSize: e.fontSizeLG,
    modalIconHoverColor: e.colorIconHover,
    modalConfirmIconSize: e.fontSize * e.lineHeight,
    modalCloseBtnSize: e.controlHeightLG * 0.55
  });
  return [mVe(l), hVe(l), gVe(l), BU(l), e.wireframe && bVe(l), Ap(l, "zoom")];
}), J2 = (e) => ({
  position: e || "absolute",
  inset: 0
}), SVe = (e) => {
  const {
    iconCls: t,
    motionDurationSlow: n,
    paddingXXS: o,
    marginXXS: l,
    prefixCls: r
  } = e;
  return {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    color: "#fff",
    background: new xn("#000").setAlpha(0.5).toRgbString(),
    cursor: "pointer",
    opacity: 0,
    transition: `opacity ${n}`,
    [`.${r}-mask-info`]: _(_({}, Fo), {
      padding: `0 ${o}px`,
      [t]: {
        marginInlineEnd: l,
        svg: {
          verticalAlign: "baseline"
        }
      }
    })
  };
}, CVe = (e) => {
  const {
    previewCls: t,
    modalMaskBg: n,
    paddingSM: o,
    previewOperationColorDisabled: l,
    motionDurationSlow: r
  } = e, a = new xn(n).setAlpha(0.1), i = a.clone().setAlpha(0.2);
  return {
    [`${t}-operations`]: _(_({}, nn(e)), {
      display: "flex",
      flexDirection: "row-reverse",
      alignItems: "center",
      color: e.previewOperationColor,
      listStyle: "none",
      background: a.toRgbString(),
      pointerEvents: "auto",
      "&-operation": {
        marginInlineStart: o,
        padding: o,
        cursor: "pointer",
        transition: `all ${r}`,
        userSelect: "none",
        "&:hover": {
          background: i.toRgbString()
        },
        "&-disabled": {
          color: l,
          pointerEvents: "none"
        },
        "&:last-of-type": {
          marginInlineStart: 0
        }
      },
      "&-progress": {
        position: "absolute",
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%)"
      },
      "&-icon": {
        fontSize: e.previewOperationSize
      }
    })
  };
}, wVe = (e) => {
  const {
    modalMaskBg: t,
    iconCls: n,
    previewOperationColorDisabled: o,
    previewCls: l,
    zIndexPopup: r,
    motionDurationSlow: a
  } = e, i = new xn(t).setAlpha(0.1), s = i.clone().setAlpha(0.2);
  return {
    [`${l}-switch-left, ${l}-switch-right`]: {
      position: "fixed",
      insetBlockStart: "50%",
      zIndex: r + 1,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: e.imagePreviewSwitchSize,
      height: e.imagePreviewSwitchSize,
      marginTop: -e.imagePreviewSwitchSize / 2,
      color: e.previewOperationColor,
      background: i.toRgbString(),
      borderRadius: "50%",
      transform: "translateY(-50%)",
      cursor: "pointer",
      transition: `all ${a}`,
      pointerEvents: "auto",
      userSelect: "none",
      "&:hover": {
        background: s.toRgbString()
      },
      "&-disabled": {
        "&, &:hover": {
          color: o,
          background: "transparent",
          cursor: "not-allowed",
          [`> ${n}`]: {
            cursor: "not-allowed"
          }
        }
      },
      [`> ${n}`]: {
        fontSize: e.previewOperationSize
      }
    },
    [`${l}-switch-left`]: {
      insetInlineStart: e.marginSM
    },
    [`${l}-switch-right`]: {
      insetInlineEnd: e.marginSM
    }
  };
}, $Ve = (e) => {
  const {
    motionEaseOut: t,
    previewCls: n,
    motionDurationSlow: o,
    componentCls: l
  } = e;
  return [
    {
      [`${l}-preview-root`]: {
        [n]: {
          height: "100%",
          textAlign: "center",
          pointerEvents: "none"
        },
        [`${n}-body`]: _(_({}, J2()), {
          overflow: "hidden"
        }),
        [`${n}-img`]: {
          maxWidth: "100%",
          maxHeight: "100%",
          verticalAlign: "middle",
          transform: "scale3d(1, 1, 1)",
          cursor: "grab",
          transition: `transform ${o} ${t} 0s`,
          userSelect: "none",
          pointerEvents: "auto",
          "&-wrapper": _(_({}, J2()), {
            transition: `transform ${o} ${t} 0s`,
            // https://github.com/ant-design/ant-design/issues/39913
            // TailwindCSS will reset img default style.
            // Let's set back.
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            "&::before": {
              display: "inline-block",
              width: 1,
              height: "50%",
              marginInlineEnd: -1,
              content: '""'
            }
          })
        },
        [`${n}-moving`]: {
          [`${n}-preview-img`]: {
            cursor: "grabbing",
            "&-wrapper": {
              transitionDuration: "0s"
            }
          }
        }
      }
    },
    // Override
    {
      [`${l}-preview-root`]: {
        [`${n}-wrap`]: {
          zIndex: e.zIndexPopup
        }
      }
    },
    // Preview operations & switch
    {
      [`${l}-preview-operations-wrapper`]: {
        position: "fixed",
        insetBlockStart: 0,
        insetInlineEnd: 0,
        zIndex: e.zIndexPopup + 1,
        width: "100%"
      },
      "&": [CVe(e), wVe(e)]
    }
  ];
}, xVe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // ============================== image ==============================
    [t]: {
      position: "relative",
      display: "inline-block",
      [`${t}-img`]: {
        width: "100%",
        height: "auto",
        verticalAlign: "middle"
      },
      [`${t}-img-placeholder`]: {
        backgroundColor: e.colorBgContainerDisabled,
        backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center center",
        backgroundSize: "30%"
      },
      [`${t}-mask`]: _({}, SVe(e)),
      [`${t}-mask:hover`]: {
        opacity: 1
      },
      [`${t}-placeholder`]: _({}, J2())
    }
  };
}, EVe = (e) => {
  const {
    previewCls: t
  } = e;
  return {
    [`${t}-root`]: Ap(e, "zoom"),
    "&": VI(e, !0)
  };
}, FU = Zt("Image", (e) => {
  const t = `${e.componentCls}-preview`, n = Vt(e, {
    previewCls: t,
    modalMaskBg: new xn("#000").setAlpha(0.45).toRgbString(),
    imagePreviewSwitchSize: e.controlHeightLG
  });
  return [xVe(n), $Ve(n), BU(Vt(n, {
    componentCls: t
  })), EVe(n)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 80,
  previewOperationColor: new xn(e.colorTextLightSolid).toRgbString(),
  previewOperationColorDisabled: new xn(e.colorTextLightSolid).setAlpha(0.25).toRgbString(),
  previewOperationSize: e.fontSizeIcon * 1.5
  // FIXME: fontSizeIconLG
})), VU = {
  rotateLeft: $(tP, null, null),
  rotateRight: $(nP, null, null),
  zoomIn: $(oP, null, null),
  zoomOut: $(lP, null, null),
  close: $(Hl, null, null),
  left: $(Ii, null, null),
  right: $(Br, null, null),
  flipX: $(Hy, null, null),
  flipY: $(Hy, {
    rotate: 90
  }, null)
}, OVe = () => ({
  previewPrefixCls: String,
  preview: Wn()
}), zU = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AImagePreviewGroup",
  inheritAttrs: !1,
  props: OVe(),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: l,
      rootPrefixCls: r
    } = bt("image", e), a = O(() => `${l.value}-preview`), [i, s] = FU(l), c = O(() => {
      const {
        preview: u
      } = e;
      if (u === !1)
        return u;
      const d = typeof u == "object" ? u : {};
      return _(_({}, d), {
        rootClassName: s.value,
        transitionName: Vl(r.value, "zoom", d.transitionName),
        maskTransitionName: Vl(r.value, "fade", d.maskTransitionName)
      });
    });
    return () => i($(MU, Q(Q({}, _(_({}, n), e)), {}, {
      preview: c.value,
      icons: VU,
      previewPrefixCls: a.value
    }), o));
  }
}), cu = /* @__PURE__ */ le({
  name: "AImage",
  inheritAttrs: !1,
  props: RU(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      rootPrefixCls: r,
      configProvider: a
    } = bt("image", e), [i, s] = FU(l), c = O(() => {
      const {
        preview: u
      } = e;
      if (u === !1)
        return u;
      const d = typeof u == "object" ? u : {};
      return _(_({
        icons: VU
      }, d), {
        transitionName: Vl(r.value, "zoom", d.transitionName),
        maskTransitionName: Vl(r.value, "fade", d.maskTransitionName)
      });
    });
    return () => {
      var u, d;
      const f = ((d = (u = a.locale) === null || u === void 0 ? void 0 : u.value) === null || d === void 0 ? void 0 : d.Image) || rr.Image, p = () => $("div", {
        class: `${l.value}-mask-info`
      }, [$(Bh, null, null), f == null ? void 0 : f.preview]), {
        previewMask: m = n.previewMask || p
      } = e;
      return i($(LU, Q(Q({}, _(_(_({}, o), e), {
        prefixCls: l.value
      })), {}, {
        preview: c.value,
        rootClassName: ke(e.rootClassName, s.value)
      }), _(_({}, n), {
        previewMask: typeof m == "function" ? m : null
      })));
    };
  }
});
cu.PreviewGroup = zU;
cu.install = function(e) {
  return e.component(cu.name, cu), e.component(cu.PreviewGroup.name, cu.PreviewGroup), e;
};
var _Ve = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, name: "up", theme: "outlined" };
function RA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      IVe(e, l, n[l]);
    });
  }
  return e;
}
function IVe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var rP = function(t, n) {
  var o = RA({}, t, n.attrs);
  return $(cn, RA({}, o, {
    icon: _Ve
  }), null);
};
rP.displayName = "UpOutlined";
rP.inheritAttrs = !1;
function Z2() {
  return typeof BigInt == "function";
}
function jv(e) {
  let t = e.trim(), n = t.startsWith("-");
  n && (t = t.slice(1)), t = t.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, ""), t.startsWith(".") && (t = `0${t}`);
  const o = t || "0", l = o.split("."), r = l[0] || "0", a = l[1] || "0";
  r === "0" && a === "0" && (n = !1);
  const i = n ? "-" : "";
  return {
    negative: n,
    negativeStr: i,
    trimStr: o,
    integerStr: r,
    decimalStr: a,
    fullStr: `${i}${o}`
  };
}
function aP(e) {
  const t = String(e);
  return !Number.isNaN(Number(t)) && t.includes("e");
}
function jm(e) {
  const t = String(e);
  if (aP(e)) {
    let n = Number(t.slice(t.indexOf("e-") + 2));
    const o = t.match(/\.(\d+)/);
    return o != null && o[1] && (n += o[1].length), n;
  }
  return t.includes(".") && sP(t) ? t.length - t.indexOf(".") - 1 : 0;
}
function iP(e) {
  let t = String(e);
  if (aP(e)) {
    if (e > Number.MAX_SAFE_INTEGER)
      return String(Z2() ? BigInt(e).toString() : Number.MAX_SAFE_INTEGER);
    if (e < Number.MIN_SAFE_INTEGER)
      return String(Z2() ? BigInt(e).toString() : Number.MIN_SAFE_INTEGER);
    t = e.toFixed(jm(t));
  }
  return jv(t).fullStr;
}
function sP(e) {
  return typeof e == "number" ? !Number.isNaN(e) : e ? (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(e) || // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(e) || // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(e)
  ) : !1;
}
function HU(e) {
  return !e && e !== 0 && !Number.isNaN(e) || !String(e).trim();
}
class uu {
  constructor(t) {
    if (this.origin = "", HU(t)) {
      this.empty = !0;
      return;
    }
    this.origin = String(t), this.number = Number(t);
  }
  negate() {
    return new uu(-this.toNumber());
  }
  add(t) {
    if (this.isInvalidate())
      return new uu(t);
    const n = Number(t);
    if (Number.isNaN(n))
      return this;
    const o = this.number + n;
    if (o > Number.MAX_SAFE_INTEGER)
      return new uu(Number.MAX_SAFE_INTEGER);
    if (o < Number.MIN_SAFE_INTEGER)
      return new uu(Number.MIN_SAFE_INTEGER);
    const l = Math.max(jm(this.number), jm(n));
    return new uu(o.toFixed(l));
  }
  isEmpty() {
    return this.empty;
  }
  isNaN() {
    return Number.isNaN(this.number);
  }
  isInvalidate() {
    return this.isEmpty() || this.isNaN();
  }
  equals(t) {
    return this.toNumber() === (t == null ? void 0 : t.toNumber());
  }
  lessEquals(t) {
    return this.add(t.negate().toString()).toNumber() <= 0;
  }
  toNumber() {
    return this.number;
  }
  toString() {
    return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0) ? this.isInvalidate() ? "" : iP(this.number) : this.origin;
  }
}
class tf {
  constructor(t) {
    if (this.origin = "", HU(t)) {
      this.empty = !0;
      return;
    }
    if (this.origin = String(t), t === "-" || Number.isNaN(t)) {
      this.nan = !0;
      return;
    }
    let n = t;
    if (aP(n) && (n = Number(n)), n = typeof n == "string" ? n : iP(n), sP(n)) {
      const o = jv(n);
      this.negative = o.negative;
      const l = o.trimStr.split(".");
      this.integer = BigInt(l[0]);
      const r = l[1] || "0";
      this.decimal = BigInt(r), this.decimalLen = r.length;
    } else
      this.nan = !0;
  }
  getMark() {
    return this.negative ? "-" : "";
  }
  getIntegerStr() {
    return this.integer.toString();
  }
  getDecimalStr() {
    return this.decimal.toString().padStart(this.decimalLen, "0");
  }
  /**
   * Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
   * This is used for add function only.
   */
  alignDecimal(t) {
    const n = `${this.getMark()}${this.getIntegerStr()}${this.getDecimalStr().padEnd(t, "0")}`;
    return BigInt(n);
  }
  negate() {
    const t = new tf(this.toString());
    return t.negative = !t.negative, t;
  }
  add(t) {
    if (this.isInvalidate())
      return new tf(t);
    const n = new tf(t);
    if (n.isInvalidate())
      return this;
    const o = Math.max(this.getDecimalStr().length, n.getDecimalStr().length), l = this.alignDecimal(o), r = n.alignDecimal(o), a = (l + r).toString(), {
      negativeStr: i,
      trimStr: s
    } = jv(a), c = `${i}${s.padStart(o + 1, "0")}`;
    return new tf(`${c.slice(0, -o)}.${c.slice(-o)}`);
  }
  isEmpty() {
    return this.empty;
  }
  isNaN() {
    return this.nan;
  }
  isInvalidate() {
    return this.isEmpty() || this.isNaN();
  }
  equals(t) {
    return this.toString() === (t == null ? void 0 : t.toString());
  }
  lessEquals(t) {
    return this.add(t.negate().toString()).toNumber() <= 0;
  }
  toNumber() {
    return this.isNaN() ? NaN : Number(this.toString());
  }
  toString() {
    return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0) ? this.isInvalidate() ? "" : jv(`${this.getMark()}${this.getIntegerStr()}.${this.getDecimalStr()}`).fullStr : this.origin;
  }
}
function ri(e) {
  return Z2() ? new tf(e) : new uu(e);
}
function Q2(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (e === "")
    return "";
  const {
    negativeStr: l,
    integerStr: r,
    decimalStr: a
  } = jv(e), i = `${t}${a}`, s = `${l}${r}`;
  if (n >= 0) {
    const c = Number(a[n]);
    if (c >= 5 && !o) {
      const u = ri(e).add(`${l}0.${"0".repeat(n)}${10 - c}`);
      return Q2(u.toString(), t, n, o);
    }
    return n === 0 ? s : `${s}${t}${a.padEnd(n, "0").slice(0, n)}`;
  }
  return i === ".0" ? s : `${s}${i}`;
}
const TVe = 200, PVe = 600, kVe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "StepHandler",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    upDisabled: Boolean,
    downDisabled: Boolean,
    onStep: Fe()
  },
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o
    } = t;
    const l = /* @__PURE__ */ H(), r = (i, s) => {
      i.preventDefault(), o("step", s);
      function c() {
        o("step", s), l.value = setTimeout(c, TVe);
      }
      l.value = setTimeout(c, PVe);
    }, a = () => {
      clearTimeout(l.value);
    };
    return yt(() => {
      a();
    }), () => {
      if (_I())
        return null;
      const {
        prefixCls: i,
        upDisabled: s,
        downDisabled: c
      } = e, u = `${i}-handler`, d = ke(u, `${u}-up`, {
        [`${u}-up-disabled`]: s
      }), f = ke(u, `${u}-down`, {
        [`${u}-down-disabled`]: c
      }), p = {
        unselectable: "on",
        role: "button",
        onMouseup: a,
        onMouseleave: a
      }, {
        upNode: m,
        downNode: v
      } = n;
      return $("div", {
        class: `${u}-wrap`
      }, [$("span", Q(Q({}, p), {}, {
        onMousedown: (h) => {
          r(h, !0);
        },
        "aria-label": "Increase Value",
        "aria-disabled": s,
        class: d
      }), [(m == null ? void 0 : m()) || $("span", {
        unselectable: "on",
        class: `${i}-handler-up-inner`
      }, null)]), $("span", Q(Q({}, p), {}, {
        onMousedown: (h) => {
          r(h, !1);
        },
        "aria-label": "Decrease Value",
        "aria-disabled": c,
        class: f
      }), [(v == null ? void 0 : v()) || $("span", {
        unselectable: "on",
        class: `${i}-handler-down-inner`
      }, null)])]);
    };
  }
});
function NVe(e, t) {
  const n = /* @__PURE__ */ H(null);
  function o() {
    try {
      const {
        selectionStart: r,
        selectionEnd: a,
        value: i
      } = e.value, s = i.substring(0, r), c = i.substring(a);
      n.value = {
        start: r,
        end: a,
        value: i,
        beforeTxt: s,
        afterTxt: c
      };
    } catch (r) {
    }
  }
  function l() {
    if (e.value && n.value && t.value)
      try {
        const {
          value: r
        } = e.value, {
          beforeTxt: a,
          afterTxt: i,
          start: s
        } = n.value;
        let c = r.length;
        if (r.endsWith(i))
          c = r.length - n.value.afterTxt.length;
        else if (r.startsWith(a))
          c = a.length;
        else {
          const u = a[s - 1], d = r.indexOf(u, s - 1);
          d !== -1 && (c = d + 1);
        }
        e.value.setSelectionRange(c, c);
      } catch (r) {
        bn(!1, `Something warning of cursor restore. Please fire issue about this: ${r.message}`);
      }
  }
  return [o, l];
}
const MVe = () => {
  const e = /* @__PURE__ */ Ce(0), t = () => {
    rn.cancel(e.value);
  };
  return yt(() => {
    t();
  }), (n) => {
    t(), e.value = rn(() => {
      n();
    });
  };
};
var AVe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const DA = (e, t) => e || t.isEmpty() ? t.toString() : t.toNumber(), LA = (e) => {
  const t = ri(e);
  return t.isInvalidate() ? null : t;
}, jU = () => ({
  /** value will show as string */
  stringMode: Qe(),
  defaultValue: zt([String, Number]),
  value: zt([String, Number]),
  prefixCls: At(),
  min: zt([String, Number]),
  max: zt([String, Number]),
  step: zt([String, Number], 1),
  tabindex: Number,
  controls: Qe(!0),
  readonly: Qe(),
  disabled: Qe(),
  autofocus: Qe(),
  keyboard: Qe(!0),
  /** Parse display value to validate number */
  parser: Fe(),
  /** Transform `value` to display value show in input */
  formatter: Fe(),
  /** Syntactic sugar of `formatter`. Config precision of display. */
  precision: Number,
  /** Syntactic sugar of `formatter`. Config decimal separator of display. */
  decimalSeparator: String,
  onInput: Fe(),
  onChange: Fe(),
  onPressEnter: Fe(),
  onStep: Fe(),
  onBlur: Fe(),
  onFocus: Fe()
}), RVe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "InnerInputNumber",
  inheritAttrs: !1,
  props: _(_({}, jU()), {
    lazy: Boolean
  }),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: l,
      expose: r
    } = t;
    const a = /* @__PURE__ */ Ce(), i = /* @__PURE__ */ Ce(!1), s = /* @__PURE__ */ Ce(!1), c = /* @__PURE__ */ Ce(!1), u = /* @__PURE__ */ Ce(ri(e.value));
    function d(j) {
      e.value === void 0 && (u.value = j);
    }
    const f = (j, W) => {
      if (!W)
        return e.precision >= 0 ? e.precision : Math.max(jm(j), jm(e.step));
    }, p = (j) => {
      const W = String(j);
      if (e.parser)
        return e.parser(W);
      let Y = W;
      return e.decimalSeparator && (Y = Y.replace(e.decimalSeparator, ".")), Y.replace(/[^\w.-]+/g, "");
    }, m = /* @__PURE__ */ Ce(""), v = (j, W) => {
      if (e.formatter)
        return e.formatter(j, {
          userTyping: W,
          input: String(m.value)
        });
      let Y = typeof j == "number" ? iP(j) : j;
      if (!W) {
        const U = f(Y, W);
        if (sP(Y) && (e.decimalSeparator || U >= 0)) {
          const te = e.decimalSeparator || ".";
          Y = Q2(Y, te, U);
        }
      }
      return Y;
    }, h = (() => {
      const j = e.value;
      return u.value.isInvalidate() && ["string", "number"].includes(typeof j) ? Number.isNaN(j) ? "" : j : v(u.value.toString(), !1);
    })();
    m.value = h;
    function g(j, W) {
      m.value = v(
        // Invalidate number is sometime passed by external control, we should let it go
        // Otherwise is controlled by internal interactive logic which check by userTyping
        // You can ref 'show limited value when input is not focused' test for more info.
        j.isInvalidate() ? j.toString(!1) : j.toString(!W),
        W
      );
    }
    const y = O(() => LA(e.max)), b = O(() => LA(e.min)), C = O(() => !y.value || !u.value || u.value.isInvalidate() ? !1 : y.value.lessEquals(u.value)), w = O(() => !b.value || !u.value || u.value.isInvalidate() ? !1 : u.value.lessEquals(b.value)), [x, E] = NVe(a, i), I = (j) => y.value && !j.lessEquals(y.value) ? y.value : b.value && !b.value.lessEquals(j) ? b.value : null, T = (j) => !I(j), P = (j, W) => {
      var Y;
      let U = j, te = T(U) || U.isEmpty();
      if (!U.isEmpty() && !W && (U = I(U) || U, te = !0), !e.readonly && !e.disabled && te) {
        const J = U.toString(), re = f(J, W);
        return re >= 0 && (U = ri(Q2(J, ".", re))), U.equals(u.value) || (d(U), (Y = e.onChange) === null || Y === void 0 || Y.call(e, U.isEmpty() ? null : DA(e.stringMode, U)), e.value === void 0 && g(U, W)), U;
      }
      return u.value;
    }, k = MVe(), N = (j) => {
      var W;
      if (x(), m.value = j, !c.value) {
        const Y = p(j), U = ri(Y);
        U.isNaN() || P(U, !0);
      }
      (W = e.onInput) === null || W === void 0 || W.call(e, j), k(() => {
        let Y = j;
        e.parser || (Y = j.replace(//g, ".")), Y !== j && N(Y);
      });
    }, R = () => {
      c.value = !0;
    }, z = () => {
      c.value = !1, N(a.value.value);
    }, D = (j) => {
      N(j.target.value);
    }, F = (j) => {
      var W, Y;
      if (j && C.value || !j && w.value)
        return;
      s.value = !1;
      let U = ri(e.step);
      j || (U = U.negate());
      const te = (u.value || ri(0)).add(U.toString()), J = P(te, !1);
      (W = e.onStep) === null || W === void 0 || W.call(e, DA(e.stringMode, J), {
        offset: e.step,
        type: j ? "up" : "down"
      }), (Y = a.value) === null || Y === void 0 || Y.focus();
    }, M = (j) => {
      const W = ri(p(m.value));
      let Y = W;
      W.isNaN() ? Y = u.value : Y = P(W, j), e.value !== void 0 ? g(u.value, !1) : Y.isNaN() || g(Y, !1);
    }, A = () => {
      s.value = !0;
    }, L = (j) => {
      var W;
      const {
        which: Y
      } = j;
      s.value = !0, Y === ot.ENTER && (c.value || (s.value = !1), M(!1), (W = e.onPressEnter) === null || W === void 0 || W.call(e, j)), e.keyboard !== !1 && !c.value && [ot.UP, ot.DOWN].includes(Y) && (F(ot.UP === Y), j.preventDefault());
    }, B = () => {
      s.value = !1;
    }, V = (j) => {
      M(!1), i.value = !1, s.value = !1, l("blur", j);
    };
    return pe(() => e.precision, () => {
      u.value.isInvalidate() || g(u.value, !1);
    }, {
      flush: "post"
    }), pe(() => e.value, () => {
      const j = ri(e.value);
      u.value = j;
      const W = ri(p(m.value));
      (!j.equals(W) || !s.value || e.formatter) && g(j, s.value);
    }, {
      flush: "post"
    }), pe(m, () => {
      e.formatter && E();
    }, {
      flush: "post"
    }), pe(() => e.disabled, (j) => {
      j && (i.value = !1);
    }), r({
      focus: () => {
        var j;
        (j = a.value) === null || j === void 0 || j.focus();
      },
      blur: () => {
        var j;
        (j = a.value) === null || j === void 0 || j.blur();
      }
    }), () => {
      const j = _(_({}, n), e), {
        prefixCls: W = "rc-input-number",
        min: Y,
        max: U,
        step: te = 1,
        defaultValue: J,
        value: re,
        disabled: oe,
        readonly: q,
        keyboard: K,
        controls: se = !0,
        autofocus: Z,
        stringMode: ee,
        parser: fe,
        formatter: me,
        precision: ge,
        decimalSeparator: he,
        onChange: $e,
        onInput: ne,
        onPressEnter: ae,
        onStep: ce,
        lazy: xe,
        class: Te,
        style: Se
      } = j, be = AVe(j, ["prefixCls", "min", "max", "step", "defaultValue", "value", "disabled", "readonly", "keyboard", "controls", "autofocus", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep", "lazy", "class", "style"]), {
        upHandler: ie,
        downHandler: we
      } = o, Ne = `${W}-input`, tt = {};
      return xe ? tt.onChange = D : tt.onInput = D, $("div", {
        class: ke(W, Te, {
          [`${W}-focused`]: i.value,
          [`${W}-disabled`]: oe,
          [`${W}-readonly`]: q,
          [`${W}-not-a-number`]: u.value.isNaN(),
          [`${W}-out-of-range`]: !u.value.isInvalidate() && !T(u.value)
        }),
        style: Se,
        onKeydown: L,
        onKeyup: B
      }, [se && $(kVe, {
        prefixCls: W,
        upDisabled: C.value,
        downDisabled: w.value,
        onStep: F
      }, {
        upNode: ie,
        downNode: we
      }), $("div", {
        class: `${Ne}-wrap`
      }, [$("input", Q(Q(Q({
        autofocus: Z,
        autocomplete: "off",
        role: "spinbutton",
        "aria-valuemin": Y,
        "aria-valuemax": U,
        "aria-valuenow": u.value.isInvalidate() ? null : u.value.toString(),
        step: te
      }, be), {}, {
        ref: a,
        class: Ne,
        value: m.value,
        disabled: oe,
        readonly: q,
        onFocus: (Pe) => {
          i.value = !0, l("focus", Pe);
        }
      }, tt), {}, {
        onBlur: V,
        onCompositionstart: R,
        onCompositionend: z,
        onBeforeinput: A
      }), null)])]);
    };
  }
});
function Zw(e) {
  return e != null;
}
const DVe = (e) => {
  const {
    componentCls: t,
    lineWidth: n,
    lineType: o,
    colorBorder: l,
    borderRadius: r,
    fontSizeLG: a,
    controlHeightLG: i,
    controlHeightSM: s,
    colorError: c,
    inputPaddingHorizontalSM: u,
    colorTextDescription: d,
    motionDurationMid: f,
    colorPrimary: p,
    controlHeight: m,
    inputPaddingHorizontal: v,
    colorBgContainer: h,
    colorTextDisabled: g,
    borderRadiusSM: y,
    borderRadiusLG: b,
    controlWidth: C,
    handleVisible: w
  } = e;
  return [
    {
      [t]: _(_(_(_({}, nn(e)), hd(e)), Mh(e, t)), {
        display: "inline-block",
        width: C,
        margin: 0,
        padding: 0,
        border: `${n}px ${o} ${l}`,
        borderRadius: r,
        "&-rtl": {
          direction: "rtl",
          [`${t}-input`]: {
            direction: "rtl"
          }
        },
        "&-lg": {
          padding: 0,
          fontSize: a,
          borderRadius: b,
          [`input${t}-input`]: {
            height: i - 2 * n
          }
        },
        "&-sm": {
          padding: 0,
          borderRadius: y,
          [`input${t}-input`]: {
            height: s - 2 * n,
            padding: `0 ${u}px`
          }
        },
        "&:hover": _({}, Bp(e)),
        "&-focused": _({}, xc(e)),
        "&-disabled": _(_({}, ET(e)), {
          [`${t}-input`]: {
            cursor: "not-allowed"
          }
        }),
        // ===================== Out Of Range =====================
        "&-out-of-range": {
          input: {
            color: c
          }
        },
        // Style for input-group: input with label, with button or dropdown...
        "&-group": _(_(_({}, nn(e)), YW(e)), {
          "&-wrapper": {
            display: "inline-block",
            textAlign: "start",
            verticalAlign: "top",
            [`${t}-affix-wrapper`]: {
              width: "100%"
            },
            // Size
            "&-lg": {
              [`${t}-group-addon`]: {
                borderRadius: b
              }
            },
            "&-sm": {
              [`${t}-group-addon`]: {
                borderRadius: y
              }
            }
          }
        }),
        [t]: {
          "&-input": _(_({
            width: "100%",
            height: m - 2 * n,
            padding: `0 ${v}px`,
            textAlign: "start",
            backgroundColor: "transparent",
            border: 0,
            borderRadius: r,
            outline: 0,
            transition: `all ${f} linear`,
            appearance: "textfield",
            color: e.colorText,
            fontSize: "inherit",
            verticalAlign: "top"
          }, xT(e.colorTextPlaceholder)), {
            '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
              margin: 0,
              /* stylelint-disable-next-line property-no-vendor-prefix */
              webkitAppearance: "none",
              appearance: "none"
            }
          })
        }
      })
    },
    // Handler
    {
      [t]: {
        [`&:hover ${t}-handler-wrap, &-focused ${t}-handler-wrap`]: {
          opacity: 1
        },
        [`${t}-handler-wrap`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          width: e.handleWidth,
          height: "100%",
          background: h,
          borderStartStartRadius: 0,
          borderStartEndRadius: r,
          borderEndEndRadius: r,
          borderEndStartRadius: 0,
          opacity: w === !0 ? 1 : 0,
          display: "flex",
          flexDirection: "column",
          alignItems: "stretch",
          transition: `opacity ${f} linear ${f}`,
          // Fix input number inside Menu makes icon too large
          // We arise the selector priority by nest selector here
          // https://github.com/ant-design/ant-design/issues/14367
          [`${t}-handler`]: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flex: "auto",
            height: "40%",
            [`
              ${t}-handler-up-inner,
              ${t}-handler-down-inner
            `]: {
              marginInlineEnd: 0,
              fontSize: e.handleFontSize
            }
          }
        },
        [`${t}-handler`]: {
          height: "50%",
          overflow: "hidden",
          color: d,
          fontWeight: "bold",
          lineHeight: 0,
          textAlign: "center",
          cursor: "pointer",
          borderInlineStart: `${n}px ${o} ${l}`,
          transition: `all ${f} linear`,
          "&:active": {
            background: e.colorFillAlter
          },
          // Hover
          "&:hover": {
            height: "60%",
            [`
              ${t}-handler-up-inner,
              ${t}-handler-down-inner
            `]: {
              color: p
            }
          },
          "&-up-inner, &-down-inner": _(_({}, cd()), {
            color: d,
            transition: `all ${f} linear`,
            userSelect: "none"
          })
        },
        [`${t}-handler-up`]: {
          borderStartEndRadius: r
        },
        [`${t}-handler-down`]: {
          borderBlockStart: `${n}px ${o} ${l}`,
          borderEndEndRadius: r
        },
        // Disabled
        "&-disabled, &-readonly": {
          [`${t}-handler-wrap`]: {
            display: "none"
          },
          [`${t}-input`]: {
            color: "inherit"
          }
        },
        [`
          ${t}-handler-up-disabled,
          ${t}-handler-down-disabled
        `]: {
          cursor: "not-allowed"
        },
        [`
          ${t}-handler-up-disabled:hover &-handler-up-inner,
          ${t}-handler-down-disabled:hover &-handler-down-inner
        `]: {
          color: g
        }
      }
    },
    // Border-less
    {
      [`${t}-borderless`]: {
        borderColor: "transparent",
        boxShadow: "none",
        [`${t}-handler-down`]: {
          borderBlockStartWidth: 0
        }
      }
    }
  ];
}, LVe = (e) => {
  const {
    componentCls: t,
    inputPaddingHorizontal: n,
    inputAffixPadding: o,
    controlWidth: l,
    borderRadiusLG: r,
    borderRadiusSM: a
  } = e;
  return {
    [`${t}-affix-wrapper`]: _(_(_({}, hd(e)), Mh(e, `${t}-affix-wrapper`)), {
      // or number handler will cover form status
      position: "relative",
      display: "inline-flex",
      width: l,
      padding: 0,
      paddingInlineStart: n,
      "&-lg": {
        borderRadius: r
      },
      "&-sm": {
        borderRadius: a
      },
      [`&:not(${t}-affix-wrapper-disabled):hover`]: _(_({}, Bp(e)), {
        zIndex: 1
      }),
      "&-focused, &:focus": {
        zIndex: 1
      },
      "&-disabled": {
        [`${t}[disabled]`]: {
          background: "transparent"
        }
      },
      [`> div${t}`]: {
        width: "100%",
        border: "none",
        outline: "none",
        [`&${t}-focused`]: {
          boxShadow: "none !important"
        }
      },
      [`input${t}-input`]: {
        padding: 0
      },
      "&::before": {
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${t}-handler-wrap`]: {
        zIndex: 2
      },
      [t]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          pointerEvents: "none"
        },
        "&-prefix": {
          marginInlineEnd: o
        },
        "&-suffix": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          zIndex: 1,
          height: "100%",
          marginInlineEnd: n,
          marginInlineStart: o
        }
      }
    })
  };
}, BVe = Zt("InputNumber", (e) => {
  const t = gd(e);
  return [
    DVe(t),
    LVe(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    Rp(t)
  ];
}, (e) => ({
  controlWidth: 90,
  handleWidth: e.controlHeightSM - e.lineWidth * 2,
  handleFontSize: e.fontSize / 2,
  handleVisible: "auto"
}));
var FVe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const BA = jU(), VVe = () => _(_({}, BA), {
  size: At(),
  bordered: Qe(!0),
  placeholder: String,
  name: String,
  id: String,
  type: String,
  addonBefore: de.any,
  addonAfter: de.any,
  prefix: de.any,
  "onUpdate:value": BA.onChange,
  valueModifiers: Object,
  status: At()
}), Qw = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AInputNumber",
  inheritAttrs: !1,
  props: VVe(),
  // emits: ['focus', 'blur', 'change', 'input', 'update:value'],
  slots: Object,
  setup(e, t) {
    let {
      emit: n,
      expose: o,
      attrs: l,
      slots: r
    } = t;
    var a;
    const i = Ko(), s = sl.useInject(), c = O(() => Ja(s.status, e.status)), {
      prefixCls: u,
      size: d,
      direction: f,
      disabled: p
    } = bt("input-number", e), {
      compactSize: m,
      compactItemClassnames: v
    } = Rc(u, f), h = Cr(), g = O(() => {
      var R;
      return (R = p.value) !== null && R !== void 0 ? R : h.value;
    }), [y, b] = BVe(u), C = O(() => m.value || d.value), w = /* @__PURE__ */ Ce((a = e.value) !== null && a !== void 0 ? a : e.defaultValue), x = /* @__PURE__ */ Ce(!1);
    pe(() => e.value, () => {
      w.value = e.value;
    });
    const E = /* @__PURE__ */ Ce(null), I = () => {
      var R;
      (R = E.value) === null || R === void 0 || R.focus();
    };
    o({
      focus: I,
      blur: () => {
        var R;
        (R = E.value) === null || R === void 0 || R.blur();
      }
    });
    const P = (R) => {
      e.value === void 0 && (w.value = R), n("update:value", R), n("change", R), i.onFieldChange();
    }, k = (R) => {
      x.value = !1, n("blur", R), i.onFieldBlur();
    }, N = (R) => {
      x.value = !0, n("focus", R);
    };
    return () => {
      var R, z, D, F;
      const {
        hasFeedback: M,
        isFormItemInput: A,
        feedbackIcon: L
      } = s, B = (R = e.id) !== null && R !== void 0 ? R : i.id.value, V = _(_(_({}, l), e), {
        id: B,
        disabled: g.value
      }), {
        class: j,
        bordered: W,
        readonly: Y,
        style: U,
        addonBefore: te = (z = r.addonBefore) === null || z === void 0 ? void 0 : z.call(r),
        addonAfter: J = (D = r.addonAfter) === null || D === void 0 ? void 0 : D.call(r),
        prefix: re = (F = r.prefix) === null || F === void 0 ? void 0 : F.call(r),
        valueModifiers: oe = {}
      } = V, q = FVe(V, ["class", "bordered", "readonly", "style", "addonBefore", "addonAfter", "prefix", "valueModifiers"]), K = u.value, se = ke({
        [`${K}-lg`]: C.value === "large",
        [`${K}-sm`]: C.value === "small",
        [`${K}-rtl`]: f.value === "rtl",
        [`${K}-readonly`]: Y,
        [`${K}-borderless`]: !W,
        [`${K}-in-form-item`]: A
      }, Ll(K, c.value), j, v.value, b.value);
      let Z = $(RVe, Q(Q({}, pn(q, ["size", "defaultValue"])), {}, {
        ref: E,
        lazy: !!oe.lazy,
        value: w.value,
        class: se,
        prefixCls: K,
        readonly: Y,
        onChange: P,
        onBlur: k,
        onFocus: N
      }), {
        upHandler: r.upIcon ? () => $("span", {
          class: `${K}-handler-up-inner`
        }, [r.upIcon()]) : () => $(rP, {
          class: `${K}-handler-up-inner`
        }, null),
        downHandler: r.downIcon ? () => $("span", {
          class: `${K}-handler-down-inner`
        }, [r.downIcon()]) : () => $(pd, {
          class: `${K}-handler-down-inner`
        }, null)
      });
      const ee = Zw(te) || Zw(J), fe = Zw(re);
      if (fe || M) {
        const me = ke(`${K}-affix-wrapper`, Ll(`${K}-affix-wrapper`, c.value, M), {
          [`${K}-affix-wrapper-focused`]: x.value,
          [`${K}-affix-wrapper-disabled`]: g.value,
          [`${K}-affix-wrapper-sm`]: C.value === "small",
          [`${K}-affix-wrapper-lg`]: C.value === "large",
          [`${K}-affix-wrapper-rtl`]: f.value === "rtl",
          [`${K}-affix-wrapper-readonly`]: Y,
          [`${K}-affix-wrapper-borderless`]: !W,
          // className will go to addon wrapper
          [`${j}`]: !ee && j
        }, b.value);
        Z = $("div", {
          class: me,
          style: U,
          onClick: I
        }, [fe && $("span", {
          class: `${K}-prefix`
        }, [re]), Z, M && $("span", {
          class: `${K}-suffix`
        }, [L])]);
      }
      if (ee) {
        const me = `${K}-group`, ge = `${me}-addon`, he = te ? $("div", {
          class: ge
        }, [te]) : null, $e = J ? $("div", {
          class: ge
        }, [J]) : null, ne = ke(`${K}-wrapper`, me, {
          [`${me}-rtl`]: f.value === "rtl"
        }, b.value), ae = ke(`${K}-group-wrapper`, {
          [`${K}-group-wrapper-sm`]: C.value === "small",
          [`${K}-group-wrapper-lg`]: C.value === "large",
          [`${K}-group-wrapper-rtl`]: f.value === "rtl"
        }, Ll(`${u}-group-wrapper`, c.value, M), j, b.value);
        Z = $("div", {
          class: ae,
          style: U
        }, [$("div", {
          class: ne
        }, [he && $(Rm, null, {
          default: () => [$(vy, null, {
            default: () => [he]
          })]
        }), Z, $e && $(Rm, null, {
          default: () => [$(vy, null, {
            default: () => [$e]
          })]
        })])]);
      }
      return y(_n(Z, {
        style: U
      }));
    };
  }
}), zVe = _(Qw, {
  install: (e) => (e.component(Qw.name, Qw), e)
}), HVe = (e) => {
  const {
    componentCls: t,
    colorBgContainer: n,
    colorBgBody: o,
    colorText: l
  } = e;
  return {
    [`${t}-sider-light`]: {
      background: n,
      [`${t}-sider-trigger`]: {
        color: l,
        background: n
      },
      [`${t}-sider-zero-width-trigger`]: {
        color: l,
        background: n,
        border: `1px solid ${o}`,
        borderInlineStart: 0
      }
    }
  };
}, jVe = (e) => {
  const {
    antCls: t,
    // .ant
    componentCls: n,
    // .ant-layout
    colorText: o,
    colorTextLightSolid: l,
    colorBgHeader: r,
    colorBgBody: a,
    colorBgTrigger: i,
    layoutHeaderHeight: s,
    layoutHeaderPaddingInline: c,
    layoutHeaderColor: u,
    layoutFooterPadding: d,
    layoutTriggerHeight: f,
    layoutZeroTriggerSize: p,
    motionDurationMid: m,
    motionDurationSlow: v,
    fontSize: h,
    borderRadius: g
  } = e;
  return {
    [n]: _(_({
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      color: o,
      /* fix firefox can't set height smaller than content on flex item */
      minHeight: 0,
      background: a,
      "&, *": {
        boxSizing: "border-box"
      },
      [`&${n}-has-sider`]: {
        flexDirection: "row",
        [`> ${n}, > ${n}-content`]: {
          // https://segmentfault.com/a/1190000019498300
          width: 0
        }
      },
      [`${n}-header, &${n}-footer`]: {
        flex: "0 0 auto"
      },
      [`${n}-header`]: {
        height: s,
        paddingInline: c,
        color: u,
        lineHeight: `${s}px`,
        background: r,
        // Other components/menu/style/index.less line:686
        // Integration with header element so menu items have the same height
        [`${t}-menu`]: {
          lineHeight: "inherit"
        }
      },
      [`${n}-footer`]: {
        padding: d,
        color: o,
        fontSize: h,
        background: a
      },
      [`${n}-content`]: {
        flex: "auto",
        // fix firefox can't set height smaller than content on flex item
        minHeight: 0
      },
      [`${n}-sider`]: {
        position: "relative",
        // fix firefox can't set width smaller than content on flex item
        minWidth: 0,
        background: r,
        transition: `all ${m}, background 0s`,
        "&-children": {
          height: "100%",
          // Hack for fixing margin collapse bug
          // https://github.com/ant-design/ant-design/issues/7967
          // solution from https://stackoverflow.com/a/33132624/3040605
          marginTop: -0.1,
          paddingTop: 0.1,
          [`${t}-menu${t}-menu-inline-collapsed`]: {
            width: "auto"
          }
        },
        "&-has-trigger": {
          paddingBottom: f
        },
        "&-right": {
          order: 1
        },
        "&-trigger": {
          position: "fixed",
          bottom: 0,
          zIndex: 1,
          height: f,
          color: l,
          lineHeight: `${f}px`,
          textAlign: "center",
          background: i,
          cursor: "pointer",
          transition: `all ${m}`
        },
        "&-zero-width": {
          "> *": {
            overflow: "hidden"
          },
          "&-trigger": {
            position: "absolute",
            top: s,
            insetInlineEnd: -p,
            zIndex: 1,
            width: p,
            height: p,
            color: l,
            fontSize: e.fontSizeXL,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            background: r,
            borderStartStartRadius: 0,
            borderStartEndRadius: g,
            borderEndEndRadius: g,
            borderEndStartRadius: 0,
            cursor: "pointer",
            transition: `background ${v} ease`,
            "&::after": {
              position: "absolute",
              inset: 0,
              background: "transparent",
              transition: `all ${v}`,
              content: '""'
            },
            "&:hover::after": {
              // FIXME: Hardcode, but seems no need to create a token for this
              background: "rgba(255, 255, 255, 0.2)"
            },
            "&-right": {
              insetInlineStart: -p,
              borderStartStartRadius: g,
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              borderEndStartRadius: g
            }
          }
        }
      }
    }, HVe(e)), {
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
}, WVe = Zt("Layout", (e) => {
  const {
    colorText: t,
    controlHeightSM: n,
    controlHeight: o,
    controlHeightLG: l,
    marginXXS: r
  } = e, a = l * 1.25, i = Vt(e, {
    // Layout
    layoutHeaderHeight: o * 2,
    layoutHeaderPaddingInline: a,
    layoutHeaderColor: t,
    layoutFooterPadding: `${n}px ${a}px`,
    layoutTriggerHeight: l + r * 2,
    layoutZeroTriggerSize: l
  });
  return [jVe(i)];
}, (e) => {
  const {
    colorBgLayout: t
  } = e;
  return {
    colorBgHeader: "#001529",
    colorBgBody: t,
    colorBgTrigger: "#002140"
  };
}), cP = () => ({
  prefixCls: String,
  hasSider: {
    type: Boolean,
    default: void 0
  },
  tagName: String
});
function JS(e) {
  let {
    suffixCls: t,
    tagName: n,
    name: o
  } = e;
  return (l) => /* @__PURE__ */ le({
    compatConfig: {
      MODE: 3
    },
    name: o,
    props: cP(),
    setup(a, i) {
      let {
        slots: s
      } = i;
      const {
        prefixCls: c
      } = bt(t, a);
      return () => {
        const u = _(_({}, a), {
          prefixCls: c.value,
          tagName: n
        });
        return $(l, u, s);
      };
    }
  });
}
const uP = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  props: cP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => $(e.tagName, {
      class: e.prefixCls
    }, n);
  }
}), KVe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: cP(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("", e), [a, i] = WVe(l), s = /* @__PURE__ */ H([]);
    at(cW, {
      addSider: (d) => {
        s.value = [...s.value, d];
      },
      removeSider: (d) => {
        s.value = s.value.filter((f) => f !== d);
      }
    });
    const u = O(() => {
      const {
        prefixCls: d,
        hasSider: f
      } = e;
      return {
        [i.value]: !0,
        [`${d}`]: !0,
        [`${d}-has-sider`]: typeof f == "boolean" ? f : s.value.length > 0,
        [`${d}-rtl`]: r.value === "rtl"
      };
    });
    return () => {
      const {
        tagName: d
      } = e;
      return a($(d, _(_({}, o), {
        class: [u.value, o.class]
      }), n));
    };
  }
}), e$ = JS({
  suffixCls: "layout",
  tagName: "section",
  name: "ALayout"
})(KVe), Kb = JS({
  suffixCls: "layout-header",
  tagName: "header",
  name: "ALayoutHeader"
})(uP), Ub = JS({
  suffixCls: "layout-footer",
  tagName: "footer",
  name: "ALayoutFooter"
})(uP), Gb = JS({
  suffixCls: "layout-content",
  tagName: "main",
  name: "ALayoutContent"
})(uP);
var UVe = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "bars", theme: "outlined" };
function FA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      GVe(e, l, n[l]);
    });
  }
  return e;
}
function GVe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var dP = function(t, n) {
  var o = FA({}, t, n.attrs);
  return $(cn, FA({}, o, {
    icon: UVe
  }), null);
};
dP.displayName = "BarsOutlined";
dP.inheritAttrs = !1;
const VA = {
  xs: "479.98px",
  sm: "575.98px",
  md: "767.98px",
  lg: "991.98px",
  xl: "1199.98px",
  xxl: "1599.98px",
  xxxl: "1999.98px"
}, YVe = () => ({
  prefixCls: String,
  collapsible: {
    type: Boolean,
    default: void 0
  },
  collapsed: {
    type: Boolean,
    default: void 0
  },
  defaultCollapsed: {
    type: Boolean,
    default: void 0
  },
  reverseArrow: {
    type: Boolean,
    default: void 0
  },
  zeroWidthTriggerStyle: {
    type: Object,
    default: void 0
  },
  trigger: de.any,
  width: de.oneOfType([de.number, de.string]),
  collapsedWidth: de.oneOfType([de.number, de.string]),
  breakpoint: de.oneOf($l("xs", "sm", "md", "lg", "xl", "xxl", "xxxl")),
  theme: de.oneOf($l("light", "dark")).def("dark"),
  onBreakpoint: Function,
  onCollapse: Function
}), XVe = /* @__PURE__ */ (() => {
  let e = 0;
  return function() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return e += 1, `${t}${e}`;
  };
})(), Yb = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ALayoutSider",
  inheritAttrs: !1,
  props: sn(YVe(), {
    collapsible: !1,
    defaultCollapsed: !1,
    reverseArrow: !1,
    width: 200,
    collapsedWidth: 80
  }),
  emits: ["breakpoint", "update:collapsed", "collapse"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      slots: l
    } = t;
    const {
      prefixCls: r
    } = bt("layout-sider", e), a = ze(cW, void 0), i = /* @__PURE__ */ Ce(!!(e.collapsed !== void 0 ? e.collapsed : e.defaultCollapsed)), s = /* @__PURE__ */ Ce(!1);
    pe(() => e.collapsed, () => {
      i.value = !!e.collapsed;
    }), at(sW, i);
    const c = (v, h) => {
      e.collapsed === void 0 && (i.value = v), n("update:collapsed", v), n("collapse", v, h);
    }, u = /* @__PURE__ */ Ce((v) => {
      s.value = v.matches, n("breakpoint", v.matches), i.value !== v.matches && c(v.matches, "responsive");
    });
    let d;
    function f(v) {
      return u.value(v);
    }
    const p = XVe("ant-sider-");
    a && a.addSider(p), nt(() => {
      pe(() => e.breakpoint, () => {
        try {
          d == null || d.removeEventListener("change", f);
        } catch (v) {
          d == null || d.removeListener(f);
        }
        if (typeof window != "undefined") {
          const {
            matchMedia: v
          } = window;
          if (v && e.breakpoint && e.breakpoint in VA) {
            d = v(`(max-width: ${VA[e.breakpoint]})`);
            try {
              d.addEventListener("change", f);
            } catch (h) {
              d.addListener(f);
            }
            f(d);
          }
        }
      }, {
        immediate: !0
      });
    }), yt(() => {
      try {
        d == null || d.removeEventListener("change", f);
      } catch (v) {
        d == null || d.removeListener(f);
      }
      a && a.removeSider(p);
    });
    const m = () => {
      c(!i.value, "clickTrigger");
    };
    return () => {
      var v, h;
      const g = r.value, {
        collapsedWidth: y,
        width: b,
        reverseArrow: C,
        zeroWidthTriggerStyle: w,
        trigger: x = (v = l.trigger) === null || v === void 0 ? void 0 : v.call(l),
        collapsible: E,
        theme: I
      } = e, T = i.value ? y : b, P = yy(T) ? `${T}px` : String(T), k = parseFloat(String(y || 0)) === 0 ? $("span", {
        onClick: m,
        class: ke(`${g}-zero-width-trigger`, `${g}-zero-width-trigger-${C ? "right" : "left"}`),
        style: w
      }, [x || $(dP, null, null)]) : null, N = {
        expanded: $(C ? Br : Ii, null, null),
        collapsed: $(C ? Ii : Br, null, null)
      }, R = i.value ? "collapsed" : "expanded", z = N[R], D = x !== null ? k || $("div", {
        class: `${g}-trigger`,
        onClick: m,
        style: {
          width: P
        }
      }, [x || z]) : null, F = [o.style, {
        flex: `0 0 ${P}`,
        maxWidth: P,
        minWidth: P,
        width: P
      }], M = ke(g, `${g}-${I}`, {
        [`${g}-collapsed`]: !!i.value,
        [`${g}-has-trigger`]: E && x !== null && !k,
        [`${g}-below`]: !!s.value,
        [`${g}-zero-width`]: parseFloat(P) === 0
      }, o.class);
      return $("aside", Q(Q({}, o), {}, {
        class: M,
        style: F
      }), [$("div", {
        class: `${g}-children`
      }, [(h = l.default) === null || h === void 0 ? void 0 : h.call(l)]), E || s.value && k ? D : null]);
    };
  }
}), qVe = Kb, JVe = Ub, ZVe = Yb, QVe = Gb, eze = _(e$, {
  Header: Kb,
  Footer: Ub,
  Content: Gb,
  Sider: Yb,
  install: (e) => (e.component(e$.name, e$), e.component(Kb.name, Kb), e.component(Ub.name, Ub), e.component(Yb.name, Yb), e.component(Gb.name, Gb), e)
});
function tze(e, t, n) {
  var o = n || {}, l = o.noTrailing, r = l === void 0 ? !1 : l, a = o.noLeading, i = a === void 0 ? !1 : a, s = o.debounceMode, c = s === void 0 ? void 0 : s, u, d = !1, f = 0;
  function p() {
    u && clearTimeout(u);
  }
  function m(h) {
    var g = h || {}, y = g.upcomingOnly, b = y === void 0 ? !1 : y;
    p(), d = !b;
  }
  function v() {
    for (var h = arguments.length, g = new Array(h), y = 0; y < h; y++)
      g[y] = arguments[y];
    var b = this, C = Date.now() - f;
    if (d)
      return;
    function w() {
      f = Date.now(), t.apply(b, g);
    }
    function x() {
      u = void 0;
    }
    !i && c && !u && w(), p(), c === void 0 && C > e ? i ? (f = Date.now(), r || (u = setTimeout(c ? x : w, e))) : w() : r !== !0 && (u = setTimeout(c ? x : w, c === void 0 ? e - C : e));
  }
  return v.cancel = m, v;
}
function nze(e, t, n) {
  var o = {}, l = o.atBegin, r = l === void 0 ? !1 : l;
  return tze(e, t, {
    debounceMode: r !== !1
  });
}
const oze = new mn("antSpinMove", {
  to: {
    opacity: 1
  }
}), lze = new mn("antRotate", {
  to: {
    transform: "rotate(405deg)"
  }
}), rze = (e) => ({
  [`${e.componentCls}`]: _(_({}, nn(e)), {
    position: "absolute",
    display: "none",
    color: e.colorPrimary,
    textAlign: "center",
    verticalAlign: "middle",
    opacity: 0,
    transition: `transform ${e.motionDurationSlow} ${e.motionEaseInOutCirc}`,
    "&-spinning": {
      position: "static",
      display: "inline-block",
      opacity: 1
    },
    "&-nested-loading": {
      position: "relative",
      [`> div > ${e.componentCls}`]: {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        zIndex: 4,
        display: "block",
        width: "100%",
        height: "100%",
        maxHeight: e.contentHeight,
        [`${e.componentCls}-dot`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: "50%",
          margin: -e.spinDotSize / 2
        },
        [`${e.componentCls}-text`]: {
          position: "absolute",
          top: "50%",
          width: "100%",
          paddingTop: (e.spinDotSize - e.fontSize) / 2 + 2,
          textShadow: `0 1px 2px ${e.colorBgContainer}`
          // FIXME: shadow
        },
        [`&${e.componentCls}-show-text ${e.componentCls}-dot`]: {
          marginTop: -(e.spinDotSize / 2) - 10
        },
        "&-sm": {
          [`${e.componentCls}-dot`]: {
            margin: -e.spinDotSizeSM / 2
          },
          [`${e.componentCls}-text`]: {
            paddingTop: (e.spinDotSizeSM - e.fontSize) / 2 + 2
          },
          [`&${e.componentCls}-show-text ${e.componentCls}-dot`]: {
            marginTop: -(e.spinDotSizeSM / 2) - 10
          }
        },
        "&-lg": {
          [`${e.componentCls}-dot`]: {
            margin: -(e.spinDotSizeLG / 2)
          },
          [`${e.componentCls}-text`]: {
            paddingTop: (e.spinDotSizeLG - e.fontSize) / 2 + 2
          },
          [`&${e.componentCls}-show-text ${e.componentCls}-dot`]: {
            marginTop: -(e.spinDotSizeLG / 2) - 10
          }
        }
      },
      [`${e.componentCls}-container`]: {
        position: "relative",
        transition: `opacity ${e.motionDurationSlow}`,
        "&::after": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          height: "100%",
          background: e.colorBgContainer,
          opacity: 0,
          transition: `all ${e.motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        }
      },
      [`${e.componentCls}-blur`]: {
        clear: "both",
        opacity: 0.5,
        userSelect: "none",
        pointerEvents: "none",
        "&::after": {
          opacity: 0.4,
          pointerEvents: "auto"
        }
      }
    },
    // tip
    // ------------------------------
    "&-tip": {
      color: e.spinDotDefault
    },
    // dots
    // ------------------------------
    [`${e.componentCls}-dot`]: {
      position: "relative",
      display: "inline-block",
      fontSize: e.spinDotSize,
      width: "1em",
      height: "1em",
      "&-item": {
        position: "absolute",
        display: "block",
        width: (e.spinDotSize - e.marginXXS / 2) / 2,
        height: (e.spinDotSize - e.marginXXS / 2) / 2,
        backgroundColor: e.colorPrimary,
        borderRadius: "100%",
        transform: "scale(0.75)",
        transformOrigin: "50% 50%",
        opacity: 0.3,
        animationName: oze,
        animationDuration: "1s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear",
        animationDirection: "alternate",
        "&:nth-child(1)": {
          top: 0,
          insetInlineStart: 0
        },
        "&:nth-child(2)": {
          top: 0,
          insetInlineEnd: 0,
          animationDelay: "0.4s"
        },
        "&:nth-child(3)": {
          insetInlineEnd: 0,
          bottom: 0,
          animationDelay: "0.8s"
        },
        "&:nth-child(4)": {
          bottom: 0,
          insetInlineStart: 0,
          animationDelay: "1.2s"
        }
      },
      "&-spin": {
        transform: "rotate(45deg)",
        animationName: lze,
        animationDuration: "1.2s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear"
      }
    },
    // Sizes
    // ------------------------------
    // small
    [`&-sm ${e.componentCls}-dot`]: {
      fontSize: e.spinDotSizeSM,
      i: {
        width: (e.spinDotSizeSM - e.marginXXS / 2) / 2,
        height: (e.spinDotSizeSM - e.marginXXS / 2) / 2
      }
    },
    // large
    [`&-lg ${e.componentCls}-dot`]: {
      fontSize: e.spinDotSizeLG,
      i: {
        width: (e.spinDotSizeLG - e.marginXXS) / 2,
        height: (e.spinDotSizeLG - e.marginXXS) / 2
      }
    },
    [`&${e.componentCls}-show-text ${e.componentCls}-text`]: {
      display: "block"
    }
  })
}), aze = Zt("Spin", (e) => {
  const t = Vt(e, {
    spinDotDefault: e.colorTextDescription,
    spinDotSize: e.controlHeightLG / 2,
    spinDotSizeSM: e.controlHeightLG * 0.35,
    spinDotSizeLG: e.controlHeight
  });
  return [rze(t)];
}, {
  contentHeight: 400
});
var ize = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const sze = () => ({
  prefixCls: String,
  spinning: {
    type: Boolean,
    default: void 0
  },
  size: String,
  wrapperClassName: String,
  tip: de.any,
  delay: Number,
  indicator: de.any
});
let Xb = null;
function cze(e, t) {
  return !!e && !!t && !isNaN(Number(t));
}
function uze(e) {
  const t = e.indicator;
  Xb = typeof t == "function" ? t : () => $(t, null, null);
}
const yi = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ASpin",
  inheritAttrs: !1,
  props: sn(sze(), {
    size: "default",
    spinning: !0,
    wrapperClassName: ""
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: l,
      size: r,
      direction: a
    } = bt("spin", e), [i, s] = aze(l), c = /* @__PURE__ */ Ce(e.spinning && !cze(e.spinning, e.delay));
    let u;
    return pe([() => e.spinning, () => e.delay], () => {
      u == null || u.cancel(), u = nze(e.delay, () => {
        c.value = e.spinning;
      }), u == null || u();
    }, {
      immediate: !0,
      flush: "post"
    }), yt(() => {
      u == null || u.cancel();
    }), () => {
      var d, f;
      const {
        class: p
      } = n, m = ize(n, ["class"]), {
        tip: v = (d = o.tip) === null || d === void 0 ? void 0 : d.call(o)
      } = e, h = (f = o.default) === null || f === void 0 ? void 0 : f.call(o), g = {
        [s.value]: !0,
        [l.value]: !0,
        [`${l.value}-sm`]: r.value === "small",
        [`${l.value}-lg`]: r.value === "large",
        [`${l.value}-spinning`]: c.value,
        [`${l.value}-show-text`]: !!v,
        [`${l.value}-rtl`]: a.value === "rtl",
        [p]: !!p
      };
      function y(C) {
        const w = `${C}-dot`;
        let x = Wo(o, e, "indicator");
        return x === null ? null : (Array.isArray(x) && (x = x.length === 1 ? x[0] : x), dn(x) ? No(x, {
          class: w
        }) : Xb && dn(Xb()) ? No(Xb(), {
          class: w
        }) : $("span", {
          class: `${w} ${C}-dot-spin`
        }, [$("i", {
          class: `${C}-dot-item`
        }, null), $("i", {
          class: `${C}-dot-item`
        }, null), $("i", {
          class: `${C}-dot-item`
        }, null), $("i", {
          class: `${C}-dot-item`
        }, null)]));
      }
      const b = $("div", Q(Q({}, m), {}, {
        class: g,
        "aria-live": "polite",
        "aria-busy": c.value
      }), [y(l.value), v ? $("div", {
        class: `${l.value}-text`
      }, [v]) : null]);
      if (h && mo(h).length) {
        const C = {
          [`${l.value}-container`]: !0,
          [`${l.value}-blur`]: c.value
        };
        return i($("div", {
          class: [`${l.value}-nested-loading`, e.wrapperClassName, s.value]
        }, [c.value && $("div", {
          key: "loading"
        }, [b]), $("div", {
          class: C,
          key: "container"
        }, [h])]));
      }
      return i(b);
    };
  }
});
yi.setDefaultIndicator = uze;
yi.install = function(e) {
  return e.component(yi.name, yi), e;
};
var dze = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, name: "double-left", theme: "outlined" };
function zA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      fze(e, l, n[l]);
    });
  }
  return e;
}
function fze(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var jy = function(t, n) {
  var o = zA({}, t, n.attrs);
  return $(cn, zA({}, o, {
    icon: dze
  }), null);
};
jy.displayName = "DoubleLeftOutlined";
jy.inheritAttrs = !1;
var pze = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, name: "double-right", theme: "outlined" };
function HA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      vze(e, l, n[l]);
    });
  }
  return e;
}
function vze(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Wy = function(t, n) {
  var o = HA({}, t, n.attrs);
  return $(cn, HA({}, o, {
    icon: pze
  }), null);
};
Wy.displayName = "DoubleRightOutlined";
Wy.inheritAttrs = !1;
const mze = /* @__PURE__ */ le({
  name: "MiniSelect",
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: $S(),
  Option: pl.Option,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    return () => {
      const l = _(_(_({}, e), {
        size: "small"
      }), n);
      return $(pl, l, o);
    };
  }
}), hze = /* @__PURE__ */ le({
  name: "MiddleSelect",
  inheritAttrs: !1,
  props: $S(),
  Option: pl.Option,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    return () => {
      const l = _(_(_({}, e), {
        size: "middle"
      }), n);
      return $(pl, l, o);
    };
  }
}), Xc = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Pager",
  inheritAttrs: !1,
  props: {
    rootPrefixCls: String,
    page: Number,
    active: {
      type: Boolean,
      default: void 0
    },
    last: {
      type: Boolean,
      default: void 0
    },
    locale: de.object,
    showTitle: {
      type: Boolean,
      default: void 0
    },
    itemRender: {
      type: Function,
      default: () => {
      }
    },
    onClick: {
      type: Function
    },
    onKeypress: {
      type: Function
    }
  },
  eimt: ["click", "keypress"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o
    } = t;
    const l = () => {
      n("click", e.page);
    }, r = (a) => {
      n("keypress", a, l, e.page);
    };
    return () => {
      const {
        showTitle: a,
        page: i,
        itemRender: s
      } = e, {
        class: c,
        style: u
      } = o, d = `${e.rootPrefixCls}-item`, f = ke(d, `${d}-${e.page}`, {
        [`${d}-active`]: e.active,
        [`${d}-disabled`]: !e.page
      }, c);
      return $("li", {
        onClick: l,
        onKeypress: r,
        title: a ? String(i) : null,
        tabindex: "0",
        class: f,
        style: u
      }, [s({
        page: i,
        type: "page",
        originalElement: $("a", {
          rel: "nofollow"
        }, [i])
      })]);
    };
  }
}), eu = {
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
}, gze = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    changeSize: Function,
    quickGo: Function,
    selectComponentClass: de.any,
    current: Number,
    pageSizeOptions: de.array.def(["10", "20", "50", "100"]),
    pageSize: Number,
    buildOptionText: Function,
    locale: de.object,
    rootPrefixCls: String,
    selectPrefixCls: String,
    goButton: de.any
  },
  setup(e) {
    const t = /* @__PURE__ */ H(""), n = O(() => !t.value || isNaN(t.value) ? void 0 : Number(t.value)), o = (s) => `${s.value} ${e.locale.items_per_page}`, l = (s) => {
      const {
        value: c
      } = s.target;
      t.value !== c && (t.value = c);
    }, r = (s) => {
      const {
        goButton: c,
        quickGo: u,
        rootPrefixCls: d
      } = e;
      if (!(c || t.value === ""))
        if (s.relatedTarget && (s.relatedTarget.className.indexOf(`${d}-item-link`) >= 0 || s.relatedTarget.className.indexOf(`${d}-item`) >= 0)) {
          t.value = "";
          return;
        } else
          u(n.value), t.value = "";
    }, a = (s) => {
      t.value !== "" && (s.keyCode === eu.ENTER || s.type === "click") && (e.quickGo(n.value), t.value = "");
    }, i = O(() => {
      const {
        pageSize: s,
        pageSizeOptions: c
      } = e;
      return c.some((u) => u.toString() === s.toString()) ? c : c.concat([s.toString()]).sort((u, d) => {
        const f = isNaN(Number(u)) ? 0 : Number(u), p = isNaN(Number(d)) ? 0 : Number(d);
        return f - p;
      });
    });
    return () => {
      const {
        rootPrefixCls: s,
        locale: c,
        changeSize: u,
        quickGo: d,
        goButton: f,
        selectComponentClass: p,
        selectPrefixCls: m,
        pageSize: v,
        disabled: h
      } = e, g = `${s}-options`;
      let y = null, b = null, C = null;
      if (!u && !d)
        return null;
      if (u && p) {
        const w = e.buildOptionText || o, x = i.value.map((E, I) => $(p.Option, {
          key: I,
          value: E
        }, {
          default: () => [w({
            value: E
          })]
        }));
        y = $(p, {
          disabled: h,
          prefixCls: m,
          showSearch: !1,
          class: `${g}-size-changer`,
          optionLabelProp: "children",
          value: (v || i.value[0]).toString(),
          onChange: (E) => u(Number(E)),
          getPopupContainer: (E) => E.parentNode
        }, {
          default: () => [x]
        });
      }
      return d && (f && (C = typeof f == "boolean" ? $("button", {
        type: "button",
        onClick: a,
        onKeyup: a,
        disabled: h,
        class: `${g}-quick-jumper-button`
      }, [c.jump_to_confirm]) : $("span", {
        onClick: a,
        onKeyup: a
      }, [f])), b = $("div", {
        class: `${g}-quick-jumper`
      }, [c.jump_to, $(kp, {
        disabled: h,
        type: "text",
        value: t.value,
        onInput: l,
        onChange: l,
        onKeyup: a,
        onBlur: r
      }, null), c.page, C])), $("li", {
        class: `${g}`
      }, [y, b]);
    };
  }
}), bze = {
  // Options.jsx
  items_per_page: "/",
  jump_to: "",
  jump_to_confirm: "",
  page: "",
  // Pagination.jsx
  prev_page: "",
  next_page: "",
  prev_5: " 5 ",
  next_5: " 5 ",
  prev_3: " 3 ",
  next_3: " 3 "
};
var yze = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function Sze(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
}
function Cze(e) {
  let {
    originalElement: t
  } = e;
  return t;
}
function ji(e, t, n) {
  const o = typeof e == "undefined" ? t.statePageSize : e;
  return Math.floor((n.total - 1) / o) + 1;
}
const wze = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Pagination",
  mixins: [dd],
  inheritAttrs: !1,
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    prefixCls: de.string.def("rc-pagination"),
    selectPrefixCls: de.string.def("rc-select"),
    current: Number,
    defaultCurrent: de.number.def(1),
    total: de.number.def(0),
    pageSize: Number,
    defaultPageSize: de.number.def(10),
    hideOnSinglePage: {
      type: Boolean,
      default: !1
    },
    showSizeChanger: {
      type: Boolean,
      default: void 0
    },
    showLessItems: {
      type: Boolean,
      default: !1
    },
    // showSizeChange: PropTypes.func.def(noop),
    selectComponentClass: de.any,
    showPrevNextJumpers: {
      type: Boolean,
      default: !0
    },
    showQuickJumper: de.oneOfType([de.looseBool, de.object]).def(!1),
    showTitle: {
      type: Boolean,
      default: !0
    },
    pageSizeOptions: de.arrayOf(de.oneOfType([de.number, de.string])),
    buildOptionText: Function,
    showTotal: Function,
    simple: {
      type: Boolean,
      default: void 0
    },
    locale: de.object.def(bze),
    itemRender: de.func.def(Cze),
    prevIcon: de.any,
    nextIcon: de.any,
    jumpPrevIcon: de.any,
    jumpNextIcon: de.any,
    totalBoundaryShowSizeChanger: de.number.def(50)
  },
  data() {
    const e = this.$props;
    let t = hy([this.current, this.defaultCurrent]);
    const n = hy([this.pageSize, this.defaultPageSize]);
    return t = Math.min(t, ji(n, void 0, e)), {
      stateCurrent: t,
      stateCurrentInputValue: t,
      statePageSize: n
    };
  },
  watch: {
    current(e) {
      this.setState({
        stateCurrent: e,
        stateCurrentInputValue: e
      });
    },
    pageSize(e) {
      const t = {};
      let n = this.stateCurrent;
      const o = ji(e, this.$data, this.$props);
      n = n > o ? o : n, os(this, "current") || (t.stateCurrent = n, t.stateCurrentInputValue = n), t.statePageSize = e, this.setState(t);
    },
    stateCurrent(e, t) {
      this.$nextTick(() => {
        if (this.$refs.paginationNode) {
          const n = this.$refs.paginationNode.querySelector(`.${this.prefixCls}-item-${t}`);
          n && document.activeElement === n && n.blur();
        }
      });
    },
    total() {
      const e = {}, t = ji(this.pageSize, this.$data, this.$props);
      if (os(this, "current")) {
        const n = Math.min(this.current, t);
        e.stateCurrent = n, e.stateCurrentInputValue = n;
      } else {
        let n = this.stateCurrent;
        n === 0 && t > 0 ? n = 1 : n = Math.min(this.stateCurrent, t), e.stateCurrent = n;
      }
      this.setState(e);
    }
  },
  methods: {
    getJumpPrevPage() {
      return Math.max(1, this.stateCurrent - (this.showLessItems ? 3 : 5));
    },
    getJumpNextPage() {
      return Math.min(ji(void 0, this.$data, this.$props), this.stateCurrent + (this.showLessItems ? 3 : 5));
    },
    getItemIcon(e, t) {
      const {
        prefixCls: n
      } = this.$props;
      return Jz(this, e, this.$props) || $("button", {
        type: "button",
        "aria-label": t,
        class: `${n}-item-link`
      }, null);
    },
    getValidValue(e) {
      const t = e.target.value, n = ji(void 0, this.$data, this.$props), {
        stateCurrentInputValue: o
      } = this.$data;
      let l;
      return t === "" ? l = t : isNaN(Number(t)) ? l = o : t >= n ? l = n : l = Number(t), l;
    },
    isValid(e) {
      return Sze(e) && e !== this.stateCurrent;
    },
    shouldDisplayQuickJumper() {
      const {
        showQuickJumper: e,
        pageSize: t,
        total: n
      } = this.$props;
      return n <= t ? !1 : e;
    },
    // calculatePage (p) {
    //   let pageSize = p
    //   if (typeof pageSize === 'undefined') {
    //     pageSize = this.statePageSize
    //   }
    //   return Math.floor((this.total - 1) / pageSize) + 1
    // },
    handleKeyDown(e) {
      (e.keyCode === eu.ARROW_UP || e.keyCode === eu.ARROW_DOWN) && e.preventDefault();
    },
    handleKeyUp(e) {
      const t = this.getValidValue(e), n = this.stateCurrentInputValue;
      t !== n && this.setState({
        stateCurrentInputValue: t
      }), e.keyCode === eu.ENTER ? this.handleChange(t) : e.keyCode === eu.ARROW_UP ? this.handleChange(t - 1) : e.keyCode === eu.ARROW_DOWN && this.handleChange(t + 1);
    },
    changePageSize(e) {
      let t = this.stateCurrent;
      const n = t, o = ji(e, this.$data, this.$props);
      t = t > o ? o : t, o === 0 && (t = this.stateCurrent), typeof e == "number" && (os(this, "pageSize") || this.setState({
        statePageSize: e
      }), os(this, "current") || this.setState({
        stateCurrent: t,
        stateCurrentInputValue: t
      })), this.__emit("update:pageSize", e), t !== n && this.__emit("update:current", t), this.__emit("showSizeChange", t, e), this.__emit("change", t, e);
    },
    handleChange(e) {
      const {
        disabled: t
      } = this.$props;
      let n = e;
      if (this.isValid(n) && !t) {
        const o = ji(void 0, this.$data, this.$props);
        return n > o ? n = o : n < 1 && (n = 1), os(this, "current") || this.setState({
          stateCurrent: n,
          stateCurrentInputValue: n
        }), this.__emit("update:current", n), this.__emit("change", n, this.statePageSize), n;
      }
      return this.stateCurrent;
    },
    prev() {
      this.hasPrev() && this.handleChange(this.stateCurrent - 1);
    },
    next() {
      this.hasNext() && this.handleChange(this.stateCurrent + 1);
    },
    jumpPrev() {
      this.handleChange(this.getJumpPrevPage());
    },
    jumpNext() {
      this.handleChange(this.getJumpNextPage());
    },
    hasPrev() {
      return this.stateCurrent > 1;
    },
    hasNext() {
      return this.stateCurrent < ji(void 0, this.$data, this.$props);
    },
    getShowSizeChanger() {
      const {
        showSizeChanger: e,
        total: t,
        totalBoundaryShowSizeChanger: n
      } = this.$props;
      return typeof e != "undefined" ? e : t > n;
    },
    runIfEnter(e, t) {
      if (e.key === "Enter" || e.charCode === 13) {
        e.preventDefault();
        for (var n = arguments.length, o = new Array(n > 2 ? n - 2 : 0), l = 2; l < n; l++)
          o[l - 2] = arguments[l];
        t(...o);
      }
    },
    runIfEnterPrev(e) {
      this.runIfEnter(e, this.prev);
    },
    runIfEnterNext(e) {
      this.runIfEnter(e, this.next);
    },
    runIfEnterJumpPrev(e) {
      this.runIfEnter(e, this.jumpPrev);
    },
    runIfEnterJumpNext(e) {
      this.runIfEnter(e, this.jumpNext);
    },
    handleGoTO(e) {
      (e.keyCode === eu.ENTER || e.type === "click") && this.handleChange(this.stateCurrentInputValue);
    },
    renderPrev(e) {
      const {
        itemRender: t
      } = this.$props, n = t({
        page: e,
        type: "prev",
        originalElement: this.getItemIcon("prevIcon", "prev page")
      }), o = !this.hasPrev();
      return Io(n) ? _n(n, o ? {
        disabled: o
      } : {}) : n;
    },
    renderNext(e) {
      const {
        itemRender: t
      } = this.$props, n = t({
        page: e,
        type: "next",
        originalElement: this.getItemIcon("nextIcon", "next page")
      }), o = !this.hasNext();
      return Io(n) ? _n(n, o ? {
        disabled: o
      } : {}) : n;
    }
  },
  render() {
    const {
      prefixCls: e,
      disabled: t,
      hideOnSinglePage: n,
      total: o,
      locale: l,
      showQuickJumper: r,
      showLessItems: a,
      showTitle: i,
      showTotal: s,
      simple: c,
      itemRender: u,
      showPrevNextJumpers: d,
      jumpPrevIcon: f,
      jumpNextIcon: p,
      selectComponentClass: m,
      selectPrefixCls: v,
      pageSizeOptions: h
    } = this.$props, {
      stateCurrent: g,
      statePageSize: y
    } = this, b = nI(this.$attrs).extraAttrs, {
      class: C
    } = b, w = yze(b, ["class"]);
    if (n === !0 && this.total <= y)
      return null;
    const x = ji(void 0, this.$data, this.$props), E = [];
    let I = null, T = null, P = null, k = null, N = null;
    const R = r && r.goButton, z = a ? 1 : 2, D = g - 1 > 0 ? g - 1 : 0, F = g + 1 < x ? g + 1 : x, M = this.hasPrev(), A = this.hasNext();
    if (c)
      return R && (typeof R == "boolean" ? N = $("button", {
        type: "button",
        onClick: this.handleGoTO,
        onKeyup: this.handleGoTO
      }, [l.jump_to_confirm]) : N = $("span", {
        onClick: this.handleGoTO,
        onKeyup: this.handleGoTO
      }, [R]), N = $("li", {
        title: i ? `${l.jump_to}${g}/${x}` : null,
        class: `${e}-simple-pager`
      }, [N])), $("ul", Q({
        class: ke(`${e} ${e}-simple`, {
          [`${e}-disabled`]: t
        }, C)
      }, w), [$("li", {
        title: i ? l.prev_page : null,
        onClick: this.prev,
        tabindex: M ? 0 : null,
        onKeypress: this.runIfEnterPrev,
        class: ke(`${e}-prev`, {
          [`${e}-disabled`]: !M
        }),
        "aria-disabled": !M
      }, [this.renderPrev(D)]), $("li", {
        title: i ? `${g}/${x}` : null,
        class: `${e}-simple-pager`
      }, [$(kp, {
        type: "text",
        value: this.stateCurrentInputValue,
        disabled: t,
        onKeydown: this.handleKeyDown,
        onKeyup: this.handleKeyUp,
        onInput: this.handleKeyUp,
        onChange: this.handleKeyUp,
        size: "3"
      }, null), $("span", {
        class: `${e}-slash`
      }, [Ft("")]), x]), $("li", {
        title: i ? l.next_page : null,
        onClick: this.next,
        tabindex: A ? 0 : null,
        onKeypress: this.runIfEnterNext,
        class: ke(`${e}-next`, {
          [`${e}-disabled`]: !A
        }),
        "aria-disabled": !A
      }, [this.renderNext(F)]), N]);
    if (x <= 3 + z * 2) {
      const W = {
        locale: l,
        rootPrefixCls: e,
        showTitle: i,
        itemRender: u,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter
      };
      x || E.push($(Xc, Q(Q({}, W), {}, {
        key: "noPager",
        page: 1,
        class: `${e}-item-disabled`
      }), null));
      for (let Y = 1; Y <= x; Y += 1) {
        const U = g === Y;
        E.push($(Xc, Q(Q({}, W), {}, {
          key: Y,
          page: Y,
          active: U
        }), null));
      }
    } else {
      const W = a ? l.prev_3 : l.prev_5, Y = a ? l.next_3 : l.next_5;
      d && (I = $("li", {
        title: this.showTitle ? W : null,
        key: "prev",
        onClick: this.jumpPrev,
        tabindex: "0",
        onKeypress: this.runIfEnterJumpPrev,
        class: ke(`${e}-jump-prev`, {
          [`${e}-jump-prev-custom-icon`]: !!f
        })
      }, [u({
        page: this.getJumpPrevPage(),
        type: "jump-prev",
        originalElement: this.getItemIcon("jumpPrevIcon", "prev page")
      })]), T = $("li", {
        title: this.showTitle ? Y : null,
        key: "next",
        tabindex: "0",
        onClick: this.jumpNext,
        onKeypress: this.runIfEnterJumpNext,
        class: ke(`${e}-jump-next`, {
          [`${e}-jump-next-custom-icon`]: !!p
        })
      }, [u({
        page: this.getJumpNextPage(),
        type: "jump-next",
        originalElement: this.getItemIcon("jumpNextIcon", "next page")
      })])), k = $(Xc, {
        locale: l,
        last: !0,
        rootPrefixCls: e,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: x,
        page: x,
        active: !1,
        showTitle: i,
        itemRender: u
      }, null), P = $(Xc, {
        locale: l,
        rootPrefixCls: e,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: 1,
        page: 1,
        active: !1,
        showTitle: i,
        itemRender: u
      }, null);
      let U = Math.max(1, g - z), te = Math.min(g + z, x);
      g - 1 <= z && (te = 1 + z * 2), x - g <= z && (U = x - z * 2);
      for (let J = U; J <= te; J += 1) {
        const re = g === J;
        E.push($(Xc, {
          locale: l,
          rootPrefixCls: e,
          onClick: this.handleChange,
          onKeypress: this.runIfEnter,
          key: J,
          page: J,
          active: re,
          showTitle: i,
          itemRender: u
        }, null));
      }
      g - 1 >= z * 2 && g !== 3 && (E[0] = $(Xc, {
        locale: l,
        rootPrefixCls: e,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: U,
        page: U,
        class: `${e}-item-after-jump-prev`,
        active: !1,
        showTitle: this.showTitle,
        itemRender: u
      }, null), E.unshift(I)), x - g >= z * 2 && g !== x - 2 && (E[E.length - 1] = $(Xc, {
        locale: l,
        rootPrefixCls: e,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: te,
        page: te,
        class: `${e}-item-before-jump-next`,
        active: !1,
        showTitle: this.showTitle,
        itemRender: u
      }, null), E.push(T)), U !== 1 && E.unshift(P), te !== x && E.push(k);
    }
    let L = null;
    s && (L = $("li", {
      class: `${e}-total-text`
    }, [s(o, [o === 0 ? 0 : (g - 1) * y + 1, g * y > o ? o : g * y])]));
    const B = !M || !x, V = !A || !x, j = this.buildOptionText || this.$slots.buildOptionText;
    return $("ul", Q(Q({
      unselectable: "on",
      ref: "paginationNode"
    }, w), {}, {
      class: ke({
        [`${e}`]: !0,
        [`${e}-disabled`]: t
      }, C)
    }), [L, $("li", {
      title: i ? l.prev_page : null,
      onClick: this.prev,
      tabindex: B ? null : 0,
      onKeypress: this.runIfEnterPrev,
      class: ke(`${e}-prev`, {
        [`${e}-disabled`]: B
      }),
      "aria-disabled": B
    }, [this.renderPrev(D)]), E, $("li", {
      title: i ? l.next_page : null,
      onClick: this.next,
      tabindex: V ? null : 0,
      onKeypress: this.runIfEnterNext,
      class: ke(`${e}-next`, {
        [`${e}-disabled`]: V
      }),
      "aria-disabled": V
    }, [this.renderNext(F)]), $(gze, {
      disabled: t,
      locale: l,
      rootPrefixCls: e,
      selectComponentClass: m,
      selectPrefixCls: v,
      changeSize: this.getShowSizeChanger() ? this.changePageSize : null,
      current: g,
      pageSize: y,
      pageSizeOptions: h,
      buildOptionText: j || null,
      quickGo: this.shouldDisplayQuickJumper() ? this.handleChange : null,
      goButton: R
    }, null)]);
  }
}), $ze = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-disabled`]: {
      "&, &:hover": {
        cursor: "not-allowed",
        [`${t}-item-link`]: {
          color: e.colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      "&:focus-visible": {
        cursor: "not-allowed",
        [`${t}-item-link`]: {
          color: e.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    },
    [`&${t}-disabled`]: {
      cursor: "not-allowed",
      [`&${t}-mini`]: {
        [`
          &:hover ${t}-item:not(${t}-item-active),
          &:active ${t}-item:not(${t}-item-active),
          &:hover ${t}-item-link,
          &:active ${t}-item-link
        `]: {
          backgroundColor: "transparent"
        }
      },
      [`${t}-item`]: {
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        a: {
          color: e.colorTextDisabled,
          backgroundColor: "transparent",
          border: "none",
          cursor: "not-allowed"
        },
        "&-active": {
          borderColor: e.colorBorder,
          backgroundColor: e.paginationItemDisabledBgActive,
          "&:hover, &:active": {
            backgroundColor: e.paginationItemDisabledBgActive
          },
          a: {
            color: e.paginationItemDisabledColorActive
          }
        }
      },
      [`${t}-item-link`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        [`${t}-simple&`]: {
          backgroundColor: "transparent",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      },
      [`${t}-simple-pager`]: {
        color: e.colorTextDisabled
      },
      [`${t}-jump-prev, ${t}-jump-next`]: {
        [`${t}-item-link-icon`]: {
          opacity: 0
        },
        [`${t}-item-ellipsis`]: {
          opacity: 1
        }
      }
    },
    [`&${t}-simple`]: {
      [`${t}-prev, ${t}-next`]: {
        [`&${t}-disabled ${t}-item-link`]: {
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      }
    }
  };
}, xze = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`&${t}-mini ${t}-total-text, &${t}-mini ${t}-simple-pager`]: {
      height: e.paginationItemSizeSM,
      lineHeight: `${e.paginationItemSizeSM}px`
    },
    [`&${t}-mini ${t}-item`]: {
      minWidth: e.paginationItemSizeSM,
      height: e.paginationItemSizeSM,
      margin: 0,
      lineHeight: `${e.paginationItemSizeSM - 2}px`
    },
    [`&${t}-mini ${t}-item:not(${t}-item-active)`]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&:hover": {
        backgroundColor: e.colorBgTextHover
      },
      "&:active": {
        backgroundColor: e.colorBgTextActive
      }
    },
    [`&${t}-mini ${t}-prev, &${t}-mini ${t}-next`]: {
      minWidth: e.paginationItemSizeSM,
      height: e.paginationItemSizeSM,
      margin: 0,
      lineHeight: `${e.paginationItemSizeSM}px`,
      [`&:hover ${t}-item-link`]: {
        backgroundColor: e.colorBgTextHover
      },
      [`&:active ${t}-item-link`]: {
        backgroundColor: e.colorBgTextActive
      },
      [`&${t}-disabled:hover ${t}-item-link`]: {
        backgroundColor: "transparent"
      }
    },
    [`
    &${t}-mini ${t}-prev ${t}-item-link,
    &${t}-mini ${t}-next ${t}-item-link
    `]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&::after": {
        height: e.paginationItemSizeSM,
        lineHeight: `${e.paginationItemSizeSM}px`
      }
    },
    [`&${t}-mini ${t}-jump-prev, &${t}-mini ${t}-jump-next`]: {
      height: e.paginationItemSizeSM,
      marginInlineEnd: 0,
      lineHeight: `${e.paginationItemSizeSM}px`
    },
    [`&${t}-mini ${t}-options`]: {
      marginInlineStart: e.paginationMiniOptionsMarginInlineStart,
      "&-size-changer": {
        top: e.paginationMiniOptionsSizeChangerTop
      },
      "&-quick-jumper": {
        height: e.paginationItemSizeSM,
        lineHeight: `${e.paginationItemSizeSM}px`,
        input: _(_({}, OT(e)), {
          width: e.paginationMiniQuickJumperInputWidth,
          height: e.controlHeightSM
        })
      }
    }
  };
}, Eze = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`
    &${t}-simple ${t}-prev,
    &${t}-simple ${t}-next
    `]: {
      height: e.paginationItemSizeSM,
      lineHeight: `${e.paginationItemSizeSM}px`,
      verticalAlign: "top",
      [`${t}-item-link`]: {
        height: e.paginationItemSizeSM,
        backgroundColor: "transparent",
        border: 0,
        "&:hover": {
          backgroundColor: e.colorBgTextHover
        },
        "&:active": {
          backgroundColor: e.colorBgTextActive
        },
        "&::after": {
          height: e.paginationItemSizeSM,
          lineHeight: `${e.paginationItemSizeSM}px`
        }
      }
    },
    [`&${t}-simple ${t}-simple-pager`]: {
      display: "inline-block",
      height: e.paginationItemSizeSM,
      marginInlineEnd: e.marginXS,
      input: {
        boxSizing: "border-box",
        height: "100%",
        marginInlineEnd: e.marginXS,
        padding: `0 ${e.paginationItemPaddingInline}px`,
        textAlign: "center",
        backgroundColor: e.paginationItemInputBg,
        border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
        borderRadius: e.borderRadius,
        outline: "none",
        transition: `border-color ${e.motionDurationMid}`,
        color: "inherit",
        "&:hover": {
          borderColor: e.colorPrimary
        },
        "&:focus": {
          borderColor: e.colorPrimaryHover,
          boxShadow: `${e.inputOutlineOffset}px 0 ${e.controlOutlineWidth}px ${e.controlOutline}`
        },
        "&[disabled]": {
          color: e.colorTextDisabled,
          backgroundColor: e.colorBgContainerDisabled,
          borderColor: e.colorBorder,
          cursor: "not-allowed"
        }
      }
    }
  };
}, Oze = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-jump-prev, ${t}-jump-next`]: {
      outline: 0,
      [`${t}-item-container`]: {
        position: "relative",
        [`${t}-item-link-icon`]: {
          color: e.colorPrimary,
          fontSize: e.fontSizeSM,
          opacity: 0,
          transition: `all ${e.motionDurationMid}`,
          "&-svg": {
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            margin: "auto"
          }
        },
        [`${t}-item-ellipsis`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          display: "block",
          margin: "auto",
          color: e.colorTextDisabled,
          fontFamily: "Arial, Helvetica, sans-serif",
          letterSpacing: e.paginationEllipsisLetterSpacing,
          textAlign: "center",
          textIndent: e.paginationEllipsisTextIndent,
          opacity: 1,
          transition: `all ${e.motionDurationMid}`
        }
      },
      "&:hover": {
        [`${t}-item-link-icon`]: {
          opacity: 1
        },
        [`${t}-item-ellipsis`]: {
          opacity: 0
        }
      },
      "&:focus-visible": _({
        [`${t}-item-link-icon`]: {
          opacity: 1
        },
        [`${t}-item-ellipsis`]: {
          opacity: 0
        }
      }, bs(e))
    },
    [`
    ${t}-prev,
    ${t}-jump-prev,
    ${t}-jump-next
    `]: {
      marginInlineEnd: e.marginXS
    },
    [`
    ${t}-prev,
    ${t}-next,
    ${t}-jump-prev,
    ${t}-jump-next
    `]: {
      display: "inline-block",
      minWidth: e.paginationItemSize,
      height: e.paginationItemSize,
      color: e.colorText,
      fontFamily: e.paginationFontFamily,
      lineHeight: `${e.paginationItemSize}px`,
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      borderRadius: e.borderRadius,
      cursor: "pointer",
      transition: `all ${e.motionDurationMid}`
    },
    [`${t}-prev, ${t}-next`]: {
      fontFamily: "Arial, Helvetica, sans-serif",
      outline: 0,
      button: {
        color: e.colorText,
        cursor: "pointer",
        userSelect: "none"
      },
      [`${t}-item-link`]: {
        display: "block",
        width: "100%",
        height: "100%",
        padding: 0,
        fontSize: e.fontSizeSM,
        textAlign: "center",
        backgroundColor: "transparent",
        border: `${e.lineWidth}px ${e.lineType} transparent`,
        borderRadius: e.borderRadius,
        outline: "none",
        transition: `all ${e.motionDurationMid}`
      },
      [`&:focus-visible ${t}-item-link`]: _({}, bs(e)),
      [`&:hover ${t}-item-link`]: {
        backgroundColor: e.colorBgTextHover
      },
      [`&:active ${t}-item-link`]: {
        backgroundColor: e.colorBgTextActive
      },
      [`&${t}-disabled:hover`]: {
        [`${t}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`${t}-slash`]: {
      marginInlineEnd: e.paginationSlashMarginInlineEnd,
      marginInlineStart: e.paginationSlashMarginInlineStart
    },
    [`${t}-options`]: {
      display: "inline-block",
      marginInlineStart: e.margin,
      verticalAlign: "middle",
      "&-size-changer.-select": {
        display: "inline-block",
        width: "auto"
      },
      "&-quick-jumper": {
        display: "inline-block",
        height: e.controlHeight,
        marginInlineStart: e.marginXS,
        lineHeight: `${e.controlHeight}px`,
        verticalAlign: "top",
        input: _(_({}, hd(e)), {
          width: e.controlHeightLG * 1.25,
          height: e.controlHeight,
          boxSizing: "border-box",
          margin: 0,
          marginInlineStart: e.marginXS,
          marginInlineEnd: e.marginXS
        })
      }
    }
  };
}, _ze = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-item`]: _(_({
      display: "inline-block",
      minWidth: e.paginationItemSize,
      height: e.paginationItemSize,
      marginInlineEnd: e.marginXS,
      fontFamily: e.paginationFontFamily,
      lineHeight: `${e.paginationItemSize - 2}px`,
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      backgroundColor: "transparent",
      border: `${e.lineWidth}px ${e.lineType} transparent`,
      borderRadius: e.borderRadius,
      outline: 0,
      cursor: "pointer",
      userSelect: "none",
      a: {
        display: "block",
        padding: `0 ${e.paginationItemPaddingInline}px`,
        color: e.colorText,
        transition: "none",
        "&:hover": {
          textDecoration: "none"
        }
      },
      [`&:not(${t}-item-active)`]: {
        "&:hover": {
          transition: `all ${e.motionDurationMid}`,
          backgroundColor: e.colorBgTextHover
        },
        "&:active": {
          backgroundColor: e.colorBgTextActive
        }
      }
    }, ys(e)), {
      "&-active": {
        fontWeight: e.paginationFontWeightActive,
        backgroundColor: e.paginationItemBgActive,
        borderColor: e.colorPrimary,
        a: {
          color: e.colorPrimary
        },
        "&:hover": {
          borderColor: e.colorPrimaryHover
        },
        "&:hover a": {
          color: e.colorPrimaryHover
        }
      }
    })
  };
}, Ize = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: _(_(_(_(_(_(_(_({}, nn(e)), {
      "ul, ol": {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        overflow: "hidden",
        visibility: "hidden",
        content: '""'
      },
      [`${t}-total-text`]: {
        display: "inline-block",
        height: e.paginationItemSize,
        marginInlineEnd: e.marginXS,
        lineHeight: `${e.paginationItemSize - 2}px`,
        verticalAlign: "middle"
      }
    }), _ze(e)), Oze(e)), Eze(e)), xze(e)), $ze(e)), {
      // media query style
      [`@media only screen and (max-width: ${e.screenLG}px)`]: {
        [`${t}-item`]: {
          "&-after-jump-prev, &-before-jump-next": {
            display: "none"
          }
        }
      },
      [`@media only screen and (max-width: ${e.screenSM}px)`]: {
        [`${t}-options`]: {
          display: "none"
        }
      }
    }),
    // rtl style
    [`&${e.componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
}, Tze = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}${t}-disabled`]: {
      "&, &:hover": {
        [`${t}-item-link`]: {
          borderColor: e.colorBorder
        }
      },
      "&:focus-visible": {
        [`${t}-item-link`]: {
          borderColor: e.colorBorder
        }
      },
      [`${t}-item, ${t}-item-link`]: {
        backgroundColor: e.colorBgContainerDisabled,
        borderColor: e.colorBorder,
        [`&:hover:not(${t}-item-active)`]: {
          backgroundColor: e.colorBgContainerDisabled,
          borderColor: e.colorBorder,
          a: {
            color: e.colorTextDisabled
          }
        },
        [`&${t}-item-active`]: {
          backgroundColor: e.paginationItemDisabledBgActive
        }
      },
      [`${t}-prev, ${t}-next`]: {
        "&:hover button": {
          backgroundColor: e.colorBgContainerDisabled,
          borderColor: e.colorBorder,
          color: e.colorTextDisabled
        },
        [`${t}-item-link`]: {
          backgroundColor: e.colorBgContainerDisabled,
          borderColor: e.colorBorder
        }
      }
    },
    [t]: {
      [`${t}-prev, ${t}-next`]: {
        "&:hover button": {
          borderColor: e.colorPrimaryHover,
          backgroundColor: e.paginationItemBg
        },
        [`${t}-item-link`]: {
          backgroundColor: e.paginationItemLinkBg,
          borderColor: e.colorBorder
        },
        [`&:hover ${t}-item-link`]: {
          borderColor: e.colorPrimary,
          backgroundColor: e.paginationItemBg,
          color: e.colorPrimary
        },
        [`&${t}-disabled`]: {
          [`${t}-item-link`]: {
            borderColor: e.colorBorder,
            color: e.colorTextDisabled
          }
        }
      },
      [`${t}-item`]: {
        backgroundColor: e.paginationItemBg,
        border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
        [`&:hover:not(${t}-item-active)`]: {
          borderColor: e.colorPrimary,
          backgroundColor: e.paginationItemBg,
          a: {
            color: e.colorPrimary
          }
        },
        "&-active": {
          borderColor: e.colorPrimary
        }
      }
    }
  };
}, Pze = Zt("Pagination", (e) => {
  const t = Vt(e, {
    paginationItemSize: e.controlHeight,
    paginationFontFamily: e.fontFamily,
    paginationItemBg: e.colorBgContainer,
    paginationItemBgActive: e.colorBgContainer,
    paginationFontWeightActive: e.fontWeightStrong,
    paginationItemSizeSM: e.controlHeightSM,
    paginationItemInputBg: e.colorBgContainer,
    paginationMiniOptionsSizeChangerTop: 0,
    paginationItemDisabledBgActive: e.controlItemBgActiveDisabled,
    paginationItemDisabledColorActive: e.colorTextDisabled,
    paginationItemLinkBg: e.colorBgContainer,
    inputOutlineOffset: "0 0",
    paginationMiniOptionsMarginInlineStart: e.marginXXS / 2,
    paginationMiniQuickJumperInputWidth: e.controlHeightLG * 1.1,
    paginationItemPaddingInline: e.marginXXS * 1.5,
    paginationEllipsisLetterSpacing: e.marginXXS / 2,
    paginationSlashMarginInlineStart: e.marginXXS,
    paginationSlashMarginInlineEnd: e.marginSM,
    paginationEllipsisTextIndent: "0.13em"
    // magic for ui experience
  }, gd(e));
  return [Ize(t), e.wireframe && Tze(t)];
});
var kze = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const Nze = () => ({
  total: Number,
  defaultCurrent: Number,
  disabled: Qe(),
  current: Number,
  defaultPageSize: Number,
  pageSize: Number,
  hideOnSinglePage: Qe(),
  showSizeChanger: Qe(),
  pageSizeOptions: $n(),
  buildOptionText: Fe(),
  showQuickJumper: zt([Boolean, Object]),
  showTotal: Fe(),
  size: At(),
  simple: Qe(),
  locale: Object,
  prefixCls: String,
  selectPrefixCls: String,
  totalBoundaryShowSizeChanger: Number,
  selectComponentClass: String,
  itemRender: Fe(),
  role: String,
  responsive: Boolean,
  showLessItems: Qe(),
  onChange: Fe(),
  onShowSizeChange: Fe(),
  "onUpdate:current": Fe(),
  "onUpdate:pageSize": Fe()
}), Mze = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "APagination",
  inheritAttrs: !1,
  props: Nze(),
  // emits: ['change', 'showSizeChange', 'update:current', 'update:pageSize'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      configProvider: r,
      direction: a,
      size: i
    } = bt("pagination", e), [s, c] = Pze(l), u = O(() => r.getPrefixCls("select", e.selectPrefixCls)), d = Dp(), [f] = fa("Pagination", iH, /* @__PURE__ */ ft(e, "locale")), p = (m) => {
      const v = $("span", {
        class: `${m}-item-ellipsis`
      }, [Ft("")]), h = $("button", {
        class: `${m}-item-link`,
        type: "button",
        tabindex: -1
      }, [a.value === "rtl" ? $(Br, null, null) : $(Ii, null, null)]), g = $("button", {
        class: `${m}-item-link`,
        type: "button",
        tabindex: -1
      }, [a.value === "rtl" ? $(Ii, null, null) : $(Br, null, null)]), y = $("a", {
        rel: "nofollow",
        class: `${m}-item-link`
      }, [$("div", {
        class: `${m}-item-container`
      }, [a.value === "rtl" ? $(Wy, {
        class: `${m}-item-link-icon`
      }, null) : $(jy, {
        class: `${m}-item-link-icon`
      }, null), v])]), b = $("a", {
        rel: "nofollow",
        class: `${m}-item-link`
      }, [$("div", {
        class: `${m}-item-container`
      }, [a.value === "rtl" ? $(jy, {
        class: `${m}-item-link-icon`
      }, null) : $(Wy, {
        class: `${m}-item-link-icon`
      }, null), v])]);
      return {
        prevIcon: h,
        nextIcon: g,
        jumpPrevIcon: y,
        jumpNextIcon: b
      };
    };
    return () => {
      var m;
      const {
        itemRender: v = n.itemRender,
        buildOptionText: h = n.buildOptionText,
        selectComponentClass: g,
        responsive: y
      } = e, b = kze(e, ["itemRender", "buildOptionText", "selectComponentClass", "responsive"]), C = i.value === "small" || !!(!((m = d.value) === null || m === void 0) && m.xs && !i.value && y), w = _(_(_(_(_({}, b), p(l.value)), {
        prefixCls: l.value,
        selectPrefixCls: u.value,
        selectComponentClass: g || (C ? mze : hze),
        locale: f.value,
        buildOptionText: h
      }), o), {
        class: ke({
          [`${l.value}-mini`]: C,
          [`${l.value}-rtl`]: a.value === "rtl"
        }, o.class, c.value),
        itemRender: v
      });
      return s($(wze, w, null));
    };
  }
}), ZS = po(Mze), Aze = () => ({
  avatar: de.any,
  description: de.any,
  prefixCls: String,
  title: de.any
}), WU = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AListItemMeta",
  props: Aze(),
  displayName: "AListItemMeta",
  __ANT_LIST_ITEM_META: !0,
  slots: Object,
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o
    } = bt("list", e);
    return () => {
      var l, r, a, i, s, c;
      const u = `${o.value}-item-meta`, d = (l = e.title) !== null && l !== void 0 ? l : (r = n.title) === null || r === void 0 ? void 0 : r.call(n), f = (a = e.description) !== null && a !== void 0 ? a : (i = n.description) === null || i === void 0 ? void 0 : i.call(n), p = (s = e.avatar) !== null && s !== void 0 ? s : (c = n.avatar) === null || c === void 0 ? void 0 : c.call(n), m = $("div", {
        class: `${o.value}-item-meta-content`
      }, [d && $("h4", {
        class: `${o.value}-item-meta-title`
      }, [d]), f && $("div", {
        class: `${o.value}-item-meta-description`
      }, [f])]);
      return $("div", {
        class: u
      }, [p && $("div", {
        class: `${o.value}-item-meta-avatar`
      }, [p]), (d || f) && m]);
    };
  }
}), KU = Symbol("ListContextKey");
var Rze = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const Dze = () => ({
  prefixCls: String,
  extra: de.any,
  actions: de.array,
  grid: Object,
  colStyle: {
    type: Object,
    default: void 0
  }
}), UU = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AListItem",
  inheritAttrs: !1,
  Meta: WU,
  props: Dze(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      itemLayout: l,
      grid: r
    } = ze(KU, {
      grid: /* @__PURE__ */ H(),
      itemLayout: /* @__PURE__ */ H()
    }), {
      prefixCls: a
    } = bt("list", e), i = () => {
      var c;
      const u = ((c = n.default) === null || c === void 0 ? void 0 : c.call(n)) || [];
      let d;
      return u.forEach((f) => {
        kPe(f) && !$h(f) && (d = !0);
      }), d && u.length > 1;
    }, s = () => {
      var c, u;
      const d = (c = e.extra) !== null && c !== void 0 ? c : (u = n.extra) === null || u === void 0 ? void 0 : u.call(n);
      return l.value === "vertical" ? !!d : !i();
    };
    return () => {
      var c, u, d, f, p;
      const {
        class: m
      } = o, v = Rze(o, ["class"]), h = a.value, g = (c = e.extra) !== null && c !== void 0 ? c : (u = n.extra) === null || u === void 0 ? void 0 : u.call(n), y = (d = n.default) === null || d === void 0 ? void 0 : d.call(n);
      let b = (f = e.actions) !== null && f !== void 0 ? f : Fn((p = n.actions) === null || p === void 0 ? void 0 : p.call(n));
      b = b && !Array.isArray(b) ? [b] : b;
      const C = b && b.length > 0 && $("ul", {
        class: `${h}-item-action`,
        key: "actions"
      }, [b.map((E, I) => $("li", {
        key: `${h}-item-action-${I}`
      }, [E, I !== b.length - 1 && $("em", {
        class: `${h}-item-action-split`
      }, null)]))]), w = r.value ? "div" : "li", x = $(w, Q(Q({}, v), {}, {
        class: ke(`${h}-item`, {
          [`${h}-item-no-flex`]: !s()
        }, m)
      }), {
        default: () => [l.value === "vertical" && g ? [$("div", {
          class: `${h}-item-main`,
          key: "content"
        }, [y, C]), $("div", {
          class: `${h}-item-extra`,
          key: "extra"
        }, [g])] : [y, C, _n(g, {
          key: "extra"
        })]]
      });
      return r.value ? $(WS, {
        flex: 1,
        style: e.colStyle
      }, {
        default: () => [x]
      }) : x;
    };
  }
}), Lze = (e) => {
  const {
    listBorderedCls: t,
    componentCls: n,
    paddingLG: o,
    margin: l,
    padding: r,
    listItemPaddingSM: a,
    marginLG: i,
    borderRadiusLG: s
  } = e;
  return {
    [`${t}`]: {
      border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
      borderRadius: s,
      [`${n}-header,${n}-footer,${n}-item`]: {
        paddingInline: o
      },
      [`${n}-pagination`]: {
        margin: `${l}px ${i}px`
      }
    },
    [`${t}${n}-sm`]: {
      [`${n}-item,${n}-header,${n}-footer`]: {
        padding: a
      }
    },
    [`${t}${n}-lg`]: {
      [`${n}-item,${n}-header,${n}-footer`]: {
        padding: `${r}px ${o}px`
      }
    }
  };
}, Bze = (e) => {
  const {
    componentCls: t,
    screenSM: n,
    screenMD: o,
    marginLG: l,
    marginSM: r,
    margin: a
  } = e;
  return {
    [`@media screen and (max-width:${o})`]: {
      [`${t}`]: {
        [`${t}-item`]: {
          [`${t}-item-action`]: {
            marginInlineStart: l
          }
        }
      },
      [`${t}-vertical`]: {
        [`${t}-item`]: {
          [`${t}-item-extra`]: {
            marginInlineStart: l
          }
        }
      }
    },
    [`@media screen and (max-width: ${n})`]: {
      [`${t}`]: {
        [`${t}-item`]: {
          flexWrap: "wrap",
          [`${t}-action`]: {
            marginInlineStart: r
          }
        }
      },
      [`${t}-vertical`]: {
        [`${t}-item`]: {
          flexWrap: "wrap-reverse",
          [`${t}-item-main`]: {
            minWidth: e.contentWidth
          },
          [`${t}-item-extra`]: {
            margin: `auto auto ${a}px`
          }
        }
      }
    }
  };
}, Fze = (e) => {
  const {
    componentCls: t,
    antCls: n,
    controlHeight: o,
    minHeight: l,
    paddingSM: r,
    marginLG: a,
    padding: i,
    listItemPadding: s,
    colorPrimary: c,
    listItemPaddingSM: u,
    listItemPaddingLG: d,
    paddingXS: f,
    margin: p,
    colorText: m,
    colorTextDescription: v,
    motionDurationSlow: h,
    lineWidth: g
  } = e;
  return {
    [`${t}`]: _(_({}, nn(e)), {
      position: "relative",
      "*": {
        outline: "none"
      },
      [`${t}-header, ${t}-footer`]: {
        background: "transparent",
        paddingBlock: r
      },
      [`${t}-pagination`]: {
        marginBlockStart: a,
        textAlign: "end",
        // https://github.com/ant-design/ant-design/issues/20037
        [`${n}-pagination-options`]: {
          textAlign: "start"
        }
      },
      [`${t}-spin`]: {
        minHeight: l,
        textAlign: "center"
      },
      [`${t}-items`]: {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      [`${t}-item`]: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: s,
        color: m,
        [`${t}-item-meta`]: {
          display: "flex",
          flex: 1,
          alignItems: "flex-start",
          maxWidth: "100%",
          [`${t}-item-meta-avatar`]: {
            marginInlineEnd: i
          },
          [`${t}-item-meta-content`]: {
            flex: "1 0",
            width: 0,
            color: m
          },
          [`${t}-item-meta-title`]: {
            marginBottom: e.marginXXS,
            color: m,
            fontSize: e.fontSize,
            lineHeight: e.lineHeight,
            "> a": {
              color: m,
              transition: `all ${h}`,
              "&:hover": {
                color: c
              }
            }
          },
          [`${t}-item-meta-description`]: {
            color: v,
            fontSize: e.fontSize,
            lineHeight: e.lineHeight
          }
        },
        [`${t}-item-action`]: {
          flex: "0 0 auto",
          marginInlineStart: e.marginXXL,
          padding: 0,
          fontSize: 0,
          listStyle: "none",
          "& > li": {
            position: "relative",
            display: "inline-block",
            padding: `0 ${f}px`,
            color: v,
            fontSize: e.fontSize,
            lineHeight: e.lineHeight,
            textAlign: "center",
            "&:first-child": {
              paddingInlineStart: 0
            }
          },
          [`${t}-item-action-split`]: {
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineEnd: 0,
            width: g,
            height: Math.ceil(e.fontSize * e.lineHeight) - e.marginXXS * 2,
            transform: "translateY(-50%)",
            backgroundColor: e.colorSplit
          }
        }
      },
      [`${t}-empty`]: {
        padding: `${i}px 0`,
        color: v,
        fontSize: e.fontSizeSM,
        textAlign: "center"
      },
      [`${t}-empty-text`]: {
        padding: i,
        color: e.colorTextDisabled,
        fontSize: e.fontSize,
        textAlign: "center"
      },
      // ============================ without flex ============================
      [`${t}-item-no-flex`]: {
        display: "block"
      }
    }),
    [`${t}-grid ${n}-col > ${t}-item`]: {
      display: "block",
      maxWidth: "100%",
      marginBlockEnd: p,
      paddingBlock: 0,
      borderBlockEnd: "none"
    },
    [`${t}-vertical ${t}-item`]: {
      alignItems: "initial",
      [`${t}-item-main`]: {
        display: "block",
        flex: 1
      },
      [`${t}-item-extra`]: {
        marginInlineStart: a
      },
      [`${t}-item-meta`]: {
        marginBlockEnd: i,
        [`${t}-item-meta-title`]: {
          marginBlockEnd: r,
          color: m,
          fontSize: e.fontSizeLG,
          lineHeight: e.lineHeightLG
        }
      },
      [`${t}-item-action`]: {
        marginBlockStart: i,
        marginInlineStart: "auto",
        "> li": {
          padding: `0 ${i}px`,
          "&:first-child": {
            paddingInlineStart: 0
          }
        }
      }
    },
    [`${t}-split ${t}-item`]: {
      borderBlockEnd: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`,
      "&:last-child": {
        borderBlockEnd: "none"
      }
    },
    [`${t}-split ${t}-header`]: {
      borderBlockEnd: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`
    },
    [`${t}-split${t}-empty ${t}-footer`]: {
      borderTop: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`
    },
    [`${t}-loading ${t}-spin-nested-loading`]: {
      minHeight: o
    },
    [`${t}-split${t}-something-after-last-item ${n}-spin-container > ${t}-items > ${t}-item:last-child`]: {
      borderBlockEnd: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`
    },
    [`${t}-lg ${t}-item`]: {
      padding: d
    },
    [`${t}-sm ${t}-item`]: {
      padding: u
    },
    // Horizontal
    [`${t}:not(${t}-vertical)`]: {
      [`${t}-item-no-flex`]: {
        [`${t}-item-action`]: {
          float: "right"
        }
      }
    }
  };
}, Vze = Zt("List", (e) => {
  const t = Vt(e, {
    listBorderedCls: `${e.componentCls}-bordered`,
    minHeight: e.controlHeightLG,
    listItemPadding: `${e.paddingContentVertical}px ${e.paddingContentHorizontalLG}px`,
    listItemPaddingSM: `${e.paddingContentVerticalSM}px ${e.paddingContentHorizontal}px`,
    listItemPaddingLG: `${e.paddingContentVerticalLG}px ${e.paddingContentHorizontalLG}px`
  });
  return [Fze(t), Lze(t), Bze(t)];
}, {
  contentWidth: 220
}), zze = () => ({
  bordered: Qe(),
  dataSource: $n(),
  extra: Pl(),
  grid: Nt(),
  itemLayout: String,
  loading: zt([Boolean, Object]),
  loadMore: Pl(),
  pagination: zt([Boolean, Object]),
  prefixCls: String,
  rowKey: zt([String, Number, Function]),
  renderItem: Fe(),
  size: String,
  split: Qe(),
  header: Pl(),
  footer: Pl(),
  locale: Nt()
}), zs = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AList",
  inheritAttrs: !1,
  Item: UU,
  props: sn(zze(), {
    dataSource: [],
    bordered: !1,
    split: !0,
    loading: !1,
    pagination: !1
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    var l, r;
    at(KU, {
      grid: /* @__PURE__ */ ft(e, "grid"),
      itemLayout: /* @__PURE__ */ ft(e, "itemLayout")
    });
    const a = {
      current: 1,
      total: 0
    }, {
      prefixCls: i,
      direction: s,
      renderEmpty: c
    } = bt("list", e), [u, d] = Vze(i), f = O(() => e.pagination && typeof e.pagination == "object" ? e.pagination : {}), p = /* @__PURE__ */ H((l = f.value.defaultCurrent) !== null && l !== void 0 ? l : 1), m = /* @__PURE__ */ H((r = f.value.defaultPageSize) !== null && r !== void 0 ? r : 10);
    pe(f, () => {
      "current" in f.value && (p.value = f.value.current), "pageSize" in f.value && (m.value = f.value.pageSize);
    });
    const v = [], h = (R) => (z, D) => {
      p.value = z, m.value = D, f.value[R] && f.value[R](z, D);
    }, g = h("onChange"), y = h("onShowSizeChange"), b = O(() => typeof e.loading == "boolean" ? {
      spinning: e.loading
    } : e.loading), C = O(() => b.value && b.value.spinning), w = O(() => {
      let R = "";
      switch (e.size) {
        case "large":
          R = "lg";
          break;
        case "small":
          R = "sm";
          break;
      }
      return R;
    }), x = O(() => ({
      [`${i.value}`]: !0,
      [`${i.value}-vertical`]: e.itemLayout === "vertical",
      [`${i.value}-${w.value}`]: w.value,
      [`${i.value}-split`]: e.split,
      [`${i.value}-bordered`]: e.bordered,
      [`${i.value}-loading`]: C.value,
      [`${i.value}-grid`]: !!e.grid,
      [`${i.value}-rtl`]: s.value === "rtl"
    })), E = O(() => {
      const R = _(_(_({}, a), {
        total: e.dataSource.length,
        current: p.value,
        pageSize: m.value
      }), e.pagination || {}), z = Math.ceil(R.total / R.pageSize);
      return R.current > z && (R.current = z), R;
    }), I = O(() => {
      let R = [...e.dataSource];
      return e.pagination && e.dataSource.length > (E.value.current - 1) * E.value.pageSize && (R = [...e.dataSource].splice((E.value.current - 1) * E.value.pageSize, E.value.pageSize)), R;
    }), T = Dp(), P = _r(() => {
      for (let R = 0; R < rs.length; R += 1) {
        const z = rs[R];
        if (T.value[z])
          return z;
      }
    }), k = O(() => {
      if (!e.grid)
        return;
      const R = P.value && e.grid[P.value] ? e.grid[P.value] : e.grid.column;
      if (R)
        return {
          width: `${100 / R}%`,
          maxWidth: `${100 / R}%`
        };
    }), N = (R, z) => {
      var D;
      const F = (D = e.renderItem) !== null && D !== void 0 ? D : n.renderItem;
      if (!F) return null;
      let M;
      const A = typeof e.rowKey;
      return A === "function" ? M = e.rowKey(R) : A === "string" || A === "number" ? M = R[e.rowKey] : M = R.key, M || (M = `list-item-${z}`), v[z] = M, F({
        item: R,
        index: z
      });
    };
    return () => {
      var R, z, D, F, M, A, L, B;
      const V = (R = e.loadMore) !== null && R !== void 0 ? R : (z = n.loadMore) === null || z === void 0 ? void 0 : z.call(n), j = (D = e.footer) !== null && D !== void 0 ? D : (F = n.footer) === null || F === void 0 ? void 0 : F.call(n), W = (M = e.header) !== null && M !== void 0 ? M : (A = n.header) === null || A === void 0 ? void 0 : A.call(n), Y = Fn((L = n.default) === null || L === void 0 ? void 0 : L.call(n)), U = !!(V || e.pagination || j), te = ke(_(_({}, x.value), {
        [`${i.value}-something-after-last-item`]: U
      }), o.class, d.value), J = e.pagination ? $("div", {
        class: `${i.value}-pagination`
      }, [$(ZS, Q(Q({}, E.value), {}, {
        onChange: g,
        onShowSizeChange: y
      }), null)]) : null;
      let re = C.value && $("div", {
        style: {
          minHeight: "53px"
        }
      }, null);
      if (I.value.length > 0) {
        v.length = 0;
        const q = I.value.map((se, Z) => N(se, Z)), K = q.map((se, Z) => $("div", {
          key: v[Z],
          style: k.value
        }, [se]));
        re = e.grid ? $(VT, {
          gutter: e.grid.gutter
        }, {
          default: () => [K]
        }) : $("ul", {
          class: `${i.value}-items`
        }, [q]);
      } else !Y.length && !C.value && (re = $("div", {
        class: `${i.value}-empty-text`
      }, [((B = e.locale) === null || B === void 0 ? void 0 : B.emptyText) || c("List")]));
      const oe = E.value.position || "bottom";
      return u($("div", Q(Q({}, o), {}, {
        class: te
      }), [(oe === "top" || oe === "both") && J, W && $("div", {
        class: `${i.value}-header`
      }, [W]), $(yi, b.value, {
        default: () => [re, Y]
      }), j && $("div", {
        class: `${i.value}-footer`
      }, [j]), V || (oe === "bottom" || oe === "both") && J]));
    };
  }
});
zs.install = function(e) {
  return e.component(zs.name, zs), e.component(zs.Item.name, zs.Item), e.component(zs.Item.Meta.name, zs.Item.Meta), e;
};
function Hze(e) {
  const {
    selectionStart: t
  } = e;
  return e.value.slice(0, t);
}
function jze(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return (Array.isArray(t) ? t : [t]).reduce((o, l) => {
    const r = e.lastIndexOf(l);
    return r > o.location ? {
      location: r,
      prefix: l
    } : o;
  }, {
    location: -1,
    prefix: ""
  });
}
function jA(e) {
  return (e || "").toLowerCase();
}
function Wze(e, t, n) {
  const o = e[0];
  if (!o || o === n)
    return e;
  let l = e;
  const r = t.length;
  for (let a = 0; a < r; a += 1)
    if (jA(l[a]) !== jA(t[a])) {
      l = l.slice(a);
      break;
    } else a === r - 1 && (l = l.slice(r));
  return l;
}
function Kze(e, t) {
  const {
    measureLocation: n,
    prefix: o,
    targetText: l,
    selectionStart: r,
    split: a
  } = t;
  let i = e.slice(0, n);
  i[i.length - a.length] === a && (i = i.slice(0, i.length - a.length)), i && (i = `${i}${a}`);
  let s = Wze(e.slice(r), l.slice(r - n - o.length), a);
  s.slice(0, a.length) === a && (s = s.slice(a.length));
  const c = `${i}${o}${l}${a}`;
  return {
    text: `${c}${s}`,
    selectionLocation: c.length
  };
}
function Uze(e, t) {
  e.setSelectionRange(t, t), e.blur(), e.focus();
}
function Gze(e, t) {
  const {
    split: n
  } = t;
  return !n || e.indexOf(n) === -1;
}
function Yze(e, t) {
  let {
    value: n = ""
  } = t;
  const o = e.toLowerCase();
  return n.toLowerCase().indexOf(o) !== -1;
}
const GU = Symbol("MentionsContextKey");
function Xze() {
}
const qze = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "DropdownMenu",
  props: {
    prefixCls: String,
    options: {
      type: Array,
      default: () => []
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      activeIndex: o,
      setActiveIndex: l,
      selectOption: r,
      onFocus: a = Xze,
      loading: i
    } = ze(GU, {
      activeIndex: /* @__PURE__ */ Ce(),
      loading: /* @__PURE__ */ Ce(!1)
    });
    let s;
    const c = (u) => {
      clearTimeout(s), s = setTimeout(() => {
        a(u);
      });
    };
    return yt(() => {
      clearTimeout(s);
    }), () => {
      var u;
      const {
        prefixCls: d,
        options: f
      } = e, p = f[o.value] || {};
      return $(Do, {
        prefixCls: `${d}-menu`,
        activeKey: p.value,
        onSelect: (m) => {
          let {
            key: v
          } = m;
          const h = f.find((g) => {
            let {
              value: y
            } = g;
            return y === v;
          });
          r(h);
        },
        onMousedown: c
      }, {
        default: () => [!i.value && f.map((m, v) => {
          var h, g;
          const {
            value: y,
            disabled: b,
            label: C = m.value,
            class: w,
            style: x
          } = m;
          return $(bi, {
            key: y,
            disabled: b,
            onMouseenter: () => {
              l(v);
            },
            class: w,
            style: x
          }, {
            default: () => [(g = (h = n.option) === null || h === void 0 ? void 0 : h.call(n, m)) !== null && g !== void 0 ? g : typeof C == "function" ? C(m) : C]
          });
        }), !i.value && f.length === 0 ? $(bi, {
          key: "notFoundContent",
          disabled: !0
        }, {
          default: () => [(u = n.notFoundContent) === null || u === void 0 ? void 0 : u.call(n)]
        }) : null, i.value && $(bi, {
          key: "loading",
          disabled: !0
        }, {
          default: () => [$(yi, {
            size: "small"
          }, null)]
        })]
      });
    };
  }
}), Jze = {
  bottomRight: {
    points: ["tl", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  bottomLeft: {
    points: ["tr", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["bl", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["br", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
}, Zze = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "KeywordTrigger",
  props: {
    loading: {
      type: Boolean,
      default: void 0
    },
    options: {
      type: Array,
      default: () => []
    },
    prefixCls: String,
    placement: String,
    visible: {
      type: Boolean,
      default: void 0
    },
    transitionName: String,
    getPopupContainer: Function,
    direction: String,
    dropdownClassName: String
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = () => `${e.prefixCls}-dropdown`, l = () => {
      const {
        options: a
      } = e;
      return $(qze, {
        prefixCls: o(),
        options: a
      }, {
        notFoundContent: n.notFoundContent,
        option: n.option
      });
    }, r = O(() => {
      const {
        placement: a,
        direction: i
      } = e;
      let s = "topRight";
      return i === "rtl" ? s = a === "top" ? "topLeft" : "bottomLeft" : s = a === "top" ? "topRight" : "bottomRight", s;
    });
    return () => {
      const {
        visible: a,
        transitionName: i,
        getPopupContainer: s
      } = e;
      return $(fd, {
        prefixCls: o(),
        popupVisible: a,
        popup: l(),
        popupClassName: e.dropdownClassName,
        popupPlacement: r.value,
        popupTransitionName: i,
        builtinPlacements: Jze,
        getPopupContainer: s
      }, {
        default: n.default
      });
    };
  }
}), Qze = $l("top", "bottom"), YU = {
  autofocus: {
    type: Boolean,
    default: void 0
  },
  prefix: de.oneOfType([de.string, de.arrayOf(de.string)]),
  prefixCls: String,
  value: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  split: String,
  transitionName: String,
  placement: de.oneOf(Qze),
  character: de.any,
  characterRender: Function,
  filterOption: {
    type: [Boolean, Function]
  },
  validateSearch: Function,
  getPopupContainer: {
    type: Function
  },
  options: $n(),
  loading: {
    type: Boolean,
    default: void 0
  },
  rows: [Number, String],
  direction: {
    type: String
  }
}, XU = _(_({}, YU), {
  dropdownClassName: String
}), qU = {
  prefix: "@",
  split: " ",
  rows: 1,
  validateSearch: Gze,
  filterOption: () => Yze
};
sn(XU, qU);
var WA = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function KA() {
}
const eHe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Mentions",
  inheritAttrs: !1,
  props: sn(XU, qU),
  emits: ["change", "select", "search", "focus", "blur", "pressenter"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      expose: l,
      slots: r
    } = t;
    const a = /* @__PURE__ */ H(null), i = /* @__PURE__ */ H(null), s = /* @__PURE__ */ H(), c = /* @__PURE__ */ kt({
      value: e.value || "",
      measuring: !1,
      measureLocation: 0,
      measureText: null,
      measurePrefix: "",
      activeIndex: 0,
      isFocus: !1
    });
    Ot(() => {
      c.value = e.value;
    });
    const u = (k) => {
      n("change", k);
    }, d = (k) => {
      let {
        target: {
          value: N
        }
      } = k;
      u(N);
    }, f = (k, N, R) => {
      _(c, {
        measuring: !0,
        measureText: k,
        measurePrefix: N,
        measureLocation: R,
        activeIndex: 0
      });
    }, p = (k) => {
      _(c, {
        measuring: !1,
        measureLocation: 0,
        measureText: null
      }), k == null || k();
    }, m = (k) => {
      const {
        which: N
      } = k;
      if (c.measuring) {
        if (N === ot.UP || N === ot.DOWN) {
          const R = I.value.length, z = N === ot.UP ? -1 : 1, D = (c.activeIndex + z + R) % R;
          c.activeIndex = D, k.preventDefault();
        } else if (N === ot.ESC)
          p();
        else if (N === ot.ENTER) {
          if (k.preventDefault(), !I.value.length) {
            p();
            return;
          }
          const R = I.value[c.activeIndex];
          w(R);
        }
      }
    }, v = (k) => {
      const {
        key: N,
        which: R
      } = k, {
        measureText: z,
        measuring: D
      } = c, {
        prefix: F,
        validateSearch: M
      } = e, A = k.target;
      if (A.composing)
        return;
      const L = Hze(A), {
        location: B,
        prefix: V
      } = jze(L, F);
      if ([ot.ESC, ot.UP, ot.DOWN, ot.ENTER].indexOf(R) === -1)
        if (B !== -1) {
          const j = L.slice(B + V.length), W = M(j, e), Y = !!E(j).length;
          W ? (N === V || N === "Shift" || D || j !== z && Y) && f(j, V, B) : D && p(), W && n("search", j, V);
        } else D && p();
    }, h = (k) => {
      c.measuring || n("pressenter", k);
    }, g = (k) => {
      b(k);
    }, y = (k) => {
      C(k);
    }, b = (k) => {
      clearTimeout(s.value);
      const {
        isFocus: N
      } = c;
      !N && k && n("focus", k), c.isFocus = !0;
    }, C = (k) => {
      s.value = setTimeout(() => {
        c.isFocus = !1, p(), n("blur", k);
      }, 100);
    }, w = (k) => {
      const {
        split: N
      } = e, {
        value: R = ""
      } = k, {
        text: z,
        selectionLocation: D
      } = Kze(c.value, {
        measureLocation: c.measureLocation,
        targetText: R,
        prefix: c.measurePrefix,
        selectionStart: i.value.getSelectionStart(),
        split: N
      });
      u(z), p(() => {
        Uze(i.value.input, D);
      }), n("select", k, c.measurePrefix);
    }, x = (k) => {
      c.activeIndex = k;
    }, E = (k) => {
      const N = k || c.measureText || "", {
        filterOption: R
      } = e;
      return e.options.filter((D) => R ? R(N, D) : !0);
    }, I = O(() => E());
    return l({
      blur: () => {
        i.value.blur();
      },
      focus: () => {
        i.value.focus();
      }
    }), at(GU, {
      activeIndex: /* @__PURE__ */ ft(c, "activeIndex"),
      setActiveIndex: x,
      selectOption: w,
      onFocus: b,
      onBlur: C,
      loading: /* @__PURE__ */ ft(e, "loading")
    }), $o(() => {
      Ke(() => {
        c.measuring && (a.value.scrollTop = i.value.getScrollTop());
      });
    }), () => {
      const {
        measureLocation: k,
        measurePrefix: N,
        measuring: R
      } = c, {
        prefixCls: z,
        placement: D,
        transitionName: F,
        getPopupContainer: M,
        direction: A
      } = e, L = WA(e, ["prefixCls", "placement", "transitionName", "getPopupContainer", "direction"]), {
        class: B,
        style: V
      } = o, j = WA(o, ["class", "style"]), W = pn(L, ["value", "prefix", "split", "validateSearch", "filterOption", "options", "loading"]), Y = _(_(_({}, W), j), {
        onChange: KA,
        onSelect: KA,
        value: c.value,
        onInput: d,
        onBlur: y,
        onKeydown: m,
        onKeyup: v,
        onFocus: g,
        onPressenter: h
      });
      return $("div", {
        class: ke(z, B),
        style: V
      }, [$(kp, Q(Q({}, Y), {}, {
        ref: i,
        tag: "textarea"
      }), null), R && $("div", {
        ref: a,
        class: `${z}-measure`
      }, [c.value.slice(0, k), $(Zze, {
        prefixCls: z,
        transitionName: F,
        dropdownClassName: e.dropdownClassName,
        placement: D,
        options: R ? I.value : [],
        visible: !0,
        direction: A,
        getPopupContainer: M
      }, {
        default: () => [$("span", null, [N])],
        notFoundContent: r.notFoundContent,
        option: r.option
      }), c.value.slice(k + N.length)])]);
    };
  }
}), tHe = {
  value: String,
  disabled: Boolean,
  payload: Nt()
}, JU = _(_({}, tHe), {
  label: Wn([])
}), ZU = {
  name: "Option",
  props: JU,
  render(e, t) {
    let {
      slots: n
    } = t;
    var o;
    return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
  }
};
_({
  compatConfig: {
    MODE: 3
  }
}, ZU);
const nHe = (e) => {
  const {
    componentCls: t,
    colorTextDisabled: n,
    controlItemBgHover: o,
    controlPaddingHorizontal: l,
    colorText: r,
    motionDurationSlow: a,
    lineHeight: i,
    controlHeight: s,
    inputPaddingHorizontal: c,
    inputPaddingVertical: u,
    fontSize: d,
    colorBgElevated: f,
    borderRadiusLG: p,
    boxShadowSecondary: m
  } = e, v = Math.round((e.controlHeight - e.fontSize * e.lineHeight) / 2);
  return {
    [t]: _(_(_(_(_({}, nn(e)), hd(e)), {
      position: "relative",
      display: "inline-block",
      height: "auto",
      padding: 0,
      overflow: "hidden",
      lineHeight: i,
      whiteSpace: "pre-wrap",
      verticalAlign: "bottom"
    }), Mh(e, t)), {
      "&-disabled": {
        "> textarea": _({}, ET(e))
      },
      "&-focused": _({}, xc(e)),
      [`&-affix-wrapper ${t}-suffix`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: c,
        bottom: 0,
        zIndex: 1,
        display: "inline-flex",
        alignItems: "center",
        margin: "auto"
      },
      // ================= Input Area =================
      [`> textarea, ${t}-measure`]: {
        color: r,
        boxSizing: "border-box",
        minHeight: s - 2,
        margin: 0,
        padding: `${u}px ${c}px`,
        overflow: "inherit",
        overflowX: "hidden",
        overflowY: "auto",
        fontWeight: "inherit",
        fontSize: "inherit",
        fontFamily: "inherit",
        fontStyle: "inherit",
        fontVariant: "inherit",
        fontSizeAdjust: "inherit",
        fontStretch: "inherit",
        lineHeight: "inherit",
        direction: "inherit",
        letterSpacing: "inherit",
        whiteSpace: "inherit",
        textAlign: "inherit",
        verticalAlign: "top",
        wordWrap: "break-word",
        wordBreak: "inherit",
        tabSize: "inherit"
      },
      "> textarea": _({
        width: "100%",
        border: "none",
        outline: "none",
        resize: "none",
        backgroundColor: "inherit"
      }, xT(e.colorTextPlaceholder)),
      [`${t}-measure`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: -1,
        color: "transparent",
        pointerEvents: "none",
        "> span": {
          display: "inline-block",
          minHeight: "1em"
        }
      },
      // ================== Dropdown ==================
      "&-dropdown": _(_({}, nn(e)), {
        position: "absolute",
        top: -9999,
        insetInlineStart: -9999,
        zIndex: e.zIndexPopup,
        boxSizing: "border-box",
        fontSize: d,
        fontVariant: "initial",
        backgroundColor: f,
        borderRadius: p,
        outline: "none",
        boxShadow: m,
        "&-hidden": {
          display: "none"
        },
        [`${t}-dropdown-menu`]: {
          maxHeight: e.dropdownHeight,
          marginBottom: 0,
          paddingInlineStart: 0,
          overflow: "auto",
          listStyle: "none",
          outline: "none",
          "&-item": _(_({}, Fo), {
            position: "relative",
            display: "block",
            minWidth: e.controlItemWidth,
            padding: `${v}px ${l}px`,
            color: r,
            fontWeight: "normal",
            lineHeight: i,
            cursor: "pointer",
            transition: `background ${a} ease`,
            "&:hover": {
              backgroundColor: o
            },
            "&:first-child": {
              borderStartStartRadius: p,
              borderStartEndRadius: p,
              borderEndStartRadius: 0,
              borderEndEndRadius: 0
            },
            "&:last-child": {
              borderStartStartRadius: 0,
              borderStartEndRadius: 0,
              borderEndStartRadius: p,
              borderEndEndRadius: p
            },
            "&-disabled": {
              color: n,
              cursor: "not-allowed",
              "&:hover": {
                color: n,
                backgroundColor: o,
                cursor: "not-allowed"
              }
            },
            "&-selected": {
              color: r,
              fontWeight: e.fontWeightStrong,
              backgroundColor: o
            },
            "&-active": {
              backgroundColor: o
            }
          })
        }
      })
    })
  };
}, oHe = Zt("Mentions", (e) => {
  const t = gd(e);
  return [nHe(t)];
}, (e) => ({
  dropdownHeight: 250,
  controlItemWidth: 100,
  zIndexPopup: e.zIndexPopupBase + 50
}));
var UA = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function lHe() {
  return !0;
}
const rHe = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    prefix: n = "@",
    split: o = " "
  } = t, l = Array.isArray(n) ? n : [n];
  return e.split(o).map(function() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", a = null;
    return l.some((i) => r.slice(0, i.length) === i ? (a = i, !0) : !1), a !== null ? {
      prefix: a,
      value: r.slice(a.length)
    } : null;
  }).filter((r) => !!r && !!r.value);
}, aHe = () => _(_({}, YU), {
  loading: {
    type: Boolean,
    default: void 0
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onSelect: {
    type: Function
  },
  onChange: {
    type: Function
  },
  onPressenter: {
    type: Function
  },
  "onUpdate:value": {
    type: Function
  },
  notFoundContent: de.any,
  defaultValue: String,
  id: String,
  status: String
}), t$ = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AMentions",
  inheritAttrs: !1,
  props: aHe(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: l,
      expose: r
    } = t;
    var a, i, s;
    process.env.NODE_ENV !== "production" && un(!Fn(((a = n.default) === null || a === void 0 ? void 0 : a.call(n)) || []).length, "Mentions", "`Mentions.Option` is deprecated. Please use `options` instead.");
    const {
      prefixCls: c,
      renderEmpty: u,
      direction: d
    } = bt("mentions", e), [f, p] = oHe(c), m = /* @__PURE__ */ Ce(!1), v = /* @__PURE__ */ Ce(null), h = /* @__PURE__ */ Ce((s = (i = e.value) !== null && i !== void 0 ? i : e.defaultValue) !== null && s !== void 0 ? s : ""), g = Ko(), y = sl.useInject(), b = O(() => Ja(y.status, e.status));
    ZI({
      prefixCls: O(() => `${c.value}-menu`),
      mode: O(() => "vertical"),
      selectable: O(() => !1),
      onClick: () => {
      },
      validator: (R) => {
        let {
          mode: z
        } = R;
        Hn(!z || z === "vertical", "Mentions", `mode="${z}" is not supported for Mentions's Menu.`);
      }
    }), pe(() => e.value, (R) => {
      h.value = R;
    });
    const C = (R) => {
      m.value = !0, o("focus", R);
    }, w = (R) => {
      m.value = !1, o("blur", R), g.onFieldBlur();
    }, x = function() {
      for (var R = arguments.length, z = new Array(R), D = 0; D < R; D++)
        z[D] = arguments[D];
      o("select", ...z), m.value = !0;
    }, E = (R) => {
      e.value === void 0 && (h.value = R), o("update:value", R), o("change", R), g.onFieldChange();
    }, I = () => {
      const R = e.notFoundContent;
      return R !== void 0 ? R : n.notFoundContent ? n.notFoundContent() : u("Select");
    }, T = () => {
      var R;
      return Fn(((R = n.default) === null || R === void 0 ? void 0 : R.call(n)) || []).map((z) => {
        var D, F;
        return _(_({}, qz(z)), {
          label: (F = (D = z.children) === null || D === void 0 ? void 0 : D.default) === null || F === void 0 ? void 0 : F.call(D)
        });
      });
    };
    r({
      focus: () => {
        v.value.focus();
      },
      blur: () => {
        v.value.blur();
      }
    });
    const N = O(() => e.loading ? lHe : e.filterOption);
    return () => {
      const {
        disabled: R,
        getPopupContainer: z,
        rows: D = 1,
        id: F = g.id.value
      } = e, M = UA(e, ["disabled", "getPopupContainer", "rows", "id"]), {
        hasFeedback: A,
        feedbackIcon: L
      } = y, {
        class: B
      } = l, V = UA(l, ["class"]), j = pn(M, ["defaultValue", "onUpdate:value", "prefixCls"]), W = ke({
        [`${c.value}-disabled`]: R,
        [`${c.value}-focused`]: m.value,
        [`${c.value}-rtl`]: d.value === "rtl"
      }, Ll(c.value, b.value), !A && B, p.value), Y = _(_(_(_({
        prefixCls: c.value
      }, j), {
        disabled: R,
        direction: d.value,
        filterOption: N.value,
        getPopupContainer: z,
        options: e.loading ? [{
          value: "ANTDV_SEARCHING",
          disabled: !0,
          label: $(yi, {
            size: "small"
          }, null)
        }] : e.options || T(),
        class: W
      }), V), {
        rows: D,
        onChange: E,
        onSelect: x,
        onFocus: C,
        onBlur: w,
        ref: v,
        value: h.value,
        id: F
      }), U = $(eHe, Q(Q({}, Y), {}, {
        dropdownClassName: p.value
      }), {
        notFoundContent: I,
        option: n.option
      });
      return f(A ? $("div", {
        class: ke(`${c.value}-affix-wrapper`, Ll(`${c.value}-affix-wrapper`, b.value, A), B, p.value)
      }, [U, $("span", {
        class: `${c.value}-suffix`
      }, [L])]) : U);
    };
  }
}), qb = /* @__PURE__ */ le(_(_({
  compatConfig: {
    MODE: 3
  }
}, ZU), {
  name: "AMentionsOption",
  props: JU
})), iHe = _(t$, {
  Option: qb,
  getMentions: rHe,
  install: (e) => (e.component(t$.name, t$), e.component(qb.name, qb), e)
});
var sHe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
let eE;
const cHe = (e) => {
  eE = {
    x: e.pageX,
    y: e.pageY
  }, setTimeout(() => eE = null, 100);
};
OK() && vo(document.documentElement, "click", cHe, !0);
const uHe = () => ({
  prefixCls: String,
  /** @deprecated Please use `open` instead. */
  visible: {
    type: Boolean,
    default: void 0
  },
  open: {
    type: Boolean,
    default: void 0
  },
  confirmLoading: {
    type: Boolean,
    default: void 0
  },
  title: de.any,
  closable: {
    type: Boolean,
    default: void 0
  },
  closeIcon: de.any,
  onOk: Function,
  onCancel: Function,
  "onUpdate:visible": Function,
  "onUpdate:open": Function,
  onChange: Function,
  afterClose: Function,
  centered: {
    type: Boolean,
    default: void 0
  },
  width: [String, Number],
  footer: de.any,
  okText: de.any,
  okType: String,
  cancelText: de.any,
  icon: de.any,
  maskClosable: {
    type: Boolean,
    default: void 0
  },
  forceRender: {
    type: Boolean,
    default: void 0
  },
  okButtonProps: Nt(),
  cancelButtonProps: Nt(),
  destroyOnClose: {
    type: Boolean,
    default: void 0
  },
  wrapClassName: String,
  maskTransitionName: String,
  transitionName: String,
  getContainer: {
    type: [String, Function, Boolean, Object],
    default: void 0
  },
  zIndex: Number,
  bodyStyle: Nt(),
  maskStyle: Nt(),
  mask: {
    type: Boolean,
    default: void 0
  },
  keyboard: {
    type: Boolean,
    default: void 0
  },
  wrapProps: Object,
  focusTriggerAfterClose: {
    type: Boolean,
    default: void 0
  },
  modalRender: Function,
  mousePosition: Nt()
}), nl = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AModal",
  inheritAttrs: !1,
  props: sn(uHe(), {
    width: 520,
    confirmLoading: !1,
    okType: "primary"
  }),
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      attrs: l
    } = t;
    const [r] = fa("Modal"), {
      prefixCls: a,
      rootPrefixCls: i,
      direction: s,
      getPopupContainer: c
    } = bt("modal", e), [u, d] = yVe(a);
    Hn(e.visible === void 0, "Modal", "`visible` will be removed in next major version, please use `open` instead.");
    const f = (v) => {
      n("update:visible", !1), n("update:open", !1), n("cancel", v), n("change", !1);
    }, p = (v) => {
      n("ok", v);
    }, m = () => {
      var v, h;
      const {
        okText: g = (v = o.okText) === null || v === void 0 ? void 0 : v.call(o),
        okType: y,
        cancelText: b = (h = o.cancelText) === null || h === void 0 ? void 0 : h.call(o),
        confirmLoading: C
      } = e;
      return $(Ge, null, [$(ko, Q({
        onClick: f
      }, e.cancelButtonProps), {
        default: () => [b || r.value.cancelText]
      }), $(ko, Q(Q({}, Sy(y)), {}, {
        loading: C,
        onClick: p
      }, e.okButtonProps), {
        default: () => [g || r.value.okText]
      })]);
    };
    return () => {
      var v, h;
      const {
        prefixCls: g,
        visible: y,
        open: b,
        wrapClassName: C,
        centered: w,
        getContainer: x,
        closeIcon: E = (v = o.closeIcon) === null || v === void 0 ? void 0 : v.call(o),
        focusTriggerAfterClose: I = !0
      } = e, T = sHe(e, ["prefixCls", "visible", "open", "wrapClassName", "centered", "getContainer", "closeIcon", "focusTriggerAfterClose"]), P = ke(C, {
        [`${a.value}-centered`]: !!w,
        [`${a.value}-wrap-rtl`]: s.value === "rtl"
      });
      return u($(NU, Q(Q(Q({}, T), l), {}, {
        rootClassName: d.value,
        class: ke(d.value, l.class),
        getContainer: x || (c == null ? void 0 : c.value),
        prefixCls: a.value,
        wrapClassName: P,
        visible: b != null ? b : y,
        onClose: f,
        focusTriggerAfterClose: I,
        transitionName: Vl(i.value, "zoom", e.transitionName),
        maskTransitionName: Vl(i.value, "fade", e.maskTransitionName),
        mousePosition: (h = T.mousePosition) !== null && h !== void 0 ? h : eE
      }), _(_({}, o), {
        footer: o.footer || m,
        closeIcon: () => $("span", {
          class: `${a.value}-close-x`
        }, [E || $(Hl, {
          class: `${a.value}-close-icon`
        }, null)])
      })));
    };
  }
}), QU = () => {
  const e = /* @__PURE__ */ Ce(!1);
  return yt(() => {
    e.value = !0;
  }), e;
}, dHe = {
  type: {
    type: String
  },
  actionFn: Function,
  close: Function,
  autofocus: Boolean,
  prefixCls: String,
  buttonProps: Nt(),
  emitEvent: Boolean,
  quitOnNullishReturnValue: Boolean
};
function GA(e) {
  return !!(e && e.then);
}
const tE = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ActionButton",
  props: dHe,
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = /* @__PURE__ */ Ce(!1), l = /* @__PURE__ */ Ce(), r = /* @__PURE__ */ Ce(!1);
    let a;
    const i = QU();
    nt(() => {
      e.autofocus && (a = setTimeout(() => {
        var d, f;
        return (f = (d = nr(l.value)) === null || d === void 0 ? void 0 : d.focus) === null || f === void 0 ? void 0 : f.call(d);
      }));
    }), yt(() => {
      clearTimeout(a);
    });
    const s = function() {
      for (var d, f = arguments.length, p = new Array(f), m = 0; m < f; m++)
        p[m] = arguments[m];
      (d = e.close) === null || d === void 0 || d.call(e, ...p);
    }, c = (d) => {
      GA(d) && (r.value = !0, d.then(function() {
        i.value || (r.value = !1), s(...arguments), o.value = !1;
      }, (f) => (i.value || (r.value = !1), o.value = !1, Promise.reject(f))));
    }, u = (d) => {
      const {
        actionFn: f
      } = e;
      if (o.value)
        return;
      if (o.value = !0, !f) {
        s();
        return;
      }
      let p;
      if (e.emitEvent) {
        if (p = f(d), e.quitOnNullishReturnValue && !GA(p)) {
          o.value = !1, s(d);
          return;
        }
      } else if (f.length)
        p = f(e.close), o.value = !1;
      else if (p = f(), !p) {
        s();
        return;
      }
      c(p);
    };
    return () => {
      const {
        type: d,
        prefixCls: f,
        buttonProps: p
      } = e;
      return $(ko, Q(Q(Q({}, Sy(d)), {}, {
        onClick: u,
        loading: r.value,
        prefixCls: f
      }, p), {}, {
        ref: l
      }), n);
    };
  }
});
function Rd(e) {
  return typeof e == "function" ? e() : e;
}
const eG = /* @__PURE__ */ le({
  name: "ConfirmDialog",
  inheritAttrs: !1,
  props: ["icon", "onCancel", "onOk", "close", "closable", "zIndex", "afterClose", "visible", "open", "keyboard", "centered", "getContainer", "maskStyle", "okButtonProps", "cancelButtonProps", "okType", "prefixCls", "okCancel", "width", "mask", "maskClosable", "okText", "cancelText", "autoFocusButton", "transitionName", "maskTransitionName", "type", "title", "content", "direction", "rootPrefixCls", "bodyStyle", "closeIcon", "modalRender", "focusTriggerAfterClose", "wrapClassName", "confirmPrefixCls", "footer"],
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const [o] = fa("Modal");
    return process.env.NODE_ENV !== "production" && Hn(e.visible === void 0, "Modal", "`visible` is deprecated, please use `open` instead."), () => {
      const {
        icon: l,
        onCancel: r,
        onOk: a,
        close: i,
        okText: s,
        closable: c = !1,
        zIndex: u,
        afterClose: d,
        keyboard: f,
        centered: p,
        getContainer: m,
        maskStyle: v,
        okButtonProps: h,
        cancelButtonProps: g,
        okCancel: y,
        width: b = 416,
        mask: C = !0,
        maskClosable: w = !1,
        type: x,
        open: E,
        title: I,
        content: T,
        direction: P,
        closeIcon: k,
        modalRender: N,
        focusTriggerAfterClose: R,
        rootPrefixCls: z,
        bodyStyle: D,
        wrapClassName: F,
        footer: M
      } = e;
      let A = l;
      if (!l && l !== null)
        switch (x) {
          case "info":
            A = $(Dc, null, null);
            break;
          case "success":
            A = $(Za, null, null);
            break;
          case "error":
            A = $(jl, null, null);
            break;
          default:
            A = $(Qa, null, null);
        }
      const L = e.okType || "primary", B = e.prefixCls || "ant-modal", V = `${B}-confirm`, j = n.style || {}, W = y != null ? y : x === "confirm", Y = e.autoFocusButton === null ? !1 : e.autoFocusButton || "ok", U = `${B}-confirm`, te = ke(U, `${U}-${e.type}`, {
        [`${U}-rtl`]: P === "rtl"
      }, n.class), J = o.value, re = W && $(tE, {
        actionFn: r,
        close: i,
        autofocus: Y === "cancel",
        buttonProps: g,
        prefixCls: `${z}-btn`
      }, {
        default: () => [Rd(e.cancelText) || J.cancelText]
      });
      return $(nl, {
        prefixCls: B,
        class: te,
        wrapClassName: ke({
          [`${U}-centered`]: !!p
        }, F),
        onCancel: (oe) => i == null ? void 0 : i({
          triggerCancel: !0
        }, oe),
        open: E,
        title: "",
        footer: "",
        transitionName: Vl(z, "zoom", e.transitionName),
        maskTransitionName: Vl(z, "fade", e.maskTransitionName),
        mask: C,
        maskClosable: w,
        maskStyle: v,
        style: j,
        bodyStyle: D,
        width: b,
        zIndex: u,
        afterClose: d,
        keyboard: f,
        centered: p,
        getContainer: m,
        closable: c,
        closeIcon: k,
        modalRender: N,
        focusTriggerAfterClose: R
      }, {
        default: () => [$("div", {
          class: `${V}-body-wrapper`
        }, [$("div", {
          class: `${V}-body`
        }, [Rd(A), I === void 0 ? null : $("span", {
          class: `${V}-title`
        }, [Rd(I)]), $("div", {
          class: `${V}-content`
        }, [Rd(T)])]), M !== void 0 ? Rd(M) : $("div", {
          class: `${V}-btns`
        }, [re, $(tE, {
          type: L,
          actionFn: a,
          close: i,
          autofocus: Y === "ok",
          buttonProps: h,
          prefixCls: `${z}-btn`
        }, {
          default: () => [Rd(s) || (W ? J.okText : J.justOkText)]
        })])])]
      });
    };
  }
}), gu = [], Fh = (e) => {
  const t = document.createDocumentFragment();
  let n = _(_({}, pn(e, ["parentContext", "appContext"])), {
    close: r,
    open: !0
  }), o = null;
  function l() {
    o && (Bl(null, t), o = null);
    for (var c = arguments.length, u = new Array(c), d = 0; d < c; d++)
      u[d] = arguments[d];
    const f = u.some((p) => p && p.triggerCancel);
    e.onCancel && f && e.onCancel(() => {
    }, ...u.slice(1));
    for (let p = 0; p < gu.length; p++)
      if (gu[p] === r) {
        gu.splice(p, 1);
        break;
      }
  }
  function r() {
    for (var c = arguments.length, u = new Array(c), d = 0; d < c; d++)
      u[d] = arguments[d];
    n = _(_({}, n), {
      open: !1,
      afterClose: () => {
        typeof e.afterClose == "function" && e.afterClose(), l.apply(this, u);
      }
    }), n.visible && delete n.visible, a(n);
  }
  function a(c) {
    typeof c == "function" ? n = c(n) : n = _(_({}, n), c), o && D3e(o, n, t);
  }
  const i = (c) => {
    const u = gl, d = u.prefixCls, f = c.prefixCls || `${d}-modal`, p = u.iconPrefixCls, m = C7e();
    return $(Mu, Q(Q({}, u), {}, {
      prefixCls: d
    }), {
      default: () => [$(eG, Q(Q({}, c), {}, {
        rootPrefixCls: d,
        prefixCls: f,
        iconPrefixCls: p,
        locale: m,
        cancelText: c.cancelText || m.cancelText
      }), null)]
    });
  };
  function s(c) {
    const u = $(i, _({}, c));
    return u.appContext = e.parentContext || e.appContext || u.appContext, Bl(u, t), u;
  }
  return o = s(n), gu.push(r), {
    destroy: r,
    update: a
  };
};
function tG(e) {
  return _(_({}, e), {
    type: "warning"
  });
}
function nG(e) {
  return _(_({}, e), {
    type: "info"
  });
}
function oG(e) {
  return _(_({}, e), {
    type: "success"
  });
}
function lG(e) {
  return _(_({}, e), {
    type: "error"
  });
}
function rG(e) {
  return _(_({}, e), {
    type: "confirm"
  });
}
const fHe = () => ({
  config: Object,
  afterClose: Function,
  destroyAction: Function,
  open: Boolean
}), pHe = /* @__PURE__ */ le({
  name: "HookModal",
  inheritAttrs: !1,
  props: sn(fHe(), {
    config: {
      width: 520,
      okType: "primary"
    }
  }),
  setup(e, t) {
    let {
      expose: n
    } = t;
    var o;
    const l = O(() => e.open), r = O(() => e.config), {
      direction: a,
      getPrefixCls: i
    } = oS(), s = i("modal"), c = i(), u = () => {
      var m, v;
      e == null || e.afterClose(), (v = (m = r.value).afterClose) === null || v === void 0 || v.call(m);
    }, d = function() {
      e.destroyAction(...arguments);
    };
    n({
      destroy: d
    });
    const f = (o = r.value.okCancel) !== null && o !== void 0 ? o : r.value.type === "confirm", [p] = fa("Modal", rr.Modal);
    return () => $(eG, Q(Q({
      prefixCls: s,
      rootPrefixCls: c
    }, r.value), {}, {
      close: d,
      open: l.value,
      afterClose: u,
      okText: r.value.okText || (f ? p == null ? void 0 : p.value.okText : p == null ? void 0 : p.value.justOkText),
      direction: r.value.direction || a.value,
      cancelText: r.value.cancelText || (p == null ? void 0 : p.value.cancelText)
    }), null);
  }
});
let YA = 0;
const vHe = /* @__PURE__ */ le({
  name: "ElementsHolder",
  inheritAttrs: !1,
  setup(e, t) {
    let {
      expose: n
    } = t;
    const o = /* @__PURE__ */ Ce([]);
    return n({
      addModal: (r) => (o.value.push(r), o.value = o.value.slice(), () => {
        o.value = o.value.filter((a) => a !== r);
      })
    }), () => o.value.map((r) => r());
  }
});
function aG() {
  const e = /* @__PURE__ */ Ce(null), t = /* @__PURE__ */ Ce([]);
  pe(t, () => {
    t.value.length && ([...t.value].forEach((a) => {
      a();
    }), t.value = []);
  }, {
    immediate: !0
  });
  const n = (r) => function(i) {
    var s;
    YA += 1;
    const c = /* @__PURE__ */ Ce(!0), u = /* @__PURE__ */ Ce(null), d = /* @__PURE__ */ Ce(S(i)), f = /* @__PURE__ */ Ce({});
    pe(() => i, (b) => {
      h(_(_({}, /* @__PURE__ */ kn(b) ? b.value : b), f.value));
    });
    const p = function() {
      c.value = !1;
      for (var b = arguments.length, C = new Array(b), w = 0; w < b; w++)
        C[w] = arguments[w];
      const x = C.some((E) => E && E.triggerCancel);
      d.value.onCancel && x && d.value.onCancel(() => {
      }, ...C.slice(1));
    };
    let m;
    const v = () => $(pHe, {
      key: `modal-${YA}`,
      config: r(d.value),
      ref: u,
      open: c.value,
      destroyAction: p,
      afterClose: () => {
        m == null || m();
      }
    }, null);
    m = (s = e.value) === null || s === void 0 ? void 0 : s.addModal(v), m && gu.push(m);
    const h = (b) => {
      d.value = _(_({}, d.value), b);
    };
    return {
      destroy: () => {
        u.value ? p() : t.value = [...t.value, p];
      },
      update: (b) => {
        f.value = b, u.value ? h(b) : t.value = [...t.value, () => h(b)];
      }
    };
  }, o = O(() => ({
    info: n(nG),
    success: n(oG),
    error: n(lG),
    warning: n(tG),
    confirm: n(rG)
  })), l = Symbol("modalHolderKey");
  return [o.value, () => $(vHe, {
    key: l,
    ref: e
  }, null)];
}
function iG(e) {
  return Fh(tG(e));
}
nl.useModal = aG;
nl.info = function(t) {
  return Fh(nG(t));
};
nl.success = function(t) {
  return Fh(oG(t));
};
nl.error = function(t) {
  return Fh(lG(t));
};
nl.warning = iG;
nl.warn = iG;
nl.confirm = function(t) {
  return Fh(rG(t));
};
nl.destroyAll = function() {
  for (; gu.length; ) {
    const t = gu.pop();
    t && t();
  }
};
nl.install = function(e) {
  return e.component(nl.name, nl), e;
};
const sG = (e) => {
  const {
    value: t,
    formatter: n,
    precision: o,
    decimalSeparator: l,
    groupSeparator: r = "",
    prefixCls: a
  } = e;
  let i;
  if (typeof n == "function")
    i = n({
      value: t
    });
  else {
    const s = String(t), c = s.match(/^(-?)(\d*)(\.(\d+))?$/);
    if (!c)
      i = s;
    else {
      const u = c[1];
      let d = c[2] || "0", f = c[4] || "";
      d = d.replace(/\B(?=(\d{3})+(?!\d))/g, r), typeof o == "number" && (f = f.padEnd(o, "0").slice(0, o > 0 ? o : 0)), f && (f = `${l}${f}`), i = [$("span", {
        key: "int",
        class: `${a}-content-value-int`
      }, [u, d]), f && $("span", {
        key: "decimal",
        class: `${a}-content-value-decimal`
      }, [f])];
    }
  }
  return $("span", {
    class: `${a}-content-value`
  }, [i]);
};
sG.displayName = "StatisticNumber";
const mHe = (e) => {
  const {
    componentCls: t,
    marginXXS: n,
    padding: o,
    colorTextDescription: l,
    statisticTitleFontSize: r,
    colorTextHeading: a,
    statisticContentFontSize: i,
    statisticFontFamily: s
  } = e;
  return {
    [`${t}`]: _(_({}, nn(e)), {
      [`${t}-title`]: {
        marginBottom: n,
        color: l,
        fontSize: r
      },
      [`${t}-skeleton`]: {
        paddingTop: o
      },
      [`${t}-content`]: {
        color: a,
        fontSize: i,
        fontFamily: s,
        [`${t}-content-value`]: {
          display: "inline-block",
          direction: "ltr"
        },
        [`${t}-content-prefix, ${t}-content-suffix`]: {
          display: "inline-block"
        },
        [`${t}-content-prefix`]: {
          marginInlineEnd: n
        },
        [`${t}-content-suffix`]: {
          marginInlineStart: n
        }
      }
    })
  };
}, hHe = Zt("Statistic", (e) => {
  const {
    fontSizeHeading3: t,
    fontSize: n,
    fontFamily: o
  } = e, l = Vt(e, {
    statisticTitleFontSize: n,
    statisticContentFontSize: t,
    statisticFontFamily: o
  });
  return [mHe(l)];
}), cG = () => ({
  prefixCls: String,
  decimalSeparator: String,
  groupSeparator: String,
  format: String,
  value: zt([Number, String, Object]),
  valueStyle: {
    type: Object,
    default: void 0
  },
  valueRender: Fe(),
  formatter: Wn(),
  precision: Number,
  prefix: Pl(),
  suffix: Pl(),
  title: Pl(),
  loading: Qe()
}), ls = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AStatistic",
  inheritAttrs: !1,
  props: sn(cG(), {
    decimalSeparator: ".",
    groupSeparator: ",",
    loading: !1
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("statistic", e), [a, i] = hHe(l);
    return () => {
      var s, c, u, d, f, p, m;
      const {
        value: v = 0,
        valueStyle: h,
        valueRender: g
      } = e, y = l.value, b = (s = e.title) !== null && s !== void 0 ? s : (c = n.title) === null || c === void 0 ? void 0 : c.call(n), C = (u = e.prefix) !== null && u !== void 0 ? u : (d = n.prefix) === null || d === void 0 ? void 0 : d.call(n), w = (f = e.suffix) !== null && f !== void 0 ? f : (p = n.suffix) === null || p === void 0 ? void 0 : p.call(n), x = (m = e.formatter) !== null && m !== void 0 ? m : n.formatter;
      let E = $(sG, Q({
        "data-for-update": Date.now()
      }, _(_({}, e), {
        prefixCls: y,
        value: v,
        formatter: x
      })), null);
      return g && (E = g(E)), a($("div", Q(Q({}, o), {}, {
        class: [y, {
          [`${y}-rtl`]: r.value === "rtl"
        }, o.class, i.value]
      }), [b && $("div", {
        class: `${y}-title`
      }, [b]), $(Tl, {
        paragraph: !1,
        loading: e.loading
      }, {
        default: () => [$("div", {
          style: h,
          class: `${y}-content`
        }, [C && $("span", {
          class: `${y}-content-prefix`
        }, [C]), E, w && $("span", {
          class: `${y}-content-suffix`
        }, [w])])]
      })]));
    };
  }
}), gHe = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  ["M", 1e3 * 60 * 60 * 24 * 30],
  ["D", 1e3 * 60 * 60 * 24],
  ["H", 1e3 * 60 * 60],
  ["m", 1e3 * 60],
  ["s", 1e3],
  ["S", 1]
  // million seconds
];
function bHe(e, t) {
  let n = e;
  const o = /\[[^\]]*]/g, l = (t.match(o) || []).map((s) => s.slice(1, -1)), r = t.replace(o, "[]"), a = gHe.reduce((s, c) => {
    let [u, d] = c;
    if (s.includes(u)) {
      const f = Math.floor(n / d);
      return n -= f * d, s.replace(new RegExp(`${u}+`, "g"), (p) => {
        const m = p.length;
        return f.toString().padStart(m, "0");
      });
    }
    return s;
  }, r);
  let i = 0;
  return a.replace(o, () => {
    const s = l[i];
    return i += 1, s;
  });
}
function yHe(e, t) {
  const {
    format: n = ""
  } = t, o = new Date(e).getTime(), l = Date.now(), r = Math.max(o - l, 0);
  return bHe(r, n);
}
const SHe = 1e3 / 30;
function n$(e) {
  return new Date(e).getTime();
}
const CHe = () => _(_({}, cG()), {
  value: zt([Number, String, Object]),
  format: String,
  onFinish: Function,
  onChange: Function
}), wHe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AStatisticCountdown",
  props: sn(CHe(), {
    format: "HH:mm:ss"
  }),
  // emits: ['finish', 'change'],
  setup(e, t) {
    let {
      emit: n,
      slots: o
    } = t;
    const l = /* @__PURE__ */ H(), r = /* @__PURE__ */ H(), a = () => {
      const {
        value: d
      } = e;
      n$(d) >= Date.now() ? i() : s();
    }, i = () => {
      if (l.value) return;
      const d = n$(e.value);
      l.value = setInterval(() => {
        r.value.$forceUpdate(), d > Date.now() && n("change", d - Date.now()), a();
      }, SHe);
    }, s = () => {
      const {
        value: d
      } = e;
      l.value && (clearInterval(l.value), l.value = void 0, n$(d) < Date.now() && n("finish"));
    }, c = (d) => {
      let {
        value: f,
        config: p
      } = d;
      const {
        format: m
      } = e;
      return yHe(f, _(_({}, p), {
        format: m
      }));
    }, u = (d) => d;
    return nt(() => {
      a();
    }), $o(() => {
      a();
    }), yt(() => {
      s();
    }), () => {
      const d = e.value;
      return $(ls, Q({
        ref: r
      }, _(_({}, pn(e, ["onFinish", "onChange"])), {
        value: d,
        valueRender: u,
        formatter: c
      })), o);
    };
  }
});
ls.Countdown = wHe;
ls.install = function(e) {
  return e.component(ls.name, ls), e.component(ls.Countdown.name, ls.Countdown), e;
};
const $He = ls.Countdown;
var xHe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8a31.96 31.96 0 000 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, name: "arrow-left", theme: "outlined" };
function XA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      EHe(e, l, n[l]);
    });
  }
  return e;
}
function EHe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var fP = function(t, n) {
  var o = XA({}, t, n.attrs);
  return $(cn, XA({}, o, {
    icon: xHe
  }), null);
};
fP.displayName = "ArrowLeftOutlined";
fP.inheritAttrs = !1;
var OHe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M869 487.8L491.2 159.9c-2.9-2.5-6.6-3.9-10.5-3.9h-88.5c-7.4 0-10.8 9.2-5.2 14l350.2 304H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h585.1L386.9 854c-5.6 4.9-2.2 14 5.2 14h91.5c1.9 0 3.8-.7 5.2-2L869 536.2a32.07 32.07 0 000-48.4z" } }] }, name: "arrow-right", theme: "outlined" };
function qA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      _He(e, l, n[l]);
    });
  }
  return e;
}
function _He(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var pP = function(t, n) {
  var o = qA({}, t, n.attrs);
  return $(cn, qA({}, o, {
    icon: OHe
  }), null);
};
pP.displayName = "ArrowRightOutlined";
pP.inheritAttrs = !1;
var IHe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const THe = {
  border: 0,
  background: "transparent",
  padding: 0,
  lineHeight: "inherit",
  display: "inline-block"
}, Ky = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "TransButton",
  inheritAttrs: !1,
  props: {
    noStyle: {
      type: Boolean,
      default: void 0
    },
    onClick: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: l,
      expose: r
    } = t;
    const a = /* @__PURE__ */ Ce(), i = (f) => {
      const {
        keyCode: p
      } = f;
      p === ot.ENTER && f.preventDefault();
    }, s = (f) => {
      const {
        keyCode: p
      } = f;
      p === ot.ENTER && o("click", f);
    }, c = (f) => {
      o("click", f);
    }, u = () => {
      a.value && a.value.focus();
    }, d = () => {
      a.value && a.value.blur();
    };
    return nt(() => {
      e.autofocus && u();
    }), r({
      focus: u,
      blur: d
    }), () => {
      var f;
      const {
        noStyle: p,
        disabled: m
      } = e, v = IHe(e, ["noStyle", "disabled"]);
      let h = {};
      return p || (h = _({}, THe)), m && (h.pointerEvents = "none"), $("div", Q(Q(Q({
        role: "button",
        tabindex: 0,
        ref: a
      }, v), l), {}, {
        onClick: c,
        onKeydown: i,
        onKeyup: s,
        style: _(_({}, h), l.style || {})
      }), [(f = n.default) === null || f === void 0 ? void 0 : f.call(n)]);
    };
  }
}), PHe = {
  small: 8,
  middle: 16,
  large: 24
}, kHe = () => ({
  prefixCls: String,
  size: {
    type: [String, Number, Array]
  },
  direction: de.oneOf($l("horizontal", "vertical")).def("horizontal"),
  align: de.oneOf($l("start", "end", "center", "baseline")),
  wrap: Qe()
});
function NHe(e) {
  return typeof e == "string" ? PHe[e] : e || 0;
}
const Tf = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ASpace",
  inheritAttrs: !1,
  props: kHe(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      space: r,
      direction: a
    } = bt("space", e), [i, s] = Bj(l), c = IK(), u = O(() => {
      var g, y, b;
      return (b = (g = e.size) !== null && g !== void 0 ? g : (y = r == null ? void 0 : r.value) === null || y === void 0 ? void 0 : y.size) !== null && b !== void 0 ? b : "small";
    }), d = /* @__PURE__ */ H(), f = /* @__PURE__ */ H();
    pe(u, () => {
      [d.value, f.value] = (Array.isArray(u.value) ? u.value : [u.value, u.value]).map((g) => NHe(g));
    }, {
      immediate: !0
    });
    const p = O(() => e.align === void 0 && e.direction === "horizontal" ? "center" : e.align), m = O(() => ke(l.value, s.value, `${l.value}-${e.direction}`, {
      [`${l.value}-rtl`]: a.value === "rtl",
      [`${l.value}-align-${p.value}`]: p.value
    })), v = O(() => a.value === "rtl" ? "marginLeft" : "marginRight"), h = O(() => {
      const g = {};
      return c.value && (g.columnGap = `${d.value}px`, g.rowGap = `${f.value}px`), _(_({}, g), e.wrap && {
        flexWrap: "wrap",
        marginBottom: `${-f.value}px`
      });
    });
    return () => {
      var g, y;
      const {
        wrap: b,
        direction: C = "horizontal"
      } = e, w = (g = n.default) === null || g === void 0 ? void 0 : g.call(n), x = mo(w), E = x.length;
      if (E === 0)
        return null;
      const I = (y = n.split) === null || y === void 0 ? void 0 : y.call(n), T = `${l.value}-item`, P = d.value, k = E - 1;
      return $("div", Q(Q({}, o), {}, {
        class: [m.value, o.class],
        style: [h.value, o.style]
      }), [x.map((N, R) => {
        let z = w.indexOf(N);
        z === -1 && (z = `$$space-${R}`);
        let D = {};
        return c.value || (C === "vertical" ? R < k && (D = {
          marginBottom: `${P / (I ? 2 : 1)}px`
        }) : D = _(_({}, R < k && {
          [v.value]: `${P / (I ? 2 : 1)}px`
        }), b && {
          paddingBottom: `${f.value}px`
        })), i($(Ge, {
          key: z
        }, [$("div", {
          class: T,
          style: D
        }, [N]), R < k && I && $("span", {
          class: `${T}-split`,
          style: D
        }, [I])]));
      })]);
    };
  }
});
Tf.Compact = my;
Tf.install = function(e) {
  return e.component(Tf.name, Tf), e.component(my.name, my), e;
};
const MHe = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e;
  return {
    [t]: _(_({}, nn(e)), {
      position: "relative",
      padding: `${e.pageHeaderPaddingVertical}px ${e.pageHeaderPadding}px`,
      backgroundColor: e.colorBgContainer,
      [`&${t}-ghost`]: {
        backgroundColor: e.pageHeaderGhostBg
      },
      "&.has-footer": {
        paddingBottom: 0
      },
      [`${t}-back`]: {
        marginRight: e.marginMD,
        fontSize: e.fontSizeLG,
        lineHeight: 1,
        "&-button": _(_({}, cS(e)), {
          color: e.pageHeaderBackColor,
          cursor: "pointer"
        })
      },
      [`${n}-divider-vertical`]: {
        height: "14px",
        margin: `0 ${e.marginSM}`,
        verticalAlign: "middle"
      },
      [`${n}-breadcrumb + &-heading`]: {
        marginTop: e.marginXS
      },
      [`${t}-heading`]: {
        display: "flex",
        justifyContent: "space-between",
        "&-left": {
          display: "flex",
          alignItems: "center",
          margin: `${e.marginXS / 2}px 0`,
          overflow: "hidden"
        },
        "&-title": _({
          marginRight: e.marginSM,
          marginBottom: 0,
          color: e.colorTextHeading,
          fontWeight: 600,
          fontSize: e.pageHeaderHeadingTitle,
          lineHeight: `${e.controlHeight}px`
        }, Fo),
        [`${n}-avatar`]: {
          marginRight: e.marginSM
        },
        "&-sub-title": _({
          marginRight: e.marginSM,
          color: e.colorTextDescription,
          fontSize: e.pageHeaderHeadingSubTitle,
          lineHeight: e.lineHeight
        }, Fo),
        "&-extra": {
          margin: `${e.marginXS / 2}px 0`,
          whiteSpace: "nowrap",
          "> *": {
            marginLeft: e.marginSM,
            whiteSpace: "unset"
          },
          "> *:first-child": {
            marginLeft: 0
          }
        }
      },
      [`${t}-content`]: {
        paddingTop: e.pageHeaderContentPaddingVertical
      },
      [`${t}-footer`]: {
        marginTop: e.marginMD,
        [`${n}-tabs`]: {
          [`> ${n}-tabs-nav`]: {
            margin: 0,
            "&::before": {
              border: "none"
            }
          },
          [`${n}-tabs-tab`]: {
            paddingTop: e.paddingXS,
            paddingBottom: e.paddingXS,
            fontSize: e.pageHeaderTabFontSize
          }
        }
      },
      [`${t}-compact ${t}-heading`]: {
        flexWrap: "wrap"
      },
      // rtl style
      [`&${e.componentCls}-rtl`]: {
        direction: "rtl"
      }
    })
  };
}, AHe = Zt("PageHeader", (e) => {
  const t = Vt(e, {
    pageHeaderPadding: e.paddingLG,
    pageHeaderPaddingVertical: e.paddingMD,
    pageHeaderPaddingBreadcrumb: e.paddingSM,
    pageHeaderContentPaddingVertical: e.paddingSM,
    pageHeaderBackColor: e.colorTextBase,
    pageHeaderGhostBg: "transparent",
    pageHeaderHeadingTitle: e.fontSizeHeading4,
    pageHeaderHeadingSubTitle: e.fontSize,
    pageHeaderTabFontSize: e.fontSizeLG
  });
  return [MHe(t)];
}), RHe = () => ({
  backIcon: Pl(),
  prefixCls: String,
  title: Pl(),
  subTitle: Pl(),
  breadcrumb: de.object,
  tags: Pl(),
  footer: Pl(),
  extra: Pl(),
  avatar: Nt(),
  ghost: {
    type: Boolean,
    default: void 0
  },
  onBack: Function
}), DHe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "APageHeader",
  inheritAttrs: !1,
  props: RHe(),
  // emits: ['back'],
  slots: Object,
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      attrs: l
    } = t;
    const {
      prefixCls: r,
      direction: a,
      pageHeader: i
    } = bt("page-header", e), [s, c] = AHe(r), u = /* @__PURE__ */ Ce(!1), d = QU(), f = (C) => {
      let {
        width: w
      } = C;
      d.value || (u.value = w < 768);
    }, p = O(() => {
      var C, w, x;
      return (x = (C = e.ghost) !== null && C !== void 0 ? C : (w = i == null ? void 0 : i.value) === null || w === void 0 ? void 0 : w.ghost) !== null && x !== void 0 ? x : !0;
    }), m = () => {
      var C, w, x;
      return (x = (C = e.backIcon) !== null && C !== void 0 ? C : (w = o.backIcon) === null || w === void 0 ? void 0 : w.call(o)) !== null && x !== void 0 ? x : a.value === "rtl" ? $(pP, null, null) : $(fP, null, null);
    }, v = (C) => !C || !e.onBack ? null : $(sd, {
      componentName: "PageHeader",
      children: (w) => {
        let {
          back: x
        } = w;
        return $("div", {
          class: `${r.value}-back`
        }, [$(Ky, {
          onClick: (E) => {
            n("back", E);
          },
          class: `${r.value}-back-button`,
          "aria-label": x
        }, {
          default: () => [C]
        })]);
      }
    }, null), h = () => {
      var C;
      return e.breadcrumb ? $(ku, e.breadcrumb, null) : (C = o.breadcrumb) === null || C === void 0 ? void 0 : C.call(o);
    }, g = () => {
      var C, w, x, E, I, T, P, k, N;
      const {
        avatar: R
      } = e, z = (C = e.title) !== null && C !== void 0 ? C : (w = o.title) === null || w === void 0 ? void 0 : w.call(o), D = (x = e.subTitle) !== null && x !== void 0 ? x : (E = o.subTitle) === null || E === void 0 ? void 0 : E.call(o), F = (I = e.tags) !== null && I !== void 0 ? I : (T = o.tags) === null || T === void 0 ? void 0 : T.call(o), M = (P = e.extra) !== null && P !== void 0 ? P : (k = o.extra) === null || k === void 0 ? void 0 : k.call(o), A = `${r.value}-heading`, L = z || D || F || M;
      if (!L)
        return null;
      const B = m(), V = v(B);
      return $("div", {
        class: A
      }, [(V || R || L) && $("div", {
        class: `${A}-left`
      }, [V, R ? $(Pu, R, null) : (N = o.avatar) === null || N === void 0 ? void 0 : N.call(o), z && $("span", {
        class: `${A}-title`,
        title: typeof z == "string" ? z : void 0
      }, [z]), D && $("span", {
        class: `${A}-sub-title`,
        title: typeof D == "string" ? D : void 0
      }, [D]), F && $("span", {
        class: `${A}-tags`
      }, [F])]), M && $("span", {
        class: `${A}-extra`
      }, [$(Tf, null, {
        default: () => [M]
      })])]);
    }, y = () => {
      var C, w;
      const x = (C = e.footer) !== null && C !== void 0 ? C : mo((w = o.footer) === null || w === void 0 ? void 0 : w.call(o));
      return PPe(x) ? null : $("div", {
        class: `${r.value}-footer`
      }, [x]);
    }, b = (C) => $("div", {
      class: `${r.value}-content`
    }, [C]);
    return () => {
      var C, w;
      const x = ((C = e.breadcrumb) === null || C === void 0 ? void 0 : C.routes) || o.breadcrumb, E = e.footer || o.footer, I = Fn((w = o.default) === null || w === void 0 ? void 0 : w.call(o)), T = ke(r.value, {
        "has-breadcrumb": x,
        "has-footer": E,
        [`${r.value}-ghost`]: p.value,
        [`${r.value}-rtl`]: a.value === "rtl",
        [`${r.value}-compact`]: u.value
      }, l.class, c.value);
      return s($(ca, {
        onResize: f
      }, {
        default: () => [$("div", Q(Q({}, l), {}, {
          class: T
        }), [h(), g(), I.length ? b(I) : null, y()])]
      }));
    };
  }
}), LHe = po(DHe), BHe = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    zIndexPopup: o,
    colorText: l,
    colorWarning: r,
    marginXS: a,
    fontSize: i,
    fontWeightStrong: s,
    lineHeight: c
  } = e;
  return {
    [t]: {
      zIndex: o,
      [`${t}-inner-content`]: {
        color: l
      },
      [`${t}-message`]: {
        position: "relative",
        marginBottom: a,
        color: l,
        fontSize: i,
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${t}-message-icon ${n}`]: {
          color: r,
          fontSize: i,
          flex: "none",
          lineHeight: 1,
          paddingTop: (Math.round(i * c) - i) / 2
        },
        "&-title": {
          flex: "auto",
          marginInlineStart: a
        },
        "&-title-only": {
          fontWeight: s
        }
      },
      [`${t}-description`]: {
        position: "relative",
        marginInlineStart: i + a,
        marginBottom: a,
        color: l,
        fontSize: i
      },
      [`${t}-buttons`]: {
        textAlign: "end",
        button: {
          marginInlineStart: a
        }
      }
    }
  };
}, FHe = Zt("Popconfirm", (e) => BHe(e), (e) => {
  const {
    zIndexPopupBase: t
  } = e;
  return {
    zIndexPopup: t + 60
  };
});
var VHe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const zHe = () => _(_({}, WI()), {
  prefixCls: String,
  content: Wn(),
  title: Wn(),
  description: Wn(),
  okType: At("primary"),
  disabled: {
    type: Boolean,
    default: !1
  },
  okText: Wn(),
  cancelText: Wn(),
  icon: Wn(),
  okButtonProps: Nt(),
  cancelButtonProps: Nt(),
  showCancel: {
    type: Boolean,
    default: !0
  },
  onConfirm: Function,
  onCancel: Function
}), HHe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "APopconfirm",
  inheritAttrs: !1,
  props: sn(zHe(), _(_({}, Kj()), {
    trigger: "click",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: !1,
    autoAdjustOverflow: !0,
    okType: "primary",
    disabled: !1
  })),
  slots: Object,
  // emits: ['update:open', 'visibleChange'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      expose: l,
      attrs: r
    } = t;
    const a = /* @__PURE__ */ H();
    Hn(e.visible === void 0, "Popconfirm", "`visible` will be removed in next major version, please use `open` instead."), l({
      getPopupDomNode: () => {
        var x, E;
        return (E = (x = a.value) === null || x === void 0 ? void 0 : x.getPopupDomNode) === null || E === void 0 ? void 0 : E.call(x);
      }
    });
    const [i, s] = ro(!1, {
      value: /* @__PURE__ */ ft(e, "open")
    }), c = (x, E) => {
      e.open === void 0 && s(x), o("update:open", x), o("openChange", x, E);
    }, u = (x) => {
      c(!1, x);
    }, d = (x) => {
      var E;
      return (E = e.onConfirm) === null || E === void 0 ? void 0 : E.call(e, x);
    }, f = (x) => {
      var E;
      c(!1, x), (E = e.onCancel) === null || E === void 0 || E.call(e, x);
    }, p = (x) => {
      x.keyCode === ot.ESC && i && c(!1, x);
    }, m = (x) => {
      const {
        disabled: E
      } = e;
      E || c(x);
    }, {
      prefixCls: v,
      getPrefixCls: h
    } = bt("popconfirm", e), g = O(() => h()), y = O(() => h("btn")), [b] = FHe(v), [C] = fa("Popconfirm", rr.Popconfirm), w = () => {
      var x, E, I, T, P;
      const {
        okButtonProps: k,
        cancelButtonProps: N,
        title: R = (x = n.title) === null || x === void 0 ? void 0 : x.call(n),
        description: z = (E = n.description) === null || E === void 0 ? void 0 : E.call(n),
        cancelText: D = (I = n.cancel) === null || I === void 0 ? void 0 : I.call(n),
        okText: F = (T = n.okText) === null || T === void 0 ? void 0 : T.call(n),
        okType: M,
        icon: A = ((P = n.icon) === null || P === void 0 ? void 0 : P.call(n)) || $(Qa, null, null),
        showCancel: L = !0
      } = e, {
        cancelButton: B,
        okButton: V
      } = n, j = _({
        onClick: f,
        size: "small"
      }, N), W = _(_(_({
        onClick: d
      }, Sy(M)), {
        size: "small"
      }), k);
      return $("div", {
        class: `${v.value}-inner-content`
      }, [$("div", {
        class: `${v.value}-message`
      }, [A && $("span", {
        class: `${v.value}-message-icon`
      }, [A]), $("div", {
        class: [`${v.value}-message-title`, {
          [`${v.value}-message-title-only`]: !!z
        }]
      }, [R])]), z && $("div", {
        class: `${v.value}-description`
      }, [z]), $("div", {
        class: `${v.value}-buttons`
      }, [L ? B ? B(j) : $(ko, j, {
        default: () => [D || C.value.cancelText]
      }) : null, V ? V(W) : $(tE, {
        buttonProps: _(_({
          size: "small"
        }, Sy(M)), k),
        actionFn: d,
        close: u,
        prefixCls: y.value,
        quitOnNullishReturnValue: !0,
        emitEvent: !0
      }, {
        default: () => [F || C.value.okText]
      })])]);
    };
    return () => {
      var x;
      const {
        placement: E,
        overlayClassName: I,
        trigger: T = "click"
      } = e, P = VHe(e, ["placement", "overlayClassName", "trigger"]), k = pn(P, ["title", "content", "cancelText", "okText", "onUpdate:open", "onConfirm", "onCancel", "prefixCls"]), N = ke(v.value, I);
      return b($(YI, Q(Q(Q({}, k), r), {}, {
        trigger: T,
        placement: E,
        onOpenChange: m,
        open: i.value,
        overlayClassName: N,
        transitionName: Vl(g.value, "zoom-big", e.transitionName),
        ref: a,
        "data-popover-inject": !0
      }), {
        default: () => [R3e(((x = n.default) === null || x === void 0 ? void 0 : x.call(n)) || [], {
          onKeydown: (R) => {
            p(R);
          }
        }, !1)],
        content: w
      }));
    };
  }
}), jHe = po(HHe), WHe = ["normal", "exception", "active", "success"], QS = () => ({
  prefixCls: String,
  type: At(),
  percent: Number,
  format: Fe(),
  status: At(),
  showInfo: Qe(),
  strokeWidth: Number,
  strokeLinecap: At(),
  strokeColor: Wn(),
  trailColor: String,
  /** @deprecated Use `size` instead */
  width: Number,
  success: Nt(),
  gapDegree: Number,
  gapPosition: At(),
  size: zt([String, Number, Array]),
  steps: Number,
  /** @deprecated Use `success` instead */
  successPercent: Number,
  title: String,
  progressStatus: At()
});
function Au(e) {
  return !e || e < 0 ? 0 : e > 100 ? 100 : e;
}
function Uy(e) {
  let {
    success: t,
    successPercent: n
  } = e, o = n;
  return t && "progress" in t && (un(!1, "Progress", "`success.progress` is deprecated. Please use `success.percent` instead."), o = t.progress), t && "percent" in t && (o = t.percent), o;
}
function KHe(e) {
  let {
    percent: t,
    success: n,
    successPercent: o
  } = e;
  const l = Au(Uy({
    success: n,
    successPercent: o
  }));
  return [l, Au(Au(t) - l)];
}
function UHe(e) {
  let {
    success: t = {},
    strokeColor: n
  } = e;
  const {
    strokeColor: o
  } = t;
  return [o || Sf.green, n || null];
}
const eC = (e, t, n) => {
  var o, l, r, a;
  let i = -1, s = -1;
  if (t === "step") {
    const c = n.steps, u = n.strokeWidth;
    typeof e == "string" || typeof e == "undefined" ? (i = e === "small" ? 2 : 14, s = u != null ? u : 8) : typeof e == "number" ? [i, s] = [e, e] : [i = 14, s = 8] = e, i *= c;
  } else if (t === "line") {
    const c = n == null ? void 0 : n.strokeWidth;
    typeof e == "string" || typeof e == "undefined" ? s = c || (e === "small" ? 6 : 8) : typeof e == "number" ? [i, s] = [e, e] : [i = -1, s = 8] = e;
  } else (t === "circle" || t === "dashboard") && (typeof e == "string" || typeof e == "undefined" ? [i, s] = e === "small" ? [60, 60] : [120, 120] : typeof e == "number" ? [i, s] = [e, e] : (process.env.NODE_ENV !== "production" && un(!1, "Progress", 'Type "circle" and "dashboard" do not accept array as `size`, please use number or preset size instead.'), i = (l = (o = e[0]) !== null && o !== void 0 ? o : e[1]) !== null && l !== void 0 ? l : 120, s = (a = (r = e[0]) !== null && r !== void 0 ? r : e[1]) !== null && a !== void 0 ? a : 120));
  return {
    width: i,
    height: s
  };
};
var GHe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const YHe = () => _(_({}, QS()), {
  strokeColor: Wn(),
  direction: At()
}), XHe = (e) => {
  let t = [];
  return Object.keys(e).forEach((n) => {
    const o = parseFloat(n.replace(/%/g, ""));
    isNaN(o) || t.push({
      key: o,
      value: e[n]
    });
  }), t = t.sort((n, o) => n.key - o.key), t.map((n) => {
    let {
      key: o,
      value: l
    } = n;
    return `${l} ${o}%`;
  }).join(", ");
}, qHe = (e, t) => {
  const {
    from: n = Sf.blue,
    to: o = Sf.blue,
    direction: l = t === "rtl" ? "to left" : "to right"
  } = e, r = GHe(e, ["from", "to", "direction"]);
  if (Object.keys(r).length !== 0) {
    const a = XHe(r);
    return {
      backgroundImage: `linear-gradient(${l}, ${a})`
    };
  }
  return {
    backgroundImage: `linear-gradient(${l}, ${n}, ${o})`
  };
}, JHe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ProgressLine",
  inheritAttrs: !1,
  props: YHe(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const l = O(() => {
      const {
        strokeColor: p,
        direction: m
      } = e;
      return p && typeof p != "string" ? qHe(p, m) : {
        backgroundColor: p
      };
    }), r = O(() => e.strokeLinecap === "square" || e.strokeLinecap === "butt" ? 0 : void 0), a = O(() => e.trailColor ? {
      backgroundColor: e.trailColor
    } : void 0), i = O(() => {
      var p;
      return (p = e.size) !== null && p !== void 0 ? p : [-1, e.strokeWidth || (e.size === "small" ? 6 : 8)];
    }), s = O(() => eC(i.value, "line", {
      strokeWidth: e.strokeWidth
    }));
    process.env.NODE_ENV !== "production" && un("strokeWidth" in e, "Progress", "`strokeWidth` is deprecated. Please use `size` instead.");
    const c = O(() => {
      const {
        percent: p
      } = e;
      return _({
        width: `${Au(p)}%`,
        height: `${s.value.height}px`,
        borderRadius: r.value
      }, l.value);
    }), u = O(() => Uy(e)), d = O(() => {
      const {
        success: p
      } = e;
      return {
        width: `${Au(u.value)}%`,
        height: `${s.value.height}px`,
        borderRadius: r.value,
        backgroundColor: p == null ? void 0 : p.strokeColor
      };
    }), f = {
      width: s.value.width < 0 ? "100%" : s.value.width,
      height: `${s.value.height}px`
    };
    return () => {
      var p;
      return $(Ge, null, [$("div", Q(Q({}, o), {}, {
        class: [`${e.prefixCls}-outer`, o.class],
        style: [o.style, f]
      }), [$("div", {
        class: `${e.prefixCls}-inner`,
        style: a.value
      }, [$("div", {
        class: `${e.prefixCls}-bg`,
        style: c.value
      }, null), u.value !== void 0 ? $("div", {
        class: `${e.prefixCls}-success-bg`,
        style: d.value
      }, null) : null])]), (p = n.default) === null || p === void 0 ? void 0 : p.call(n)]);
    };
  }
}), ZHe = {
  percent: 0,
  prefixCls: "vc-progress",
  strokeColor: "#2db7f5",
  strokeLinecap: "round",
  strokeWidth: 1,
  trailColor: "#D9D9D9",
  trailWidth: 1
}, QHe = (e) => {
  const t = /* @__PURE__ */ H(null);
  return $o(() => {
    const n = Date.now();
    let o = !1;
    e.value.forEach((l) => {
      const r = (l == null ? void 0 : l.$el) || l;
      if (!r)
        return;
      o = !0;
      const a = r.style;
      a.transitionDuration = ".3s, .3s, .3s, .06s", t.value && n - t.value < 100 && (a.transitionDuration = "0s, 0s");
    }), o && (t.value = Date.now());
  }), e;
}, eje = {
  gapDegree: Number,
  gapPosition: {
    type: String
  },
  percent: {
    type: [Array, Number]
  },
  prefixCls: String,
  strokeColor: {
    type: [Object, String, Array]
  },
  strokeLinecap: {
    type: String
  },
  strokeWidth: Number,
  trailColor: String,
  trailWidth: Number,
  transition: String
};
var tje = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
let JA = 0;
function ZA(e) {
  return +e.replace("%", "");
}
function QA(e) {
  return Array.isArray(e) ? e : [e];
}
function eR(e, t, n, o) {
  let l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, r = arguments.length > 5 ? arguments[5] : void 0;
  const a = 50 - o / 2;
  let i = 0, s = -a, c = 0, u = -2 * a;
  switch (r) {
    case "left":
      i = -a, s = 0, c = 2 * a, u = 0;
      break;
    case "right":
      i = a, s = 0, c = -2 * a, u = 0;
      break;
    case "bottom":
      s = a, u = 2 * a;
      break;
  }
  const d = `M 50,50 m ${i},${s}
   a ${a},${a} 0 1 1 ${c},${-u}
   a ${a},${a} 0 1 1 ${-c},${u}`, f = Math.PI * 2 * a, p = {
    stroke: n,
    strokeDasharray: `${t / 100 * (f - l)}px ${f}px`,
    strokeDashoffset: `-${l / 2 + e / 100 * (f - l)}px`,
    transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s"
    // eslint-disable-line
  };
  return {
    pathString: d,
    pathStyle: p
  };
}
const nje = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "VCCircle",
  props: sn(eje, ZHe),
  setup(e) {
    JA += 1;
    const t = /* @__PURE__ */ H(JA), n = O(() => QA(e.percent)), o = O(() => QA(e.strokeColor)), [l, r] = IT();
    QHe(r);
    const a = () => {
      const {
        prefixCls: i,
        strokeWidth: s,
        strokeLinecap: c,
        gapDegree: u,
        gapPosition: d
      } = e;
      let f = 0;
      return n.value.map((p, m) => {
        const v = o.value[m] || o.value[o.value.length - 1], h = Object.prototype.toString.call(v) === "[object Object]" ? `url(#${i}-gradient-${t.value})` : "", {
          pathString: g,
          pathStyle: y
        } = eR(f, p, v, s, u, d);
        f += p;
        const b = {
          key: m,
          d: g,
          stroke: h,
          "stroke-linecap": c,
          "stroke-width": s,
          opacity: p === 0 ? 0 : 1,
          "fill-opacity": "0",
          class: `${i}-circle-path`,
          style: y
        };
        return $("path", Q({
          ref: l(m)
        }, b), null);
      });
    };
    return () => {
      const {
        prefixCls: i,
        strokeWidth: s,
        trailWidth: c,
        gapDegree: u,
        gapPosition: d,
        trailColor: f,
        strokeLinecap: p,
        strokeColor: m
      } = e, v = tje(e, ["prefixCls", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "strokeColor"]), {
        pathString: h,
        pathStyle: g
      } = eR(0, 100, f, s, u, d);
      delete v.percent;
      const y = o.value.find((C) => Object.prototype.toString.call(C) === "[object Object]"), b = {
        d: h,
        stroke: f,
        "stroke-linecap": p,
        "stroke-width": c || s,
        "fill-opacity": "0",
        class: `${i}-circle-trail`,
        style: g
      };
      return $("svg", Q({
        class: `${i}-circle`,
        viewBox: "0 0 100 100"
      }, v), [y && $("defs", null, [$("linearGradient", {
        id: `${i}-gradient-${t.value}`,
        x1: "100%",
        y1: "0%",
        x2: "0%",
        y2: "0%"
      }, [Object.keys(y).sort((C, w) => ZA(C) - ZA(w)).map((C, w) => $("stop", {
        key: w,
        offset: C,
        "stop-color": y[C]
      }, null))])]), $("path", b, null), a().reverse()]);
    };
  }
}), oje = () => _(_({}, QS()), {
  strokeColor: Wn()
}), lje = 3, rje = (e) => lje / e * 100, aje = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ProgressCircle",
  inheritAttrs: !1,
  props: sn(oje(), {
    trailColor: null
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const l = O(() => {
      var v;
      return (v = e.width) !== null && v !== void 0 ? v : 120;
    }), r = O(() => {
      var v;
      return (v = e.size) !== null && v !== void 0 ? v : [l.value, l.value];
    }), a = O(() => eC(r.value, "circle")), i = O(() => {
      if (e.gapDegree || e.gapDegree === 0)
        return e.gapDegree;
      if (e.type === "dashboard")
        return 75;
    }), s = O(() => ({
      width: `${a.value.width}px`,
      height: `${a.value.height}px`,
      fontSize: `${a.value.width * 0.15 + 6}px`
    })), c = O(() => {
      var v;
      return (v = e.strokeWidth) !== null && v !== void 0 ? v : Math.max(rje(a.value.width), 6);
    }), u = O(() => e.gapPosition || e.type === "dashboard" && "bottom" || void 0), d = O(() => KHe(e)), f = O(() => Object.prototype.toString.call(e.strokeColor) === "[object Object]"), p = O(() => UHe({
      success: e.success,
      strokeColor: e.strokeColor
    })), m = O(() => ({
      [`${e.prefixCls}-inner`]: !0,
      [`${e.prefixCls}-circle-gradient`]: f.value
    }));
    return () => {
      var v;
      const h = $(nje, {
        percent: d.value,
        strokeWidth: c.value,
        trailWidth: c.value,
        strokeColor: p.value,
        strokeLinecap: e.strokeLinecap,
        trailColor: e.trailColor,
        prefixCls: e.prefixCls,
        gapDegree: i.value,
        gapPosition: u.value
      }, null);
      return $("div", Q(Q({}, o), {}, {
        class: [m.value, o.class],
        style: [o.style, s.value]
      }), [a.value.width <= 20 ? $(Sr, null, {
        default: () => [$("span", null, [h])],
        title: n.default
      }) : $(Ge, null, [h, (v = n.default) === null || v === void 0 ? void 0 : v.call(n)])]);
    };
  }
}), ije = () => _(_({}, QS()), {
  steps: Number,
  strokeColor: zt(),
  trailColor: String
}), sje = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Steps",
  props: ije(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = O(() => Math.round(e.steps * ((e.percent || 0) / 100))), l = O(() => {
      var i;
      return (i = e.size) !== null && i !== void 0 ? i : [e.size === "small" ? 2 : 14, e.strokeWidth || 8];
    }), r = O(() => eC(l.value, "step", {
      steps: e.steps,
      strokeWidth: e.strokeWidth || 8
    })), a = O(() => {
      const {
        steps: i,
        strokeColor: s,
        trailColor: c,
        prefixCls: u
      } = e, d = [];
      for (let f = 0; f < i; f += 1) {
        const p = Array.isArray(s) ? s[f] : s, m = {
          [`${u}-steps-item`]: !0,
          [`${u}-steps-item-active`]: f <= o.value - 1
        };
        d.push($("div", {
          key: f,
          class: m,
          style: {
            backgroundColor: f <= o.value - 1 ? p : c,
            width: `${r.value.width / i}px`,
            height: `${r.value.height}px`
          }
        }, null));
      }
      return d;
    });
    return () => {
      var i;
      return $("div", {
        class: `${e.prefixCls}-steps-outer`
      }, [a.value, (i = n.default) === null || i === void 0 ? void 0 : i.call(n)]);
    };
  }
}), cje = new mn("antProgressActive", {
  "0%": {
    transform: "translateX(-100%) scaleX(0)",
    opacity: 0.1
  },
  "20%": {
    transform: "translateX(-100%) scaleX(0)",
    opacity: 0.5
  },
  to: {
    transform: "translateX(0) scaleX(1)",
    opacity: 0
  }
}), uje = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: _(_({}, nn(e)), {
      display: "inline-block",
      "&-rtl": {
        direction: "rtl"
      },
      "&-line": {
        position: "relative",
        width: "100%",
        fontSize: e.fontSize,
        marginInlineEnd: e.marginXS,
        marginBottom: e.marginXS
      },
      [`${t}-outer`]: {
        display: "inline-block",
        width: "100%"
      },
      [`&${t}-show-info`]: {
        [`${t}-outer`]: {
          marginInlineEnd: `calc(-2em - ${e.marginXS}px)`,
          paddingInlineEnd: `calc(2em + ${e.paddingXS}px)`
        }
      },
      [`${t}-inner`]: {
        position: "relative",
        display: "inline-block",
        width: "100%",
        overflow: "hidden",
        verticalAlign: "middle",
        backgroundColor: e.progressRemainingColor,
        borderRadius: e.progressLineRadius
      },
      [`${t}-inner:not(${t}-circle-gradient)`]: {
        [`${t}-circle-path`]: {
          stroke: e.colorInfo
        }
      },
      [`${t}-success-bg, ${t}-bg`]: {
        position: "relative",
        backgroundColor: e.colorInfo,
        borderRadius: e.progressLineRadius,
        transition: `all ${e.motionDurationSlow} ${e.motionEaseInOutCirc}`
      },
      [`${t}-success-bg`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        backgroundColor: e.colorSuccess
      },
      [`${t}-text`]: {
        display: "inline-block",
        width: "2em",
        marginInlineStart: e.marginXS,
        color: e.progressInfoTextColor,
        lineHeight: 1,
        whiteSpace: "nowrap",
        textAlign: "start",
        verticalAlign: "middle",
        wordBreak: "normal",
        [n]: {
          fontSize: e.fontSize
        }
      },
      [`&${t}-status-active`]: {
        [`${t}-bg::before`]: {
          position: "absolute",
          inset: 0,
          backgroundColor: e.colorBgContainer,
          borderRadius: e.progressLineRadius,
          opacity: 0,
          animationName: cje,
          animationDuration: e.progressActiveMotionDuration,
          animationTimingFunction: e.motionEaseOutQuint,
          animationIterationCount: "infinite",
          content: '""'
        }
      },
      [`&${t}-status-exception`]: {
        [`${t}-bg`]: {
          backgroundColor: e.colorError
        },
        [`${t}-text`]: {
          color: e.colorError
        }
      },
      [`&${t}-status-exception ${t}-inner:not(${t}-circle-gradient)`]: {
        [`${t}-circle-path`]: {
          stroke: e.colorError
        }
      },
      [`&${t}-status-success`]: {
        [`${t}-bg`]: {
          backgroundColor: e.colorSuccess
        },
        [`${t}-text`]: {
          color: e.colorSuccess
        }
      },
      [`&${t}-status-success ${t}-inner:not(${t}-circle-gradient)`]: {
        [`${t}-circle-path`]: {
          stroke: e.colorSuccess
        }
      }
    })
  };
}, dje = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: {
      [`${t}-circle-trail`]: {
        stroke: e.progressRemainingColor
      },
      [`&${t}-circle ${t}-inner`]: {
        position: "relative",
        lineHeight: 1,
        backgroundColor: "transparent"
      },
      [`&${t}-circle ${t}-text`]: {
        position: "absolute",
        insetBlockStart: "50%",
        insetInlineStart: 0,
        width: "100%",
        margin: 0,
        padding: 0,
        color: e.colorText,
        lineHeight: 1,
        whiteSpace: "normal",
        textAlign: "center",
        transform: "translateY(-50%)",
        [n]: {
          fontSize: `${e.fontSize / e.fontSizeSM}em`
        }
      },
      [`${t}-circle&-status-exception`]: {
        [`${t}-text`]: {
          color: e.colorError
        }
      },
      [`${t}-circle&-status-success`]: {
        [`${t}-text`]: {
          color: e.colorSuccess
        }
      }
    },
    [`${t}-inline-circle`]: {
      lineHeight: 1,
      [`${t}-inner`]: {
        verticalAlign: "bottom"
      }
    }
  };
}, fje = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`${t}-steps`]: {
        display: "inline-block",
        "&-outer": {
          display: "flex",
          flexDirection: "row",
          alignItems: "center"
        },
        "&-item": {
          flexShrink: 0,
          minWidth: e.progressStepMinWidth,
          marginInlineEnd: e.progressStepMarginInlineEnd,
          backgroundColor: e.progressRemainingColor,
          transition: `all ${e.motionDurationSlow}`,
          "&-active": {
            backgroundColor: e.colorInfo
          }
        }
      }
    }
  };
}, pje = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: {
      [`${t}-small&-line, ${t}-small&-line ${t}-text ${n}`]: {
        fontSize: e.fontSizeSM
      }
    }
  };
}, vje = Zt("Progress", (e) => {
  const t = e.marginXXS / 2, n = Vt(e, {
    progressLineRadius: 100,
    progressInfoTextColor: e.colorText,
    progressDefaultColor: e.colorInfo,
    progressRemainingColor: e.colorFillSecondary,
    progressStepMarginInlineEnd: t,
    progressStepMinWidth: t,
    progressActiveMotionDuration: "2.4s"
  });
  return [uje(n), dje(n), fje(n), pje(n)];
});
var mje = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const hje = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AProgress",
  inheritAttrs: !1,
  props: sn(QS(), {
    type: "line",
    percent: 0,
    showInfo: !0,
    // null for different theme definition
    trailColor: null,
    size: "default",
    strokeLinecap: "round"
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("progress", e), [a, i] = vje(l);
    process.env.NODE_ENV !== "production" && (un("successPercent" in e, "Progress", "`successPercent` is deprecated. Please use `success.percent` instead."), un("width" in e, "Progress", "`width` is deprecated. Please use `size` instead."));
    const s = O(() => Array.isArray(e.strokeColor) ? e.strokeColor[0] : e.strokeColor), c = O(() => {
      const {
        percent: m = 0
      } = e, v = Uy(e);
      return parseInt(v !== void 0 ? v.toString() : m.toString(), 10);
    }), u = O(() => {
      const {
        status: m
      } = e;
      return !WHe.includes(m) && c.value >= 100 ? "success" : m || "normal";
    }), d = O(() => {
      const {
        type: m,
        showInfo: v,
        size: h
      } = e, g = l.value;
      return {
        [g]: !0,
        [`${g}-inline-circle`]: m === "circle" && eC(h, "circle").width <= 20,
        [`${g}-${m === "dashboard" && "circle" || m}`]: !0,
        [`${g}-status-${u.value}`]: !0,
        [`${g}-show-info`]: v,
        [`${g}-${h}`]: h,
        [`${g}-rtl`]: r.value === "rtl",
        [i.value]: !0
      };
    }), f = O(() => typeof e.strokeColor == "string" || Array.isArray(e.strokeColor) ? e.strokeColor : void 0), p = () => {
      const {
        showInfo: m,
        format: v,
        type: h,
        percent: g,
        title: y
      } = e, b = Uy(e);
      if (!m) return null;
      let C;
      const w = v || (n == null ? void 0 : n.format) || ((E) => `${E}%`), x = h === "line";
      return v || n != null && n.format || u.value !== "exception" && u.value !== "success" ? C = w(Au(g), Au(b)) : u.value === "exception" ? C = $(x ? jl : Hl, null, null) : u.value === "success" && (C = $(x ? Za : Np, null, null)), $("span", {
        class: `${l.value}-text`,
        title: y === void 0 && typeof C == "string" ? C : void 0
      }, [C]);
    };
    return () => {
      const {
        type: m,
        steps: v,
        title: h
      } = e, {
        class: g
      } = o, y = mje(o, ["class"]), b = p();
      let C;
      return m === "line" ? C = v ? $(sje, Q(Q({}, e), {}, {
        strokeColor: f.value,
        prefixCls: l.value,
        steps: v
      }), {
        default: () => [b]
      }) : $(JHe, Q(Q({}, e), {}, {
        strokeColor: s.value,
        prefixCls: l.value,
        direction: r.value
      }), {
        default: () => [b]
      }) : (m === "circle" || m === "dashboard") && (C = $(aje, Q(Q({}, e), {}, {
        prefixCls: l.value,
        strokeColor: s.value,
        progressStatus: u.value
      }), {
        default: () => [b]
      })), a($("div", Q(Q({
        role: "progressbar"
      }, y), {}, {
        class: [d.value, g],
        title: h
      }), [C]));
    };
  }
}), vP = po(hje);
function gje(e) {
  let t = e.scrollX;
  const n = "scrollLeft";
  if (typeof t != "number") {
    const o = e.document;
    t = o.documentElement[n], typeof t != "number" && (t = o.body[n]);
  }
  return t;
}
function bje(e) {
  let t, n;
  const o = e.ownerDocument, {
    body: l
  } = o, r = o && o.documentElement, a = e.getBoundingClientRect();
  return t = a.left, n = a.top, t -= r.clientLeft || l.clientLeft || 0, n -= r.clientTop || l.clientTop || 0, {
    left: t,
    top: n
  };
}
function yje(e) {
  const t = bje(e), n = e.ownerDocument, o = n.defaultView || n.parentWindow;
  return t.left += gje(o), t.left;
}
var Sje = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z" } }] }, name: "star", theme: "filled" };
function tR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      Cje(e, l, n[l]);
    });
  }
  return e;
}
function Cje(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var mP = function(t, n) {
  var o = tR({}, t, n.attrs);
  return $(cn, tR({}, o, {
    icon: Sje
  }), null);
};
mP.displayName = "StarFilled";
mP.inheritAttrs = !1;
const wje = {
  value: Number,
  index: Number,
  prefixCls: String,
  allowHalf: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  character: de.any,
  characterRender: Function,
  focused: {
    type: Boolean,
    default: void 0
  },
  count: Number,
  onClick: Function,
  onHover: Function
}, $je = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Star",
  inheritAttrs: !1,
  props: wje,
  emits: ["hover", "click"],
  setup(e, t) {
    let {
      emit: n
    } = t;
    const o = (i) => {
      const {
        index: s
      } = e;
      n("hover", i, s);
    }, l = (i) => {
      const {
        index: s
      } = e;
      n("click", i, s);
    }, r = (i) => {
      const {
        index: s
      } = e;
      i.keyCode === 13 && n("click", i, s);
    }, a = O(() => {
      const {
        prefixCls: i,
        index: s,
        value: c,
        allowHalf: u,
        focused: d
      } = e, f = s + 1;
      let p = i;
      return c === 0 && s === 0 && d ? p += ` ${i}-focused` : u && c + 0.5 >= f && c < f ? (p += ` ${i}-half ${i}-active`, d && (p += ` ${i}-focused`)) : (p += f <= c ? ` ${i}-full` : ` ${i}-zero`, f === c && d && (p += ` ${i}-focused`)), p;
    });
    return () => {
      const {
        disabled: i,
        prefixCls: s,
        characterRender: c,
        character: u,
        index: d,
        count: f,
        value: p
      } = e, m = typeof u == "function" ? u({
        disabled: i,
        prefixCls: s,
        index: d,
        count: f,
        value: p
      }) : u;
      let v = $("li", {
        class: a.value
      }, [$("div", {
        onClick: i ? null : l,
        onKeydown: i ? null : r,
        onMousemove: i ? null : o,
        role: "radio",
        "aria-checked": p > d ? "true" : "false",
        "aria-posinset": d + 1,
        "aria-setsize": f,
        tabindex: i ? -1 : 0
      }, [$("div", {
        class: `${s}-first`
      }, [m]), $("div", {
        class: `${s}-second`
      }, [m])])]);
      return c && (v = c(v, e)), v;
    };
  }
}), xje = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-star`]: {
      position: "relative",
      display: "inline-block",
      color: "inherit",
      cursor: "pointer",
      "&:not(:last-child)": {
        marginInlineEnd: e.marginXS
      },
      "> div": {
        transition: `all ${e.motionDurationMid}, outline 0s`,
        "&:hover": {
          transform: e.rateStarHoverScale
        },
        "&:focus": {
          outline: 0
        },
        "&:focus-visible": {
          outline: `${e.lineWidth}px dashed ${e.rateStarColor}`,
          transform: e.rateStarHoverScale
        }
      },
      "&-first, &-second": {
        color: e.defaultColor,
        transition: `all ${e.motionDurationMid}`,
        userSelect: "none",
        [e.iconCls]: {
          verticalAlign: "middle"
        }
      },
      "&-first": {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        width: "50%",
        height: "100%",
        overflow: "hidden",
        opacity: 0
      },
      [`&-half ${t}-star-first, &-half ${t}-star-second`]: {
        opacity: 1
      },
      [`&-half ${t}-star-first, &-full ${t}-star-second`]: {
        color: "inherit"
      }
    }
  };
}, Eje = (e) => ({
  [`&-rtl${e.componentCls}`]: {
    direction: "rtl"
  }
}), Oje = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: _(_(_(_(_({}, nn(e)), {
      display: "inline-block",
      margin: 0,
      padding: 0,
      color: e.rateStarColor,
      fontSize: e.rateStarSize,
      lineHeight: "unset",
      listStyle: "none",
      outline: "none",
      // disable styles
      [`&-disabled${t} ${t}-star`]: {
        cursor: "default",
        "&:hover": {
          transform: "scale(1)"
        }
      }
    }), xje(e)), {
      // text styles
      [`+ ${t}-text`]: {
        display: "inline-block",
        marginInlineStart: e.marginXS,
        fontSize: e.fontSize
      }
    }), Eje(e))
  };
}, _je = Zt("Rate", (e) => {
  const {
    colorFillContent: t
  } = e, n = Vt(e, {
    rateStarColor: e["yellow-6"],
    rateStarSize: e.controlHeightLG * 0.5,
    rateStarHoverScale: "scale(1.1)",
    defaultColor: t
  });
  return [Oje(n)];
}), Ije = () => ({
  prefixCls: String,
  count: Number,
  value: Number,
  allowHalf: {
    type: Boolean,
    default: void 0
  },
  allowClear: {
    type: Boolean,
    default: void 0
  },
  tooltips: Array,
  disabled: {
    type: Boolean,
    default: void 0
  },
  character: de.any,
  autofocus: {
    type: Boolean,
    default: void 0
  },
  tabindex: de.oneOfType([de.number, de.string]),
  direction: String,
  id: String,
  onChange: Function,
  onHoverChange: Function,
  "onUpdate:value": Function,
  onFocus: Function,
  onBlur: Function,
  onKeydown: Function
}), Tje = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ARate",
  inheritAttrs: !1,
  props: sn(Ije(), {
    value: 0,
    count: 5,
    allowHalf: !1,
    allowClear: !0,
    tabindex: 0,
    direction: "ltr"
  }),
  // emits: ['hoverChange', 'update:value', 'change', 'focus', 'blur', 'keydown'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: l,
      expose: r
    } = t;
    const {
      prefixCls: a,
      direction: i
    } = bt("rate", e), [s, c] = _je(a), u = Ko(), d = /* @__PURE__ */ H(), [f, p] = IT(), m = /* @__PURE__ */ kt({
      value: e.value,
      focused: !1,
      cleanedValue: null,
      hoverValue: void 0
    });
    pe(() => e.value, () => {
      m.value = e.value;
    });
    const v = (k) => nr(p.value.get(k)), h = (k, N) => {
      const R = i.value === "rtl";
      let z = k + 1;
      if (e.allowHalf) {
        const D = v(k), F = yje(D), M = D.clientWidth;
        (R && N - F > M / 2 || !R && N - F < M / 2) && (z -= 0.5);
      }
      return z;
    }, g = (k) => {
      e.value === void 0 && (m.value = k), l("update:value", k), l("change", k), u.onFieldChange();
    }, y = (k, N) => {
      const R = h(N, k.pageX);
      R !== m.cleanedValue && (m.hoverValue = R, m.cleanedValue = null), l("hoverChange", R);
    }, b = () => {
      m.hoverValue = void 0, m.cleanedValue = null, l("hoverChange", void 0);
    }, C = (k, N) => {
      const {
        allowClear: R
      } = e, z = h(N, k.pageX);
      let D = !1;
      R && (D = z === m.value), b(), g(D ? 0 : z), m.cleanedValue = D ? z : null;
    }, w = (k) => {
      m.focused = !0, l("focus", k);
    }, x = (k) => {
      m.focused = !1, l("blur", k), u.onFieldBlur();
    }, E = (k) => {
      const {
        keyCode: N
      } = k, {
        count: R,
        allowHalf: z
      } = e, D = i.value === "rtl";
      N === ot.RIGHT && m.value < R && !D ? (z ? m.value += 0.5 : m.value += 1, g(m.value), k.preventDefault()) : N === ot.LEFT && m.value > 0 && !D || N === ot.RIGHT && m.value > 0 && D ? (z ? m.value -= 0.5 : m.value -= 1, g(m.value), k.preventDefault()) : N === ot.LEFT && m.value < R && D && (z ? m.value += 0.5 : m.value += 1, g(m.value), k.preventDefault()), l("keydown", k);
    }, I = () => {
      e.disabled || d.value.focus();
    };
    r({
      focus: I,
      blur: () => {
        e.disabled || d.value.blur();
      }
    }), nt(() => {
      const {
        autofocus: k,
        disabled: N
      } = e;
      k && !N && I();
    });
    const P = (k, N) => {
      let {
        index: R
      } = N;
      const {
        tooltips: z
      } = e;
      return z ? $(Sr, {
        title: z[R]
      }, {
        default: () => [k]
      }) : k;
    };
    return () => {
      const {
        count: k,
        allowHalf: N,
        disabled: R,
        tabindex: z,
        id: D = u.id.value
      } = e, {
        class: F,
        style: M
      } = o, A = [], L = R ? `${a.value}-disabled` : "", B = e.character || n.character || (() => $(mP, null, null));
      for (let j = 0; j < k; j++)
        A.push($($je, {
          ref: f(j),
          key: j,
          index: j,
          count: k,
          disabled: R,
          prefixCls: `${a.value}-star`,
          allowHalf: N,
          value: m.hoverValue === void 0 ? m.value : m.hoverValue,
          onClick: C,
          onHover: y,
          character: B,
          characterRender: P,
          focused: m.focused
        }, null));
      const V = ke(a.value, L, F, {
        [c.value]: !0,
        [`${a.value}-rtl`]: i.value === "rtl"
      });
      return s($("ul", Q(Q({}, o), {}, {
        id: D,
        class: V,
        style: M,
        onMouseleave: R ? null : b,
        tabindex: R ? -1 : z,
        onFocus: R ? null : w,
        onBlur: R ? null : x,
        onKeydown: R ? null : E,
        ref: d,
        role: "radiogroup"
      }), [A]));
    };
  }
}), Pje = po(Tje);
var kje = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48zM480 416c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v184c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V416zm32 352a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "warning", theme: "filled" };
function nR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      Nje(e, l, n[l]);
    });
  }
  return e;
}
function Nje(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var hP = function(t, n) {
  var o = nR({}, t, n.attrs);
  return $(cn, nR({}, o, {
    icon: kje
  }), null);
};
hP.displayName = "WarningFilled";
hP.inheritAttrs = !1;
const Mje = () => $("svg", {
  width: "252",
  height: "294"
}, [$("defs", null, [$("path", {
  d: "M0 .387h251.772v251.772H0z"
}, null)]), $("g", {
  fill: "none",
  "fill-rule": "evenodd"
}, [$("g", {
  transform: "translate(0 .012)"
}, [$("mask", {
  fill: "#fff"
}, null), $("path", {
  d: "M0 127.32v-2.095C0 56.279 55.892.387 124.838.387h2.096c68.946 0 124.838 55.892 124.838 124.838v2.096c0 68.946-55.892 124.838-124.838 124.838h-2.096C55.892 252.16 0 196.267 0 127.321",
  fill: "#E4EBF7",
  mask: "url(#b)"
}, null)]), $("path", {
  d: "M39.755 130.84a8.276 8.276 0 1 1-16.468-1.66 8.276 8.276 0 0 1 16.468 1.66",
  fill: "#FFF"
}, null), $("path", {
  d: "M36.975 134.297l10.482 5.943M48.373 146.508l-12.648 10.788",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), $("path", {
  d: "M39.875 159.352a5.667 5.667 0 1 1-11.277-1.136 5.667 5.667 0 0 1 11.277 1.136M57.588 143.247a5.708 5.708 0 1 1-11.358-1.145 5.708 5.708 0 0 1 11.358 1.145M99.018 26.875l29.82-.014a4.587 4.587 0 1 0-.003-9.175l-29.82.013a4.587 4.587 0 1 0 .003 9.176M110.424 45.211l29.82-.013a4.588 4.588 0 0 0-.004-9.175l-29.82.013a4.587 4.587 0 1 0 .004 9.175",
  fill: "#FFF"
}, null), $("path", {
  d: "M112.798 26.861v-.002l15.784-.006a4.588 4.588 0 1 0 .003 9.175l-15.783.007v-.002a4.586 4.586 0 0 0-.004-9.172M184.523 135.668c-.553 5.485-5.447 9.483-10.931 8.93-5.485-.553-9.483-5.448-8.93-10.932.552-5.485 5.447-9.483 10.932-8.93 5.485.553 9.483 5.447 8.93 10.932",
  fill: "#FFF"
}, null), $("path", {
  d: "M179.26 141.75l12.64 7.167M193.006 156.477l-15.255 13.011",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), $("path", {
  d: "M184.668 170.057a6.835 6.835 0 1 1-13.6-1.372 6.835 6.835 0 0 1 13.6 1.372M203.34 153.325a6.885 6.885 0 1 1-13.7-1.382 6.885 6.885 0 0 1 13.7 1.382",
  fill: "#FFF"
}, null), $("path", {
  d: "M151.931 192.324a2.222 2.222 0 1 1-4.444 0 2.222 2.222 0 0 1 4.444 0zM225.27 116.056a2.222 2.222 0 1 1-4.445 0 2.222 2.222 0 0 1 4.444 0zM216.38 151.08a2.223 2.223 0 1 1-4.446-.001 2.223 2.223 0 0 1 4.446 0zM176.917 107.636a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM195.291 92.165a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM202.058 180.711a2.223 2.223 0 1 1-4.446 0 2.223 2.223 0 0 1 4.446 0z",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), $("path", {
  stroke: "#FFF",
  "stroke-width": "2",
  d: "M214.404 153.302l-1.912 20.184-10.928 5.99M173.661 174.792l-6.356 9.814h-11.36l-4.508 6.484M174.941 125.168v-15.804M220.824 117.25l-12.84 7.901-15.31-7.902V94.39"
}, null), $("path", {
  d: "M166.588 65.936h-3.951a4.756 4.756 0 0 1-4.743-4.742 4.756 4.756 0 0 1 4.743-4.743h3.951a4.756 4.756 0 0 1 4.743 4.743 4.756 4.756 0 0 1-4.743 4.742",
  fill: "#FFF"
}, null), $("path", {
  d: "M174.823 30.03c0-16.281 13.198-29.48 29.48-29.48 16.28 0 29.48 13.199 29.48 29.48 0 16.28-13.2 29.48-29.48 29.48-16.282 0-29.48-13.2-29.48-29.48",
  fill: "#1890FF"
}, null), $("path", {
  d: "M205.952 38.387c.5.5.785 1.142.785 1.928s-.286 1.465-.785 1.964c-.572.5-1.214.75-2 .75-.785 0-1.429-.285-1.929-.785-.572-.5-.82-1.143-.82-1.929s.248-1.428.82-1.928c.5-.5 1.144-.75 1.93-.75.785 0 1.462.25 1.999.75m4.285-19.463c1.428 1.249 2.143 2.963 2.143 5.142 0 1.712-.427 3.13-1.219 4.25-.067.096-.137.18-.218.265-.416.429-1.41 1.346-2.956 2.699a5.07 5.07 0 0 0-1.428 1.75 5.207 5.207 0 0 0-.536 2.357v.5h-4.107v-.5c0-1.357.215-2.536.714-3.5.464-.964 1.857-2.464 4.178-4.536l.43-.5c.643-.785.964-1.643.964-2.535 0-1.18-.358-2.108-1-2.785-.678-.68-1.643-1.001-2.858-1.001-1.536 0-2.642.464-3.357 1.43-.37.5-.621 1.135-.76 1.904a1.999 1.999 0 0 1-1.971 1.63h-.004c-1.277 0-2.257-1.183-1.98-2.43.337-1.518 1.02-2.78 2.073-3.784 1.536-1.5 3.607-2.25 6.25-2.25 2.32 0 4.214.607 5.642 1.894",
  fill: "#FFF"
}, null), $("path", {
  d: "M52.04 76.131s21.81 5.36 27.307 15.945c5.575 10.74-6.352 9.26-15.73 4.935-10.86-5.008-24.7-11.822-11.577-20.88",
  fill: "#FFB594"
}, null), $("path", {
  d: "M90.483 67.504l-.449 2.893c-.753.49-4.748-2.663-4.748-2.663l-1.645.748-1.346-5.684s6.815-4.589 8.917-5.018c2.452-.501 9.884.94 10.7 2.278 0 0 1.32.486-2.227.69-3.548.203-5.043.447-6.79 3.132-1.747 2.686-2.412 3.624-2.412 3.624",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M128.055 111.367c-2.627-7.724-6.15-13.18-8.917-15.478-3.5-2.906-9.34-2.225-11.366-4.187-1.27-1.231-3.215-1.197-3.215-1.197s-14.98-3.158-16.828-3.479c-2.37-.41-2.124-.714-6.054-1.405-1.57-1.907-2.917-1.122-2.917-1.122l-7.11-1.383c-.853-1.472-2.423-1.023-2.423-1.023l-2.468-.897c-1.645 9.976-7.74 13.796-7.74 13.796 1.795 1.122 15.703 8.3 15.703 8.3l5.107 37.11s-3.321 5.694 1.346 9.109c0 0 19.883-3.743 34.921-.329 0 0 3.047-2.546.972-8.806.523-3.01 1.394-8.263 1.736-11.622.385.772 2.019 1.918 3.14 3.477 0 0 9.407-7.365 11.052-14.012-.832-.723-1.598-1.585-2.267-2.453-.567-.736-.358-2.056-.765-2.717-.669-1.084-1.804-1.378-1.907-1.682",
  fill: "#FFF"
}, null), $("path", {
  d: "M101.09 289.998s4.295 2.041 7.354 1.021c2.821-.94 4.53.668 7.08 1.178 2.55.51 6.874 1.1 11.686-1.26-.103-5.51-6.889-3.98-11.96-6.713-2.563-1.38-3.784-4.722-3.598-8.799h-9.402s-1.392 10.52-1.16 14.573",
  fill: "#CBD1D1"
}, null), $("path", {
  d: "M101.067 289.826s2.428 1.271 6.759.653c3.058-.437 3.712.481 7.423 1.031 3.712.55 10.724-.069 11.823-.894.413 1.1-.343 2.063-.343 2.063s-1.512.603-4.812.824c-2.03.136-5.8.291-7.607-.503-1.787-1.375-5.247-1.903-5.728-.241-3.918.95-7.355-.286-7.355-.286l-.16-2.647z",
  fill: "#2B0849"
}, null), $("path", {
  d: "M108.341 276.044h3.094s-.103 6.702 4.536 8.558c-4.64.618-8.558-2.303-7.63-8.558",
  fill: "#A4AABA"
}, null), $("path", {
  d: "M57.542 272.401s-2.107 7.416-4.485 12.306c-1.798 3.695-4.225 7.492 5.465 7.492 6.648 0 8.953-.48 7.423-6.599-1.53-6.12.266-13.199.266-13.199h-8.669z",
  fill: "#CBD1D1"
}, null), $("path", {
  d: "M51.476 289.793s2.097 1.169 6.633 1.169c6.083 0 8.249-1.65 8.249-1.65s.602 1.114-.619 2.165c-.993.855-3.597 1.591-7.39 1.546-4.145-.048-5.832-.566-6.736-1.168-.825-.55-.687-1.58-.137-2.062",
  fill: "#2B0849"
}, null), $("path", {
  d: "M58.419 274.304s.033 1.519-.314 2.93c-.349 1.42-1.078 3.104-1.13 4.139-.058 1.151 4.537 1.58 5.155.034.62-1.547 1.294-6.427 1.913-7.252.619-.825-4.903-2.119-5.624.15",
  fill: "#A4AABA"
}, null), $("path", {
  d: "M99.66 278.514l13.378.092s1.298-54.52 1.853-64.403c.554-9.882 3.776-43.364 1.002-63.128l-12.547-.644-22.849.78s-.434 3.966-1.195 9.976c-.063.496-.682.843-.749 1.365-.075.585.423 1.354.32 1.966-2.364 14.08-6.377 33.104-8.744 46.677-.116.666-1.234 1.009-1.458 2.691-.04.302.211 1.525.112 1.795-6.873 18.744-10.949 47.842-14.277 61.885l14.607-.014s2.197-8.57 4.03-16.97c2.811-12.886 23.111-85.01 23.111-85.01l3.016-.521 1.043 46.35s-.224 1.234.337 2.02c.56.785-.56 1.123-.392 2.244l.392 1.794s-.449 7.178-.898 11.89c-.448 4.71-.092 39.165-.092 39.165",
  fill: "#7BB2F9"
}, null), $("path", {
  d: "M76.085 221.626c1.153.094 4.038-2.019 6.955-4.935M106.36 225.142s2.774-1.11 6.103-3.883",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M107.275 222.1s2.773-1.11 6.102-3.884",
  stroke: "#648BD8",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M74.74 224.767s2.622-.591 6.505-3.365M86.03 151.634c-.27 3.106.3 8.525-4.336 9.123M103.625 149.88s.11 14.012-1.293 15.065c-2.219 1.664-2.99 1.944-2.99 1.944M99.79 150.438s.035 12.88-1.196 24.377M93.673 175.911s7.212-1.664 9.431-1.664M74.31 205.861a212.013 212.013 0 0 1-.979 4.56s-1.458 1.832-1.009 3.776c.449 1.944-.947 2.045-4.985 15.355-1.696 5.59-4.49 18.591-6.348 27.597l-.231 1.12M75.689 197.807a320.934 320.934 0 0 1-.882 4.754M82.591 152.233L81.395 162.7s-1.097.15-.5 2.244c.113 1.346-2.674 15.775-5.18 30.43M56.12 274.418h13.31",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M116.241 148.22s-17.047-3.104-35.893.2c.158 2.514-.003 4.15-.003 4.15s14.687-2.818 35.67-.312c.252-2.355.226-4.038.226-4.038",
  fill: "#192064"
}, null), $("path", {
  d: "M106.322 151.165l.003-4.911a.81.81 0 0 0-.778-.815c-2.44-.091-5.066-.108-7.836-.014a.818.818 0 0 0-.789.815l-.003 4.906a.81.81 0 0 0 .831.813c2.385-.06 4.973-.064 7.73.017a.815.815 0 0 0 .842-.81",
  fill: "#FFF"
}, null), $("path", {
  d: "M105.207 150.233l.002-3.076a.642.642 0 0 0-.619-.646 94.321 94.321 0 0 0-5.866-.01.65.65 0 0 0-.63.647v3.072a.64.64 0 0 0 .654.644 121.12 121.12 0 0 1 5.794.011c.362.01.665-.28.665-.642",
  fill: "#192064"
}, null), $("path", {
  d: "M100.263 275.415h12.338M101.436 270.53c.006 3.387.042 5.79.111 6.506M101.451 264.548a915.75 915.75 0 0 0-.015 4.337M100.986 174.965l.898 44.642s.673 1.57-.225 2.692c-.897 1.122 2.468.673.898 2.243-1.57 1.57.897 1.122 0 3.365-.596 1.489-.994 21.1-1.096 35.146",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M46.876 83.427s-.516 6.045 7.223 5.552c11.2-.712 9.218-9.345 31.54-21.655-.786-2.708-2.447-4.744-2.447-4.744s-11.068 3.11-22.584 8.046c-6.766 2.9-13.395 6.352-13.732 12.801M104.46 91.057l.941-5.372-8.884-11.43-5.037 5.372-1.74 7.834a.321.321 0 0 0 .108.32c.965.8 6.5 5.013 14.347 3.544a.332.332 0 0 0 .264-.268",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M93.942 79.387s-4.533-2.853-2.432-6.855c1.623-3.09 4.513 1.133 4.513 1.133s.52-3.642 3.121-3.642c.52-1.04 1.561-4.162 1.561-4.162s11.445 2.601 13.526 3.121c0 5.203-2.304 19.424-7.84 19.861-8.892.703-12.449-9.456-12.449-9.456",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M113.874 73.446c2.601-2.081 3.47-9.722 3.47-9.722s-2.479-.49-6.64-2.05c-4.683-2.081-12.798-4.747-17.48.976-9.668 3.223-2.05 19.823-2.05 19.823l2.713-3.021s-3.935-3.287-2.08-6.243c2.17-3.462 3.92 1.073 3.92 1.073s.637-2.387 3.581-3.342c.355-.71 1.036-2.674 1.432-3.85a1.073 1.073 0 0 1 1.263-.704c2.4.558 8.677 2.019 11.356 2.662.522.125.871.615.82 1.15l-.305 3.248z",
  fill: "#520038"
}, null), $("path", {
  d: "M104.977 76.064c-.103.61-.582 1.038-1.07.956-.489-.083-.801-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.644.698 1.254M112.132 77.694c-.103.61-.582 1.038-1.07.956-.488-.083-.8-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.643.698 1.254",
  fill: "#552950"
}, null), $("path", {
  stroke: "#DB836E",
  "stroke-width": "1.118",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  d: "M110.13 74.84l-.896 1.61-.298 4.357h-2.228"
}, null), $("path", {
  d: "M110.846 74.481s1.79-.716 2.506.537",
  stroke: "#5C2552",
  "stroke-width": "1.118",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M92.386 74.282s.477-1.114 1.113-.716c.637.398 1.274 1.433.558 1.99-.717.556.159 1.67.159 1.67",
  stroke: "#DB836E",
  "stroke-width": "1.118",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M103.287 72.93s1.83 1.113 4.137.954",
  stroke: "#5C2552",
  "stroke-width": "1.118",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M103.685 81.762s2.227 1.193 4.376 1.193M104.64 84.308s.954.398 1.511.318M94.693 81.205s2.308 7.4 10.424 7.639",
  stroke: "#DB836E",
  "stroke-width": "1.118",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M81.45 89.384s.45 5.647-4.935 12.787M69 82.654s-.726 9.282-8.204 14.206",
  stroke: "#E4EBF7",
  "stroke-width": "1.101",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M129.405 122.865s-5.272 7.403-9.422 10.768",
  stroke: "#E4EBF7",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M119.306 107.329s.452 4.366-2.127 32.062",
  stroke: "#E4EBF7",
  "stroke-width": "1.101",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M150.028 151.232h-49.837a1.01 1.01 0 0 1-1.01-1.01v-31.688c0-.557.452-1.01 1.01-1.01h49.837c.558 0 1.01.453 1.01 1.01v31.688a1.01 1.01 0 0 1-1.01 1.01",
  fill: "#F2D7AD"
}, null), $("path", {
  d: "M150.29 151.232h-19.863v-33.707h20.784v32.786a.92.92 0 0 1-.92.92",
  fill: "#F4D19D"
}, null), $("path", {
  d: "M123.554 127.896H92.917a.518.518 0 0 1-.425-.816l6.38-9.113c.193-.277.51-.442.85-.442h31.092l-7.26 10.371z",
  fill: "#F2D7AD"
}, null), $("path", {
  fill: "#CC9B6E",
  d: "M123.689 128.447H99.25v-.519h24.169l7.183-10.26.424.298z"
}, null), $("path", {
  d: "M158.298 127.896h-18.669a2.073 2.073 0 0 1-1.659-.83l-7.156-9.541h19.965c.49 0 .95.23 1.244.622l6.69 8.92a.519.519 0 0 1-.415.83",
  fill: "#F4D19D"
}, null), $("path", {
  fill: "#CC9B6E",
  d: "M157.847 128.479h-19.384l-7.857-10.475.415-.31 7.7 10.266h19.126zM130.554 150.685l-.032-8.177.519-.002.032 8.177z"
}, null), $("path", {
  fill: "#CC9B6E",
  d: "M130.511 139.783l-.08-21.414.519-.002.08 21.414zM111.876 140.932l-.498-.143 1.479-5.167.498.143zM108.437 141.06l-2.679-2.935 2.665-3.434.41.318-2.397 3.089 2.384 2.612zM116.607 141.06l-.383-.35 2.383-2.612-2.397-3.089.41-.318 2.665 3.434z"
}, null), $("path", {
  d: "M154.316 131.892l-3.114-1.96.038 3.514-1.043.092c-1.682.115-3.634.23-4.789.23-1.902 0-2.693 2.258 2.23 2.648l-2.645-.596s-2.168 1.317.504 2.3c0 0-1.58 1.217.561 2.58-.584 3.504 5.247 4.058 7.122 3.59 1.876-.47 4.233-2.359 4.487-5.16.28-3.085-.89-5.432-3.35-7.238",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M153.686 133.577s-6.522.47-8.36.372c-1.836-.098-1.904 2.19 2.359 2.264 3.739.15 5.451-.044 5.451-.044",
  stroke: "#DB836E",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M145.16 135.877c-1.85 1.346.561 2.355.561 2.355s3.478.898 6.73.617",
  stroke: "#DB836E",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M151.89 141.71s-6.28.111-6.73-2.132c-.223-1.346.45-1.402.45-1.402M146.114 140.868s-1.103 3.16 5.44 3.533M151.202 129.932v3.477M52.838 89.286c3.533-.337 8.423-1.248 13.582-7.754",
  stroke: "#DB836E",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M168.567 248.318a6.647 6.647 0 0 1-6.647-6.647v-66.466a6.647 6.647 0 1 1 13.294 0v66.466a6.647 6.647 0 0 1-6.647 6.647",
  fill: "#5BA02E"
}, null), $("path", {
  d: "M176.543 247.653a6.647 6.647 0 0 1-6.646-6.647v-33.232a6.647 6.647 0 1 1 13.293 0v33.232a6.647 6.647 0 0 1-6.647 6.647",
  fill: "#92C110"
}, null), $("path", {
  d: "M186.443 293.613H158.92a3.187 3.187 0 0 1-3.187-3.187v-46.134a3.187 3.187 0 0 1 3.187-3.187h27.524a3.187 3.187 0 0 1 3.187 3.187v46.134a3.187 3.187 0 0 1-3.187 3.187",
  fill: "#F2D7AD"
}, null), $("path", {
  d: "M88.979 89.48s7.776 5.384 16.6 2.842",
  stroke: "#E4EBF7",
  "stroke-width": "1.101",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null)])]), Aje = () => $("svg", {
  width: "254",
  height: "294"
}, [$("defs", null, [$("path", {
  d: "M0 .335h253.49v253.49H0z"
}, null), $("path", {
  d: "M0 293.665h253.49V.401H0z"
}, null)]), $("g", {
  fill: "none",
  "fill-rule": "evenodd"
}, [$("g", {
  transform: "translate(0 .067)"
}, [$("mask", {
  fill: "#fff"
}, null), $("path", {
  d: "M0 128.134v-2.11C0 56.608 56.273.334 125.69.334h2.11c69.416 0 125.69 56.274 125.69 125.69v2.11c0 69.417-56.274 125.69-125.69 125.69h-2.11C56.273 253.824 0 197.551 0 128.134",
  fill: "#E4EBF7",
  mask: "url(#b)"
}, null)]), $("path", {
  d: "M39.989 132.108a8.332 8.332 0 1 1-16.581-1.671 8.332 8.332 0 0 1 16.58 1.671",
  fill: "#FFF"
}, null), $("path", {
  d: "M37.19 135.59l10.553 5.983M48.665 147.884l-12.734 10.861",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), $("path", {
  d: "M40.11 160.816a5.706 5.706 0 1 1-11.354-1.145 5.706 5.706 0 0 1 11.354 1.145M57.943 144.6a5.747 5.747 0 1 1-11.436-1.152 5.747 5.747 0 0 1 11.436 1.153M99.656 27.434l30.024-.013a4.619 4.619 0 1 0-.004-9.238l-30.024.013a4.62 4.62 0 0 0 .004 9.238M111.14 45.896l30.023-.013a4.62 4.62 0 1 0-.004-9.238l-30.024.013a4.619 4.619 0 1 0 .004 9.238",
  fill: "#FFF"
}, null), $("path", {
  d: "M113.53 27.421v-.002l15.89-.007a4.619 4.619 0 1 0 .005 9.238l-15.892.007v-.002a4.618 4.618 0 0 0-.004-9.234M150.167 70.091h-3.979a4.789 4.789 0 0 1-4.774-4.775 4.788 4.788 0 0 1 4.774-4.774h3.979a4.789 4.789 0 0 1 4.775 4.774 4.789 4.789 0 0 1-4.775 4.775",
  fill: "#FFF"
}, null), $("path", {
  d: "M171.687 30.234c0-16.392 13.289-29.68 29.681-29.68 16.392 0 29.68 13.288 29.68 29.68 0 16.393-13.288 29.681-29.68 29.681s-29.68-13.288-29.68-29.68",
  fill: "#FF603B"
}, null), $("path", {
  d: "M203.557 19.435l-.676 15.035a1.514 1.514 0 0 1-3.026 0l-.675-15.035a2.19 2.19 0 1 1 4.377 0m-.264 19.378c.513.477.77 1.1.77 1.87s-.257 1.393-.77 1.907c-.55.476-1.21.733-1.943.733a2.545 2.545 0 0 1-1.87-.77c-.55-.514-.806-1.136-.806-1.87 0-.77.256-1.393.806-1.87.513-.513 1.137-.733 1.87-.733.77 0 1.43.22 1.943.733",
  fill: "#FFF"
}, null), $("path", {
  d: "M119.3 133.275c4.426-.598 3.612-1.204 4.079-4.778.675-5.18-3.108-16.935-8.262-25.118-1.088-10.72-12.598-11.24-12.598-11.24s4.312 4.895 4.196 16.199c1.398 5.243.804 14.45.804 14.45s5.255 11.369 11.78 10.487",
  fill: "#FFB594"
}, null), $("path", {
  d: "M100.944 91.61s1.463-.583 3.211.582c8.08 1.398 10.368 6.706 11.3 11.368 1.864 1.282 1.864 2.33 1.864 3.496.365.777 1.515 3.03 1.515 3.03s-7.225 1.748-10.954 6.758c-1.399-6.41-6.936-25.235-6.936-25.235",
  fill: "#FFF"
}, null), $("path", {
  d: "M94.008 90.5l1.019-5.815-9.23-11.874-5.233 5.581-2.593 9.863s8.39 5.128 16.037 2.246",
  fill: "#FFB594"
}, null), $("path", {
  d: "M82.931 78.216s-4.557-2.868-2.445-6.892c1.632-3.107 4.537 1.139 4.537 1.139s.524-3.662 3.139-3.662c.523-1.046 1.569-4.184 1.569-4.184s11.507 2.615 13.6 3.138c-.001 5.23-2.317 19.529-7.884 19.969-8.94.706-12.516-9.508-12.516-9.508",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M102.971 72.243c2.616-2.093 3.489-9.775 3.489-9.775s-2.492-.492-6.676-2.062c-4.708-2.092-12.867-4.771-17.575.982-9.54 4.41-2.062 19.93-2.062 19.93l2.729-3.037s-3.956-3.304-2.092-6.277c2.183-3.48 3.943 1.08 3.943 1.08s.64-2.4 3.6-3.36c.356-.714 1.04-2.69 1.44-3.872a1.08 1.08 0 0 1 1.27-.707c2.41.56 8.723 2.03 11.417 2.676.524.126.876.619.825 1.156l-.308 3.266z",
  fill: "#520038"
}, null), $("path", {
  d: "M101.22 76.514c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.961.491.083.805.647.702 1.26M94.26 75.074c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.96.491.082.805.646.702 1.26",
  fill: "#552950"
}, null), $("path", {
  stroke: "#DB836E",
  "stroke-width": "1.063",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  d: "M99.206 73.644l-.9 1.62-.3 4.38h-2.24"
}, null), $("path", {
  d: "M99.926 73.284s1.8-.72 2.52.54",
  stroke: "#5C2552",
  "stroke-width": "1.117",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M81.367 73.084s.48-1.12 1.12-.72c.64.4 1.28 1.44.56 2s.16 1.68.16 1.68",
  stroke: "#DB836E",
  "stroke-width": "1.117",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M92.326 71.724s1.84 1.12 4.16.96",
  stroke: "#5C2552",
  "stroke-width": "1.117",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M92.726 80.604s2.24 1.2 4.4 1.2M93.686 83.164s.96.4 1.52.32M83.687 80.044s1.786 6.547 9.262 7.954",
  stroke: "#DB836E",
  "stroke-width": "1.063",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M95.548 91.663s-1.068 2.821-8.298 2.105c-7.23-.717-10.29-5.044-10.29-5.044",
  stroke: "#E4EBF7",
  "stroke-width": "1.136",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M78.126 87.478s6.526 4.972 16.47 2.486c0 0 9.577 1.02 11.536 5.322 5.36 11.77.543 36.835 0 39.962 3.496 4.055-.466 8.483-.466 8.483-15.624-3.548-35.81-.6-35.81-.6-4.849-3.546-1.223-9.044-1.223-9.044L62.38 110.32c-2.485-15.227.833-19.803 3.549-20.743 3.03-1.049 8.04-1.282 8.04-1.282.496-.058 1.08-.076 1.37-.233 2.36-1.282 2.787-.583 2.787-.583",
  fill: "#FFF"
}, null), $("path", {
  d: "M65.828 89.81s-6.875.465-7.59 8.156c-.466 8.857 3.03 10.954 3.03 10.954s6.075 22.102 16.796 22.957c8.39-2.176 4.758-6.702 4.661-11.42-.233-11.304-7.108-16.897-7.108-16.897s-4.212-13.75-9.789-13.75",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M71.716 124.225s.855 11.264 9.828 6.486c4.765-2.536 7.581-13.828 9.789-22.568 1.456-5.768 2.58-12.197 2.58-12.197l-4.973-1.709s-2.408 5.516-7.769 12.275c-4.335 5.467-9.144 11.11-9.455 17.713",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M108.463 105.191s1.747 2.724-2.331 30.535c2.376 2.216 1.053 6.012-.233 7.51",
  stroke: "#E4EBF7",
  "stroke-width": "1.085",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M123.262 131.527s-.427 2.732-11.77 1.981c-15.187-1.006-25.326-3.25-25.326-3.25l.933-5.8s.723.215 9.71-.068c11.887-.373 18.714-6.07 24.964-1.022 4.039 3.263 1.489 8.16 1.489 8.16",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M70.24 90.974s-5.593-4.739-11.054 2.68c-3.318 7.223.517 15.284 2.664 19.578-.31 3.729 2.33 4.311 2.33 4.311s.108.895 1.516 2.68c4.078-7.03 6.72-9.166 13.711-12.546-.328-.656-1.877-3.265-1.825-3.767.175-1.69-1.282-2.623-1.282-2.623s-.286-.156-1.165-2.738c-.788-2.313-2.036-5.177-4.895-7.575",
  fill: "#FFF"
}, null), $("path", {
  d: "M90.232 288.027s4.855 2.308 8.313 1.155c3.188-1.063 5.12.755 8.002 1.331 2.881.577 7.769 1.243 13.207-1.424-.117-6.228-7.786-4.499-13.518-7.588-2.895-1.56-4.276-5.336-4.066-9.944H91.544s-1.573 11.89-1.312 16.47",
  fill: "#CBD1D1"
}, null), $("path", {
  d: "M90.207 287.833s2.745 1.437 7.639.738c3.456-.494 3.223.66 7.418 1.282 4.195.621 13.092-.194 14.334-1.126.466 1.242-.388 2.33-.388 2.33s-1.709.682-5.438.932c-2.295.154-8.098.276-10.14-.621-2.02-1.554-4.894-1.515-6.06-.234-4.427 1.075-7.184-.31-7.184-.31l-.181-2.991z",
  fill: "#2B0849"
}, null), $("path", {
  d: "M98.429 272.257h3.496s-.117 7.574 5.127 9.671c-5.244.7-9.672-2.602-8.623-9.671",
  fill: "#A4AABA"
}, null), $("path", {
  d: "M44.425 272.046s-2.208 7.774-4.702 12.899c-1.884 3.874-4.428 7.854 5.729 7.854 6.97 0 9.385-.503 7.782-6.917-1.604-6.415.279-13.836.279-13.836h-9.088z",
  fill: "#CBD1D1"
}, null), $("path", {
  d: "M38.066 290.277s2.198 1.225 6.954 1.225c6.376 0 8.646-1.73 8.646-1.73s.63 1.168-.649 2.27c-1.04.897-3.77 1.668-7.745 1.621-4.347-.05-6.115-.593-7.062-1.224-.864-.577-.72-1.657-.144-2.162",
  fill: "#2B0849"
}, null), $("path", {
  d: "M45.344 274.041s.035 1.592-.329 3.07c-.365 1.49-1.13 3.255-1.184 4.34-.061 1.206 4.755 1.657 5.403.036.65-1.622 1.357-6.737 2.006-7.602.648-.865-5.14-2.222-5.896.156",
  fill: "#A4AABA"
}, null), $("path", {
  d: "M89.476 277.57l13.899.095s1.349-56.643 1.925-66.909c.576-10.267 3.923-45.052 1.042-65.585l-13.037-.669-23.737.81s-.452 4.12-1.243 10.365c-.065.515-.708.874-.777 1.417-.078.608.439 1.407.332 2.044-2.455 14.627-5.797 32.736-8.256 46.837-.121.693-1.282 1.048-1.515 2.796-.042.314.22 1.584.116 1.865-7.14 19.473-12.202 52.601-15.66 67.19l15.176-.015s2.282-10.145 4.185-18.871c2.922-13.389 24.012-88.32 24.012-88.32l3.133-.954-.158 48.568s-.233 1.282.35 2.098c.583.815-.581 1.167-.408 2.331l.408 1.864s-.466 7.458-.932 12.352c-.467 4.895 1.145 40.69 1.145 40.69",
  fill: "#7BB2F9"
}, null), $("path", {
  d: "M64.57 218.881c1.197.099 4.195-2.097 7.225-5.127M96.024 222.534s2.881-1.152 6.34-4.034",
  stroke: "#648BD8",
  "stroke-width": "1.085",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M96.973 219.373s2.882-1.153 6.34-4.034",
  stroke: "#648BD8",
  "stroke-width": "1.032",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M63.172 222.144s2.724-.614 6.759-3.496M74.903 146.166c-.281 3.226.31 8.856-4.506 9.478M93.182 144.344s.115 14.557-1.344 15.65c-2.305 1.73-3.107 2.02-3.107 2.02M89.197 144.923s.269 13.144-1.01 25.088M83.525 170.71s6.81-1.051 9.116-1.051M46.026 270.045l-.892 4.538M46.937 263.289l-.815 4.157M62.725 202.503c-.33 1.618-.102 1.904-.449 3.438 0 0-2.756 1.903-2.29 3.923.466 2.02-.31 3.424-4.505 17.252-1.762 5.807-4.233 18.922-6.165 28.278-.03.144-.521 2.646-1.14 5.8M64.158 194.136c-.295 1.658-.6 3.31-.917 4.938M71.33 146.787l-1.244 10.877s-1.14.155-.519 2.33c.117 1.399-2.778 16.39-5.382 31.615M44.242 273.727H58.07",
  stroke: "#648BD8",
  "stroke-width": "1.085",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M106.18 142.117c-3.028-.489-18.825-2.744-36.219.2a.625.625 0 0 0-.518.644c.063 1.307.044 2.343.015 2.995a.617.617 0 0 0 .716.636c3.303-.534 17.037-2.412 35.664-.266.347.04.66-.214.692-.56.124-1.347.16-2.425.17-3.029a.616.616 0 0 0-.52-.62",
  fill: "#192064"
}, null), $("path", {
  d: "M96.398 145.264l.003-5.102a.843.843 0 0 0-.809-.847 114.104 114.104 0 0 0-8.141-.014.85.85 0 0 0-.82.847l-.003 5.097c0 .476.388.857.864.845 2.478-.064 5.166-.067 8.03.017a.848.848 0 0 0 .876-.843",
  fill: "#FFF"
}, null), $("path", {
  d: "M95.239 144.296l.002-3.195a.667.667 0 0 0-.643-.672c-1.9-.061-3.941-.073-6.094-.01a.675.675 0 0 0-.654.672l-.002 3.192c0 .376.305.677.68.669 1.859-.042 3.874-.043 6.02.012.376.01.69-.291.691-.668",
  fill: "#192064"
}, null), $("path", {
  d: "M90.102 273.522h12.819M91.216 269.761c.006 3.519-.072 5.55 0 6.292M90.923 263.474c-.009 1.599-.016 2.558-.016 4.505M90.44 170.404l.932 46.38s.7 1.631-.233 2.796c-.932 1.166 2.564.7.932 2.33-1.63 1.633.933 1.166 0 3.497-.618 1.546-1.031 21.921-1.138 36.513",
  stroke: "#648BD8",
  "stroke-width": "1.085",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M73.736 98.665l2.214 4.312s2.098.816 1.865 2.68l.816 2.214M64.297 116.611c.233-.932 2.176-7.147 12.585-10.488M77.598 90.042s7.691 6.137 16.547 2.72",
  stroke: "#E4EBF7",
  "stroke-width": "1.085",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M91.974 86.954s5.476-.816 7.574-4.545c1.297-.345.72 2.212-.33 3.671-.7.971-1.01 1.554-1.01 1.554s.194.31.155.816c-.053.697-.175.653-.272 1.048-.081.335.108.657 0 1.049-.046.17-.198.5-.382.878-.12.249-.072.687-.2.948-.231.469-1.562 1.87-2.622 2.855-3.826 3.554-5.018 1.644-6.001-.408-.894-1.865-.661-5.127-.874-6.875-.35-2.914-2.622-3.03-1.923-4.429.343-.685 2.87.69 3.263 1.748.757 2.04 2.952 1.807 2.622 1.69",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M99.8 82.429c-.465.077-.35.272-.97 1.243-.622.971-4.817 2.932-6.39 3.224-2.589.48-2.278-1.56-4.254-2.855-1.69-1.107-3.562-.638-1.398 1.398.99.932.932 1.107 1.398 3.205.335 1.506-.64 3.67.7 5.593",
  stroke: "#DB836E",
  "stroke-width": ".774",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M79.543 108.673c-2.1 2.926-4.266 6.175-5.557 8.762",
  stroke: "#E59788",
  "stroke-width": ".774",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M87.72 124.768s-2.098-1.942-5.127-2.719c-3.03-.777-3.574-.155-5.516.078-1.942.233-3.885-.932-3.652.7.233 1.63 5.05 1.01 5.206 2.097.155 1.087-6.37 2.796-8.313 2.175-.777.777.466 1.864 2.02 2.175.233 1.554 2.253 1.554 2.253 1.554s.699 1.01 2.641 1.088c2.486 1.32 8.934-.7 10.954-1.554 2.02-.855-.466-5.594-.466-5.594",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M73.425 122.826s.66 1.127 3.167 1.418c2.315.27 2.563.583 2.563.583s-2.545 2.894-9.07 2.272M72.416 129.274s3.826.097 4.933-.718M74.98 130.75s1.961.136 3.36-.505M77.232 131.916s1.748.019 2.914-.505M73.328 122.321s-.595-1.032 1.262-.427c1.671.544 2.833.055 5.128.155 1.389.061 3.067-.297 3.982.15 1.606.784 3.632 2.181 3.632 2.181s10.526 1.204 19.033-1.127M78.864 108.104s-8.39 2.758-13.168 12.12",
  stroke: "#E59788",
  "stroke-width": ".774",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M109.278 112.533s3.38-3.613 7.575-4.662",
  stroke: "#E4EBF7",
  "stroke-width": "1.085",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M107.375 123.006s9.697-2.745 11.445-.88",
  stroke: "#E59788",
  "stroke-width": ".774",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M194.605 83.656l3.971-3.886M187.166 90.933l3.736-3.655M191.752 84.207l-4.462-4.56M198.453 91.057l-4.133-4.225M129.256 163.074l3.718-3.718M122.291 170.039l3.498-3.498M126.561 163.626l-4.27-4.27M132.975 170.039l-3.955-3.955",
  stroke: "#BFCDDD",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M190.156 211.779h-1.604a4.023 4.023 0 0 1-4.011-4.011V175.68a4.023 4.023 0 0 1 4.01-4.01h1.605a4.023 4.023 0 0 1 4.011 4.01v32.088a4.023 4.023 0 0 1-4.01 4.01",
  fill: "#A3B4C6"
}, null), $("path", {
  d: "M237.824 212.977a4.813 4.813 0 0 1-4.813 4.813h-86.636a4.813 4.813 0 0 1 0-9.626h86.636a4.813 4.813 0 0 1 4.813 4.813",
  fill: "#A3B4C6"
}, null), $("mask", {
  fill: "#fff"
}, null), $("path", {
  fill: "#A3B4C6",
  mask: "url(#d)",
  d: "M154.098 190.096h70.513v-84.617h-70.513z"
}, null), $("path", {
  d: "M224.928 190.096H153.78a3.219 3.219 0 0 1-3.208-3.209V167.92a3.219 3.219 0 0 1 3.208-3.21h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.219 3.219 0 0 1-3.21 3.209M224.928 130.832H153.78a3.218 3.218 0 0 1-3.208-3.208v-18.968a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.218 3.218 0 0 1-3.21 3.208",
  fill: "#BFCDDD",
  mask: "url(#d)"
}, null), $("path", {
  d: "M159.563 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 120.546h-22.461a.802.802 0 0 1-.802-.802v-3.208c0-.443.359-.803.802-.803h22.46c.444 0 .803.36.803.803v3.208c0 .443-.36.802-.802.802",
  fill: "#FFF",
  mask: "url(#d)"
}, null), $("path", {
  d: "M224.928 160.464H153.78a3.218 3.218 0 0 1-3.208-3.209v-18.967a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.209v18.967a3.218 3.218 0 0 1-3.21 3.209",
  fill: "#BFCDDD",
  mask: "url(#d)"
}, null), $("path", {
  d: "M173.455 130.832h49.301M164.984 130.832h6.089M155.952 130.832h6.75M173.837 160.613h49.3M165.365 160.613h6.089M155.57 160.613h6.751",
  stroke: "#7C90A5",
  "stroke-width": "1.124",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  mask: "url(#d)"
}, null), $("path", {
  d: "M159.563 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M166.98 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M174.397 151.038a2.407 2.407 0 1 1 .001-4.814 2.407 2.407 0 0 1 0 4.814M222.539 151.038h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802M159.563 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 179.987h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802",
  fill: "#FFF",
  mask: "url(#d)"
}, null), $("path", {
  d: "M203.04 221.108h-27.372a2.413 2.413 0 0 1-2.406-2.407v-11.448a2.414 2.414 0 0 1 2.406-2.407h27.372a2.414 2.414 0 0 1 2.407 2.407V218.7a2.413 2.413 0 0 1-2.407 2.407",
  fill: "#BFCDDD",
  mask: "url(#d)"
}, null), $("path", {
  d: "M177.259 207.217v11.52M201.05 207.217v11.52",
  stroke: "#A3B4C6",
  "stroke-width": "1.124",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  mask: "url(#d)"
}, null), $("path", {
  d: "M162.873 267.894a9.422 9.422 0 0 1-9.422-9.422v-14.82a9.423 9.423 0 0 1 18.845 0v14.82a9.423 9.423 0 0 1-9.423 9.422",
  fill: "#5BA02E",
  mask: "url(#d)"
}, null), $("path", {
  d: "M171.22 267.83a9.422 9.422 0 0 1-9.422-9.423v-3.438a9.423 9.423 0 0 1 18.845 0v3.438a9.423 9.423 0 0 1-9.422 9.423",
  fill: "#92C110",
  mask: "url(#d)"
}, null), $("path", {
  d: "M181.31 293.666h-27.712a3.209 3.209 0 0 1-3.209-3.21V269.79a3.209 3.209 0 0 1 3.209-3.21h27.711a3.209 3.209 0 0 1 3.209 3.21v20.668a3.209 3.209 0 0 1-3.209 3.209",
  fill: "#F2D7AD",
  mask: "url(#d)"
}, null)])]), Rje = () => $("svg", {
  width: "251",
  height: "294"
}, [$("g", {
  fill: "none",
  "fill-rule": "evenodd"
}, [$("path", {
  d: "M0 129.023v-2.084C0 58.364 55.591 2.774 124.165 2.774h2.085c68.574 0 124.165 55.59 124.165 124.165v2.084c0 68.575-55.59 124.166-124.165 124.166h-2.085C55.591 253.189 0 197.598 0 129.023",
  fill: "#E4EBF7"
}, null), $("path", {
  d: "M41.417 132.92a8.231 8.231 0 1 1-16.38-1.65 8.231 8.231 0 0 1 16.38 1.65",
  fill: "#FFF"
}, null), $("path", {
  d: "M38.652 136.36l10.425 5.91M49.989 148.505l-12.58 10.73",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), $("path", {
  d: "M41.536 161.28a5.636 5.636 0 1 1-11.216-1.13 5.636 5.636 0 0 1 11.216 1.13M59.154 145.261a5.677 5.677 0 1 1-11.297-1.138 5.677 5.677 0 0 1 11.297 1.138M100.36 29.516l29.66-.013a4.562 4.562 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 0 0 .005 9.126M111.705 47.754l29.659-.013a4.563 4.563 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 1 0 .005 9.126",
  fill: "#FFF"
}, null), $("path", {
  d: "M114.066 29.503V29.5l15.698-.007a4.563 4.563 0 1 0 .004 9.126l-15.698.007v-.002a4.562 4.562 0 0 0-.004-9.122M185.405 137.723c-.55 5.455-5.418 9.432-10.873 8.882-5.456-.55-9.432-5.418-8.882-10.873.55-5.455 5.418-9.432 10.873-8.882 5.455.55 9.432 5.418 8.882 10.873",
  fill: "#FFF"
}, null), $("path", {
  d: "M180.17 143.772l12.572 7.129M193.841 158.42L178.67 171.36",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), $("path", {
  d: "M185.55 171.926a6.798 6.798 0 1 1-13.528-1.363 6.798 6.798 0 0 1 13.527 1.363M204.12 155.285a6.848 6.848 0 1 1-13.627-1.375 6.848 6.848 0 0 1 13.626 1.375",
  fill: "#FFF"
}, null), $("path", {
  d: "M152.988 194.074a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0zM225.931 118.217a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM217.09 153.051a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.42 0zM177.84 109.842a2.21 2.21 0 1 1-4.422 0 2.21 2.21 0 0 1 4.421 0zM196.114 94.454a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM202.844 182.523a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0z",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), $("path", {
  stroke: "#FFF",
  "stroke-width": "2",
  d: "M215.125 155.262l-1.902 20.075-10.87 5.958M174.601 176.636l-6.322 9.761H156.98l-4.484 6.449M175.874 127.28V111.56M221.51 119.404l-12.77 7.859-15.228-7.86V96.668"
}, null), $("path", {
  d: "M180.68 29.32C180.68 13.128 193.806 0 210 0c16.193 0 29.32 13.127 29.32 29.32 0 16.194-13.127 29.322-29.32 29.322-16.193 0-29.32-13.128-29.32-29.321",
  fill: "#A26EF4"
}, null), $("path", {
  d: "M221.45 41.706l-21.563-.125a1.744 1.744 0 0 1-1.734-1.754l.071-12.23a1.744 1.744 0 0 1 1.754-1.734l21.562.125c.964.006 1.74.791 1.735 1.755l-.071 12.229a1.744 1.744 0 0 1-1.754 1.734",
  fill: "#FFF"
}, null), $("path", {
  d: "M215.106 29.192c-.015 2.577-2.049 4.654-4.543 4.64-2.494-.014-4.504-2.115-4.489-4.693l.04-6.925c.016-2.577 2.05-4.654 4.543-4.64 2.494.015 4.504 2.116 4.49 4.693l-.04 6.925zm-4.53-14.074a6.877 6.877 0 0 0-6.916 6.837l-.043 7.368a6.877 6.877 0 0 0 13.754.08l.042-7.368a6.878 6.878 0 0 0-6.837-6.917zM167.566 68.367h-3.93a4.73 4.73 0 0 1-4.717-4.717 4.73 4.73 0 0 1 4.717-4.717h3.93a4.73 4.73 0 0 1 4.717 4.717 4.73 4.73 0 0 1-4.717 4.717",
  fill: "#FFF"
}, null), $("path", {
  d: "M168.214 248.838a6.611 6.611 0 0 1-6.61-6.611v-66.108a6.611 6.611 0 0 1 13.221 0v66.108a6.611 6.611 0 0 1-6.61 6.61",
  fill: "#5BA02E"
}, null), $("path", {
  d: "M176.147 248.176a6.611 6.611 0 0 1-6.61-6.61v-33.054a6.611 6.611 0 1 1 13.221 0v33.053a6.611 6.611 0 0 1-6.61 6.611",
  fill: "#92C110"
}, null), $("path", {
  d: "M185.994 293.89h-27.376a3.17 3.17 0 0 1-3.17-3.17v-45.887a3.17 3.17 0 0 1 3.17-3.17h27.376a3.17 3.17 0 0 1 3.17 3.17v45.886a3.17 3.17 0 0 1-3.17 3.17",
  fill: "#F2D7AD"
}, null), $("path", {
  d: "M81.972 147.673s6.377-.927 17.566-1.28c11.729-.371 17.57 1.086 17.57 1.086s3.697-3.855.968-8.424c1.278-12.077 5.982-32.827.335-48.273-1.116-1.339-3.743-1.512-7.536-.62-1.337.315-7.147-.149-7.983-.1l-15.311-.347s-3.487-.17-8.035-.508c-1.512-.113-4.227-1.683-5.458-.338-.406.443-2.425 5.669-1.97 16.077l8.635 35.642s-3.141 3.61 1.219 7.085",
  fill: "#FFF"
}, null), $("path", {
  d: "M75.768 73.325l-.9-6.397 11.982-6.52s7.302-.118 8.038 1.205c.737 1.324-5.616.993-5.616.993s-1.836 1.388-2.615 2.5c-1.654 2.363-.986 6.471-8.318 5.986-1.708.284-2.57 2.233-2.57 2.233",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M52.44 77.672s14.217 9.406 24.973 14.444c1.061.497-2.094 16.183-11.892 11.811-7.436-3.318-20.162-8.44-21.482-14.496-.71-3.258 2.543-7.643 8.401-11.76M141.862 80.113s-6.693 2.999-13.844 6.876c-3.894 2.11-10.137 4.704-12.33 7.988-6.224 9.314 3.536 11.22 12.947 7.503 6.71-2.651 28.999-12.127 13.227-22.367",
  fill: "#FFB594"
}, null), $("path", {
  d: "M76.166 66.36l3.06 3.881s-2.783 2.67-6.31 5.747c-7.103 6.195-12.803 14.296-15.995 16.44-3.966 2.662-9.754 3.314-12.177-.118-3.553-5.032.464-14.628 31.422-25.95",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M64.674 85.116s-2.34 8.413-8.912 14.447c.652.548 18.586 10.51 22.144 10.056 5.238-.669 6.417-18.968 1.145-20.531-.702-.208-5.901-1.286-8.853-2.167-.87-.26-1.611-1.71-3.545-.936l-1.98-.869zM128.362 85.826s5.318 1.956 7.325 13.734c-.546.274-17.55 12.35-21.829 7.805-6.534-6.94-.766-17.393 4.275-18.61 4.646-1.121 5.03-1.37 10.23-2.929",
  fill: "#FFF"
}, null), $("path", {
  d: "M78.18 94.656s.911 7.41-4.914 13.078",
  stroke: "#E4EBF7",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M87.397 94.68s3.124 2.572 10.263 2.572c7.14 0 9.074-3.437 9.074-3.437",
  stroke: "#E4EBF7",
  "stroke-width": ".932",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M117.184 68.639l-6.781-6.177s-5.355-4.314-9.223-.893c-3.867 3.422 4.463 2.083 5.653 4.165 1.19 2.082.848 1.143-2.083.446-5.603-1.331-2.082.893 2.975 5.355 2.091 1.845 6.992.955 6.992.955l2.467-3.851z",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M105.282 91.315l-.297-10.937-15.918-.027-.53 10.45c-.026.403.17.788.515.999 2.049 1.251 9.387 5.093 15.799.424.287-.21.443-.554.431-.91",
  fill: "#FFB594"
}, null), $("path", {
  d: "M107.573 74.24c.817-1.147.982-9.118 1.015-11.928a1.046 1.046 0 0 0-.965-1.055l-4.62-.365c-7.71-1.044-17.071.624-18.253 6.346-5.482 5.813-.421 13.244-.421 13.244s1.963 3.566 4.305 6.791c.756 1.041.398-3.731 3.04-5.929 5.524-4.594 15.899-7.103 15.899-7.103",
  fill: "#5C2552"
}, null), $("path", {
  d: "M88.426 83.206s2.685 6.202 11.602 6.522c7.82.28 8.973-7.008 7.434-17.505l-.909-5.483c-6.118-2.897-15.478.54-15.478.54s-.576 2.044-.19 5.504c-2.276 2.066-1.824 5.618-1.824 5.618s-.905-1.922-1.98-2.321c-.86-.32-1.897.089-2.322 1.98-1.04 4.632 3.667 5.145 3.667 5.145",
  fill: "#FFC6A0"
}, null), $("path", {
  stroke: "#DB836E",
  "stroke-width": "1.145",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  d: "M100.843 77.099l1.701-.928-1.015-4.324.674-1.406"
}, null), $("path", {
  d: "M105.546 74.092c-.022.713-.452 1.279-.96 1.263-.51-.016-.904-.607-.882-1.32.021-.713.452-1.278.96-1.263.51.016.904.607.882 1.32M97.592 74.349c-.022.713-.452 1.278-.961 1.263-.509-.016-.904-.607-.882-1.32.022-.713.452-1.279.961-1.263.51.016.904.606.882 1.32",
  fill: "#552950"
}, null), $("path", {
  d: "M91.132 86.786s5.269 4.957 12.679 2.327",
  stroke: "#DB836E",
  "stroke-width": "1.145",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M99.776 81.903s-3.592.232-1.44-2.79c1.59-1.496 4.897-.46 4.897-.46s1.156 3.906-3.457 3.25",
  fill: "#DB836E"
}, null), $("path", {
  d: "M102.88 70.6s2.483.84 3.402.715M93.883 71.975s2.492-1.144 4.778-1.073",
  stroke: "#5C2552",
  "stroke-width": "1.526",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M86.32 77.374s.961.879 1.458 2.106c-.377.48-1.033 1.152-.236 1.809M99.337 83.719s1.911.151 2.509-.254",
  stroke: "#DB836E",
  "stroke-width": "1.145",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M87.782 115.821l15.73-3.012M100.165 115.821l10.04-2.008",
  stroke: "#E4EBF7",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M66.508 86.763s-1.598 8.83-6.697 14.078",
  stroke: "#E4EBF7",
  "stroke-width": "1.114",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M128.31 87.934s3.013 4.121 4.06 11.785",
  stroke: "#E4EBF7",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M64.09 84.816s-6.03 9.912-13.607 9.903",
  stroke: "#DB836E",
  "stroke-width": ".795",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M112.366 65.909l-.142 5.32s5.993 4.472 11.945 9.202c4.482 3.562 8.888 7.455 10.985 8.662 4.804 2.766 8.9 3.355 11.076 1.808 4.071-2.894 4.373-9.878-8.136-15.263-4.271-1.838-16.144-6.36-25.728-9.73",
  fill: "#FFC6A0"
}, null), $("path", {
  d: "M130.532 85.488s4.588 5.757 11.619 6.214",
  stroke: "#DB836E",
  "stroke-width": ".75",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M121.708 105.73s-.393 8.564-1.34 13.612",
  stroke: "#E4EBF7",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M115.784 161.512s-3.57-1.488-2.678-7.14",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M101.52 290.246s4.326 2.057 7.408 1.03c2.842-.948 4.564.673 7.132 1.186 2.57.514 6.925 1.108 11.772-1.269-.104-5.551-6.939-4.01-12.048-6.763-2.582-1.39-3.812-4.757-3.625-8.863h-9.471s-1.402 10.596-1.169 14.68",
  fill: "#CBD1D1"
}, null), $("path", {
  d: "M101.496 290.073s2.447 1.281 6.809.658c3.081-.44 3.74.485 7.479 1.039 3.739.554 10.802-.07 11.91-.9.415 1.108-.347 2.077-.347 2.077s-1.523.608-4.847.831c-2.045.137-5.843.293-7.663-.507-1.8-1.385-5.286-1.917-5.77-.243-3.947.958-7.41-.288-7.41-.288l-.16-2.667z",
  fill: "#2B0849"
}, null), $("path", {
  d: "M108.824 276.19h3.116s-.103 6.751 4.57 8.62c-4.673.624-8.62-2.32-7.686-8.62",
  fill: "#A4AABA"
}, null), $("path", {
  d: "M57.65 272.52s-2.122 7.47-4.518 12.396c-1.811 3.724-4.255 7.548 5.505 7.548 6.698 0 9.02-.483 7.479-6.648-1.541-6.164.268-13.296.268-13.296H57.65z",
  fill: "#CBD1D1"
}, null), $("path", {
  d: "M51.54 290.04s2.111 1.178 6.682 1.178c6.128 0 8.31-1.662 8.31-1.662s.605 1.122-.624 2.18c-1 .862-3.624 1.603-7.444 1.559-4.177-.049-5.876-.57-6.786-1.177-.831-.554-.692-1.593-.138-2.078",
  fill: "#2B0849"
}, null), $("path", {
  d: "M58.533 274.438s.034 1.529-.315 2.95c-.352 1.431-1.087 3.127-1.139 4.17-.058 1.16 4.57 1.592 5.194.035.623-1.559 1.303-6.475 1.927-7.306.622-.831-4.94-2.135-5.667.15",
  fill: "#A4AABA"
}, null), $("path", {
  d: "M100.885 277.015l13.306.092s1.291-54.228 1.843-64.056c.552-9.828 3.756-43.13.997-62.788l-12.48-.64-22.725.776s-.433 3.944-1.19 9.921c-.062.493-.677.838-.744 1.358-.075.582.42 1.347.318 1.956-2.35 14.003-6.343 32.926-8.697 46.425-.116.663-1.227 1.004-1.45 2.677-.04.3.21 1.516.112 1.785-6.836 18.643-10.89 47.584-14.2 61.551l14.528-.014s2.185-8.524 4.008-16.878c2.796-12.817 22.987-84.553 22.987-84.553l3-.517 1.037 46.1s-.223 1.228.334 2.008c.558.782-.556 1.117-.39 2.233l.39 1.784s-.446 7.14-.892 11.826c-.446 4.685-.092 38.954-.092 38.954",
  fill: "#7BB2F9"
}, null), $("path", {
  d: "M77.438 220.434c1.146.094 4.016-2.008 6.916-4.91M107.55 223.931s2.758-1.103 6.069-3.862",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M108.459 220.905s2.759-1.104 6.07-3.863",
  stroke: "#648BD8",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M76.099 223.557s2.608-.587 6.47-3.346M87.33 150.82c-.27 3.088.297 8.478-4.315 9.073M104.829 149.075s.11 13.936-1.286 14.983c-2.207 1.655-2.975 1.934-2.975 1.934M101.014 149.63s.035 12.81-1.19 24.245M94.93 174.965s7.174-1.655 9.38-1.655M75.671 204.754c-.316 1.55-.64 3.067-.973 4.535 0 0-1.45 1.822-1.003 3.756.446 1.934-.943 2.034-4.96 15.273-1.686 5.559-4.464 18.49-6.313 27.447-.078.38-4.018 18.06-4.093 18.423M77.043 196.743a313.269 313.269 0 0 1-.877 4.729M83.908 151.414l-1.19 10.413s-1.091.148-.496 2.23c.111 1.34-2.66 15.692-5.153 30.267M57.58 272.94h13.238",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), $("path", {
  d: "M117.377 147.423s-16.955-3.087-35.7.199c.157 2.501-.002 4.128-.002 4.128s14.607-2.802 35.476-.31c.251-2.342.226-4.017.226-4.017",
  fill: "#192064"
}, null), $("path", {
  d: "M107.511 150.353l.004-4.885a.807.807 0 0 0-.774-.81c-2.428-.092-5.04-.108-7.795-.014a.814.814 0 0 0-.784.81l-.003 4.88c0 .456.371.82.827.808a140.76 140.76 0 0 1 7.688.017.81.81 0 0 0 .837-.806",
  fill: "#FFF"
}, null), $("path", {
  d: "M106.402 149.426l.002-3.06a.64.64 0 0 0-.616-.643 94.135 94.135 0 0 0-5.834-.009.647.647 0 0 0-.626.643l-.001 3.056c0 .36.291.648.651.64 1.78-.04 3.708-.041 5.762.012.36.009.662-.279.662-.64",
  fill: "#192064"
}, null), $("path", {
  d: "M101.485 273.933h12.272M102.652 269.075c.006 3.368.04 5.759.11 6.47M102.667 263.125c-.009 1.53-.015 2.98-.016 4.313M102.204 174.024l.893 44.402s.669 1.561-.224 2.677c-.892 1.116 2.455.67.893 2.231-1.562 1.562.893 1.116 0 3.347-.592 1.48-.988 20.987-1.09 34.956",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null)])]), Dje = (e) => {
  const {
    componentCls: t,
    lineHeightHeading3: n,
    iconCls: o,
    padding: l,
    paddingXL: r,
    paddingXS: a,
    paddingLG: i,
    marginXS: s,
    lineHeight: c
  } = e;
  return {
    // Result
    [t]: {
      padding: `${i * 2}px ${r}px`,
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    },
    // Exception Status image
    [`${t} ${t}-image`]: {
      width: e.imageWidth,
      height: e.imageHeight,
      margin: "auto"
    },
    [`${t} ${t}-icon`]: {
      marginBottom: i,
      textAlign: "center",
      [`& > ${o}`]: {
        fontSize: e.resultIconFontSize
      }
    },
    [`${t} ${t}-title`]: {
      color: e.colorTextHeading,
      fontSize: e.resultTitleFontSize,
      lineHeight: n,
      marginBlock: s,
      textAlign: "center"
    },
    [`${t} ${t}-subtitle`]: {
      color: e.colorTextDescription,
      fontSize: e.resultSubtitleFontSize,
      lineHeight: c,
      textAlign: "center"
    },
    [`${t} ${t}-content`]: {
      marginTop: i,
      padding: `${i}px ${l * 2.5}px`,
      backgroundColor: e.colorFillAlter
    },
    [`${t} ${t}-extra`]: {
      margin: e.resultExtraMargin,
      textAlign: "center",
      "& > *": {
        marginInlineEnd: a,
        "&:last-child": {
          marginInlineEnd: 0
        }
      }
    }
  };
}, Lje = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [`${t}-success ${t}-icon > ${n}`]: {
      color: e.resultSuccessIconColor
    },
    [`${t}-error ${t}-icon > ${n}`]: {
      color: e.resultErrorIconColor
    },
    [`${t}-info ${t}-icon > ${n}`]: {
      color: e.resultInfoIconColor
    },
    [`${t}-warning ${t}-icon > ${n}`]: {
      color: e.resultWarningIconColor
    }
  };
}, Bje = (e) => [Dje(e), Lje(e)], Fje = (e) => Bje(e), Vje = Zt("Result", (e) => {
  const {
    paddingLG: t,
    fontSizeHeading3: n
  } = e, o = e.fontSize, l = `${t}px 0 0 0`, r = e.colorInfo, a = e.colorError, i = e.colorSuccess, s = e.colorWarning, c = Vt(e, {
    resultTitleFontSize: n,
    resultSubtitleFontSize: o,
    resultIconFontSize: n * 3,
    resultExtraMargin: l,
    resultInfoIconColor: r,
    resultErrorIconColor: a,
    resultSuccessIconColor: i,
    resultWarningIconColor: s
  });
  return [Fje(c)];
}, {
  imageWidth: 250,
  imageHeight: 295
}), zje = {
  success: Za,
  error: jl,
  info: Qa,
  warning: hP
}, Vh = {
  404: Mje,
  500: Aje,
  403: Rje
}, Hje = Object.keys(Vh), jje = () => ({
  prefixCls: String,
  icon: de.any,
  status: {
    type: [Number, String],
    default: "info"
  },
  title: de.any,
  subTitle: de.any,
  extra: de.any
}), Wje = (e, t) => {
  let {
    status: n,
    icon: o
  } = t;
  if (Hje.includes(`${n}`)) {
    const a = Vh[n];
    return $("div", {
      class: `${e}-icon ${e}-image`
    }, [$(a, null, null)]);
  }
  const l = zje[n], r = o || $(l, null, null);
  return $("div", {
    class: `${e}-icon`
  }, [r]);
}, Kje = (e, t) => t && $("div", {
  class: `${e}-extra`
}, [t]), Ru = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AResult",
  inheritAttrs: !1,
  props: jje(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("result", e), [a, i] = Vje(l), s = O(() => ke(l.value, i.value, `${l.value}-${e.status}`, {
      [`${l.value}-rtl`]: r.value === "rtl"
    }));
    return () => {
      var c, u, d, f, p, m, v, h;
      const g = (c = e.title) !== null && c !== void 0 ? c : (u = n.title) === null || u === void 0 ? void 0 : u.call(n), y = (d = e.subTitle) !== null && d !== void 0 ? d : (f = n.subTitle) === null || f === void 0 ? void 0 : f.call(n), b = (p = e.icon) !== null && p !== void 0 ? p : (m = n.icon) === null || m === void 0 ? void 0 : m.call(n), C = (v = e.extra) !== null && v !== void 0 ? v : (h = n.extra) === null || h === void 0 ? void 0 : h.call(n), w = l.value;
      return a($("div", Q(Q({}, o), {}, {
        class: [s.value, o.class]
      }), [Wje(w, {
        status: e.status,
        icon: b
      }), $("div", {
        class: `${w}-title`
      }, [g]), y && $("div", {
        class: `${w}-subtitle`
      }, [y]), Kje(w, C), n.default && $("div", {
        class: `${w}-content`
      }, [n.default()])]));
    };
  }
});
Ru.PRESENTED_IMAGE_403 = Vh[403];
Ru.PRESENTED_IMAGE_404 = Vh[404];
Ru.PRESENTED_IMAGE_500 = Vh[500];
Ru.install = function(e) {
  return e.component(Ru.name, Ru), e;
};
const Uje = po(VT), gP = (e, t) => {
  let {
    attrs: n
  } = t;
  const {
    included: o,
    vertical: l,
    style: r,
    class: a
  } = n;
  let {
    length: i,
    offset: s,
    reverse: c
  } = n;
  i < 0 && (c = !c, i = Math.abs(i), s = 100 - s);
  const u = l ? {
    [c ? "top" : "bottom"]: `${s}%`,
    [c ? "bottom" : "top"]: "auto",
    height: `${i}%`
  } : {
    [c ? "right" : "left"]: `${s}%`,
    [c ? "left" : "right"]: "auto",
    width: `${i}%`
  }, d = _(_({}, r), u);
  return o ? $("div", {
    class: a,
    style: d
  }, null) : null;
};
gP.inheritAttrs = !1;
const Gje = (e, t, n, o, l, r) => {
  Hn(n ? o > 0 : !0, "Slider", "`Slider[step]` should be a positive number in order to make Slider[dots] work.");
  const a = Object.keys(t).map(parseFloat).sort((i, s) => i - s);
  if (n && o)
    for (let i = l; i <= r; i += o)
      a.indexOf(i) === -1 && a.push(i);
  return a;
}, uG = (e, t) => {
  let {
    attrs: n
  } = t;
  const {
    prefixCls: o,
    vertical: l,
    reverse: r,
    marks: a,
    dots: i,
    step: s,
    included: c,
    lowerBound: u,
    upperBound: d,
    max: f,
    min: p,
    dotStyle: m,
    activeDotStyle: v
  } = n, h = f - p, g = Gje(l, a, i, s, p, f).map((y) => {
    const b = `${Math.abs(y - p) / h * 100}%`, C = !c && y === d || c && y <= d && y >= u;
    let w = l ? _(_({}, m), {
      [r ? "top" : "bottom"]: b
    }) : _(_({}, m), {
      [r ? "right" : "left"]: b
    });
    C && (w = _(_({}, w), v));
    const x = ke({
      [`${o}-dot`]: !0,
      [`${o}-dot-active`]: C,
      [`${o}-dot-reverse`]: r
    });
    return $("span", {
      class: x,
      style: w,
      key: y
    }, null);
  });
  return $("div", {
    class: `${o}-step`
  }, [g]);
};
uG.inheritAttrs = !1;
const dG = (e, t) => {
  let {
    attrs: n,
    slots: o
  } = t;
  const {
    class: l,
    vertical: r,
    reverse: a,
    marks: i,
    included: s,
    upperBound: c,
    lowerBound: u,
    max: d,
    min: f,
    onClickLabel: p
  } = n, m = Object.keys(i), v = o.mark, h = d - f, g = m.map(parseFloat).sort((y, b) => y - b).map((y) => {
    const b = typeof i[y] == "function" ? i[y]() : i[y], C = typeof b == "object" && !Io(b);
    let w = C ? b.label : b;
    if (!w && w !== 0)
      return null;
    v && (w = v({
      point: y,
      label: w
    }));
    const x = !s && y === c || s && y <= c && y >= u, E = ke({
      [`${l}-text`]: !0,
      [`${l}-text-active`]: x
    }), I = {
      marginBottom: "-50%",
      [a ? "top" : "bottom"]: `${(y - f) / h * 100}%`
    }, T = {
      transform: `translateX(${a ? "50%" : "-50%"})`,
      msTransform: `translateX(${a ? "50%" : "-50%"})`,
      [a ? "right" : "left"]: `${(y - f) / h * 100}%`
    }, P = r ? I : T, k = C ? _(_({}, P), b.style) : P, N = {
      [Ho ? "onTouchstartPassive" : "onTouchstart"]: (R) => p(R, y)
    };
    return $("span", Q({
      class: E,
      style: k,
      key: y,
      onMousedown: (R) => p(R, y)
    }, N), [w]);
  });
  return $("div", {
    class: l
  }, [g]);
};
dG.inheritAttrs = !1;
const fG = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Handle",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    vertical: {
      type: Boolean,
      default: void 0
    },
    offset: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    value: Number,
    tabindex: de.oneOfType([de.number, de.string]),
    reverse: {
      type: Boolean,
      default: void 0
    },
    ariaLabel: String,
    ariaLabelledBy: String,
    ariaValueTextFormatter: Function,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onMousedown: {
      type: Function
    }
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      expose: l
    } = t;
    const r = /* @__PURE__ */ Ce(!1), a = /* @__PURE__ */ Ce(), i = () => {
      document.activeElement === a.value && (r.value = !0);
    }, s = (h) => {
      r.value = !1, o("blur", h);
    }, c = () => {
      r.value = !1;
    }, u = () => {
      var h;
      (h = a.value) === null || h === void 0 || h.focus();
    }, d = () => {
      var h;
      (h = a.value) === null || h === void 0 || h.blur();
    }, f = () => {
      r.value = !0, u();
    }, p = (h) => {
      h.preventDefault(), u(), o("mousedown", h);
    };
    l({
      focus: u,
      blur: d,
      clickFocus: f,
      ref: a
    });
    let m = null;
    nt(() => {
      m = vo(document, "mouseup", i);
    }), yt(() => {
      m == null || m.remove();
    });
    const v = O(() => {
      const {
        vertical: h,
        offset: g,
        reverse: y
      } = e;
      return h ? {
        [y ? "top" : "bottom"]: `${g}%`,
        [y ? "bottom" : "top"]: "auto",
        transform: y ? null : "translateY(+50%)"
      } : {
        [y ? "right" : "left"]: `${g}%`,
        [y ? "left" : "right"]: "auto",
        transform: `translateX(${y ? "+" : "-"}50%)`
      };
    });
    return () => {
      const {
        prefixCls: h,
        disabled: g,
        min: y,
        max: b,
        value: C,
        tabindex: w,
        ariaLabel: x,
        ariaLabelledBy: E,
        ariaValueTextFormatter: I,
        onMouseenter: T,
        onMouseleave: P
      } = e, k = ke(n.class, {
        [`${h}-handle-click-focused`]: r.value
      }), N = {
        "aria-valuemin": y,
        "aria-valuemax": b,
        "aria-valuenow": C,
        "aria-disabled": !!g
      }, R = [n.style, v.value];
      let z = w || 0;
      (g || w === null) && (z = null);
      let D;
      I && (D = I(C));
      const F = _(_(_(_({}, n), {
        role: "slider",
        tabindex: z
      }), N), {
        class: k,
        onBlur: s,
        onKeydown: c,
        onMousedown: p,
        onMouseenter: T,
        onMouseleave: P,
        ref: a,
        style: R
      });
      return $("div", Q(Q({}, F), {}, {
        "aria-label": x,
        "aria-labelledby": E,
        "aria-valuetext": D
      }), null);
    };
  }
});
function o$(e, t) {
  try {
    return Object.keys(t).some((n) => e.target === t[n].ref);
  } catch (n) {
    return !1;
  }
}
function pG(e, t) {
  let {
    min: n,
    max: o
  } = t;
  return e < n || e > o;
}
function oR(e) {
  return e.touches.length > 1 || e.type.toLowerCase() === "touchend" && e.touches.length > 0;
}
function lR(e, t) {
  let {
    marks: n,
    step: o,
    min: l,
    max: r
  } = t;
  const a = Object.keys(n).map(parseFloat);
  if (o !== null) {
    const s = Math.pow(10, vG(o)), c = Math.floor((r * s - l * s) / (o * s)), u = Math.min((e - l) / o, c), d = Math.round(u) * o + l;
    a.push(d);
  }
  const i = a.map((s) => Math.abs(e - s));
  return a[i.indexOf(Math.min(...i))];
}
function vG(e) {
  const t = e.toString();
  let n = 0;
  return t.indexOf(".") >= 0 && (n = t.length - t.indexOf(".") - 1), n;
}
function rR(e, t) {
  let n = 1;
  return window.visualViewport && (n = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(2)), (e ? t.clientY : t.pageX) / n;
}
function aR(e, t) {
  let n = 1;
  return window.visualViewport && (n = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(2)), (e ? t.touches[0].clientY : t.touches[0].pageX) / n;
}
function iR(e, t) {
  const n = t.getBoundingClientRect();
  return e ? n.top + n.height * 0.5 : window.scrollX + n.left + n.width * 0.5;
}
function bP(e, t) {
  let {
    max: n,
    min: o
  } = t;
  return e <= o ? o : e >= n ? n : e;
}
function mG(e, t) {
  const {
    step: n
  } = t, o = isFinite(lR(e, t)) ? lR(e, t) : 0;
  return n === null ? o : parseFloat(o.toFixed(vG(n)));
}
function up(e) {
  e.stopPropagation(), e.preventDefault();
}
function Yje(e, t, n) {
  const o = {
    increase: (a, i) => a + i,
    decrease: (a, i) => a - i
  }, l = o[e](Object.keys(n.marks).indexOf(JSON.stringify(t)), 1), r = Object.keys(n.marks)[l];
  return n.step ? o[e](t, n.step) : Object.keys(n.marks).length && n.marks[r] ? n.marks[r] : t;
}
function hG(e, t, n) {
  const o = "increase", l = "decrease";
  let r = o;
  switch (e.keyCode) {
    case ot.UP:
      r = t && n ? l : o;
      break;
    case ot.RIGHT:
      r = !t && n ? l : o;
      break;
    case ot.DOWN:
      r = t && n ? o : l;
      break;
    case ot.LEFT:
      r = !t && n ? o : l;
      break;
    case ot.END:
      return (a, i) => i.max;
    case ot.HOME:
      return (a, i) => i.min;
    case ot.PAGE_UP:
      return (a, i) => a + i.step * 2;
    case ot.PAGE_DOWN:
      return (a, i) => a - i.step * 2;
    default:
      return;
  }
  return (a, i) => Yje(r, a, i);
}
var Xje = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function qc() {
}
function gG(e) {
  const t = {
    id: String,
    min: Number,
    max: Number,
    step: Number,
    marks: de.object,
    included: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    handle: Function,
    dots: {
      type: Boolean,
      default: void 0
    },
    vertical: {
      type: Boolean,
      default: void 0
    },
    reverse: {
      type: Boolean,
      default: void 0
    },
    minimumTrackStyle: de.object,
    maximumTrackStyle: de.object,
    handleStyle: de.oneOfType([de.object, de.arrayOf(de.object)]),
    trackStyle: de.oneOfType([de.object, de.arrayOf(de.object)]),
    railStyle: de.object,
    dotStyle: de.object,
    activeDotStyle: de.object,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    draggableTrack: {
      type: Boolean,
      default: void 0
    }
  };
  return /* @__PURE__ */ le({
    compatConfig: {
      MODE: 3
    },
    name: "CreateSlider",
    mixins: [dd, e],
    inheritAttrs: !1,
    props: sn(t, {
      prefixCls: "rc-slider",
      min: 0,
      max: 100,
      step: 1,
      marks: {},
      included: !0,
      disabled: !1,
      dots: !1,
      vertical: !1,
      reverse: !1,
      trackStyle: [{}],
      handleStyle: [{}],
      railStyle: {},
      dotStyle: {},
      activeDotStyle: {}
    }),
    emits: ["change", "blur", "focus"],
    data() {
      const {
        step: n,
        max: o,
        min: l
      } = this, r = isFinite(o - l) ? (o - l) % n === 0 : !0;
      return Hn(n && Math.floor(n) === n ? r : !0, `Slider[max] - Slider[min] (${o - l}) should be a multiple of Slider[step] (${n})`), this.handlesRefs = {}, {};
    },
    mounted() {
      this.$nextTick(() => {
        this.document = this.sliderRef && this.sliderRef.ownerDocument;
        const {
          autofocus: n,
          disabled: o
        } = this;
        n && !o && this.focus();
      });
    },
    beforeUnmount() {
      this.$nextTick(() => {
        this.removeDocumentEvents();
      });
    },
    methods: {
      defaultHandle(n) {
        var {
          index: o,
          directives: l,
          className: r,
          style: a
        } = n, i = Xje(n, ["index", "directives", "className", "style"]);
        if (delete i.dragging, i.value === null)
          return null;
        const s = _(_({}, i), {
          class: r,
          style: a,
          key: o
        });
        return $(fG, s, null);
      },
      onDown(n, o) {
        let l = o;
        const {
          draggableTrack: r,
          vertical: a
        } = this.$props, {
          bounds: i
        } = this.$data, s = r && this.positionGetValue ? this.positionGetValue(l) || [] : [], c = o$(n, this.handlesRefs);
        if (this.dragTrack = r && i.length >= 2 && !c && !s.map((u, d) => {
          const f = d ? !0 : u >= i[d];
          return d === s.length - 1 ? u <= i[d] : f;
        }).some((u) => !u), this.dragTrack)
          this.dragOffset = l, this.startBounds = [...i];
        else {
          if (!c)
            this.dragOffset = 0;
          else {
            const u = iR(a, n.target);
            this.dragOffset = l - u, l = u;
          }
          this.onStart(l);
        }
      },
      onMouseDown(n) {
        if (n.button !== 0)
          return;
        this.removeDocumentEvents();
        const o = this.$props.vertical, l = rR(o, n);
        this.onDown(n, l), this.addDocumentMouseEvents();
      },
      onTouchStart(n) {
        if (oR(n)) return;
        const o = this.vertical, l = aR(o, n);
        this.onDown(n, l), this.addDocumentTouchEvents(), up(n);
      },
      onFocus(n) {
        const {
          vertical: o
        } = this;
        if (o$(n, this.handlesRefs) && !this.dragTrack) {
          const l = iR(o, n.target);
          this.dragOffset = 0, this.onStart(l), up(n), this.$emit("focus", n);
        }
      },
      onBlur(n) {
        this.dragTrack || this.onEnd(), this.$emit("blur", n);
      },
      onMouseUp() {
        this.handlesRefs[this.prevMovedHandleIndex] && this.handlesRefs[this.prevMovedHandleIndex].clickFocus();
      },
      onMouseMove(n) {
        if (!this.sliderRef) {
          this.onEnd();
          return;
        }
        const o = rR(this.vertical, n);
        this.onMove(n, o - this.dragOffset, this.dragTrack, this.startBounds);
      },
      onTouchMove(n) {
        if (oR(n) || !this.sliderRef) {
          this.onEnd();
          return;
        }
        const o = aR(this.vertical, n);
        this.onMove(n, o - this.dragOffset, this.dragTrack, this.startBounds);
      },
      onKeyDown(n) {
        this.sliderRef && o$(n, this.handlesRefs) && this.onKeyboard(n);
      },
      onClickMarkLabel(n, o) {
        n.stopPropagation(), this.onChange({
          sValue: o
        }), this.setState({
          sValue: o
        }, () => this.onEnd(!0));
      },
      getSliderStart() {
        const n = this.sliderRef, {
          vertical: o,
          reverse: l
        } = this, r = n.getBoundingClientRect();
        return o ? l ? r.bottom : r.top : window.scrollX + (l ? r.right : r.left);
      },
      getSliderLength() {
        const n = this.sliderRef;
        if (!n)
          return 0;
        const o = n.getBoundingClientRect();
        return this.vertical ? o.height : o.width;
      },
      addDocumentTouchEvents() {
        this.onTouchMoveListener = vo(this.document, "touchmove", this.onTouchMove), this.onTouchUpListener = vo(this.document, "touchend", this.onEnd);
      },
      addDocumentMouseEvents() {
        this.onMouseMoveListener = vo(this.document, "mousemove", this.onMouseMove), this.onMouseUpListener = vo(this.document, "mouseup", this.onEnd);
      },
      removeDocumentEvents() {
        this.onTouchMoveListener && this.onTouchMoveListener.remove(), this.onTouchUpListener && this.onTouchUpListener.remove(), this.onMouseMoveListener && this.onMouseMoveListener.remove(), this.onMouseUpListener && this.onMouseUpListener.remove();
      },
      focus() {
        var n;
        this.$props.disabled || (n = this.handlesRefs[0]) === null || n === void 0 || n.focus();
      },
      blur() {
        this.$props.disabled || Object.keys(this.handlesRefs).forEach((n) => {
          var o, l;
          (l = (o = this.handlesRefs[n]) === null || o === void 0 ? void 0 : o.blur) === null || l === void 0 || l.call(o);
        });
      },
      calcValue(n) {
        const {
          vertical: o,
          min: l,
          max: r
        } = this, a = Math.abs(Math.max(n, 0) / this.getSliderLength());
        return o ? (1 - a) * (r - l) + l : a * (r - l) + l;
      },
      calcValueByPos(n) {
        const l = (this.reverse ? -1 : 1) * (n - this.getSliderStart());
        return this.trimAlignValue(this.calcValue(l));
      },
      calcOffset(n) {
        const {
          min: o,
          max: l
        } = this, r = (n - o) / (l - o);
        return Math.max(0, r * 100);
      },
      saveSlider(n) {
        this.sliderRef = n;
      },
      saveHandle(n, o) {
        this.handlesRefs[n] = o;
      }
    },
    render() {
      const {
        prefixCls: n,
        marks: o,
        dots: l,
        step: r,
        included: a,
        disabled: i,
        vertical: s,
        reverse: c,
        min: u,
        max: d,
        maximumTrackStyle: f,
        railStyle: p,
        dotStyle: m,
        activeDotStyle: v,
        id: h
      } = this, {
        class: g,
        style: y
      } = this.$attrs, {
        tracks: b,
        handles: C
      } = this.renderSlider(), w = ke(n, g, {
        [`${n}-with-marks`]: Object.keys(o).length,
        [`${n}-disabled`]: i,
        [`${n}-vertical`]: s,
        [`${n}-horizontal`]: !s
      }), x = {
        vertical: s,
        marks: o,
        included: a,
        lowerBound: this.getLowerBound(),
        upperBound: this.getUpperBound(),
        max: d,
        min: u,
        reverse: c,
        class: `${n}-mark`,
        onClickLabel: i ? qc : this.onClickMarkLabel
      }, E = {
        [Ho ? "onTouchstartPassive" : "onTouchstart"]: i ? qc : this.onTouchStart
      };
      return $("div", Q(Q({
        id: h,
        ref: this.saveSlider,
        tabindex: "-1",
        class: w
      }, E), {}, {
        onMousedown: i ? qc : this.onMouseDown,
        onMouseup: i ? qc : this.onMouseUp,
        onKeydown: i ? qc : this.onKeyDown,
        onFocus: i ? qc : this.onFocus,
        onBlur: i ? qc : this.onBlur,
        style: y
      }), [$("div", {
        class: `${n}-rail`,
        style: _(_({}, f), p)
      }, null), b, $(uG, {
        prefixCls: n,
        vertical: s,
        reverse: c,
        marks: o,
        dots: l,
        step: r,
        included: a,
        lowerBound: this.getLowerBound(),
        upperBound: this.getUpperBound(),
        max: d,
        min: u,
        dotStyle: m,
        activeDotStyle: v
      }, null), C, $(dG, x, {
        mark: this.$slots.mark
      }), nS(this)]);
    }
  });
}
const qje = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Slider",
  mixins: [dd],
  inheritAttrs: !1,
  props: {
    defaultValue: Number,
    value: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    tabindex: de.oneOfType([de.number, de.string]),
    reverse: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    ariaLabelForHandle: String,
    ariaLabelledByForHandle: String,
    ariaValueTextFormatterForHandle: String,
    startPoint: Number
  },
  emits: ["beforeChange", "afterChange", "change"],
  data() {
    const e = this.defaultValue !== void 0 ? this.defaultValue : this.min, t = this.value !== void 0 ? this.value : e;
    return {
      sValue: this.trimAlignValue(t),
      dragging: !1
    };
  },
  watch: {
    value: {
      handler(e) {
        this.setChangeValue(e);
      },
      deep: !0
    },
    min() {
      const {
        sValue: e
      } = this;
      this.setChangeValue(e);
    },
    max() {
      const {
        sValue: e
      } = this;
      this.setChangeValue(e);
    }
  },
  methods: {
    setChangeValue(e) {
      const t = e !== void 0 ? e : this.sValue, n = this.trimAlignValue(t, this.$props);
      n !== this.sValue && (this.setState({
        sValue: n
      }), pG(t, this.$props) && this.$emit("change", n));
    },
    onChange(e) {
      const t = !os(this, "value"), n = e.sValue > this.max ? _(_({}, e), {
        sValue: this.max
      }) : e;
      t && this.setState(n);
      const o = n.sValue;
      this.$emit("change", o);
    },
    onStart(e) {
      this.setState({
        dragging: !0
      });
      const {
        sValue: t
      } = this;
      this.$emit("beforeChange", t);
      const n = this.calcValueByPos(e);
      this.startValue = n, this.startPosition = e, n !== t && (this.prevMovedHandleIndex = 0, this.onChange({
        sValue: n
      }));
    },
    onEnd(e) {
      const {
        dragging: t
      } = this;
      this.removeDocumentEvents(), (t || e) && this.$emit("afterChange", this.sValue), this.setState({
        dragging: !1
      });
    },
    onMove(e, t) {
      up(e);
      const {
        sValue: n
      } = this, o = this.calcValueByPos(t);
      o !== n && this.onChange({
        sValue: o
      });
    },
    onKeyboard(e) {
      const {
        reverse: t,
        vertical: n
      } = this.$props, o = hG(e, n, t);
      if (o) {
        up(e);
        const {
          sValue: l
        } = this, r = o(l, this.$props), a = this.trimAlignValue(r);
        if (a === l) return;
        this.onChange({
          sValue: a
        }), this.$emit("afterChange", a), this.onEnd();
      }
    },
    getLowerBound() {
      const e = this.$props.startPoint || this.$props.min;
      return this.$data.sValue > e ? e : this.$data.sValue;
    },
    getUpperBound() {
      return this.$data.sValue < this.$props.startPoint ? this.$props.startPoint : this.$data.sValue;
    },
    trimAlignValue(e) {
      let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (e === null)
        return null;
      const n = _(_({}, this.$props), t), o = bP(e, n);
      return mG(o, n);
    },
    getTrack(e) {
      let {
        prefixCls: t,
        reverse: n,
        vertical: o,
        included: l,
        minimumTrackStyle: r,
        mergedTrackStyle: a,
        length: i,
        offset: s
      } = e;
      return $(gP, {
        class: `${t}-track`,
        vertical: o,
        included: l,
        offset: s,
        reverse: n,
        length: i,
        style: _(_({}, r), a)
      }, null);
    },
    renderSlider() {
      const {
        prefixCls: e,
        vertical: t,
        included: n,
        disabled: o,
        minimumTrackStyle: l,
        trackStyle: r,
        handleStyle: a,
        tabindex: i,
        ariaLabelForHandle: s,
        ariaLabelledByForHandle: c,
        ariaValueTextFormatterForHandle: u,
        min: d,
        max: f,
        startPoint: p,
        reverse: m,
        handle: v,
        defaultHandle: h
      } = this, g = v || h, {
        sValue: y,
        dragging: b
      } = this, C = this.calcOffset(y), w = g({
        class: `${e}-handle`,
        prefixCls: e,
        vertical: t,
        offset: C,
        value: y,
        dragging: b,
        disabled: o,
        min: d,
        max: f,
        reverse: m,
        index: 0,
        tabindex: i,
        ariaLabel: s,
        ariaLabelledBy: c,
        ariaValueTextFormatter: u,
        style: a[0] || a,
        ref: (I) => this.saveHandle(0, I),
        onFocus: this.onFocus,
        onBlur: this.onBlur
      }), x = p !== void 0 ? this.calcOffset(p) : 0, E = r[0] || r;
      return {
        tracks: this.getTrack({
          prefixCls: e,
          reverse: m,
          vertical: t,
          included: n,
          offset: x,
          minimumTrackStyle: l,
          mergedTrackStyle: E,
          length: C - x
        }),
        handles: w
      };
    }
  }
}), Jje = gG(qje), sv = (e) => {
  let {
    value: t,
    handle: n,
    bounds: o,
    props: l
  } = e;
  const {
    allowCross: r,
    pushable: a
  } = l, i = Number(a), s = bP(t, l);
  let c = s;
  return !r && n != null && o !== void 0 && (n > 0 && s <= o[n - 1] + i && (c = o[n - 1] + i), n < o.length - 1 && s >= o[n + 1] - i && (c = o[n + 1] - i)), mG(c, l);
}, Zje = {
  defaultValue: de.arrayOf(de.number),
  value: de.arrayOf(de.number),
  count: Number,
  pushable: nj(de.oneOfType([de.looseBool, de.number])),
  allowCross: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  reverse: {
    type: Boolean,
    default: void 0
  },
  tabindex: de.arrayOf(de.number),
  prefixCls: String,
  min: Number,
  max: Number,
  autofocus: {
    type: Boolean,
    default: void 0
  },
  ariaLabelGroupForHandles: Array,
  ariaLabelledByGroupForHandles: Array,
  ariaValueTextFormatterGroupForHandles: Array,
  draggableTrack: {
    type: Boolean,
    default: void 0
  }
}, Qje = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Range",
  mixins: [dd],
  inheritAttrs: !1,
  props: sn(Zje, {
    count: 1,
    allowCross: !0,
    pushable: !1,
    tabindex: [],
    draggableTrack: !1,
    ariaLabelGroupForHandles: [],
    ariaLabelledByGroupForHandles: [],
    ariaValueTextFormatterGroupForHandles: []
  }),
  emits: ["beforeChange", "afterChange", "change"],
  displayName: "Range",
  data() {
    const {
      count: e,
      min: t,
      max: n
    } = this, o = Array(...Array(e + 1)).map(() => t), l = os(this, "defaultValue") ? this.defaultValue : o;
    let {
      value: r
    } = this;
    r === void 0 && (r = l);
    const a = r.map((s, c) => sv({
      value: s,
      handle: c,
      props: this.$props
    }));
    return {
      sHandle: null,
      recent: a[0] === n ? 0 : a.length - 1,
      bounds: a
    };
  },
  watch: {
    value: {
      handler(e) {
        const {
          bounds: t
        } = this;
        this.setChangeValue(e || t);
      },
      deep: !0
    },
    min() {
      const {
        value: e
      } = this;
      this.setChangeValue(e || this.bounds);
    },
    max() {
      const {
        value: e
      } = this;
      this.setChangeValue(e || this.bounds);
    }
  },
  methods: {
    setChangeValue(e) {
      const {
        bounds: t
      } = this;
      let n = e.map((o, l) => sv({
        value: o,
        handle: l,
        bounds: t,
        props: this.$props
      }));
      if (t.length === n.length) {
        if (n.every((o, l) => o === t[l]))
          return null;
      } else
        n = e.map((o, l) => sv({
          value: o,
          handle: l,
          props: this.$props
        }));
      if (this.setState({
        bounds: n
      }), e.some((o) => pG(o, this.$props))) {
        const o = e.map((l) => bP(l, this.$props));
        this.$emit("change", o);
      }
    },
    onChange(e) {
      if (!os(this, "value"))
        this.setState(e);
      else {
        const l = {};
        ["sHandle", "recent"].forEach((r) => {
          e[r] !== void 0 && (l[r] = e[r]);
        }), Object.keys(l).length && this.setState(l);
      }
      const o = _(_({}, this.$data), e).bounds;
      this.$emit("change", o);
    },
    positionGetValue(e) {
      const t = this.getValue(), n = this.calcValueByPos(e), o = this.getClosestBound(n), l = this.getBoundNeedMoving(n, o), r = t[l];
      if (n === r) return null;
      const a = [...t];
      return a[l] = n, a;
    },
    onStart(e) {
      const {
        bounds: t
      } = this;
      this.$emit("beforeChange", t);
      const n = this.calcValueByPos(e);
      this.startValue = n, this.startPosition = e;
      const o = this.getClosestBound(n);
      this.prevMovedHandleIndex = this.getBoundNeedMoving(n, o), this.setState({
        sHandle: this.prevMovedHandleIndex,
        recent: this.prevMovedHandleIndex
      });
      const l = t[this.prevMovedHandleIndex];
      if (n === l) return;
      const r = [...t];
      r[this.prevMovedHandleIndex] = n, this.onChange({
        bounds: r
      });
    },
    onEnd(e) {
      const {
        sHandle: t
      } = this;
      this.removeDocumentEvents(), t || (this.dragTrack = !1), (t !== null || e) && this.$emit("afterChange", this.bounds), this.setState({
        sHandle: null
      });
    },
    onMove(e, t, n, o) {
      up(e);
      const {
        $data: l,
        $props: r
      } = this, a = r.max || 100, i = r.min || 0;
      if (n) {
        let f = r.vertical ? -t : t;
        f = r.reverse ? -f : f;
        const p = a - Math.max(...o), m = i - Math.min(...o), v = Math.min(Math.max(f / (this.getSliderLength() / 100), m), p), h = o.map((g) => Math.floor(Math.max(Math.min(g + v, a), i)));
        l.bounds.map((g, y) => g === h[y]).some((g) => !g) && this.onChange({
          bounds: h
        });
        return;
      }
      const {
        bounds: s,
        sHandle: c
      } = this, u = this.calcValueByPos(t), d = s[c];
      u !== d && this.moveTo(u);
    },
    onKeyboard(e) {
      const {
        reverse: t,
        vertical: n
      } = this.$props, o = hG(e, n, t);
      if (o) {
        up(e);
        const {
          bounds: l,
          sHandle: r
        } = this, a = l[r === null ? this.recent : r], i = o(a, this.$props), s = sv({
          value: i,
          handle: r,
          bounds: l,
          props: this.$props
        });
        if (s === a) return;
        this.moveTo(s, !0);
      }
    },
    getClosestBound(e) {
      const {
        bounds: t
      } = this;
      let n = 0;
      for (let o = 1; o < t.length - 1; o += 1)
        e >= t[o] && (n = o);
      return Math.abs(t[n + 1] - e) < Math.abs(t[n] - e) && (n += 1), n;
    },
    getBoundNeedMoving(e, t) {
      const {
        bounds: n,
        recent: o
      } = this;
      let l = t;
      const r = n[t + 1] === n[t];
      return r && n[o] === n[t] && (l = o), r && e !== n[t + 1] && (l = e < n[t + 1] ? t : t + 1), l;
    },
    getLowerBound() {
      return this.bounds[0];
    },
    getUpperBound() {
      const {
        bounds: e
      } = this;
      return e[e.length - 1];
    },
    /**
     * Returns an array of possible slider points, taking into account both
     * `marks` and `step`. The result is cached.
     */
    getPoints() {
      const {
        marks: e,
        step: t,
        min: n,
        max: o
      } = this, l = this.internalPointsCache;
      if (!l || l.marks !== e || l.step !== t) {
        const r = _({}, e);
        if (t !== null)
          for (let i = n; i <= o; i += t)
            r[i] = i;
        const a = Object.keys(r).map(parseFloat);
        a.sort((i, s) => i - s), this.internalPointsCache = {
          marks: e,
          step: t,
          points: a
        };
      }
      return this.internalPointsCache.points;
    },
    moveTo(e, t) {
      const n = [...this.bounds], {
        sHandle: o,
        recent: l
      } = this, r = o === null ? l : o;
      n[r] = e;
      let a = r;
      this.$props.pushable !== !1 ? this.pushSurroundingHandles(n, a) : this.$props.allowCross && (n.sort((i, s) => i - s), a = n.indexOf(e)), this.onChange({
        recent: a,
        sHandle: a,
        bounds: n
      }), t && (this.$emit("afterChange", n), this.setState({}, () => {
        this.handlesRefs[a].focus();
      }), this.onEnd());
    },
    pushSurroundingHandles(e, t) {
      const n = e[t], {
        pushable: o
      } = this, l = Number(o);
      let r = 0;
      if (e[t + 1] - n < l && (r = 1), n - e[t - 1] < l && (r = -1), r === 0)
        return;
      const a = t + r, i = r * (e[a] - n);
      this.pushHandle(e, a, r, l - i) || (e[t] = e[a] - r * l);
    },
    pushHandle(e, t, n, o) {
      const l = e[t];
      let r = e[t];
      for (; n * (r - l) < o; ) {
        if (!this.pushHandleOnePoint(e, t, n))
          return e[t] = l, !1;
        r = e[t];
      }
      return !0;
    },
    pushHandleOnePoint(e, t, n) {
      const o = this.getPoints(), r = o.indexOf(e[t]) + n;
      if (r >= o.length || r < 0)
        return !1;
      const a = t + n, i = o[r], {
        pushable: s
      } = this, c = Number(s), u = n * (e[a] - i);
      return this.pushHandle(e, a, n, c - u) ? (e[t] = i, !0) : !1;
    },
    trimAlignValue(e) {
      const {
        sHandle: t,
        bounds: n
      } = this;
      return sv({
        value: e,
        handle: t,
        bounds: n,
        props: this.$props
      });
    },
    ensureValueNotConflict(e, t, n) {
      let {
        allowCross: o,
        pushable: l
      } = n;
      const r = this.$data || {}, {
        bounds: a
      } = r;
      if (e = e === void 0 ? r.sHandle : e, l = Number(l), !o && e != null && a !== void 0) {
        if (e > 0 && t <= a[e - 1] + l)
          return a[e - 1] + l;
        if (e < a.length - 1 && t >= a[e + 1] - l)
          return a[e + 1] - l;
      }
      return t;
    },
    getTrack(e) {
      let {
        bounds: t,
        prefixCls: n,
        reverse: o,
        vertical: l,
        included: r,
        offsets: a,
        trackStyle: i
      } = e;
      return t.slice(0, -1).map((s, c) => {
        const u = c + 1, d = ke({
          [`${n}-track`]: !0,
          [`${n}-track-${u}`]: !0
        });
        return $(gP, {
          class: d,
          vertical: l,
          reverse: o,
          included: r,
          offset: a[u - 1],
          length: a[u] - a[u - 1],
          style: i[c],
          key: u
        }, null);
      });
    },
    renderSlider() {
      const {
        sHandle: e,
        bounds: t,
        prefixCls: n,
        vertical: o,
        included: l,
        disabled: r,
        min: a,
        max: i,
        reverse: s,
        handle: c,
        defaultHandle: u,
        trackStyle: d,
        handleStyle: f,
        tabindex: p,
        ariaLabelGroupForHandles: m,
        ariaLabelledByGroupForHandles: v,
        ariaValueTextFormatterGroupForHandles: h
      } = this, g = c || u, y = t.map((w) => this.calcOffset(w)), b = `${n}-handle`, C = t.map((w, x) => {
        let E = p[x] || 0;
        (r || p[x] === null) && (E = null);
        const I = e === x;
        return g({
          class: ke({
            [b]: !0,
            [`${b}-${x + 1}`]: !0,
            [`${b}-dragging`]: I
          }),
          prefixCls: n,
          vertical: o,
          dragging: I,
          offset: y[x],
          value: w,
          index: x,
          tabindex: E,
          min: a,
          max: i,
          reverse: s,
          disabled: r,
          style: f[x],
          ref: (T) => this.saveHandle(x, T),
          onFocus: this.onFocus,
          onBlur: this.onBlur,
          ariaLabel: m[x],
          ariaLabelledBy: v[x],
          ariaValueTextFormatter: h[x]
        });
      });
      return {
        tracks: this.getTrack({
          bounds: t,
          prefixCls: n,
          reverse: s,
          vertical: o,
          included: l,
          offsets: y,
          trackStyle: d
        }),
        handles: C
      };
    }
  }
}), eWe = gG(Qje), tWe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "SliderTooltip",
  inheritAttrs: !1,
  props: Wj(),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const l = /* @__PURE__ */ H(null), r = /* @__PURE__ */ H(null);
    function a() {
      rn.cancel(r.value), r.value = null;
    }
    function i() {
      r.value = rn(() => {
        var c;
        (c = l.value) === null || c === void 0 || c.forcePopupAlign(), r.value = null;
      });
    }
    const s = () => {
      a(), e.open && i();
    };
    return pe([() => e.open, () => e.title], () => {
      s();
    }, {
      flush: "post",
      immediate: !0
    }), nd(() => {
      s();
    }), yt(() => {
      a();
    }), () => $(Sr, Q(Q({
      ref: l
    }, e), n), o);
  }
}), nWe = (e) => {
  const {
    componentCls: t,
    controlSize: n,
    dotSize: o,
    marginFull: l,
    marginPart: r,
    colorFillContentHover: a
  } = e;
  return {
    [t]: _(_({}, nn(e)), {
      position: "relative",
      height: n,
      margin: `${r}px ${l}px`,
      padding: 0,
      cursor: "pointer",
      touchAction: "none",
      "&-vertical": {
        margin: `${l}px ${r}px`
      },
      [`${t}-rail`]: {
        position: "absolute",
        backgroundColor: e.colorFillTertiary,
        borderRadius: e.borderRadiusXS,
        transition: `background-color ${e.motionDurationMid}`
      },
      [`${t}-track`]: {
        position: "absolute",
        backgroundColor: e.colorPrimaryBorder,
        borderRadius: e.borderRadiusXS,
        transition: `background-color ${e.motionDurationMid}`
      },
      "&:hover": {
        [`${t}-rail`]: {
          backgroundColor: e.colorFillSecondary
        },
        [`${t}-track`]: {
          backgroundColor: e.colorPrimaryBorderHover
        },
        [`${t}-dot`]: {
          borderColor: a
        },
        [`${t}-handle::after`]: {
          boxShadow: `0 0 0 ${e.handleLineWidth}px ${e.colorPrimaryBorderHover}`
        },
        [`${t}-dot-active`]: {
          borderColor: e.colorPrimary
        }
      },
      [`${t}-handle`]: {
        position: "absolute",
        width: e.handleSize,
        height: e.handleSize,
        outline: "none",
        [`${t}-dragging`]: {
          zIndex: 1
        },
        // 
        "&::before": {
          content: '""',
          position: "absolute",
          insetInlineStart: -e.handleLineWidth,
          insetBlockStart: -e.handleLineWidth,
          width: e.handleSize + e.handleLineWidth * 2,
          height: e.handleSize + e.handleLineWidth * 2,
          backgroundColor: "transparent"
        },
        "&::after": {
          content: '""',
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: e.handleSize,
          height: e.handleSize,
          backgroundColor: e.colorBgElevated,
          boxShadow: `0 0 0 ${e.handleLineWidth}px ${e.colorPrimaryBorder}`,
          borderRadius: "50%",
          cursor: "pointer",
          transition: `
            inset-inline-start ${e.motionDurationMid},
            inset-block-start ${e.motionDurationMid},
            width ${e.motionDurationMid},
            height ${e.motionDurationMid},
            box-shadow ${e.motionDurationMid}
          `
        },
        "&:hover, &:active, &:focus": {
          "&::before": {
            insetInlineStart: -((e.handleSizeHover - e.handleSize) / 2 + e.handleLineWidthHover),
            insetBlockStart: -((e.handleSizeHover - e.handleSize) / 2 + e.handleLineWidthHover),
            width: e.handleSizeHover + e.handleLineWidthHover * 2,
            height: e.handleSizeHover + e.handleLineWidthHover * 2
          },
          "&::after": {
            boxShadow: `0 0 0 ${e.handleLineWidthHover}px ${e.colorPrimary}`,
            width: e.handleSizeHover,
            height: e.handleSizeHover,
            insetInlineStart: (e.handleSize - e.handleSizeHover) / 2,
            insetBlockStart: (e.handleSize - e.handleSizeHover) / 2
          }
        }
      },
      [`${t}-mark`]: {
        position: "absolute",
        fontSize: e.fontSize
      },
      [`${t}-mark-text`]: {
        position: "absolute",
        display: "inline-block",
        color: e.colorTextDescription,
        textAlign: "center",
        wordBreak: "keep-all",
        cursor: "pointer",
        userSelect: "none",
        "&-active": {
          color: e.colorText
        }
      },
      [`${t}-step`]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none"
      },
      [`${t}-dot`]: {
        position: "absolute",
        width: o,
        height: o,
        backgroundColor: e.colorBgElevated,
        border: `${e.handleLineWidth}px solid ${e.colorBorderSecondary}`,
        borderRadius: "50%",
        cursor: "pointer",
        transition: `border-color ${e.motionDurationSlow}`,
        "&-active": {
          borderColor: e.colorPrimaryBorder
        }
      },
      [`&${t}-disabled`]: {
        cursor: "not-allowed",
        [`${t}-rail`]: {
          backgroundColor: `${e.colorFillSecondary} !important`
        },
        [`${t}-track`]: {
          backgroundColor: `${e.colorTextDisabled} !important`
        },
        [`
          ${t}-dot
        `]: {
          backgroundColor: e.colorBgElevated,
          borderColor: e.colorTextDisabled,
          boxShadow: "none",
          cursor: "not-allowed"
        },
        [`${t}-handle::after`]: {
          backgroundColor: e.colorBgElevated,
          cursor: "not-allowed",
          width: e.handleSize,
          height: e.handleSize,
          boxShadow: `0 0 0 ${e.handleLineWidth}px ${new xn(e.colorTextDisabled).onBackground(e.colorBgContainer).toHexString()}`,
          insetInlineStart: 0,
          insetBlockStart: 0
        },
        [`
          ${t}-mark-text,
          ${t}-dot
        `]: {
          cursor: "not-allowed !important"
        }
      }
    })
  };
}, bG = (e, t) => {
  const {
    componentCls: n,
    railSize: o,
    handleSize: l,
    dotSize: r
  } = e, a = t ? "paddingBlock" : "paddingInline", i = t ? "width" : "height", s = t ? "height" : "width", c = t ? "insetBlockStart" : "insetInlineStart", u = t ? "top" : "insetInlineStart";
  return {
    [a]: o,
    [s]: o * 3,
    [`${n}-rail`]: {
      [i]: "100%",
      [s]: o
    },
    [`${n}-track`]: {
      [s]: o
    },
    [`${n}-handle`]: {
      [c]: (o * 3 - l) / 2
    },
    [`${n}-mark`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [u]: l,
      [i]: "100%"
    },
    [`${n}-step`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [u]: o,
      [i]: "100%",
      [s]: o
    },
    [`${n}-dot`]: {
      position: "absolute",
      [c]: (o - r) / 2
    }
  };
}, oWe = (e) => {
  const {
    componentCls: t,
    marginPartWithMark: n
  } = e;
  return {
    [`${t}-horizontal`]: _(_({}, bG(e, !0)), {
      [`&${t}-with-marks`]: {
        marginBottom: n
      }
    })
  };
}, lWe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-vertical`]: _(_({}, bG(e, !1)), {
      height: "100%"
    })
  };
}, rWe = Zt("Slider", (e) => {
  const t = Vt(e, {
    marginPart: (e.controlHeight - e.controlSize) / 2,
    marginFull: e.controlSize / 2,
    marginPartWithMark: e.controlHeightLG - e.controlSize
  });
  return [nWe(t), oWe(t), lWe(t)];
}, (e) => {
  const n = e.controlHeightLG / 4, o = e.controlHeightSM / 2, l = e.lineWidth + 1, r = e.lineWidth + 1 * 3;
  return {
    controlSize: n,
    railSize: 4,
    handleSize: n,
    handleSizeHover: o,
    dotSize: 8,
    handleLineWidth: l,
    handleLineWidthHover: r
  };
});
var sR = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const aWe = (e) => typeof e == "number" ? e.toString() : "", iWe = () => ({
  id: String,
  prefixCls: String,
  tooltipPrefixCls: String,
  range: zt([Boolean, Object]),
  reverse: Qe(),
  min: Number,
  max: Number,
  step: zt([Object, Number]),
  marks: Nt(),
  dots: Qe(),
  value: zt([Array, Number]),
  defaultValue: zt([Array, Number]),
  included: Qe(),
  disabled: Qe(),
  vertical: Qe(),
  tipFormatter: zt([Function, Object], () => aWe),
  tooltipOpen: Qe(),
  /** @deprecated `tooltipVisible` is deprecated. Please use `tooltipOpen` instead. */
  tooltipVisible: Qe(),
  tooltipPlacement: At(),
  getTooltipPopupContainer: Fe(),
  autofocus: Qe(),
  handleStyle: zt([Array, Object]),
  trackStyle: zt([Array, Object]),
  onChange: Fe(),
  onAfterChange: Fe(),
  onFocus: Fe(),
  onBlur: Fe(),
  "onUpdate:value": Fe()
}), sWe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ASlider",
  inheritAttrs: !1,
  props: iWe(),
  // emits: ['update:value', 'change', 'afterChange', 'blur'],
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: l,
      expose: r
    } = t;
    process.env.NODE_ENV !== "production" && [["tooltipVisible", "tooltipOpen"]].forEach((E) => {
      let [I, T] = E;
      un(e.tooltipVisible === void 0, "Slider", `\`${I}\` is deprecated, please use \`${T}\` instead.`);
    });
    const {
      prefixCls: a,
      rootPrefixCls: i,
      direction: s,
      getPopupContainer: c,
      configProvider: u
    } = bt("slider", e), [d, f] = rWe(a), p = Ko(), m = /* @__PURE__ */ H(), v = /* @__PURE__ */ H({}), h = (E, I) => {
      v.value[E] = I;
    }, g = O(() => e.tooltipPlacement ? e.tooltipPlacement : e.vertical ? s.value === "rtl" ? "left" : "right" : "top"), y = () => {
      var E;
      (E = m.value) === null || E === void 0 || E.focus();
    }, b = () => {
      var E;
      (E = m.value) === null || E === void 0 || E.blur();
    }, C = (E) => {
      l("update:value", E), l("change", E), p.onFieldChange();
    }, w = (E) => {
      l("blur", E);
    };
    r({
      focus: y,
      blur: b
    });
    const x = (E) => {
      var {
        tooltipPrefixCls: I
      } = E, T = E.info, {
        value: P,
        dragging: k,
        index: N
      } = T, R = sR(T, ["value", "dragging", "index"]);
      const {
        tipFormatter: z,
        tooltipOpen: D = e.tooltipVisible,
        getTooltipPopupContainer: F
      } = e, M = z ? v.value[N] || k : !1, A = D || D === void 0 && M;
      return $(tWe, {
        prefixCls: I,
        title: z ? z(P) : "",
        open: A,
        placement: g.value,
        transitionName: `${i.value}-zoom-down`,
        key: N,
        overlayClassName: `${a.value}-tooltip`,
        getPopupContainer: F || (c == null ? void 0 : c.value)
      }, {
        default: () => [$(fG, Q(Q({}, R), {}, {
          value: P,
          onMouseenter: () => h(N, !0),
          onMouseleave: () => h(N, !1)
        }), null)]
      });
    };
    return () => {
      const {
        tooltipPrefixCls: E,
        range: I,
        id: T = p.id.value
      } = e, P = sR(e, ["tooltipPrefixCls", "range", "id"]), k = u.getPrefixCls("tooltip", E), N = ke(n.class, {
        [`${a.value}-rtl`]: s.value === "rtl"
      }, f.value);
      s.value === "rtl" && !P.vertical && (P.reverse = !P.reverse);
      let R;
      return typeof I == "object" && (R = I.draggableTrack), d(I ? $(eWe, Q(Q(Q({}, n), P), {}, {
        step: P.step,
        draggableTrack: R,
        class: N,
        ref: m,
        handle: (z) => x({
          tooltipPrefixCls: k,
          prefixCls: a.value,
          info: z
        }),
        prefixCls: a.value,
        onChange: C,
        onBlur: w
      }), {
        mark: o.mark
      }) : $(Jje, Q(Q(Q({}, n), P), {}, {
        id: T,
        step: P.step,
        class: N,
        ref: m,
        handle: (z) => x({
          tooltipPrefixCls: k,
          prefixCls: a.value,
          info: z
        }),
        prefixCls: a.value,
        onChange: C,
        onBlur: w
      }), {
        mark: o.mark
      }));
    };
  }
}), cWe = po(sWe);
function cR(e) {
  return typeof e == "string";
}
function uWe() {
}
const yG = () => ({
  prefixCls: String,
  itemWidth: String,
  active: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  status: At(),
  iconPrefix: String,
  icon: de.any,
  adjustMarginRight: String,
  stepNumber: Number,
  stepIndex: Number,
  description: de.any,
  title: de.any,
  subTitle: de.any,
  progressDot: nj(de.oneOfType([de.looseBool, de.func])),
  tailContent: de.any,
  icons: de.shape({
    finish: de.any,
    error: de.any
  }).loose,
  onClick: Fe(),
  onStepClick: Fe(),
  stepIcon: Fe(),
  itemRender: Fe(),
  __legacy: Qe()
}), SG = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Step",
  inheritAttrs: !1,
  props: yG(),
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: l
    } = t;
    const r = (i) => {
      o("click", i), o("stepClick", e.stepIndex);
    }, a = (i) => {
      let {
        icon: s,
        title: c,
        description: u
      } = i;
      const {
        prefixCls: d,
        stepNumber: f,
        status: p,
        iconPrefix: m,
        icons: v,
        progressDot: h = n.progressDot,
        stepIcon: g = n.stepIcon
      } = e;
      let y;
      const b = ke(`${d}-icon`, `${m}icon`, {
        [`${m}icon-${s}`]: s && cR(s),
        [`${m}icon-check`]: !s && p === "finish" && (v && !v.finish || !v),
        [`${m}icon-cross`]: !s && p === "error" && (v && !v.error || !v)
      }), C = $("span", {
        class: `${d}-icon-dot`
      }, null);
      return h ? typeof h == "function" ? y = $("span", {
        class: `${d}-icon`
      }, [h({
        iconDot: C,
        index: f - 1,
        status: p,
        title: c,
        description: u,
        prefixCls: d
      })]) : y = $("span", {
        class: `${d}-icon`
      }, [C]) : s && !cR(s) ? y = $("span", {
        class: `${d}-icon`
      }, [s]) : v && v.finish && p === "finish" ? y = $("span", {
        class: `${d}-icon`
      }, [v.finish]) : v && v.error && p === "error" ? y = $("span", {
        class: `${d}-icon`
      }, [v.error]) : s || p === "finish" || p === "error" ? y = $("span", {
        class: b
      }, null) : y = $("span", {
        class: `${d}-icon`
      }, [f]), g && (y = g({
        index: f - 1,
        status: p,
        title: c,
        description: u,
        node: y
      })), y;
    };
    return () => {
      var i, s, c, u;
      const {
        prefixCls: d,
        itemWidth: f,
        active: p,
        status: m = "wait",
        tailContent: v,
        adjustMarginRight: h,
        disabled: g,
        title: y = (i = n.title) === null || i === void 0 ? void 0 : i.call(n),
        description: b = (s = n.description) === null || s === void 0 ? void 0 : s.call(n),
        subTitle: C = (c = n.subTitle) === null || c === void 0 ? void 0 : c.call(n),
        icon: w = (u = n.icon) === null || u === void 0 ? void 0 : u.call(n),
        onClick: x,
        onStepClick: E
      } = e, I = m || "wait", T = ke(`${d}-item`, `${d}-item-${I}`, {
        [`${d}-item-custom`]: w,
        [`${d}-item-active`]: p,
        [`${d}-item-disabled`]: g === !0
      }), P = {};
      f && (P.width = f), h && (P.marginRight = h);
      const k = {
        onClick: x || uWe
      };
      E && !g && (k.role = "button", k.tabindex = 0, k.onClick = r);
      const N = $("div", Q(Q({}, pn(l, ["__legacy"])), {}, {
        class: [T, l.class],
        style: [l.style, P]
      }), [$("div", Q(Q({}, k), {}, {
        class: `${d}-item-container`
      }), [$("div", {
        class: `${d}-item-tail`
      }, [v]), $("div", {
        class: `${d}-item-icon`
      }, [a({
        icon: w,
        title: y,
        description: b
      })]), $("div", {
        class: `${d}-item-content`
      }, [$("div", {
        class: `${d}-item-title`
      }, [y, C && $("div", {
        title: typeof C == "string" ? C : void 0,
        class: `${d}-item-subtitle`
      }, [C])]), b && $("div", {
        class: `${d}-item-description`
      }, [b])])])]);
      return e.itemRender ? e.itemRender(N) : N;
    };
  }
});
var dWe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const fWe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Steps",
  props: {
    type: de.string.def("default"),
    prefixCls: de.string.def("vc-steps"),
    iconPrefix: de.string.def("vc"),
    direction: de.string.def("horizontal"),
    labelPlacement: de.string.def("horizontal"),
    status: At("process"),
    size: de.string.def(""),
    progressDot: de.oneOfType([de.looseBool, de.func]).def(void 0),
    initial: de.number.def(0),
    current: de.number.def(0),
    items: de.array.def(() => []),
    icons: de.shape({
      finish: de.any,
      error: de.any
    }).loose,
    stepIcon: Fe(),
    isInline: de.looseBool,
    itemRender: Fe()
  },
  emits: ["change"],
  setup(e, t) {
    let {
      slots: n,
      emit: o
    } = t;
    const l = (i) => {
      const {
        current: s
      } = e;
      s !== i && o("change", i);
    }, r = (i, s, c) => {
      const {
        prefixCls: u,
        iconPrefix: d,
        status: f,
        current: p,
        initial: m,
        icons: v,
        stepIcon: h = n.stepIcon,
        isInline: g,
        itemRender: y,
        progressDot: b = n.progressDot
      } = e, C = g || b, w = _(_({}, i), {
        class: ""
      }), x = m + s, E = {
        active: x === p,
        stepNumber: x + 1,
        stepIndex: x,
        key: x,
        prefixCls: u,
        iconPrefix: d,
        progressDot: C,
        stepIcon: h,
        icons: v,
        onStepClick: l
      };
      return f === "error" && s === p - 1 && (w.class = `${u}-next-error`), w.status || (x === p ? w.status = f : x < p ? w.status = "finish" : w.status = "wait"), g && (w.icon = void 0, w.subTitle = void 0), c ? c(_(_({}, w), E)) : (y && (w.itemRender = (I) => y(w, I)), $(SG, Q(Q(Q({}, w), E), {}, {
        __legacy: !1
      }), null));
    }, a = (i, s) => r(_({}, i.props), s, (c) => _n(i, c));
    return () => {
      var i;
      const {
        prefixCls: s,
        direction: c,
        type: u,
        labelPlacement: d,
        iconPrefix: f,
        status: p,
        size: m,
        current: v,
        progressDot: h = n.progressDot,
        initial: g,
        icons: y,
        items: b,
        isInline: C,
        itemRender: w
      } = e, x = dWe(e, ["prefixCls", "direction", "type", "labelPlacement", "iconPrefix", "status", "size", "current", "progressDot", "initial", "icons", "items", "isInline", "itemRender"]), E = u === "navigation", I = C || h, T = C ? "horizontal" : c, P = C ? void 0 : m, k = I ? "vertical" : d, N = ke(s, `${s}-${c}`, {
        [`${s}-${P}`]: P,
        [`${s}-label-${k}`]: T === "horizontal",
        [`${s}-dot`]: !!I,
        [`${s}-navigation`]: E,
        [`${s}-inline`]: C
      });
      return $("div", Q({
        class: N
      }, x), [b.filter((R) => R).map((R, z) => r(R, z)), mo((i = n.default) === null || i === void 0 ? void 0 : i.call(n)).map(a)]);
    };
  }
}), pWe = (e) => {
  const {
    componentCls: t,
    stepsIconCustomTop: n,
    stepsIconCustomSize: o,
    stepsIconCustomFontSize: l
  } = e;
  return {
    [`${t}-item-custom`]: {
      [`> ${t}-item-container > ${t}-item-icon`]: {
        height: "auto",
        background: "none",
        border: 0,
        [`> ${t}-icon`]: {
          top: n,
          width: o,
          height: o,
          fontSize: l,
          lineHeight: `${o}px`
        }
      }
    },
    // Only adjust horizontal customize icon width
    [`&:not(${t}-vertical)`]: {
      [`${t}-item-custom`]: {
        [`${t}-item-icon`]: {
          width: "auto",
          background: "none"
        }
      }
    }
  };
}, vWe = (e) => {
  const {
    componentCls: t,
    stepsIconSize: n,
    lineHeight: o,
    stepsSmallIconSize: l
  } = e;
  return {
    [`&${t}-label-vertical`]: {
      [`${t}-item`]: {
        overflow: "visible",
        "&-tail": {
          marginInlineStart: n / 2 + e.controlHeightLG,
          padding: `${e.paddingXXS}px ${e.paddingLG}px`
        },
        "&-content": {
          display: "block",
          width: (n / 2 + e.controlHeightLG) * 2,
          marginTop: e.marginSM,
          textAlign: "center"
        },
        "&-icon": {
          display: "inline-block",
          marginInlineStart: e.controlHeightLG
        },
        "&-title": {
          paddingInlineEnd: 0,
          paddingInlineStart: 0,
          "&::after": {
            display: "none"
          }
        },
        "&-subtitle": {
          display: "block",
          marginBottom: e.marginXXS,
          marginInlineStart: 0,
          lineHeight: o
        }
      },
      [`&${t}-small:not(${t}-dot)`]: {
        [`${t}-item`]: {
          "&-icon": {
            marginInlineStart: e.controlHeightLG + (n - l) / 2
          }
        }
      }
    }
  };
}, mWe = (e) => {
  const {
    componentCls: t,
    stepsNavContentMaxWidth: n,
    stepsNavArrowColor: o,
    stepsNavActiveColor: l,
    motionDurationSlow: r
  } = e;
  return {
    [`&${t}-navigation`]: {
      paddingTop: e.paddingSM,
      [`&${t}-small`]: {
        [`${t}-item`]: {
          "&-container": {
            marginInlineStart: -e.marginSM
          }
        }
      },
      [`${t}-item`]: {
        overflow: "visible",
        textAlign: "center",
        "&-container": {
          display: "inline-block",
          height: "100%",
          marginInlineStart: -e.margin,
          paddingBottom: e.paddingSM,
          textAlign: "start",
          transition: `opacity ${r}`,
          [`${t}-item-content`]: {
            maxWidth: n
          },
          [`${t}-item-title`]: _(_({
            maxWidth: "100%",
            paddingInlineEnd: 0
          }, Fo), {
            "&::after": {
              display: "none"
            }
          })
        },
        [`&:not(${t}-item-active)`]: {
          [`${t}-item-container[role='button']`]: {
            cursor: "pointer",
            "&:hover": {
              opacity: 0.85
            }
          }
        },
        "&:last-child": {
          flex: 1,
          "&::after": {
            display: "none"
          }
        },
        "&::after": {
          position: "absolute",
          top: `calc(50% - ${e.paddingSM / 2}px)`,
          insetInlineStart: "100%",
          display: "inline-block",
          width: e.fontSizeIcon,
          height: e.fontSizeIcon,
          borderTop: `${e.lineWidth}px ${e.lineType} ${o}`,
          borderBottom: "none",
          borderInlineStart: "none",
          borderInlineEnd: `${e.lineWidth}px ${e.lineType} ${o}`,
          transform: "translateY(-50%) translateX(-50%) rotate(45deg)",
          content: '""'
        },
        "&::before": {
          position: "absolute",
          bottom: 0,
          insetInlineStart: "50%",
          display: "inline-block",
          width: 0,
          height: e.lineWidthBold,
          backgroundColor: l,
          transition: `width ${r}, inset-inline-start ${r}`,
          transitionTimingFunction: "ease-out",
          content: '""'
        }
      },
      [`${t}-item${t}-item-active::before`]: {
        insetInlineStart: 0,
        width: "100%"
      }
    },
    [`&${t}-navigation${t}-vertical`]: {
      [`> ${t}-item`]: {
        marginInlineEnd: 0,
        "&::before": {
          display: "none"
        },
        [`&${t}-item-active::before`]: {
          top: 0,
          insetInlineEnd: 0,
          insetInlineStart: "unset",
          display: "block",
          width: e.lineWidth * 3,
          height: `calc(100% - ${e.marginLG}px)`
        },
        "&::after": {
          position: "relative",
          insetInlineStart: "50%",
          display: "block",
          width: e.controlHeight * 0.25,
          height: e.controlHeight * 0.25,
          marginBottom: e.marginXS,
          textAlign: "center",
          transform: "translateY(-50%) translateX(-50%) rotate(135deg)"
        },
        [`> ${t}-item-container > ${t}-item-tail`]: {
          visibility: "hidden"
        }
      }
    },
    [`&${t}-navigation${t}-horizontal`]: {
      [`> ${t}-item > ${t}-item-container > ${t}-item-tail`]: {
        visibility: "hidden"
      }
    }
  };
}, hWe = (e) => {
  const {
    antCls: t,
    componentCls: n
  } = e;
  return {
    [`&${n}-with-progress`]: {
      [`${n}-item`]: {
        paddingTop: e.paddingXXS,
        [`&-process ${n}-item-container ${n}-item-icon ${n}-icon`]: {
          color: e.processIconColor
        }
      },
      [`&${n}-vertical > ${n}-item `]: {
        paddingInlineStart: e.paddingXXS,
        [`> ${n}-item-container > ${n}-item-tail`]: {
          top: e.marginXXS,
          insetInlineStart: e.stepsIconSize / 2 - e.lineWidth + e.paddingXXS
        }
      },
      [`&, &${n}-small`]: {
        [`&${n}-horizontal ${n}-item:first-child`]: {
          paddingBottom: e.paddingXXS,
          paddingInlineStart: e.paddingXXS
        }
      },
      [`&${n}-small${n}-vertical > ${n}-item > ${n}-item-container > ${n}-item-tail`]: {
        insetInlineStart: e.stepsSmallIconSize / 2 - e.lineWidth + e.paddingXXS
      },
      [`&${n}-label-vertical`]: {
        [`${n}-item ${n}-item-tail`]: {
          top: e.margin - 2 * e.lineWidth
        }
      },
      [`${n}-item-icon`]: {
        position: "relative",
        [`${t}-progress`]: {
          position: "absolute",
          insetBlockStart: (e.stepsIconSize - e.stepsProgressSize - e.lineWidth * 2) / 2,
          insetInlineStart: (e.stepsIconSize - e.stepsProgressSize - e.lineWidth * 2) / 2
        }
      }
    }
  };
}, gWe = (e) => {
  const {
    componentCls: t,
    descriptionWidth: n,
    lineHeight: o,
    stepsCurrentDotSize: l,
    stepsDotSize: r,
    motionDurationSlow: a
  } = e;
  return {
    [`&${t}-dot, &${t}-dot${t}-small`]: {
      [`${t}-item`]: {
        "&-title": {
          lineHeight: o
        },
        "&-tail": {
          top: Math.floor((e.stepsDotSize - e.lineWidth * 3) / 2),
          width: "100%",
          marginTop: 0,
          marginBottom: 0,
          marginInline: `${n / 2}px 0`,
          padding: 0,
          "&::after": {
            width: `calc(100% - ${e.marginSM * 2}px)`,
            height: e.lineWidth * 3,
            marginInlineStart: e.marginSM
          }
        },
        "&-icon": {
          width: r,
          height: r,
          marginInlineStart: (e.descriptionWidth - r) / 2,
          paddingInlineEnd: 0,
          lineHeight: `${r}px`,
          background: "transparent",
          border: 0,
          [`${t}-icon-dot`]: {
            position: "relative",
            float: "left",
            width: "100%",
            height: "100%",
            borderRadius: 100,
            transition: `all ${a}`,
            /* expand hover area */
            "&::after": {
              position: "absolute",
              top: -e.marginSM,
              insetInlineStart: (r - e.controlHeightLG * 1.5) / 2,
              width: e.controlHeightLG * 1.5,
              height: e.controlHeight,
              background: "transparent",
              content: '""'
            }
          }
        },
        "&-content": {
          width: n
        },
        [`&-process ${t}-item-icon`]: {
          position: "relative",
          top: (r - l) / 2,
          width: l,
          height: l,
          lineHeight: `${l}px`,
          background: "none",
          marginInlineStart: (e.descriptionWidth - l) / 2
        },
        [`&-process ${t}-icon`]: {
          [`&:first-child ${t}-icon-dot`]: {
            insetInlineStart: 0
          }
        }
      }
    },
    [`&${t}-vertical${t}-dot`]: {
      [`${t}-item-icon`]: {
        marginTop: (e.controlHeight - r) / 2,
        marginInlineStart: 0,
        background: "none"
      },
      [`${t}-item-process ${t}-item-icon`]: {
        marginTop: (e.controlHeight - l) / 2,
        top: 0,
        insetInlineStart: (r - l) / 2,
        marginInlineStart: 0
      },
      // https://github.com/ant-design/ant-design/issues/18354
      [`${t}-item > ${t}-item-container > ${t}-item-tail`]: {
        top: (e.controlHeight - r) / 2,
        insetInlineStart: 0,
        margin: 0,
        padding: `${r + e.paddingXS}px 0 ${e.paddingXS}px`,
        "&::after": {
          marginInlineStart: (r - e.lineWidth) / 2
        }
      },
      [`&${t}-small`]: {
        [`${t}-item-icon`]: {
          marginTop: (e.controlHeightSM - r) / 2
        },
        [`${t}-item-process ${t}-item-icon`]: {
          marginTop: (e.controlHeightSM - l) / 2
        },
        [`${t}-item > ${t}-item-container > ${t}-item-tail`]: {
          top: (e.controlHeightSM - r) / 2
        }
      },
      [`${t}-item:first-child ${t}-icon-dot`]: {
        insetInlineStart: 0
      },
      [`${t}-item-content`]: {
        width: "inherit"
      }
    }
  };
}, bWe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`&${t}-rtl`]: {
      direction: "rtl",
      [`${t}-item`]: {
        "&-subtitle": {
          float: "left"
        }
      },
      // nav
      [`&${t}-navigation`]: {
        [`${t}-item::after`]: {
          transform: "rotate(-45deg)"
        }
      },
      // vertical
      [`&${t}-vertical`]: {
        [`> ${t}-item`]: {
          "&::after": {
            transform: "rotate(225deg)"
          },
          [`${t}-item-icon`]: {
            float: "right"
          }
        }
      },
      // progress-dot
      [`&${t}-dot`]: {
        [`${t}-item-icon ${t}-icon-dot, &${t}-small ${t}-item-icon ${t}-icon-dot`]: {
          float: "right"
        }
      }
    }
  };
}, yWe = (e) => {
  const {
    componentCls: t,
    stepsSmallIconSize: n,
    // stepsSmallIconMargin,
    fontSizeSM: o,
    fontSize: l,
    colorTextDescription: r
  } = e;
  return {
    [`&${t}-small`]: {
      [`&${t}-horizontal:not(${t}-label-vertical) ${t}-item`]: {
        paddingInlineStart: e.paddingSM,
        "&:first-child": {
          paddingInlineStart: 0
        }
      },
      [`${t}-item-icon`]: {
        width: n,
        height: n,
        // margin: stepsSmallIconMargin,
        marginTop: 0,
        marginBottom: 0,
        marginInline: `0 ${e.marginXS}px`,
        fontSize: o,
        lineHeight: `${n}px`,
        textAlign: "center",
        borderRadius: n
      },
      [`${t}-item-title`]: {
        paddingInlineEnd: e.paddingSM,
        fontSize: l,
        lineHeight: `${n}px`,
        "&::after": {
          top: n / 2
        }
      },
      [`${t}-item-description`]: {
        color: r,
        fontSize: l
      },
      [`${t}-item-tail`]: {
        top: n / 2 - e.paddingXXS
      },
      [`${t}-item-custom ${t}-item-icon`]: {
        width: "inherit",
        height: "inherit",
        lineHeight: "inherit",
        background: "none",
        border: 0,
        borderRadius: 0,
        [`> ${t}-icon`]: {
          fontSize: n,
          lineHeight: `${n}px`,
          transform: "none"
        }
      }
    }
  };
}, SWe = (e) => {
  const {
    componentCls: t,
    stepsSmallIconSize: n,
    stepsIconSize: o
  } = e;
  return {
    [`&${t}-vertical`]: {
      display: "flex",
      flexDirection: "column",
      [`> ${t}-item`]: {
        display: "block",
        flex: "1 0 auto",
        paddingInlineStart: 0,
        overflow: "visible",
        [`${t}-item-icon`]: {
          float: "left",
          marginInlineEnd: e.margin
        },
        [`${t}-item-content`]: {
          display: "block",
          minHeight: e.controlHeight * 1.5,
          overflow: "hidden"
        },
        [`${t}-item-title`]: {
          lineHeight: `${o}px`
        },
        [`${t}-item-description`]: {
          paddingBottom: e.paddingSM
        }
      },
      [`> ${t}-item > ${t}-item-container > ${t}-item-tail`]: {
        position: "absolute",
        top: 0,
        insetInlineStart: e.stepsIconSize / 2 - e.lineWidth,
        width: e.lineWidth,
        height: "100%",
        padding: `${o + e.marginXXS * 1.5}px 0 ${e.marginXXS * 1.5}px`,
        "&::after": {
          width: e.lineWidth,
          height: "100%"
        }
      },
      [`> ${t}-item:not(:last-child) > ${t}-item-container > ${t}-item-tail`]: {
        display: "block"
      },
      [` > ${t}-item > ${t}-item-container > ${t}-item-content > ${t}-item-title`]: {
        "&::after": {
          display: "none"
        }
      },
      [`&${t}-small ${t}-item-container`]: {
        [`${t}-item-tail`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: e.stepsSmallIconSize / 2 - e.lineWidth,
          padding: `${n + e.marginXXS * 1.5}px 0 ${e.marginXXS * 1.5}px`
        },
        [`${t}-item-title`]: {
          lineHeight: `${n}px`
        }
      }
    }
  };
}, CWe = (e) => {
  const {
    componentCls: t,
    inlineDotSize: n,
    inlineTitleColor: o,
    inlineTailColor: l
  } = e, r = e.paddingXS + e.lineWidth, a = {
    [`${t}-item-container ${t}-item-content ${t}-item-title`]: {
      color: o
    }
  };
  return {
    [`&${t}-inline`]: {
      width: "auto",
      display: "inline-flex",
      [`${t}-item`]: {
        flex: "none",
        "&-container": {
          padding: `${r}px ${e.paddingXXS}px 0`,
          margin: `0 ${e.marginXXS / 2}px`,
          borderRadius: e.borderRadiusSM,
          cursor: "pointer",
          transition: `background-color ${e.motionDurationMid}`,
          "&:hover": {
            background: e.controlItemBgHover
          },
          "&[role='button']:hover": {
            opacity: 1
          }
        },
        "&-icon": {
          width: n,
          height: n,
          marginInlineStart: `calc(50% - ${n / 2}px)`,
          [`> ${t}-icon`]: {
            top: 0
          },
          [`${t}-icon-dot`]: {
            borderRadius: e.fontSizeSM / 4
          }
        },
        "&-content": {
          width: "auto",
          marginTop: e.marginXS - e.lineWidth
        },
        "&-title": {
          color: o,
          fontSize: e.fontSizeSM,
          lineHeight: e.lineHeightSM,
          fontWeight: "normal",
          marginBottom: e.marginXXS / 2
        },
        "&-description": {
          display: "none"
        },
        "&-tail": {
          marginInlineStart: 0,
          top: r + n / 2,
          transform: "translateY(-50%)",
          "&:after": {
            width: "100%",
            height: e.lineWidth,
            borderRadius: 0,
            marginInlineStart: 0,
            background: l
          }
        },
        [`&:first-child ${t}-item-tail`]: {
          width: "50%",
          marginInlineStart: "50%"
        },
        [`&:last-child ${t}-item-tail`]: {
          display: "block",
          width: "50%"
        },
        "&-wait": _({
          [`${t}-item-icon ${t}-icon ${t}-icon-dot`]: {
            backgroundColor: e.colorBorderBg,
            border: `${e.lineWidth}px ${e.lineType} ${l}`
          }
        }, a),
        "&-finish": _({
          [`${t}-item-tail::after`]: {
            backgroundColor: l
          },
          [`${t}-item-icon ${t}-icon ${t}-icon-dot`]: {
            backgroundColor: l,
            border: `${e.lineWidth}px ${e.lineType} ${l}`
          }
        }, a),
        "&-error": a,
        "&-active, &-process": _({
          [`${t}-item-icon`]: {
            width: n,
            height: n,
            marginInlineStart: `calc(50% - ${n / 2}px)`,
            top: 0
          }
        }, a),
        [`&:not(${t}-item-active) > ${t}-item-container[role='button']:hover`]: {
          [`${t}-item-title`]: {
            color: o
          }
        }
      }
    }
  };
};
var nf;
(function(e) {
  e.wait = "wait", e.process = "process", e.finish = "finish", e.error = "error";
})(nf || (nf = {}));
const jg = (e, t) => {
  const n = `${t.componentCls}-item`, o = `${e}IconColor`, l = `${e}TitleColor`, r = `${e}DescriptionColor`, a = `${e}TailColor`, i = `${e}IconBgColor`, s = `${e}IconBorderColor`, c = `${e}DotColor`;
  return {
    [`${n}-${e} ${n}-icon`]: {
      backgroundColor: t[i],
      borderColor: t[s],
      [`> ${t.componentCls}-icon`]: {
        color: t[o],
        [`${t.componentCls}-icon-dot`]: {
          background: t[c]
        }
      }
    },
    [`${n}-${e}${n}-custom ${n}-icon`]: {
      [`> ${t.componentCls}-icon`]: {
        color: t[c]
      }
    },
    [`${n}-${e} > ${n}-container > ${n}-content > ${n}-title`]: {
      color: t[l],
      "&::after": {
        backgroundColor: t[a]
      }
    },
    [`${n}-${e} > ${n}-container > ${n}-content > ${n}-description`]: {
      color: t[r]
    },
    [`${n}-${e} > ${n}-container > ${n}-tail::after`]: {
      backgroundColor: t[a]
    }
  };
}, wWe = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n
  } = e, o = `${t}-item`;
  return _(_(_(_(_(_({
    [o]: {
      position: "relative",
      display: "inline-block",
      flex: 1,
      overflow: "hidden",
      verticalAlign: "top",
      "&:last-child": {
        flex: "none",
        [`> ${o}-container > ${o}-tail, > ${o}-container >  ${o}-content > ${o}-title::after`]: {
          display: "none"
        }
      }
    },
    [`${o}-container`]: {
      outline: "none"
    },
    [`${o}-icon, ${o}-content`]: {
      display: "inline-block",
      verticalAlign: "top"
    },
    [`${o}-icon`]: {
      width: e.stepsIconSize,
      height: e.stepsIconSize,
      marginTop: 0,
      marginBottom: 0,
      marginInlineStart: 0,
      marginInlineEnd: e.marginXS,
      fontSize: e.stepsIconFontSize,
      fontFamily: e.fontFamily,
      lineHeight: `${e.stepsIconSize}px`,
      textAlign: "center",
      borderRadius: e.stepsIconSize,
      border: `${e.lineWidth}px ${e.lineType} transparent`,
      transition: `background-color ${n}, border-color ${n}`,
      [`${t}-icon`]: {
        position: "relative",
        top: e.stepsIconTop,
        color: e.colorPrimary,
        lineHeight: 1
      }
    },
    [`${o}-tail`]: {
      position: "absolute",
      top: e.stepsIconSize / 2 - e.paddingXXS,
      insetInlineStart: 0,
      width: "100%",
      "&::after": {
        display: "inline-block",
        width: "100%",
        height: e.lineWidth,
        background: e.colorSplit,
        borderRadius: e.lineWidth,
        transition: `background ${n}`,
        content: '""'
      }
    },
    [`${o}-title`]: {
      position: "relative",
      display: "inline-block",
      paddingInlineEnd: e.padding,
      color: e.colorText,
      fontSize: e.fontSizeLG,
      lineHeight: `${e.stepsTitleLineHeight}px`,
      "&::after": {
        position: "absolute",
        top: e.stepsTitleLineHeight / 2,
        insetInlineStart: "100%",
        display: "block",
        width: 9999,
        height: e.lineWidth,
        background: e.processTailColor,
        content: '""'
      }
    },
    [`${o}-subtitle`]: {
      display: "inline",
      marginInlineStart: e.marginXS,
      color: e.colorTextDescription,
      fontWeight: "normal",
      fontSize: e.fontSize
    },
    [`${o}-description`]: {
      color: e.colorTextDescription,
      fontSize: e.fontSize
    }
  }, jg(nf.wait, e)), jg(nf.process, e)), {
    [`${o}-process > ${o}-container > ${o}-title`]: {
      fontWeight: e.fontWeightStrong
    }
  }), jg(nf.finish, e)), jg(nf.error, e)), {
    [`${o}${t}-next-error > ${t}-item-title::after`]: {
      background: e.colorError
    },
    [`${o}-disabled`]: {
      cursor: "not-allowed"
    }
  });
}, $We = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n
  } = e;
  return {
    [`& ${t}-item`]: {
      [`&:not(${t}-item-active)`]: {
        [`& > ${t}-item-container[role='button']`]: {
          cursor: "pointer",
          [`${t}-item`]: {
            [`&-title, &-subtitle, &-description, &-icon ${t}-icon`]: {
              transition: `color ${n}`
            }
          },
          "&:hover": {
            [`${t}-item`]: {
              "&-title, &-subtitle, &-description": {
                color: e.colorPrimary
              }
            }
          }
        },
        [`&:not(${t}-item-process)`]: {
          [`& > ${t}-item-container[role='button']:hover`]: {
            [`${t}-item`]: {
              "&-icon": {
                borderColor: e.colorPrimary,
                [`${t}-icon`]: {
                  color: e.colorPrimary
                }
              }
            }
          }
        }
      }
    },
    [`&${t}-horizontal:not(${t}-label-vertical)`]: {
      [`${t}-item`]: {
        paddingInlineStart: e.padding,
        whiteSpace: "nowrap",
        "&:first-child": {
          paddingInlineStart: 0
        },
        [`&:last-child ${t}-item-title`]: {
          paddingInlineEnd: 0
        },
        "&-tail": {
          display: "none"
        },
        "&-description": {
          maxWidth: e.descriptionWidth,
          whiteSpace: "normal"
        }
      }
    }
  };
}, xWe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: _(_(_(_(_(_(_(_(_(_(_(_(_({}, nn(e)), {
      display: "flex",
      width: "100%",
      fontSize: 0,
      textAlign: "initial"
    }), wWe(e)), $We(e)), pWe(e)), yWe(e)), SWe(e)), vWe(e)), gWe(e)), mWe(e)), bWe(e)), hWe(e)), CWe(e))
  };
}, EWe = Zt("Steps", (e) => {
  const {
    wireframe: t,
    colorTextDisabled: n,
    fontSizeHeading3: o,
    fontSize: l,
    controlHeight: r,
    controlHeightLG: a,
    colorTextLightSolid: i,
    colorText: s,
    colorPrimary: c,
    colorTextLabel: u,
    colorTextDescription: d,
    colorTextQuaternary: f,
    colorFillContent: p,
    controlItemBgActive: m,
    colorError: v,
    colorBgContainer: h,
    colorBorderSecondary: g
  } = e, y = e.controlHeight, b = e.colorSplit, C = Vt(e, {
    // Steps variable default.less
    processTailColor: b,
    stepsNavArrowColor: n,
    stepsIconSize: y,
    stepsIconCustomSize: y,
    stepsIconCustomTop: 0,
    stepsIconCustomFontSize: a / 2,
    stepsIconTop: -0.5,
    stepsIconFontSize: l,
    stepsTitleLineHeight: r,
    stepsSmallIconSize: o,
    stepsDotSize: r / 4,
    stepsCurrentDotSize: a / 4,
    stepsNavContentMaxWidth: "auto",
    // Steps component less variable
    processIconColor: i,
    processTitleColor: s,
    processDescriptionColor: s,
    processIconBgColor: c,
    processIconBorderColor: c,
    processDotColor: c,
    waitIconColor: t ? n : u,
    waitTitleColor: d,
    waitDescriptionColor: d,
    waitTailColor: b,
    waitIconBgColor: t ? h : p,
    waitIconBorderColor: t ? n : "transparent",
    waitDotColor: n,
    finishIconColor: c,
    finishTitleColor: s,
    finishDescriptionColor: d,
    finishTailColor: c,
    finishIconBgColor: t ? h : m,
    finishIconBorderColor: t ? c : m,
    finishDotColor: c,
    errorIconColor: i,
    errorTitleColor: v,
    errorDescriptionColor: v,
    errorTailColor: b,
    errorIconBgColor: v,
    errorIconBorderColor: v,
    errorDotColor: v,
    stepsNavActiveColor: c,
    stepsProgressSize: a,
    // Steps inline variable
    inlineDotSize: 6,
    inlineTitleColor: f,
    inlineTailColor: g
  });
  return [xWe(C)];
}, {
  descriptionWidth: 140
}), OWe = () => ({
  prefixCls: String,
  iconPrefix: String,
  current: Number,
  initial: Number,
  percent: Number,
  responsive: Qe(),
  items: $n(),
  labelPlacement: At(),
  status: At(),
  size: At(),
  direction: At(),
  progressDot: zt([Boolean, Function]),
  type: At(),
  onChange: Fe(),
  "onUpdate:current": Fe()
}), l$ = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ASteps",
  inheritAttrs: !1,
  props: sn(OWe(), {
    current: 0,
    responsive: !0,
    labelPlacement: "horizontal"
  }),
  slots: Object,
  // emits: ['update:current', 'change'],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: l
    } = t;
    const {
      prefixCls: r,
      direction: a,
      configProvider: i
    } = bt("steps", e), [s, c] = EWe(r), [, u] = _s(), d = Dp(), f = O(() => e.responsive && d.value.xs ? "vertical" : e.direction), p = O(() => i.getPrefixCls("", e.iconPrefix)), m = (b) => {
      l("update:current", b), l("change", b);
    }, v = O(() => e.type === "inline"), h = O(() => v.value ? void 0 : e.percent), g = (b) => {
      let {
        node: C,
        status: w
      } = b;
      if (w === "process" && e.percent !== void 0) {
        const x = e.size === "small" ? u.value.controlHeight : u.value.controlHeightLG;
        return $("div", {
          class: `${r.value}-progress-icon`
        }, [$(vP, {
          type: "circle",
          percent: h.value,
          size: x,
          strokeWidth: 4,
          format: () => null
        }, null), C]);
      }
      return C;
    }, y = O(() => ({
      finish: $(Np, {
        class: `${r.value}-finish-icon`
      }, null),
      error: $(Hl, {
        class: `${r.value}-error-icon`
      }, null)
    }));
    return () => {
      const b = ke({
        [`${r.value}-rtl`]: a.value === "rtl",
        [`${r.value}-with-progress`]: h.value !== void 0
      }, n.class, c.value), C = (w, x) => w.description ? $(Sr, {
        title: w.description
      }, {
        default: () => [x]
      }) : x;
      return s($(fWe, Q(Q(Q({
        icons: y.value
      }, n), pn(e, ["percent", "responsive"])), {}, {
        items: e.items,
        direction: f.value,
        prefixCls: r.value,
        iconPrefix: p.value,
        class: b,
        onChange: m,
        isInline: v.value,
        itemRender: v.value ? C : void 0
      }), _({
        stepIcon: g
      }, o)));
    };
  }
}), Jb = /* @__PURE__ */ le(_(_({
  compatConfig: {
    MODE: 3
  }
}, SG), {
  name: "AStep",
  props: yG()
})), _We = _(l$, {
  Step: Jb,
  install: (e) => (e.component(l$.name, l$), e.component(Jb.name, Jb), e)
}), IWe = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-inner`;
  return {
    [t]: {
      [`&${t}-small`]: {
        minWidth: e.switchMinWidthSM,
        height: e.switchHeightSM,
        lineHeight: `${e.switchHeightSM}px`,
        [`${t}-inner`]: {
          paddingInlineStart: e.switchInnerMarginMaxSM,
          paddingInlineEnd: e.switchInnerMarginMinSM,
          [`${n}-checked`]: {
            marginInlineStart: `calc(-100% + ${e.switchPinSizeSM + e.switchPadding * 2}px - ${e.switchInnerMarginMaxSM * 2}px)`,
            marginInlineEnd: `calc(100% - ${e.switchPinSizeSM + e.switchPadding * 2}px + ${e.switchInnerMarginMaxSM * 2}px)`
          },
          [`${n}-unchecked`]: {
            marginTop: -e.switchHeightSM,
            marginInlineStart: 0,
            marginInlineEnd: 0
          }
        },
        [`${t}-handle`]: {
          width: e.switchPinSizeSM,
          height: e.switchPinSizeSM
        },
        [`${t}-loading-icon`]: {
          top: (e.switchPinSizeSM - e.switchLoadingIconSize) / 2,
          fontSize: e.switchLoadingIconSize
        },
        [`&${t}-checked`]: {
          [`${t}-inner`]: {
            paddingInlineStart: e.switchInnerMarginMinSM,
            paddingInlineEnd: e.switchInnerMarginMaxSM,
            [`${n}-checked`]: {
              marginInlineStart: 0,
              marginInlineEnd: 0
            },
            [`${n}-unchecked`]: {
              marginInlineStart: `calc(100% - ${e.switchPinSizeSM + e.switchPadding * 2}px + ${e.switchInnerMarginMaxSM * 2}px)`,
              marginInlineEnd: `calc(-100% + ${e.switchPinSizeSM + e.switchPadding * 2}px - ${e.switchInnerMarginMaxSM * 2}px)`
            }
          },
          [`${t}-handle`]: {
            insetInlineStart: `calc(100% - ${e.switchPinSizeSM + e.switchPadding}px)`
          }
        },
        [`&:not(${t}-disabled):active`]: {
          [`&:not(${t}-checked) ${n}`]: {
            [`${n}-unchecked`]: {
              marginInlineStart: e.marginXXS / 2,
              marginInlineEnd: -e.marginXXS / 2
            }
          },
          [`&${t}-checked ${n}`]: {
            [`${n}-checked`]: {
              marginInlineStart: -e.marginXXS / 2,
              marginInlineEnd: e.marginXXS / 2
            }
          }
        }
      }
    }
  };
}, TWe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`${t}-loading-icon${e.iconCls}`]: {
        position: "relative",
        top: (e.switchPinSize - e.fontSize) / 2,
        color: e.switchLoadingIconColor,
        verticalAlign: "top"
      },
      [`&${t}-checked ${t}-loading-icon`]: {
        color: e.switchColor
      }
    }
  };
}, PWe = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-handle`;
  return {
    [t]: {
      [n]: {
        position: "absolute",
        top: e.switchPadding,
        insetInlineStart: e.switchPadding,
        width: e.switchPinSize,
        height: e.switchPinSize,
        transition: `all ${e.switchDuration} ease-in-out`,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          backgroundColor: e.colorWhite,
          borderRadius: e.switchPinSize / 2,
          boxShadow: e.switchHandleShadow,
          transition: `all ${e.switchDuration} ease-in-out`,
          content: '""'
        }
      },
      [`&${t}-checked ${n}`]: {
        insetInlineStart: `calc(100% - ${e.switchPinSize + e.switchPadding}px)`
      },
      [`&:not(${t}-disabled):active`]: {
        [`${n}::before`]: {
          insetInlineEnd: e.switchHandleActiveInset,
          insetInlineStart: 0
        },
        [`&${t}-checked ${n}::before`]: {
          insetInlineEnd: 0,
          insetInlineStart: e.switchHandleActiveInset
        }
      }
    }
  };
}, kWe = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-inner`;
  return {
    [t]: {
      [n]: {
        display: "block",
        overflow: "hidden",
        borderRadius: 100,
        height: "100%",
        paddingInlineStart: e.switchInnerMarginMax,
        paddingInlineEnd: e.switchInnerMarginMin,
        transition: `padding-inline-start ${e.switchDuration} ease-in-out, padding-inline-end ${e.switchDuration} ease-in-out`,
        [`${n}-checked, ${n}-unchecked`]: {
          display: "block",
          color: e.colorTextLightSolid,
          fontSize: e.fontSizeSM,
          transition: `margin-inline-start ${e.switchDuration} ease-in-out, margin-inline-end ${e.switchDuration} ease-in-out`,
          pointerEvents: "none"
        },
        [`${n}-checked`]: {
          marginInlineStart: `calc(-100% + ${e.switchPinSize + e.switchPadding * 2}px - ${e.switchInnerMarginMax * 2}px)`,
          marginInlineEnd: `calc(100% - ${e.switchPinSize + e.switchPadding * 2}px + ${e.switchInnerMarginMax * 2}px)`
        },
        [`${n}-unchecked`]: {
          marginTop: -e.switchHeight,
          marginInlineStart: 0,
          marginInlineEnd: 0
        }
      },
      [`&${t}-checked ${n}`]: {
        paddingInlineStart: e.switchInnerMarginMin,
        paddingInlineEnd: e.switchInnerMarginMax,
        [`${n}-checked`]: {
          marginInlineStart: 0,
          marginInlineEnd: 0
        },
        [`${n}-unchecked`]: {
          marginInlineStart: `calc(100% - ${e.switchPinSize + e.switchPadding * 2}px + ${e.switchInnerMarginMax * 2}px)`,
          marginInlineEnd: `calc(-100% + ${e.switchPinSize + e.switchPadding * 2}px - ${e.switchInnerMarginMax * 2}px)`
        }
      },
      [`&:not(${t}-disabled):active`]: {
        [`&:not(${t}-checked) ${n}`]: {
          [`${n}-unchecked`]: {
            marginInlineStart: e.switchPadding * 2,
            marginInlineEnd: -e.switchPadding * 2
          }
        },
        [`&${t}-checked ${n}`]: {
          [`${n}-checked`]: {
            marginInlineStart: -e.switchPadding * 2,
            marginInlineEnd: e.switchPadding * 2
          }
        }
      }
    }
  };
}, NWe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: _(_(_(_({}, nn(e)), {
      position: "relative",
      display: "inline-block",
      boxSizing: "border-box",
      minWidth: e.switchMinWidth,
      height: e.switchHeight,
      lineHeight: `${e.switchHeight}px`,
      verticalAlign: "middle",
      background: e.colorTextQuaternary,
      border: "0",
      borderRadius: 100,
      cursor: "pointer",
      transition: `all ${e.motionDurationMid}`,
      userSelect: "none",
      [`&:hover:not(${t}-disabled)`]: {
        background: e.colorTextTertiary
      }
    }), ys(e)), {
      [`&${t}-checked`]: {
        background: e.switchColor,
        [`&:hover:not(${t}-disabled)`]: {
          background: e.colorPrimaryHover
        }
      },
      [`&${t}-loading, &${t}-disabled`]: {
        cursor: "not-allowed",
        opacity: e.switchDisabledOpacity,
        "*": {
          boxShadow: "none",
          cursor: "not-allowed"
        }
      },
      // rtl style
      [`&${t}-rtl`]: {
        direction: "rtl"
      }
    })
  };
}, MWe = Zt("Switch", (e) => {
  const t = e.fontSize * e.lineHeight, n = e.controlHeight / 2, o = 2, l = t - o * 2, r = n - o * 2, a = Vt(e, {
    switchMinWidth: l * 2 + o * 4,
    switchHeight: t,
    switchDuration: e.motionDurationMid,
    switchColor: e.colorPrimary,
    switchDisabledOpacity: e.opacityLoading,
    switchInnerMarginMin: l / 2,
    switchInnerMarginMax: l + o + o * 2,
    switchPadding: o,
    switchPinSize: l,
    switchBg: e.colorBgContainer,
    switchMinWidthSM: r * 2 + o * 2,
    switchHeightSM: n,
    switchInnerMarginMinSM: r / 2,
    switchInnerMarginMaxSM: r + o + o * 2,
    switchPinSizeSM: r,
    switchHandleShadow: `0 2px 4px 0 ${new xn("#00230b").setAlpha(0.2).toRgbString()}`,
    switchLoadingIconSize: e.fontSizeIcon * 0.75,
    switchLoadingIconColor: `rgba(0, 0, 0, ${e.opacityLoading})`,
    switchHandleActiveInset: "-30%"
  });
  return [
    NWe(a),
    // inner style
    kWe(a),
    // handle style
    PWe(a),
    // loading style
    TWe(a),
    // small style
    IWe(a)
  ];
}), AWe = $l("small", "default"), RWe = () => ({
  id: String,
  prefixCls: String,
  size: de.oneOf(AWe),
  disabled: {
    type: Boolean,
    default: void 0
  },
  checkedChildren: de.any,
  unCheckedChildren: de.any,
  tabindex: de.oneOfType([de.string, de.number]),
  autofocus: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  checked: de.oneOfType([de.string, de.number, de.looseBool]),
  checkedValue: de.oneOfType([de.string, de.number, de.looseBool]).def(!0),
  unCheckedValue: de.oneOfType([de.string, de.number, de.looseBool]).def(!1),
  onChange: {
    type: Function
  },
  onClick: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onMouseup: {
    type: Function
  },
  "onUpdate:checked": {
    type: Function
  },
  onBlur: Function,
  onFocus: Function
}), DWe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ASwitch",
  __ANT_SWITCH: !0,
  inheritAttrs: !1,
  props: RWe(),
  slots: Object,
  // emits: ['update:checked', 'mouseup', 'change', 'click', 'keydown', 'blur'],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: l,
      emit: r
    } = t;
    const a = Ko(), i = Cr(), s = O(() => {
      var T;
      return (T = e.disabled) !== null && T !== void 0 ? T : i.value;
    });
    _c(() => {
      Hn(!("defaultChecked" in n), "Switch", "'defaultChecked' is deprecated, please use 'v-model:checked'"), Hn(!("value" in n), "Switch", "`value` is not validate prop, do you mean `checked`?");
    });
    const c = /* @__PURE__ */ H(e.checked !== void 0 ? e.checked : n.defaultChecked), u = O(() => c.value === e.checkedValue);
    pe(() => e.checked, () => {
      c.value = e.checked;
    });
    const {
      prefixCls: d,
      direction: f,
      size: p
    } = bt("switch", e), [m, v] = MWe(d), h = /* @__PURE__ */ H(), g = () => {
      var T;
      (T = h.value) === null || T === void 0 || T.focus();
    };
    l({
      focus: g,
      blur: () => {
        var T;
        (T = h.value) === null || T === void 0 || T.blur();
      }
    }), nt(() => {
      Ke(() => {
        e.autofocus && !s.value && h.value.focus();
      });
    });
    const b = (T, P) => {
      s.value || (r("update:checked", T), r("change", T, P), a.onFieldChange());
    }, C = (T) => {
      r("blur", T);
    }, w = (T) => {
      g();
      const P = u.value ? e.unCheckedValue : e.checkedValue;
      b(P, T), r("click", P, T);
    }, x = (T) => {
      T.keyCode === ot.LEFT ? b(e.unCheckedValue, T) : T.keyCode === ot.RIGHT && b(e.checkedValue, T), r("keydown", T);
    }, E = (T) => {
      var P;
      (P = h.value) === null || P === void 0 || P.blur(), r("mouseup", T);
    }, I = O(() => ({
      [`${d.value}-small`]: p.value === "small",
      [`${d.value}-loading`]: e.loading,
      [`${d.value}-checked`]: u.value,
      [`${d.value}-disabled`]: s.value,
      [d.value]: !0,
      [`${d.value}-rtl`]: f.value === "rtl",
      [v.value]: !0
    }));
    return () => {
      var T;
      return m($(XI, null, {
        default: () => [$("button", Q(Q(Q({}, pn(e, ["prefixCls", "checkedChildren", "unCheckedChildren", "checked", "autofocus", "checkedValue", "unCheckedValue", "id", "onChange", "onUpdate:checked"])), n), {}, {
          id: (T = e.id) !== null && T !== void 0 ? T : a.id.value,
          onKeydown: x,
          onClick: w,
          onBlur: C,
          onMouseup: E,
          type: "button",
          role: "switch",
          "aria-checked": c.value,
          disabled: s.value || e.loading,
          class: [n.class, I.value],
          ref: h
        }), [$("div", {
          class: `${d.value}-handle`
        }, [e.loading ? $(ar, {
          class: `${d.value}-loading-icon`
        }, null) : null]), $("span", {
          class: `${d.value}-inner`
        }, [$("span", {
          class: `${d.value}-inner-checked`
        }, [Wo(o, e, "checkedChildren")]), $("span", {
          class: `${d.value}-inner-unchecked`
        }, [Wo(o, e, "unCheckedChildren")])])])]
      }));
    };
  }
}), LWe = po(DWe), CG = Symbol("TableContextProps"), BWe = (e) => {
  at(CG, e);
}, Di = () => ze(CG, {}), FWe = "RC_TABLE_KEY";
function wG(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function $G(e, t) {
  if (!t && typeof t != "number")
    return e;
  const n = wG(t);
  let o = e;
  for (let l = 0; l < n.length; l += 1) {
    if (!o)
      return null;
    const r = n[l];
    o = o[r];
  }
  return o;
}
function tC(e) {
  const t = [], n = {};
  return e.forEach((o) => {
    const {
      key: l,
      dataIndex: r
    } = o || {};
    let a = l || wG(r).join("-") || FWe;
    for (; n[a]; )
      a = `${a}_next`;
    n[a] = !0, t.push(a);
  }), t;
}
function VWe() {
  const e = {};
  function t(r, a) {
    a && Object.keys(a).forEach((i) => {
      const s = a[i];
      s && typeof s == "object" ? (r[i] = r[i] || {}, t(r[i], s)) : r[i] = s;
    });
  }
  for (var n = arguments.length, o = new Array(n), l = 0; l < n; l++)
    o[l] = arguments[l];
  return o.forEach((r) => {
    t(e, r);
  }), e;
}
function nE(e) {
  return e != null;
}
const xG = Symbol("SlotsContextProps"), zWe = (e) => {
  at(xG, e);
}, yP = () => ze(xG, O(() => ({}))), EG = Symbol("ContextProps"), HWe = (e) => {
  at(EG, e);
}, jWe = () => ze(EG, {
  onResizeColumn: () => {
  }
}), Pf = "RC_TABLE_INTERNAL_COL_DEFINE", OG = Symbol("HoverContextProps"), WWe = (e) => {
  at(OG, e);
}, KWe = () => ze(OG, {
  startRow: /* @__PURE__ */ Ce(-1),
  endRow: /* @__PURE__ */ Ce(-1),
  onHover() {
  }
}), oE = /* @__PURE__ */ Ce(!1), UWe = () => {
  nt(() => {
    oE.value = oE.value || FT("position", "sticky");
  });
}, GWe = () => oE;
var YWe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function XWe(e, t, n, o) {
  const l = e + t - 1;
  return e <= o && l >= n;
}
function qWe(e) {
  return e && typeof e == "object" && !Array.isArray(e) && !dn(e);
}
const nC = /* @__PURE__ */ le({
  name: "Cell",
  props: ["prefixCls", "record", "index", "renderIndex", "dataIndex", "customRender", "component", "colSpan", "rowSpan", "fixLeft", "fixRight", "firstFixLeft", "lastFixLeft", "firstFixRight", "lastFixRight", "appendNode", "additionalProps", "ellipsis", "align", "rowType", "isSticky", "column", "cellType", "transformCellText"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = yP(), {
      onHover: l,
      startRow: r,
      endRow: a
    } = KWe(), i = O(() => {
      var v, h, g, y;
      return (g = (v = e.colSpan) !== null && v !== void 0 ? v : (h = e.additionalProps) === null || h === void 0 ? void 0 : h.colSpan) !== null && g !== void 0 ? g : (y = e.additionalProps) === null || y === void 0 ? void 0 : y.colspan;
    }), s = O(() => {
      var v, h, g, y;
      return (g = (v = e.rowSpan) !== null && v !== void 0 ? v : (h = e.additionalProps) === null || h === void 0 ? void 0 : h.rowSpan) !== null && g !== void 0 ? g : (y = e.additionalProps) === null || y === void 0 ? void 0 : y.rowspan;
    }), c = _r(() => {
      const {
        index: v
      } = e;
      return XWe(v, s.value || 1, r.value, a.value);
    }), u = GWe(), d = (v, h) => {
      var g;
      const {
        record: y,
        index: b,
        additionalProps: C
      } = e;
      y && l(b, b + h - 1), (g = C == null ? void 0 : C.onMouseenter) === null || g === void 0 || g.call(C, v);
    }, f = (v) => {
      var h;
      const {
        record: g,
        additionalProps: y
      } = e;
      g && l(-1, -1), (h = y == null ? void 0 : y.onMouseleave) === null || h === void 0 || h.call(y, v);
    }, p = (v) => {
      const h = mo(v)[0];
      return dn(h) ? h.type === Vr ? h.children : Array.isArray(h.children) ? p(h.children) : void 0 : h;
    }, m = /* @__PURE__ */ Ce(null);
    return pe([c, () => e.prefixCls, m], () => {
      const v = nr(m.value);
      v && (c.value ? Ey(v, `${e.prefixCls}-cell-row-hover`) : Oy(v, `${e.prefixCls}-cell-row-hover`));
    }), () => {
      var v, h, g, y, b, C;
      const {
        prefixCls: w,
        record: x,
        index: E,
        renderIndex: I,
        dataIndex: T,
        customRender: P,
        component: k = "td",
        fixLeft: N,
        fixRight: R,
        firstFixLeft: z,
        lastFixLeft: D,
        firstFixRight: F,
        lastFixRight: M,
        appendNode: A = (v = n.appendNode) === null || v === void 0 ? void 0 : v.call(n),
        additionalProps: L = {},
        ellipsis: B,
        align: V,
        rowType: j,
        isSticky: W,
        column: Y = {},
        cellType: U
      } = e, te = `${w}-cell`;
      let J, re;
      const oe = (h = n.default) === null || h === void 0 ? void 0 : h.call(n);
      if (nE(oe) || U === "header")
        re = oe;
      else {
        const Se = $G(x, T);
        if (re = Se, P) {
          const be = P({
            text: Se,
            value: Se,
            record: x,
            index: E,
            renderIndex: I,
            column: Y.__originColumn__
          });
          qWe(be) ? (process.env.NODE_ENV !== "production" && bn(!1, "`columns.customRender` return cell props is deprecated with perf issue, please use `customCell` instead."), re = be.children, J = be.props) : re = be;
        }
        if (!(Pf in Y) && U === "body" && o.value.bodyCell && !(!((g = Y.slots) === null || g === void 0) && g.customRender)) {
          const be = fS(o.value, "bodyCell", {
            text: Se,
            value: Se,
            record: x,
            index: E,
            column: Y.__originColumn__
          }, () => {
            const ie = re === void 0 ? Se : re;
            return [typeof ie == "object" && Io(ie) || typeof ie != "object" ? ie : null];
          });
          re = Fn(be);
        }
        e.transformCellText && (re = e.transformCellText({
          text: re,
          record: x,
          index: E,
          column: Y.__originColumn__
        }));
      }
      typeof re == "object" && !Array.isArray(re) && !dn(re) && (re = null), B && (D || F) && (re = $("span", {
        class: `${te}-content`
      }, [re])), Array.isArray(re) && re.length === 1 && (re = re[0]);
      const q = J || {}, {
        colSpan: K,
        rowSpan: se,
        style: Z,
        class: ee
      } = q, fe = YWe(q, ["colSpan", "rowSpan", "style", "class"]), me = (y = K !== void 0 ? K : i.value) !== null && y !== void 0 ? y : 1, ge = (b = se !== void 0 ? se : s.value) !== null && b !== void 0 ? b : 1;
      if (me === 0 || ge === 0)
        return null;
      const he = {}, $e = typeof N == "number" && u.value, ne = typeof R == "number" && u.value;
      $e && (he.position = "sticky", he.left = `${N}px`), ne && (he.position = "sticky", he.right = `${R}px`);
      const ae = {};
      V && (ae.textAlign = V);
      let ce;
      const xe = B === !0 ? {
        showTitle: !0
      } : B;
      xe && (xe.showTitle || j === "header") && (typeof re == "string" || typeof re == "number" ? ce = re.toString() : dn(re) && (ce = p([re])));
      const Te = _(_(_({
        title: ce
      }, fe), L), {
        colSpan: me !== 1 ? me : null,
        rowSpan: ge !== 1 ? ge : null,
        class: ke(te, {
          [`${te}-fix-left`]: $e && u.value,
          [`${te}-fix-left-first`]: z && u.value,
          [`${te}-fix-left-last`]: D && u.value,
          [`${te}-fix-right`]: ne && u.value,
          [`${te}-fix-right-first`]: F && u.value,
          [`${te}-fix-right-last`]: M && u.value,
          [`${te}-ellipsis`]: B,
          [`${te}-with-append`]: A,
          [`${te}-fix-sticky`]: ($e || ne) && W && u.value
        }, L.class, ee),
        onMouseenter: (Se) => {
          d(Se, ge);
        },
        onMouseleave: f,
        style: [L.style, ae, he, Z]
      });
      return $(k, Q(Q({}, Te), {}, {
        ref: m
      }), {
        default: () => [A, re, (C = n.dragHandle) === null || C === void 0 ? void 0 : C.call(n)]
      });
    };
  }
});
function SP(e, t, n, o, l) {
  const r = n[e] || {}, a = n[t] || {};
  let i, s;
  r.fixed === "left" ? i = o.left[e] : a.fixed === "right" && (s = o.right[t]);
  let c = !1, u = !1, d = !1, f = !1;
  const p = n[t + 1], m = n[e - 1];
  return l === "rtl" ? i !== void 0 ? f = !(m && m.fixed === "left") : s !== void 0 && (d = !(p && p.fixed === "right")) : i !== void 0 ? c = !(p && p.fixed === "left") : s !== void 0 && (u = !(m && m.fixed === "right")), {
    fixLeft: i,
    fixRight: s,
    lastFixLeft: c,
    firstFixRight: u,
    lastFixRight: d,
    firstFixLeft: f,
    isSticky: o.isSticky
  };
}
const uR = {
  mouse: {
    move: "mousemove",
    stop: "mouseup"
  },
  touch: {
    move: "touchmove",
    stop: "touchend"
  }
}, dR = 50, JWe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "DragHandle",
  props: {
    prefixCls: String,
    width: {
      type: Number,
      required: !0
    },
    minWidth: {
      type: Number,
      default: dR
    },
    maxWidth: {
      type: Number,
      default: 1 / 0
    },
    column: {
      type: Object,
      default: void 0
    }
  },
  setup(e) {
    let t = 0, n = {
      remove: () => {
      }
    }, o = {
      remove: () => {
      }
    };
    const l = () => {
      n.remove(), o.remove();
    };
    Uo(() => {
      l();
    }), Ot(() => {
      un(!isNaN(e.width), "Table", "width must be a number when use resizable");
    });
    const {
      onResizeColumn: r
    } = jWe(), a = O(() => typeof e.minWidth == "number" && !isNaN(e.minWidth) ? e.minWidth : dR), i = O(() => typeof e.maxWidth == "number" && !isNaN(e.maxWidth) ? e.maxWidth : 1 / 0), s = xt();
    let c = 0;
    const u = /* @__PURE__ */ Ce(!1);
    let d;
    const f = (b) => {
      let C = 0;
      b.touches ? b.touches.length ? C = b.touches[0].pageX : C = b.changedTouches[0].pageX : C = b.pageX;
      const w = t - C;
      let x = Math.max(c - w, a.value);
      x = Math.min(x, i.value), rn.cancel(d), d = rn(() => {
        r(x, e.column.__originColumn__);
      });
    }, p = (b) => {
      f(b);
    }, m = (b) => {
      u.value = !1, f(b), l();
    }, v = (b, C) => {
      u.value = !0, l(), c = s.vnode.el.parentNode.getBoundingClientRect().width, !(b instanceof MouseEvent && b.which !== 1) && (b.stopPropagation && b.stopPropagation(), t = b.touches ? b.touches[0].pageX : b.pageX, n = vo(document.documentElement, C.move, p), o = vo(document.documentElement, C.stop, m));
    }, h = (b) => {
      b.stopPropagation(), b.preventDefault(), v(b, uR.mouse);
    }, g = (b) => {
      b.stopPropagation(), b.preventDefault(), v(b, uR.touch);
    }, y = (b) => {
      b.stopPropagation(), b.preventDefault();
    };
    return () => {
      const {
        prefixCls: b
      } = e, C = {
        [Ho ? "onTouchstartPassive" : "onTouchstart"]: (w) => g(w)
      };
      return $("div", Q(Q({
        class: `${b}-resize-handle ${u.value ? "dragging" : ""}`,
        onMousedown: h
      }, C), {}, {
        onClick: y
      }), [$("div", {
        class: `${b}-resize-handle-line`
      }, null)]);
    };
  }
}), ZWe = /* @__PURE__ */ le({
  name: "HeaderRow",
  props: ["cells", "stickyOffsets", "flattenColumns", "rowComponent", "cellComponent", "index", "customHeaderRow"],
  setup(e) {
    const t = Di();
    return () => {
      const {
        prefixCls: n,
        direction: o
      } = t, {
        cells: l,
        stickyOffsets: r,
        flattenColumns: a,
        rowComponent: i,
        cellComponent: s,
        customHeaderRow: c,
        index: u
      } = e;
      let d;
      c && (d = c(l.map((p) => p.column), u));
      const f = tC(l.map((p) => p.column));
      return $(i, d, {
        default: () => [l.map((p, m) => {
          const {
            column: v
          } = p, h = SP(p.colStart, p.colEnd, a, r, o);
          let g;
          v && v.customHeaderCell && (g = p.column.customHeaderCell(v));
          const y = v;
          return $(nC, Q(Q(Q({}, p), {}, {
            cellType: "header",
            ellipsis: v.ellipsis,
            align: v.align,
            component: s,
            prefixCls: n,
            key: f[m]
          }, h), {}, {
            additionalProps: g,
            rowType: "header",
            column: v
          }), {
            default: () => v.title,
            dragHandle: () => y.resizable ? $(JWe, {
              prefixCls: n,
              width: y.width,
              minWidth: y.minWidth,
              maxWidth: y.maxWidth,
              column: y
            }, null) : null
          });
        })]
      });
    };
  }
});
function QWe(e) {
  const t = [];
  function n(l, r) {
    let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    t[a] = t[a] || [];
    let i = r;
    return l.filter(Boolean).map((c) => {
      const u = {
        key: c.key,
        class: ke(c.className, c.class),
        // children: column.title,
        column: c,
        colStart: i
      };
      let d = 1;
      const f = c.children;
      return f && f.length > 0 && (d = n(f, i, a + 1).reduce((p, m) => p + m, 0), u.hasSubColumns = !0), "colSpan" in c && ({
        colSpan: d
      } = c), "rowSpan" in c && (u.rowSpan = c.rowSpan), u.colSpan = d, u.colEnd = u.colStart + d - 1, t[a].push(u), i += d, d;
    });
  }
  n(e, 0);
  const o = t.length;
  for (let l = 0; l < o; l += 1)
    t[l].forEach((r) => {
      !("rowSpan" in r) && !r.hasSubColumns && (r.rowSpan = o - l);
    });
  return t;
}
const fR = /* @__PURE__ */ le({
  name: "TableHeader",
  inheritAttrs: !1,
  props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow"],
  setup(e) {
    const t = Di(), n = O(() => QWe(e.columns));
    return () => {
      const {
        prefixCls: o,
        getComponent: l
      } = t, {
        stickyOffsets: r,
        flattenColumns: a,
        customHeaderRow: i
      } = e, s = l(["header", "wrapper"], "thead"), c = l(["header", "row"], "tr"), u = l(["header", "cell"], "th");
      return $(s, {
        class: `${o}-thead`
      }, {
        default: () => [n.value.map((d, f) => $(ZWe, {
          key: f,
          flattenColumns: a,
          cells: d,
          stickyOffsets: r,
          rowComponent: c,
          cellComponent: u,
          customHeaderRow: i,
          index: f
        }, null))]
      });
    };
  }
}), _G = Symbol("ExpandedRowProps"), eKe = (e) => {
  at(_G, e);
}, tKe = () => ze(_G, {}), IG = /* @__PURE__ */ le({
  name: "ExpandedRow",
  inheritAttrs: !1,
  props: ["prefixCls", "component", "cellComponent", "expanded", "colSpan", "isEmpty"],
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const l = Di(), r = tKe(), {
      fixHeader: a,
      fixColumn: i,
      componentWidth: s,
      horizonScroll: c
    } = r;
    return () => {
      const {
        prefixCls: u,
        component: d,
        cellComponent: f,
        expanded: p,
        colSpan: m,
        isEmpty: v
      } = e;
      return $(d, {
        class: o.class,
        style: {
          display: p ? null : "none"
        }
      }, {
        default: () => [$(nC, {
          component: f,
          prefixCls: u,
          colSpan: m
        }, {
          default: () => {
            var h;
            let g = (h = n.default) === null || h === void 0 ? void 0 : h.call(n);
            return (v ? c.value : i.value) && (g = $("div", {
              style: {
                width: `${s.value - (a.value ? l.scrollbarSize : 0)}px`,
                position: "sticky",
                left: 0,
                overflow: "hidden"
              },
              class: `${u}-expanded-row-fixed`
            }, [g])), g;
          }
        })]
      });
    };
  }
}), nKe = /* @__PURE__ */ le({
  name: "MeasureCell",
  props: ["columnKey"],
  setup(e, t) {
    let {
      emit: n
    } = t;
    const o = /* @__PURE__ */ H();
    return nt(() => {
      o.value && n("columnResize", e.columnKey, o.value.offsetWidth);
    }), () => $(ca, {
      onResize: (l) => {
        let {
          offsetWidth: r
        } = l;
        n("columnResize", e.columnKey, r);
      }
    }, {
      default: () => [$("td", {
        ref: o,
        style: {
          padding: 0,
          border: 0,
          height: 0
        }
      }, [$("div", {
        style: {
          height: 0,
          overflow: "hidden"
        }
      }, [Ft("")])])]
    });
  }
}), TG = Symbol("BodyContextProps"), oKe = (e) => {
  at(TG, e);
}, PG = () => ze(TG, {}), lKe = /* @__PURE__ */ le({
  name: "BodyRow",
  inheritAttrs: !1,
  props: ["record", "index", "renderIndex", "recordKey", "expandedKeys", "rowComponent", "cellComponent", "customRow", "rowExpandable", "indent", "rowKey", "getRowKey", "childrenColumnName"],
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const o = Di(), l = PG(), r = /* @__PURE__ */ Ce(!1), a = O(() => e.expandedKeys && e.expandedKeys.has(e.recordKey));
    Ot(() => {
      a.value && (r.value = !0);
    });
    const i = O(() => l.expandableType === "row" && (!e.rowExpandable || e.rowExpandable(e.record))), s = O(() => l.expandableType === "nest"), c = O(() => e.childrenColumnName && e.record && e.record[e.childrenColumnName]), u = O(() => i.value || s.value), d = (h, g) => {
      l.onTriggerExpand(h, g);
    }, f = O(() => {
      var h;
      return ((h = e.customRow) === null || h === void 0 ? void 0 : h.call(e, e.record, e.index)) || {};
    }), p = function(h) {
      var g, y;
      l.expandRowByClick && u.value && d(e.record, h);
      for (var b = arguments.length, C = new Array(b > 1 ? b - 1 : 0), w = 1; w < b; w++)
        C[w - 1] = arguments[w];
      (y = (g = f.value) === null || g === void 0 ? void 0 : g.onClick) === null || y === void 0 || y.call(g, h, ...C);
    }, m = O(() => {
      const {
        record: h,
        index: g,
        indent: y
      } = e, {
        rowClassName: b
      } = l;
      return typeof b == "string" ? b : typeof b == "function" ? b(h, g, y) : "";
    }), v = O(() => tC(l.flattenColumns));
    return () => {
      const {
        class: h,
        style: g
      } = n, {
        record: y,
        index: b,
        rowKey: C,
        indent: w = 0,
        rowComponent: x,
        cellComponent: E
      } = e, {
        prefixCls: I,
        fixedInfoList: T,
        transformCellText: P
      } = o, {
        flattenColumns: k,
        expandedRowClassName: N,
        indentSize: R,
        expandIcon: z,
        expandedRowRender: D,
        expandIconColumnIndex: F
      } = l, M = $(x, Q(Q({}, f.value), {}, {
        "data-row-key": C,
        class: ke(h, `${I}-row`, `${I}-row-level-${w}`, m.value, f.value.class),
        style: [g, f.value.style],
        onClick: p
      }), {
        default: () => [k.map((L, B) => {
          const {
            customRender: V,
            dataIndex: j,
            className: W
          } = L, Y = v[B], U = T[B];
          let te;
          L.customCell && (te = L.customCell(y, b, L));
          const J = B === (F || 0) && s.value ? $(Ge, null, [$("span", {
            style: {
              paddingLeft: `${R * w}px`
            },
            class: `${I}-row-indent indent-level-${w}`
          }, null), z({
            prefixCls: I,
            expanded: a.value,
            expandable: c.value,
            record: y,
            onExpand: d
          })]) : null;
          return $(nC, Q(Q({
            cellType: "body",
            class: W,
            ellipsis: L.ellipsis,
            align: L.align,
            component: E,
            prefixCls: I,
            key: Y,
            record: y,
            index: b,
            renderIndex: e.renderIndex,
            dataIndex: j,
            customRender: V
          }, U), {}, {
            additionalProps: te,
            column: L,
            transformCellText: P,
            appendNode: J
          }), null);
        })]
      });
      let A;
      if (i.value && (r.value || a.value)) {
        const L = D({
          record: y,
          index: b,
          indent: w + 1,
          expanded: a.value
        }), B = N && N(y, b, w);
        A = $(IG, {
          expanded: a.value,
          class: ke(`${I}-expanded-row`, `${I}-expanded-row-level-${w + 1}`, B),
          prefixCls: I,
          component: x,
          cellComponent: E,
          colSpan: k.length,
          isEmpty: !1
        }, {
          default: () => [L]
        });
      }
      return $(Ge, null, [M, A]);
    };
  }
});
function kG(e, t, n, o, l, r) {
  const a = [];
  a.push({
    record: e,
    indent: t,
    index: r
  });
  const i = l(e), s = o == null ? void 0 : o.has(i);
  if (e && Array.isArray(e[n]) && s)
    for (let c = 0; c < e[n].length; c += 1) {
      const u = kG(e[n][c], t + 1, n, o, l, c);
      a.push(...u);
    }
  return a;
}
function rKe(e, t, n, o) {
  return O(() => {
    const r = t.value, a = n.value, i = e.value;
    if (a != null && a.size) {
      const s = [];
      for (let c = 0; c < (i == null ? void 0 : i.length); c += 1) {
        const u = i[c];
        s.push(...kG(u, 0, r, a, o.value, c));
      }
      return s;
    }
    return i == null ? void 0 : i.map((s, c) => ({
      record: s,
      indent: 0,
      index: c
    }));
  });
}
const NG = Symbol("ResizeContextProps"), aKe = (e) => {
  at(NG, e);
}, iKe = () => ze(NG, {
  onColumnResize: () => {
  }
}), sKe = /* @__PURE__ */ le({
  name: "TableBody",
  props: ["data", "getRowKey", "measureColumnWidth", "expandedKeys", "customRow", "rowExpandable", "childrenColumnName"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = iKe(), l = Di(), r = PG(), a = rKe(/* @__PURE__ */ ft(e, "data"), /* @__PURE__ */ ft(e, "childrenColumnName"), /* @__PURE__ */ ft(e, "expandedKeys"), /* @__PURE__ */ ft(e, "getRowKey")), i = /* @__PURE__ */ Ce(-1), s = /* @__PURE__ */ Ce(-1);
    let c;
    return WWe({
      startRow: i,
      endRow: s,
      onHover: (u, d) => {
        clearTimeout(c), c = setTimeout(() => {
          i.value = u, s.value = d;
        }, 100);
      }
    }), () => {
      var u;
      const {
        data: d,
        getRowKey: f,
        measureColumnWidth: p,
        expandedKeys: m,
        customRow: v,
        rowExpandable: h,
        childrenColumnName: g
      } = e, {
        onColumnResize: y
      } = o, {
        prefixCls: b,
        getComponent: C
      } = l, {
        flattenColumns: w
      } = r, x = C(["body", "wrapper"], "tbody"), E = C(["body", "row"], "tr"), I = C(["body", "cell"], "td");
      let T;
      d.length ? T = a.value.map((k, N) => {
        const {
          record: R,
          indent: z,
          index: D
        } = k, F = f(R, N);
        return $(lKe, {
          key: F,
          rowKey: F,
          record: R,
          recordKey: F,
          index: N,
          renderIndex: D,
          rowComponent: E,
          cellComponent: I,
          expandedKeys: m,
          customRow: v,
          getRowKey: f,
          rowExpandable: h,
          childrenColumnName: g,
          indent: z
        }, null);
      }) : T = $(IG, {
        expanded: !0,
        class: `${b}-placeholder`,
        prefixCls: b,
        component: E,
        cellComponent: I,
        colSpan: w.length,
        isEmpty: !0
      }, {
        default: () => [(u = n.emptyNode) === null || u === void 0 ? void 0 : u.call(n)]
      });
      const P = tC(w);
      return $(x, {
        class: `${b}-tbody`
      }, {
        default: () => [p && $("tr", {
          "aria-hidden": "true",
          class: `${b}-measure-row`,
          style: {
            height: 0,
            fontSize: 0
          }
        }, [P.map((k) => $(nKe, {
          key: k,
          columnKey: k,
          onColumnResize: y
        }, null))]), T]
      });
    };
  }
}), ai = {};
var cKe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function lE(e) {
  return e.reduce((t, n) => {
    const {
      fixed: o
    } = n, l = o === !0 ? "left" : o, r = n.children;
    return r && r.length > 0 ? [...t, ...lE(r).map((a) => _({
      fixed: l
    }, a))] : [...t, _(_({}, n), {
      fixed: l
    })];
  }, []);
}
function uKe(e) {
  let t = !0;
  for (let o = 0; o < e.length; o += 1) {
    const l = e[o];
    if (t && l.fixed !== "left")
      t = !1;
    else if (!t && l.fixed === "left") {
      bn(!1, `Index ${o - 1} of \`columns\` missing \`fixed='left'\` prop.`);
      break;
    }
  }
  let n = !0;
  for (let o = e.length - 1; o >= 0; o -= 1) {
    const l = e[o];
    if (n && l.fixed !== "right")
      n = !1;
    else if (!n && l.fixed === "right") {
      bn(!1, `Index ${o + 1} of \`columns\` missing \`fixed='right'\` prop.`);
      break;
    }
  }
}
function dKe(e) {
  return e.map((t) => {
    const {
      fixed: n
    } = t, o = cKe(t, ["fixed"]);
    let l = n;
    return n === "left" ? l = "right" : n === "right" && (l = "left"), _({
      fixed: l
    }, o);
  });
}
function fKe(e, t) {
  let {
    prefixCls: n,
    columns: o,
    // children,
    expandable: l,
    expandedKeys: r,
    getRowKey: a,
    onTriggerExpand: i,
    expandIcon: s,
    rowExpandable: c,
    expandIconColumnIndex: u,
    direction: d,
    expandRowByClick: f,
    expandColumnWidth: p,
    expandFixed: m
  } = e;
  const v = yP(), h = O(() => {
    if (l.value) {
      let b = o.value.slice();
      if (process.env.NODE_ENV !== "production" && u.value >= 0 && bn(!1, "`expandIconColumnIndex` is deprecated. Please use `Table.EXPAND_COLUMN` in `columns` instead."), !b.includes(ai)) {
        const R = u.value || 0;
        R >= 0 && b.splice(R, 0, ai);
      }
      process.env.NODE_ENV !== "production" && b.filter((R) => R === ai).length > 1 && bn(!1, "There exist more than one `EXPAND_COLUMN` in `columns`.");
      const C = b.indexOf(ai);
      b = b.filter((R, z) => R !== ai || z === C);
      const w = o.value[C];
      let x;
      (m.value === "left" || m.value) && !u.value ? x = "left" : (m.value === "right" || m.value) && u.value === o.value.length ? x = "right" : x = w ? w.fixed : null;
      const E = r.value, I = c.value, T = s.value, P = n.value, k = f.value, N = {
        [Pf]: {
          class: `${n.value}-expand-icon-col`,
          columnType: "EXPAND_COLUMN"
        },
        title: fS(v.value, "expandColumnTitle", {}, () => [""]),
        fixed: x,
        class: `${n.value}-row-expand-icon-cell`,
        width: p.value,
        customRender: (R) => {
          let {
            record: z,
            index: D
          } = R;
          const F = a.value(z, D), M = E.has(F), A = I ? I(z) : !0, L = T({
            prefixCls: P,
            expanded: M,
            expandable: A,
            record: z,
            onExpand: i
          });
          return k ? $("span", {
            onClick: (B) => B.stopPropagation()
          }, [L]) : L;
        }
      };
      return b.map((R) => R === ai ? N : R);
    }
    return process.env.NODE_ENV !== "production" && o.value.includes(ai) && bn(!1, "`expandable` is not config but there exist `EXPAND_COLUMN` in `columns`."), o.value.filter((b) => b !== ai);
  }), g = O(() => {
    let b = h.value;
    return t.value && (b = t.value(b)), b.length || (b = [{
      customRender: () => null
    }]), b;
  }), y = O(() => d.value === "rtl" ? dKe(lE(g.value)) : lE(g.value));
  return process.env.NODE_ENV !== "production" && Ot(() => {
    setTimeout(() => {
      uKe(y.value);
    });
  }), [g, y];
}
function MG(e) {
  const t = /* @__PURE__ */ Ce(e);
  let n;
  const o = /* @__PURE__ */ Ce([]);
  function l(r) {
    o.value.push(r), rn.cancel(n), n = rn(() => {
      const a = o.value;
      o.value = [], a.forEach((i) => {
        t.value = i(t.value);
      });
    });
  }
  return yt(() => {
    rn.cancel(n);
  }), [t, l];
}
function pKe(e) {
  const t = /* @__PURE__ */ H(null), n = /* @__PURE__ */ H();
  function o() {
    clearTimeout(n.value);
  }
  function l(a) {
    t.value = a, o(), n.value = setTimeout(() => {
      t.value = null, n.value = void 0;
    }, 100);
  }
  function r() {
    return t.value;
  }
  return yt(() => {
    o();
  }), [l, r];
}
function vKe(e, t, n) {
  return O(() => {
    const l = [], r = [];
    let a = 0, i = 0;
    const s = e.value, c = t.value, u = n.value;
    for (let d = 0; d < c; d += 1)
      if (u === "rtl") {
        r[d] = i, i += s[d] || 0;
        const f = c - d - 1;
        l[f] = a, a += s[f] || 0;
      } else {
        l[d] = a, a += s[d] || 0;
        const f = c - d - 1;
        r[f] = i, i += s[f] || 0;
      }
    return {
      left: l,
      right: r
    };
  });
}
var mKe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function AG(e) {
  let {
    colWidths: t,
    columns: n,
    columCount: o
  } = e;
  const l = [], r = o || n.length;
  let a = !1;
  for (let i = r - 1; i >= 0; i -= 1) {
    const s = t[i], c = n && n[i], u = c && c[Pf];
    if (s || u || a) {
      const d = u || {}, {
        columnType: f
      } = d, p = mKe(d, ["columnType"]);
      l.unshift($("col", Q({
        key: i,
        style: {
          width: typeof s == "number" ? `${s}px` : s
        }
      }, p), null)), a = !0;
    }
  }
  return $("colgroup", null, [l]);
}
function rE(e, t) {
  let {
    slots: n
  } = t;
  var o;
  return $("div", null, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)]);
}
rE.displayName = "Panel";
let hKe = 0;
const gKe = /* @__PURE__ */ le({
  name: "TableSummary",
  props: ["fixed"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Di(), l = `table-summary-uni-key-${++hKe}`, r = O(() => e.fixed === "" || e.fixed);
    return Ot(() => {
      o.summaryCollect(l, r.value);
    }), yt(() => {
      o.summaryCollect(l, !1);
    }), () => {
      var a;
      return (a = n.default) === null || a === void 0 ? void 0 : a.call(n);
    };
  }
}), bKe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ATableSummaryRow",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      var o;
      return $("tr", null, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)]);
    };
  }
}), RG = Symbol("SummaryContextProps"), yKe = (e) => {
  at(RG, e);
}, SKe = () => ze(RG, {}), CKe = /* @__PURE__ */ le({
  name: "ATableSummaryCell",
  props: ["index", "colSpan", "rowSpan", "align"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const l = Di(), r = SKe();
    return () => {
      const {
        index: a,
        colSpan: i = 1,
        rowSpan: s,
        align: c
      } = e, {
        prefixCls: u,
        direction: d
      } = l, {
        scrollColumnIndex: f,
        stickyOffsets: p,
        flattenColumns: m
      } = r, h = a + i - 1 + 1 === f ? i + 1 : i, g = SP(a, a + h - 1, m, p, d);
      return $(nC, Q({
        class: n.class,
        index: a,
        component: "td",
        prefixCls: u,
        record: null,
        dataIndex: null,
        align: c,
        colSpan: h,
        rowSpan: s,
        customRender: () => {
          var y;
          return (y = o.default) === null || y === void 0 ? void 0 : y.call(o);
        }
      }, g), null);
    };
  }
}), Wg = /* @__PURE__ */ le({
  name: "TableFooter",
  inheritAttrs: !1,
  props: ["stickyOffsets", "flattenColumns"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Di();
    return yKe(/* @__PURE__ */ kt({
      stickyOffsets: /* @__PURE__ */ ft(e, "stickyOffsets"),
      flattenColumns: /* @__PURE__ */ ft(e, "flattenColumns"),
      scrollColumnIndex: O(() => {
        const l = e.flattenColumns.length - 1, r = e.flattenColumns[l];
        return r != null && r.scrollbar ? l : null;
      })
    })), () => {
      var l;
      const {
        prefixCls: r
      } = o;
      return $("tfoot", {
        class: `${r}-summary`
      }, [(l = n.default) === null || l === void 0 ? void 0 : l.call(n)]);
    };
  }
}), wKe = gKe;
function $Ke(e) {
  let {
    prefixCls: t,
    record: n,
    onExpand: o,
    expanded: l,
    expandable: r
  } = e;
  const a = `${t}-row-expand-icon`;
  if (!r)
    return $("span", {
      class: [a, `${t}-row-spaced`]
    }, null);
  const i = (s) => {
    o(n, s), s.stopPropagation();
  };
  return $("span", {
    class: {
      [a]: !0,
      [`${t}-row-expanded`]: l,
      [`${t}-row-collapsed`]: !l
    },
    onClick: i
  }, null);
}
function xKe(e, t, n) {
  const o = [];
  function l(r) {
    (r || []).forEach((a, i) => {
      o.push(t(a, i)), l(a[n]);
    });
  }
  return l(e), o;
}
const EKe = /* @__PURE__ */ le({
  name: "StickyScrollBar",
  inheritAttrs: !1,
  props: ["offsetScroll", "container", "scrollBodyRef", "scrollBodySizeInfo"],
  emits: ["scroll"],
  setup(e, t) {
    let {
      emit: n,
      expose: o
    } = t;
    const l = Di(), r = /* @__PURE__ */ Ce(0), a = /* @__PURE__ */ Ce(0), i = /* @__PURE__ */ Ce(0);
    Ot(() => {
      r.value = e.scrollBodySizeInfo.scrollWidth || 0, a.value = e.scrollBodySizeInfo.clientWidth || 0, i.value = r.value && a.value * (a.value / r.value);
    }, {
      flush: "post"
    });
    const s = /* @__PURE__ */ Ce(), [c, u] = MG({
      scrollLeft: 0,
      isHiddenScrollBar: !0
    }), d = /* @__PURE__ */ H({
      delta: 0,
      x: 0
    }), f = /* @__PURE__ */ Ce(!1), p = () => {
      f.value = !1;
    }, m = (E) => {
      d.value = {
        delta: E.pageX - c.value.scrollLeft,
        x: 0
      }, f.value = !0, E.preventDefault();
    }, v = (E) => {
      const {
        buttons: I
      } = E || (window == null ? void 0 : window.event);
      if (!f.value || I === 0) {
        f.value && (f.value = !1);
        return;
      }
      let T = d.value.x + E.pageX - d.value.x - d.value.delta;
      T <= 0 && (T = 0), T + i.value >= a.value && (T = a.value - i.value), n("scroll", {
        scrollLeft: T / a.value * (r.value + 2)
      }), d.value.x = E.pageX;
    }, h = () => {
      if (!e.scrollBodyRef.value)
        return;
      const E = cy(e.scrollBodyRef.value).top, I = E + e.scrollBodyRef.value.offsetHeight, T = e.container === window ? document.documentElement.scrollTop + window.innerHeight : cy(e.container).top + e.container.clientHeight;
      I - sy() <= T || E >= T - e.offsetScroll ? u((P) => _(_({}, P), {
        isHiddenScrollBar: !0
      })) : u((P) => _(_({}, P), {
        isHiddenScrollBar: !1
      }));
    };
    o({
      setScrollLeft: (E) => {
        u((I) => _(_({}, I), {
          scrollLeft: E / r.value * a.value || 0
        }));
      }
    });
    let y = null, b = null, C = null, w = null;
    nt(() => {
      y = vo(document.body, "mouseup", p, !1), b = vo(document.body, "mousemove", v, !1), C = vo(window, "resize", h, !1);
    }), nd(() => {
      Ke(() => {
        h();
      });
    }), nt(() => {
      setTimeout(() => {
        pe([i, f], () => {
          h();
        }, {
          immediate: !0,
          flush: "post"
        });
      });
    }), pe(() => e.container, () => {
      w == null || w.remove(), w = vo(e.container, "scroll", h, !1);
    }, {
      immediate: !0,
      flush: "post"
    }), yt(() => {
      y == null || y.remove(), b == null || b.remove(), w == null || w.remove(), C == null || C.remove();
    }), pe(() => _({}, c.value), (E, I) => {
      E.isHiddenScrollBar !== (I == null ? void 0 : I.isHiddenScrollBar) && !E.isHiddenScrollBar && u((T) => {
        const P = e.scrollBodyRef.value;
        return P ? _(_({}, T), {
          scrollLeft: P.scrollLeft / P.scrollWidth * P.clientWidth
        }) : T;
      });
    }, {
      immediate: !0
    });
    const x = sy();
    return () => {
      if (r.value <= a.value || !i.value || c.value.isHiddenScrollBar)
        return null;
      const {
        prefixCls: E
      } = l;
      return $("div", {
        style: {
          height: `${x}px`,
          width: `${a.value}px`,
          bottom: `${e.offsetScroll}px`
        },
        class: `${E}-sticky-scroll`
      }, [$("div", {
        onMousedown: m,
        ref: s,
        class: ke(`${E}-sticky-scroll-bar`, {
          [`${E}-sticky-scroll-bar-active`]: f.value
        }),
        style: {
          width: `${i.value}px`,
          transform: `translate3d(${c.value.scrollLeft}px, 0, 0)`
        }
      }, null)]);
    };
  }
}), pR = Fl() ? window : null;
function OKe(e, t) {
  return O(() => {
    const {
      offsetHeader: n = 0,
      offsetSummary: o = 0,
      offsetScroll: l = 0,
      getContainer: r = () => pR
    } = typeof e.value == "object" ? e.value : {}, a = r() || pR, i = !!e.value;
    return {
      isSticky: i,
      stickyClassName: i ? `${t.value}-sticky-holder` : "",
      offsetHeader: n,
      offsetSummary: o,
      offsetScroll: l,
      container: a
    };
  });
}
function _Ke(e, t) {
  return O(() => {
    const n = [], o = e.value, l = t.value;
    for (let r = 0; r < l; r += 1) {
      const a = o[r];
      if (a !== void 0)
        n[r] = a;
      else
        return null;
    }
    return n;
  });
}
const vR = /* @__PURE__ */ le({
  name: "FixedHolder",
  inheritAttrs: !1,
  props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow", "noData", "maxContentScroll", "colWidths", "columCount", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName"],
  emits: ["scroll"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: l
    } = t;
    const r = Di(), a = O(() => r.isSticky && !e.fixHeader ? 0 : r.scrollbarSize), i = /* @__PURE__ */ H(), s = (v) => {
      const {
        currentTarget: h,
        deltaX: g
      } = v;
      g && (l("scroll", {
        currentTarget: h,
        scrollLeft: h.scrollLeft + g
      }), v.preventDefault());
    }, c = /* @__PURE__ */ H();
    nt(() => {
      Ke(() => {
        c.value = vo(i.value, "wheel", s);
      });
    }), yt(() => {
      var v;
      (v = c.value) === null || v === void 0 || v.remove();
    });
    const u = O(() => e.flattenColumns.every((v) => v.width && v.width !== 0 && v.width !== "0px")), d = /* @__PURE__ */ H([]), f = /* @__PURE__ */ H([]);
    Ot(() => {
      const v = e.flattenColumns[e.flattenColumns.length - 1], h = {
        fixed: v ? v.fixed : null,
        scrollbar: !0,
        customHeaderCell: () => ({
          class: `${r.prefixCls}-cell-scrollbar`
        })
      };
      d.value = a.value ? [...e.columns, h] : e.columns, f.value = a.value ? [...e.flattenColumns, h] : e.flattenColumns;
    });
    const p = O(() => {
      const {
        stickyOffsets: v,
        direction: h
      } = e, {
        right: g,
        left: y
      } = v;
      return _(_({}, v), {
        left: h === "rtl" ? [...y.map((b) => b + a.value), 0] : y,
        right: h === "rtl" ? g : [...g.map((b) => b + a.value), 0],
        isSticky: r.isSticky
      });
    }), m = _Ke(/* @__PURE__ */ ft(e, "colWidths"), /* @__PURE__ */ ft(e, "columCount"));
    return () => {
      var v;
      const {
        noData: h,
        columCount: g,
        stickyTopOffset: y,
        stickyBottomOffset: b,
        stickyClassName: C,
        maxContentScroll: w
      } = e, {
        isSticky: x
      } = r;
      return $("div", {
        style: _({
          overflow: "hidden"
        }, x ? {
          top: `${y}px`,
          bottom: `${b}px`
        } : {}),
        ref: i,
        class: ke(n.class, {
          [C]: !!C
        })
      }, [$("table", {
        style: {
          tableLayout: "fixed",
          visibility: h || m.value ? null : "hidden"
        }
      }, [(!h || !w || u.value) && $(AG, {
        colWidths: m.value ? [...m.value, a.value] : [],
        columCount: g + 1,
        columns: f.value
      }, null), (v = o.default) === null || v === void 0 ? void 0 : v.call(o, _(_({}, e), {
        stickyOffsets: p.value,
        columns: d.value,
        flattenColumns: f.value
      }))])]);
    };
  }
});
function mR(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o];
  return /* @__PURE__ */ kt(Hf(n.map((l) => [l, /* @__PURE__ */ ft(e, l)])));
}
const IKe = [], TKe = {}, aE = "rc-table-internal-hook", PKe = /* @__PURE__ */ le({
  name: "VcTable",
  inheritAttrs: !1,
  props: ["prefixCls", "data", "columns", "rowKey", "tableLayout", "scroll", "rowClassName", "title", "footer", "id", "showHeader", "components", "customRow", "customHeaderRow", "direction", "expandFixed", "expandColumnWidth", "expandedRowKeys", "defaultExpandedRowKeys", "expandedRowRender", "expandRowByClick", "expandIcon", "onExpand", "onExpandedRowsChange", "onUpdate:expandedRowKeys", "defaultExpandAllRows", "indentSize", "expandIconColumnIndex", "expandedRowClassName", "childrenColumnName", "rowExpandable", "sticky", "transformColumns", "internalHooks", "internalRefs", "canExpandable", "onUpdateInternalRefs", "transformCellText"],
  emits: ["expand", "expandedRowsChange", "updateInternalRefs", "update:expandedRowKeys"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: l
    } = t;
    const r = O(() => e.data || IKe), a = O(() => !!r.value.length), i = O(() => VWe(e.components, {})), s = (be, ie) => $G(i.value, be) || ie, c = O(() => {
      const be = e.rowKey;
      return typeof be == "function" ? be : (ie) => {
        const we = ie && ie[be];
        return process.env.NODE_ENV !== "production" && bn(we !== void 0, "Each record in table should have a unique `key` prop, or set `rowKey` to an unique primary key."), we;
      };
    }), u = O(() => e.expandIcon || $Ke), d = O(() => e.childrenColumnName || "children"), f = O(() => e.expandedRowRender ? "row" : e.canExpandable || r.value.some((be) => be && typeof be == "object" && be[d.value]) ? "nest" : !1), p = /* @__PURE__ */ Ce([]);
    Ot(() => {
      e.defaultExpandedRowKeys && (p.value = e.defaultExpandedRowKeys), e.defaultExpandAllRows && (p.value = xKe(r.value, c.value, d.value));
    })();
    const v = O(() => new Set(e.expandedRowKeys || p.value || [])), h = (be) => {
      const ie = c.value(be, r.value.indexOf(be));
      let we;
      const Ne = v.value.has(ie);
      Ne ? (v.value.delete(ie), we = [...v.value]) : we = [...v.value, ie], p.value = we, l("expand", !Ne, be), l("update:expandedRowKeys", we), l("expandedRowsChange", we);
    };
    process.env.NODE_ENV !== "production" && e.expandedRowRender && r.value.some((be) => Array.isArray(be == null ? void 0 : be[d.value])) && bn(!1, "`expandedRowRender` should not use with nested Table");
    const g = /* @__PURE__ */ H(0), [y, b] = fKe(_(_({}, /* @__PURE__ */ to(e)), {
      // children,
      expandable: O(() => !!e.expandedRowRender),
      expandedKeys: v,
      getRowKey: c,
      onTriggerExpand: h,
      expandIcon: u
    }), O(() => e.internalHooks === aE ? e.transformColumns : null)), C = O(() => ({
      columns: y.value,
      flattenColumns: b.value
    })), w = /* @__PURE__ */ H(), x = /* @__PURE__ */ H(), E = /* @__PURE__ */ H(), I = /* @__PURE__ */ H({
      scrollWidth: 0,
      clientWidth: 0
    }), T = /* @__PURE__ */ H(), [P, k] = Bn(!1), [N, R] = Bn(!1), [z, D] = MG(/* @__PURE__ */ new Map()), F = O(() => tC(b.value)), M = O(() => F.value.map((be) => z.value.get(be))), A = O(() => b.value.length), L = vKe(M, A, /* @__PURE__ */ ft(e, "direction")), B = O(() => e.scroll && nE(e.scroll.y)), V = O(() => e.scroll && nE(e.scroll.x) || !!e.expandFixed), j = O(() => V.value && b.value.some((be) => {
      let {
        fixed: ie
      } = be;
      return ie;
    })), W = /* @__PURE__ */ H(), Y = OKe(/* @__PURE__ */ ft(e, "sticky"), /* @__PURE__ */ ft(e, "prefixCls")), U = /* @__PURE__ */ kt({}), te = O(() => {
      const be = Object.values(U)[0];
      return (B.value || Y.value.isSticky) && be;
    }), J = (be, ie) => {
      ie ? U[be] = ie : delete U[be];
    }, re = /* @__PURE__ */ H({}), oe = /* @__PURE__ */ H({}), q = /* @__PURE__ */ H({});
    Ot(() => {
      B.value && (oe.value = {
        overflowY: "scroll",
        maxHeight: ru(e.scroll.y)
      }), V.value && (re.value = {
        overflowX: "auto"
      }, B.value || (oe.value = {
        overflowY: "hidden"
      }), q.value = {
        width: e.scroll.x === !0 ? "auto" : ru(e.scroll.x),
        minWidth: "100%"
      });
    });
    const K = (be, ie) => {
      pS(w.value) && D((we) => {
        if (we.get(be) !== ie) {
          const Ne = new Map(we);
          return Ne.set(be, ie), Ne;
        }
        return we;
      });
    }, [se, Z] = pKe();
    function ee(be, ie) {
      if (!ie)
        return;
      if (typeof ie == "function") {
        ie(be);
        return;
      }
      const we = ie.$el || ie;
      we.scrollLeft !== be && (we.scrollLeft = be);
    }
    const fe = (be) => {
      let {
        currentTarget: ie,
        scrollLeft: we
      } = be;
      var Ne;
      const tt = e.direction === "rtl", Pe = typeof we == "number" ? we : ie.scrollLeft, Re = ie || TKe;
      if ((!Z() || Z() === Re) && (se(Re), ee(Pe, x.value), ee(Pe, E.value), ee(Pe, T.value), ee(Pe, (Ne = W.value) === null || Ne === void 0 ? void 0 : Ne.setScrollLeft)), ie) {
        const {
          scrollWidth: Le,
          clientWidth: Ue
        } = ie;
        tt ? (k(-Pe < Le - Ue), R(-Pe > 0)) : (k(Pe > 0), R(Pe < Le - Ue));
      }
    }, me = () => {
      V.value && E.value ? fe({
        currentTarget: E.value
      }) : (k(!1), R(!1));
    };
    let ge;
    const he = (be) => {
      be !== g.value && (me(), g.value = w.value ? w.value.offsetWidth : be);
    }, $e = (be) => {
      let {
        width: ie
      } = be;
      if (clearTimeout(ge), g.value === 0) {
        he(ie);
        return;
      }
      ge = setTimeout(() => {
        he(ie);
      }, 100);
    };
    pe([V, () => e.data, () => e.columns], () => {
      V.value && me();
    }, {
      flush: "post"
    });
    const [ne, ae] = Bn(0);
    UWe(), nt(() => {
      Ke(() => {
        var be, ie;
        me(), ae(G3e(E.value).width), I.value = {
          scrollWidth: ((be = E.value) === null || be === void 0 ? void 0 : be.scrollWidth) || 0,
          clientWidth: ((ie = E.value) === null || ie === void 0 ? void 0 : ie.clientWidth) || 0
        };
      });
    }), $o(() => {
      Ke(() => {
        var be, ie;
        const we = ((be = E.value) === null || be === void 0 ? void 0 : be.scrollWidth) || 0, Ne = ((ie = E.value) === null || ie === void 0 ? void 0 : ie.clientWidth) || 0;
        (I.value.scrollWidth !== we || I.value.clientWidth !== Ne) && (I.value = {
          scrollWidth: we,
          clientWidth: Ne
        });
      });
    }), Ot(() => {
      e.internalHooks === aE && e.internalRefs && e.onUpdateInternalRefs({
        body: E.value ? E.value.$el || E.value : null
      });
    }, {
      flush: "post"
    });
    const ce = O(() => e.tableLayout ? e.tableLayout : j.value ? e.scroll.x === "max-content" ? "auto" : "fixed" : B.value || Y.value.isSticky || b.value.some((be) => {
      let {
        ellipsis: ie
      } = be;
      return ie;
    }) ? "fixed" : "auto"), xe = () => {
      var be;
      return a.value ? null : ((be = o.emptyText) === null || be === void 0 ? void 0 : be.call(o)) || "No Data";
    };
    BWe(/* @__PURE__ */ kt(_(_({}, /* @__PURE__ */ to(mR(e, "prefixCls", "direction", "transformCellText"))), {
      getComponent: s,
      scrollbarSize: ne,
      fixedInfoList: O(() => b.value.map((be, ie) => SP(ie, ie, b.value, L.value, e.direction))),
      isSticky: O(() => Y.value.isSticky),
      summaryCollect: J
    }))), oKe(/* @__PURE__ */ kt(_(_({}, /* @__PURE__ */ to(mR(e, "rowClassName", "expandedRowClassName", "expandRowByClick", "expandedRowRender", "expandIconColumnIndex", "indentSize"))), {
      columns: y,
      flattenColumns: b,
      tableLayout: ce,
      expandIcon: u,
      expandableType: f,
      onTriggerExpand: h
    }))), aKe({
      onColumnResize: K
    }), eKe({
      componentWidth: g,
      fixHeader: B,
      fixColumn: j,
      horizonScroll: V
    });
    const Te = () => $(sKe, {
      data: r.value,
      measureColumnWidth: B.value || V.value || Y.value.isSticky,
      expandedKeys: v.value,
      rowExpandable: e.rowExpandable,
      getRowKey: c.value,
      customRow: e.customRow,
      childrenColumnName: d.value
    }, {
      emptyNode: xe
    }), Se = () => $(AG, {
      colWidths: b.value.map((be) => {
        let {
          width: ie
        } = be;
        return ie;
      }),
      columns: b.value
    }, null);
    return () => {
      var be;
      const {
        prefixCls: ie,
        scroll: we,
        tableLayout: Ne,
        direction: tt,
        // Additional Part
        title: Pe = o.title,
        footer: Re = o.footer,
        // Customize
        id: Le,
        showHeader: Ue,
        customHeaderRow: Ae
      } = e, {
        isSticky: De,
        offsetHeader: _e,
        offsetSummary: Ze,
        offsetScroll: dt,
        stickyClassName: Tt,
        container: jt
      } = Y.value, Qt = s(["table"], "table"), je = s(["body"]), lt = (be = o.summary) === null || be === void 0 ? void 0 : be.call(o, {
        pageData: r.value
      });
      let Ct = () => null;
      const vn = {
        colWidths: M.value,
        columCount: b.value.length,
        stickyOffsets: L.value,
        customHeaderRow: Ae,
        fixHeader: B.value,
        scroll: we
      };
      if (process.env.NODE_ENV !== "production" && typeof je == "function" && a.value && !B.value && bn(!1, "`components.body` with render props is only work on `scroll.y`."), B.value || De) {
        let pt = () => null;
        typeof je == "function" ? (pt = () => je(r.value, {
          scrollbarSize: ne.value,
          ref: E,
          onScroll: fe
        }), vn.colWidths = b.value.map((Gn, To) => {
          let {
            width: st
          } = Gn;
          const Yt = To === y.value.length - 1 ? st - ne.value : st;
          return typeof Yt == "number" && !Number.isNaN(Yt) ? Yt : (bn(!1, "When use `components.body` with render props. Each column should have a fixed `width` value."), 0);
        })) : pt = () => $("div", {
          style: _(_({}, re.value), oe.value),
          onScroll: fe,
          ref: E,
          class: ke(`${ie}-body`)
        }, [$(Qt, {
          style: _(_({}, q.value), {
            tableLayout: ce.value
          })
        }, {
          default: () => [Se(), Te(), !te.value && lt && $(Wg, {
            stickyOffsets: L.value,
            flattenColumns: b.value
          }, {
            default: () => [lt]
          })]
        })]);
        const Lt = _(_(_({
          noData: !r.value.length,
          maxContentScroll: V.value && we.x === "max-content"
        }, vn), C.value), {
          direction: tt,
          stickyClassName: Tt,
          onScroll: fe
        });
        Ct = () => $(Ge, null, [Ue !== !1 && $(vR, Q(Q({}, Lt), {}, {
          stickyTopOffset: _e,
          class: `${ie}-header`,
          ref: x
        }), {
          default: (Gn) => $(Ge, null, [$(fR, Gn, null), te.value === "top" && $(Wg, Gn, {
            default: () => [lt]
          })])
        }), pt(), te.value && te.value !== "top" && $(vR, Q(Q({}, Lt), {}, {
          stickyBottomOffset: Ze,
          class: `${ie}-summary`,
          ref: T
        }), {
          default: (Gn) => $(Wg, Gn, {
            default: () => [lt]
          })
        }), De && E.value && $(EKe, {
          ref: W,
          offsetScroll: dt,
          scrollBodyRef: E,
          onScroll: fe,
          container: jt,
          scrollBodySizeInfo: I.value
        }, null)]);
      } else
        Ct = () => $("div", {
          style: _(_({}, re.value), oe.value),
          class: ke(`${ie}-content`),
          onScroll: fe,
          ref: E
        }, [$(Qt, {
          style: _(_({}, q.value), {
            tableLayout: ce.value
          })
        }, {
          default: () => [Se(), Ue !== !1 && $(fR, Q(Q({}, vn), C.value), null), Te(), lt && $(Wg, {
            stickyOffsets: L.value,
            flattenColumns: b.value
          }, {
            default: () => [lt]
          })]
        })]);
      const tn = Mc(n, {
        aria: !0,
        data: !0
      }), ct = () => $("div", Q(Q({}, tn), {}, {
        class: ke(ie, {
          [`${ie}-rtl`]: tt === "rtl",
          [`${ie}-ping-left`]: P.value,
          [`${ie}-ping-right`]: N.value,
          [`${ie}-layout-fixed`]: Ne === "fixed",
          [`${ie}-fixed-header`]: B.value,
          /** No used but for compatible */
          [`${ie}-fixed-column`]: j.value,
          [`${ie}-scroll-horizontal`]: V.value,
          [`${ie}-has-fix-left`]: b.value[0] && b.value[0].fixed,
          [`${ie}-has-fix-right`]: b.value[A.value - 1] && b.value[A.value - 1].fixed === "right",
          [n.class]: n.class
        }),
        style: n.style,
        id: Le,
        ref: w
      }), [Pe && $(rE, {
        class: `${ie}-title`
      }, {
        default: () => [Pe(r.value)]
      }), $("div", {
        class: `${ie}-container`
      }, [Ct()]), Re && $(rE, {
        class: `${ie}-footer`
      }, {
        default: () => [Re(r.value)]
      })]);
      return V.value ? $(ca, {
        onResize: $e
      }, {
        default: ct
      }) : ct();
    };
  }
});
function kKe() {
  const e = _({}, arguments.length <= 0 ? void 0 : arguments[0]);
  for (let t = 1; t < arguments.length; t++) {
    const n = t < 0 || arguments.length <= t ? void 0 : arguments[t];
    n && Object.keys(n).forEach((o) => {
      const l = n[o];
      l !== void 0 && (e[o] = l);
    });
  }
  return e;
}
const iE = 10;
function NKe(e, t) {
  const n = {
    current: e.current,
    pageSize: e.pageSize
  };
  return Object.keys(t && typeof t == "object" ? t : {}).forEach((l) => {
    const r = e[l];
    typeof r != "function" && (n[l] = r);
  }), n;
}
function MKe(e, t, n) {
  const o = O(() => t.value && typeof t.value == "object" ? t.value : {}), l = O(() => o.value.total || 0), [r, a] = Bn(() => ({
    current: "defaultCurrent" in o.value ? o.value.defaultCurrent : 1,
    pageSize: "defaultPageSize" in o.value ? o.value.defaultPageSize : iE
  })), i = O(() => {
    const u = kKe(r.value, o.value, {
      total: l.value > 0 ? l.value : e.value
    }), d = Math.ceil((l.value || e.value) / u.pageSize);
    return u.current > d && (u.current = d || 1), u;
  }), s = (u, d) => {
    t.value !== !1 && a({
      current: u != null ? u : 1,
      pageSize: d || i.value.pageSize
    });
  }, c = (u, d) => {
    var f, p;
    t.value && ((p = (f = o.value).onChange) === null || p === void 0 || p.call(f, u, d)), s(u, d), n(u, d || i.value.pageSize);
  };
  return [O(() => t.value === !1 ? {} : _(_({}, i.value), {
    onChange: c
  })), s];
}
function AKe(e, t, n) {
  const o = /* @__PURE__ */ Ce({});
  pe([e, t, n], () => {
    const r = /* @__PURE__ */ new Map(), a = n.value, i = t.value;
    function s(c) {
      c.forEach((u, d) => {
        const f = a(u, d);
        r.set(f, u), u && typeof u == "object" && i in u && s(u[i] || []);
      });
    }
    s(e.value), o.value = {
      kvMap: r
    };
  }, {
    deep: !0,
    immediate: !0
  });
  function l(r) {
    return o.value.kvMap.get(r);
  }
  return [l];
}
const ha = {}, sE = "SELECT_ALL", cE = "SELECT_INVERT", uE = "SELECT_NONE", RKe = [];
function DG(e, t) {
  let n = [];
  return (t || []).forEach((o) => {
    n.push(o), o && typeof o == "object" && e in o && (n = [...n, ...DG(e, o[e])]);
  }), n;
}
function DKe(e, t) {
  const n = O(() => {
    const T = e.value || {}, {
      checkStrictly: P = !0
    } = T;
    return _(_({}, T), {
      checkStrictly: P
    });
  }), [o, l] = ro(n.value.selectedRowKeys || n.value.defaultSelectedRowKeys || RKe, {
    value: O(() => n.value.selectedRowKeys)
  }), r = /* @__PURE__ */ Ce(/* @__PURE__ */ new Map()), a = (T) => {
    if (n.value.preserveSelectedRowKeys) {
      const P = /* @__PURE__ */ new Map();
      T.forEach((k) => {
        let N = t.getRecordByKey(k);
        !N && r.value.has(k) && (N = r.value.get(k)), P.set(k, N);
      }), r.value = P;
    }
  };
  Ot(() => {
    a(o.value);
  });
  const i = O(() => n.value.checkStrictly ? null : Lh(t.data.value, {
    externalGetKey: t.getRowKey.value,
    childrenPropName: t.childrenColumnName.value
  }).keyEntities), s = O(() => DG(t.childrenColumnName.value, t.pageData.value)), c = O(() => {
    const T = /* @__PURE__ */ new Map(), P = t.getRowKey.value, k = n.value.getCheckboxProps;
    return s.value.forEach((N, R) => {
      const z = P(N, R), D = (k ? k(N) : null) || {};
      T.set(z, D), process.env.NODE_ENV !== "production" && ("checked" in D || "defaultChecked" in D) && un(!1, "Table", "Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.");
    }), T;
  }), {
    maxLevel: u,
    levelEntities: d
  } = zS(i), f = (T) => {
    var P;
    return !!(!((P = c.value.get(t.getRowKey.value(T))) === null || P === void 0) && P.disabled);
  }, p = O(() => {
    if (n.value.checkStrictly)
      return [o.value || [], []];
    const {
      checkedKeys: T,
      halfCheckedKeys: P
    } = oa(o.value, !0, i.value, u.value, d.value, f);
    return [T || [], P];
  }), m = O(() => p.value[0]), v = O(() => p.value[1]), h = O(() => {
    const T = n.value.type === "radio" ? m.value.slice(0, 1) : m.value;
    return new Set(T);
  }), g = O(() => n.value.type === "radio" ? /* @__PURE__ */ new Set() : new Set(v.value)), [y, b] = Bn(null), C = (T) => {
    let P, k;
    a(T);
    const {
      preserveSelectedRowKeys: N,
      onChange: R
    } = n.value, {
      getRecordByKey: z
    } = t;
    N ? (P = T, k = T.map((D) => r.value.get(D))) : (P = [], k = [], T.forEach((D) => {
      const F = z(D);
      F !== void 0 && (P.push(D), k.push(F));
    })), l(P), R == null || R(P, k);
  }, w = (T, P, k, N) => {
    const {
      onSelect: R
    } = n.value, {
      getRecordByKey: z
    } = t || {};
    if (R) {
      const D = k.map((F) => z(F));
      R(z(T), P, D, N);
    }
    C(k);
  }, x = O(() => {
    const {
      onSelectInvert: T,
      onSelectNone: P,
      selections: k,
      hideSelectAll: N
    } = n.value, {
      data: R,
      pageData: z,
      getRowKey: D,
      locale: F
    } = t;
    return !k || N ? null : (k === !0 ? [sE, cE, uE] : k).map((A) => A === sE ? {
      key: "all",
      text: F.value.selectionAll,
      onSelect() {
        C(R.value.map((L, B) => D.value(L, B)).filter((L) => {
          const B = c.value.get(L);
          return !(B != null && B.disabled) || h.value.has(L);
        }));
      }
    } : A === cE ? {
      key: "invert",
      text: F.value.selectInvert,
      onSelect() {
        const L = new Set(h.value);
        z.value.forEach((V, j) => {
          const W = D.value(V, j), Y = c.value.get(W);
          Y != null && Y.disabled || (L.has(W) ? L.delete(W) : L.add(W));
        });
        const B = Array.from(L);
        T && (un(!1, "Table", "`onSelectInvert` will be removed in future. Please use `onChange` instead."), T(B)), C(B);
      }
    } : A === uE ? {
      key: "none",
      text: F.value.selectNone,
      onSelect() {
        P == null || P(), C(Array.from(h.value).filter((L) => {
          const B = c.value.get(L);
          return B == null ? void 0 : B.disabled;
        }));
      }
    } : A);
  }), E = O(() => s.value.length);
  return [(T) => {
    var P;
    const {
      onSelectAll: k,
      onSelectMultiple: N,
      columnWidth: R,
      type: z,
      fixed: D,
      renderCell: F,
      hideSelectAll: M,
      checkStrictly: A
    } = n.value, {
      prefixCls: L,
      getRecordByKey: B,
      getRowKey: V,
      expandType: j,
      getPopupContainer: W
    } = t;
    if (!e.value)
      return process.env.NODE_ENV !== "production" && un(!T.includes(ha), "Table", "`rowSelection` is not config but `SELECTION_COLUMN` exists in the `columns`."), T.filter((he) => he !== ha);
    let Y = T.slice();
    const U = new Set(h.value), te = s.value.map(V.value).filter((he) => !c.value.get(he).disabled), J = te.every((he) => U.has(he)), re = te.some((he) => U.has(he)), oe = () => {
      const he = [];
      J ? te.forEach((ne) => {
        U.delete(ne), he.push(ne);
      }) : te.forEach((ne) => {
        U.has(ne) || (U.add(ne), he.push(ne));
      });
      const $e = Array.from(U);
      k == null || k(!J, $e.map((ne) => B(ne)), he.map((ne) => B(ne))), C($e);
    };
    let q;
    if (z !== "radio") {
      let he;
      if (x.value) {
        const xe = $(Do, {
          getPopupContainer: W.value
        }, {
          default: () => [x.value.map((Te, Se) => {
            const {
              key: be,
              text: ie,
              onSelect: we
            } = Te;
            return $(Do.Item, {
              key: be || Se,
              onClick: () => {
                we == null || we(te);
              }
            }, {
              default: () => [ie]
            });
          })]
        });
        he = $("div", {
          class: `${L.value}-selection-extra`
        }, [$(Ia, {
          overlay: xe,
          getPopupContainer: W.value
        }, {
          default: () => [$("span", null, [$(pd, null, null)])]
        })]);
      }
      const $e = s.value.map((xe, Te) => {
        const Se = V.value(xe, Te), be = c.value.get(Se) || {};
        return _({
          checked: U.has(Se)
        }, be);
      }).filter((xe) => {
        let {
          disabled: Te
        } = xe;
        return Te;
      }), ne = !!$e.length && $e.length === E.value, ae = ne && $e.every((xe) => {
        let {
          checked: Te
        } = xe;
        return Te;
      }), ce = ne && $e.some((xe) => {
        let {
          checked: Te
        } = xe;
        return Te;
      });
      q = !M && $("div", {
        class: `${L.value}-selection`
      }, [$(la, {
        checked: ne ? ae : !!E.value && J,
        indeterminate: ne ? !ae && ce : !J && re,
        onChange: oe,
        disabled: E.value === 0 || ne,
        "aria-label": he ? "Custom selection" : "Select all",
        skipGroup: !0
      }, null), he]);
    }
    let K;
    z === "radio" ? K = (he) => {
      let {
        record: $e,
        index: ne
      } = he;
      const ae = V.value($e, ne), ce = U.has(ae);
      return {
        node: $(Jl, Q(Q({}, c.value.get(ae)), {}, {
          checked: ce,
          onClick: (xe) => xe.stopPropagation(),
          onChange: (xe) => {
            U.has(ae) || w(ae, !0, [ae], xe.nativeEvent);
          }
        }), null),
        checked: ce
      };
    } : K = (he) => {
      let {
        record: $e,
        index: ne
      } = he;
      var ae;
      const ce = V.value($e, ne), xe = U.has(ce), Te = g.value.has(ce), Se = c.value.get(ce);
      let be;
      return j.value === "nest" ? (be = Te, un(typeof (Se == null ? void 0 : Se.indeterminate) != "boolean", "Table", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.")) : be = (ae = Se == null ? void 0 : Se.indeterminate) !== null && ae !== void 0 ? ae : Te, {
        node: $(la, Q(Q({}, Se), {}, {
          indeterminate: be,
          checked: xe,
          skipGroup: !0,
          onClick: (ie) => ie.stopPropagation(),
          onChange: (ie) => {
            let {
              nativeEvent: we
            } = ie;
            const {
              shiftKey: Ne
            } = we;
            let tt = -1, Pe = -1;
            if (Ne && A) {
              const Re = /* @__PURE__ */ new Set([y.value, ce]);
              te.some((Le, Ue) => {
                if (Re.has(Le))
                  if (tt === -1)
                    tt = Ue;
                  else
                    return Pe = Ue, !0;
                return !1;
              });
            }
            if (Pe !== -1 && tt !== Pe && A) {
              const Re = te.slice(tt, Pe + 1), Le = [];
              xe ? Re.forEach((Ae) => {
                U.has(Ae) && (Le.push(Ae), U.delete(Ae));
              }) : Re.forEach((Ae) => {
                U.has(Ae) || (Le.push(Ae), U.add(Ae));
              });
              const Ue = Array.from(U);
              N == null || N(!xe, Ue.map((Ae) => B(Ae)), Le.map((Ae) => B(Ae))), C(Ue);
            } else {
              const Re = m.value;
              if (A) {
                const Le = xe ? oi(Re, ce) : Ki(Re, ce);
                w(ce, !xe, Le, we);
              } else {
                const Le = oa([...Re, ce], !0, i.value, u.value, d.value, f), {
                  checkedKeys: Ue,
                  halfCheckedKeys: Ae
                } = Le;
                let De = Ue;
                if (xe) {
                  const _e = new Set(Ue);
                  _e.delete(ce), De = oa(Array.from(_e), {
                    halfCheckedKeys: Ae
                  }, i.value, u.value, d.value, f).checkedKeys;
                }
                w(ce, !xe, De, we);
              }
            }
            b(ce);
          }
        }), null),
        checked: xe
      };
    };
    const se = (he) => {
      let {
        record: $e,
        index: ne
      } = he;
      const {
        node: ae,
        checked: ce
      } = K({
        record: $e,
        index: ne
      });
      return F ? F(ce, $e, ne, ae) : ae;
    };
    if (!Y.includes(ha))
      if (Y.findIndex((he) => {
        var $e;
        return (($e = he[Pf]) === null || $e === void 0 ? void 0 : $e.columnType) === "EXPAND_COLUMN";
      }) === 0) {
        const [he, ...$e] = Y;
        Y = [he, ha, ...$e];
      } else
        Y = [ha, ...Y];
    const Z = Y.indexOf(ha);
    process.env.NODE_ENV !== "production" && Y.filter((he) => he === ha).length > 1 && un(!1, "Table", "Multiple `SELECTION_COLUMN` exist in `columns`."), Y = Y.filter((he, $e) => he !== ha || $e === Z);
    const ee = Y[Z - 1], fe = Y[Z + 1];
    let me = D;
    me === void 0 && ((fe == null ? void 0 : fe.fixed) !== void 0 ? me = fe.fixed : (ee == null ? void 0 : ee.fixed) !== void 0 && (me = ee.fixed)), me && ee && ((P = ee[Pf]) === null || P === void 0 ? void 0 : P.columnType) === "EXPAND_COLUMN" && ee.fixed === void 0 && (ee.fixed = me);
    const ge = {
      fixed: me,
      width: R,
      className: `${L.value}-selection-column`,
      title: n.value.columnTitle || q,
      customRender: se,
      [Pf]: {
        class: `${L.value}-selection-col`
      }
    };
    return Y.map((he) => he === ha ? ge : he);
  }, h];
}
var LKe = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, name: "caret-down", theme: "outlined" };
function hR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      BKe(e, l, n[l]);
    });
  }
  return e;
}
function BKe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var CP = function(t, n) {
  var o = hR({}, t, n.attrs);
  return $(cn, hR({}, o, {
    icon: LKe
  }), null);
};
CP.displayName = "CaretDownOutlined";
CP.inheritAttrs = !1;
var FKe = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, name: "caret-up", theme: "outlined" };
function gR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      VKe(e, l, n[l]);
    });
  }
  return e;
}
function VKe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var wP = function(t, n) {
  var o = gR({}, t, n.attrs);
  return $(cn, gR({}, o, {
    icon: FKe
  }), null);
};
wP.displayName = "CaretUpOutlined";
wP.inheritAttrs = !1;
var zKe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function ed(e, t) {
  return "key" in e && e.key !== void 0 && e.key !== null ? e.key : e.dataIndex ? Array.isArray(e.dataIndex) ? e.dataIndex.join(".") : e.dataIndex : t;
}
function zh(e, t) {
  return t ? `${t}-${e}` : `${e}`;
}
function $P(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function LG() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  const t = Fn(e), n = [];
  return t.forEach((o) => {
    var l, r, a, i;
    if (!o)
      return;
    const s = o.key, c = ((l = o.props) === null || l === void 0 ? void 0 : l.style) || {}, u = ((r = o.props) === null || r === void 0 ? void 0 : r.class) || "", d = o.props || {};
    for (const [h, g] of Object.entries(d))
      d[Tp(h)] = g;
    const f = o.children || {}, {
      default: p
    } = f, m = zKe(f, ["default"]), v = _(_(_({}, m), d), {
      style: c,
      class: u
    });
    if (s && (v.key = s), !((a = o.type) === null || a === void 0) && a.__ANT_TABLE_COLUMN_GROUP)
      v.children = LG(typeof p == "function" ? p() : p);
    else {
      const h = (i = o.children) === null || i === void 0 ? void 0 : i.default;
      v.customRender = v.customRender || h;
    }
    n.push(v);
  }), n;
}
const Zb = "ascend", r$ = "descend";
function Gy(e) {
  return typeof e.sorter == "object" && typeof e.sorter.multiple == "number" ? e.sorter.multiple : !1;
}
function bR(e) {
  return typeof e == "function" ? e : e && typeof e == "object" && e.compare ? e.compare : !1;
}
function HKe(e, t) {
  return t ? e[e.indexOf(t) + 1] : e[0];
}
function dE(e, t, n) {
  let o = [];
  function l(r, a) {
    o.push({
      column: r,
      key: ed(r, a),
      multiplePriority: Gy(r),
      sortOrder: r.sortOrder
    });
  }
  return (e || []).forEach((r, a) => {
    const i = zh(a, n);
    r.children ? ("sortOrder" in r && l(r, i), o = [...o, ...dE(r.children, t, i)]) : r.sorter && ("sortOrder" in r ? l(r, i) : t && r.defaultSortOrder && o.push({
      column: r,
      key: ed(r, i),
      multiplePriority: Gy(r),
      sortOrder: r.defaultSortOrder
    }));
  }), o;
}
function BG(e, t, n, o, l, r, a, i) {
  return (t || []).map((s, c) => {
    const u = zh(c, i);
    let d = s;
    if (d.sorter) {
      const f = d.sortDirections || l, p = d.showSorterTooltip === void 0 ? a : d.showSorterTooltip, m = ed(d, u), v = n.find((T) => {
        let {
          key: P
        } = T;
        return P === m;
      }), h = v ? v.sortOrder : null, g = HKe(f, h), y = f.includes(Zb) && $(wP, {
        class: ke(`${e}-column-sorter-up`, {
          active: h === Zb
        }),
        role: "presentation"
      }, null), b = f.includes(r$) && $(CP, {
        role: "presentation",
        class: ke(`${e}-column-sorter-down`, {
          active: h === r$
        })
      }, null), {
        cancelSort: C,
        triggerAsc: w,
        triggerDesc: x
      } = r || {};
      let E = C;
      g === r$ ? E = x : g === Zb && (E = w);
      const I = typeof p == "object" ? p : {
        title: E
      };
      d = _(_({}, d), {
        className: ke(d.className, {
          [`${e}-column-sort`]: h
        }),
        title: (T) => {
          const P = $("div", {
            class: `${e}-column-sorters`
          }, [$("span", {
            class: `${e}-column-title`
          }, [$P(s.title, T)]), $("span", {
            class: ke(`${e}-column-sorter`, {
              [`${e}-column-sorter-full`]: !!(y && b)
            })
          }, [$("span", {
            class: `${e}-column-sorter-inner`
          }, [y, b])])]);
          return p ? $(Sr, I, {
            default: () => [P]
          }) : P;
        },
        customHeaderCell: (T) => {
          const P = s.customHeaderCell && s.customHeaderCell(T) || {}, k = P.onClick, N = P.onKeydown;
          return P.onClick = (R) => {
            o({
              column: s,
              key: m,
              sortOrder: g,
              multiplePriority: Gy(s)
            }), k && k(R);
          }, P.onKeydown = (R) => {
            R.keyCode === ot.ENTER && (o({
              column: s,
              key: m,
              sortOrder: g,
              multiplePriority: Gy(s)
            }), N == null || N(R));
          }, h && (P["aria-sort"] = h === "ascend" ? "ascending" : "descending"), P.class = ke(P.class, `${e}-column-has-sorters`), P.tabindex = 0, P;
        }
      });
    }
    return "children" in d && (d = _(_({}, d), {
      children: BG(e, d.children, n, o, l, r, a, u)
    })), d;
  });
}
function yR(e) {
  const {
    column: t,
    sortOrder: n
  } = e;
  return {
    column: t,
    order: n,
    field: t.dataIndex,
    columnKey: t.key
  };
}
function SR(e) {
  const t = e.filter((n) => {
    let {
      sortOrder: o
    } = n;
    return o;
  }).map(yR);
  return t.length === 0 && e.length ? _(_({}, yR(e[e.length - 1])), {
    column: void 0
  }) : t.length <= 1 ? t[0] || {} : t;
}
function fE(e, t, n) {
  const o = t.slice().sort((a, i) => i.multiplePriority - a.multiplePriority), l = e.slice(), r = o.filter((a) => {
    let {
      column: {
        sorter: i
      },
      sortOrder: s
    } = a;
    return bR(i) && s;
  });
  return r.length ? l.sort((a, i) => {
    for (let s = 0; s < r.length; s += 1) {
      const c = r[s], {
        column: {
          sorter: u
        },
        sortOrder: d
      } = c, f = bR(u);
      if (f && d) {
        const p = f(a, i, d);
        if (p !== 0)
          return d === Zb ? p : -p;
      }
    }
    return 0;
  }).map((a) => {
    const i = a[n];
    return i ? _(_({}, a), {
      [n]: fE(i, t, n)
    }) : a;
  }) : l;
}
function jKe(e) {
  let {
    prefixCls: t,
    mergedColumns: n,
    onSorterChange: o,
    sortDirections: l,
    tableLocale: r,
    showSorterTooltip: a
  } = e;
  const [i, s] = Bn(dE(n.value, !0)), c = O(() => {
    let m = !0;
    const v = dE(n.value, !1);
    if (!v.length)
      return i.value;
    const h = [];
    function g(b) {
      m ? h.push(b) : h.push(_(_({}, b), {
        sortOrder: null
      }));
    }
    let y = null;
    return v.forEach((b) => {
      y === null ? (g(b), b.sortOrder && (b.multiplePriority === !1 ? m = !1 : y = !0)) : (y && b.multiplePriority !== !1 || (m = !1), g(b));
    }), h;
  }), u = O(() => {
    const m = c.value.map((v) => {
      let {
        column: h,
        sortOrder: g
      } = v;
      return {
        column: h,
        order: g
      };
    });
    return {
      sortColumns: m,
      // Legacy
      sortColumn: m[0] && m[0].column,
      sortOrder: m[0] && m[0].order
    };
  });
  function d(m) {
    let v;
    m.multiplePriority === !1 || !c.value.length || c.value[0].multiplePriority === !1 ? v = [m] : v = [...c.value.filter((h) => {
      let {
        key: g
      } = h;
      return g !== m.key;
    }), m], s(v), o(SR(v), v);
  }
  const f = (m) => BG(t.value, m, c.value, d, l.value, r.value, a.value), p = O(() => SR(c.value));
  return [f, c, u, p];
}
var WKe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, name: "filter", theme: "filled" };
function CR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      KKe(e, l, n[l]);
    });
  }
  return e;
}
function KKe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var xP = function(t, n) {
  var o = CR({}, t, n.attrs);
  return $(cn, CR({}, o, {
    icon: WKe
  }), null);
};
xP.displayName = "FilterFilled";
xP.inheritAttrs = !1;
const UKe = (e) => {
  const {
    keyCode: t
  } = e;
  t === ot.ENTER && e.stopPropagation();
}, GKe = (e, t) => {
  let {
    slots: n
  } = t;
  var o;
  return $("div", {
    onClick: (l) => l.stopPropagation(),
    onKeydown: UKe
  }, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)]);
}, wR = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "FilterSearch",
  inheritAttrs: !1,
  props: {
    value: At(),
    onChange: Fe(),
    filterSearch: zt([Boolean, Function]),
    tablePrefixCls: At(),
    locale: Nt()
  },
  setup(e) {
    return () => {
      const {
        value: t,
        onChange: n,
        filterSearch: o,
        tablePrefixCls: l,
        locale: r
      } = e;
      return o ? $("div", {
        class: `${l}-filter-dropdown-search`
      }, [$(Yo, {
        placeholder: r.filterSearchPlaceholder,
        onChange: n,
        value: t,
        htmlSize: 1,
        class: `${l}-filter-dropdown-search-input`
      }, {
        prefix: () => $(Mp, null, null)
      })]) : null;
    };
  }
});
var $R = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const YKe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "MotionTreeNode",
  inheritAttrs: !1,
  props: _(_({}, yK), {
    active: Boolean,
    motion: Object,
    motionNodes: {
      type: Array
    },
    onMotionStart: Function,
    onMotionEnd: Function,
    motionType: String
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const l = /* @__PURE__ */ Ce(!0), r = LT(), a = /* @__PURE__ */ Ce(!1), i = O(() => e.motion ? e.motion : Ph()), s = (c, u) => {
      var d, f, p, m;
      u === "appear" ? (f = (d = i.value) === null || d === void 0 ? void 0 : d.onAfterEnter) === null || f === void 0 || f.call(d, c) : u === "leave" && ((m = (p = i.value) === null || p === void 0 ? void 0 : p.onAfterLeave) === null || m === void 0 || m.call(p, c)), a.value || e.onMotionEnd(), a.value = !0;
    };
    return pe(() => e.motionNodes, () => {
      e.motionNodes && e.motionType === "hide" && l.value && Ke(() => {
        l.value = !1;
      });
    }, {
      immediate: !0,
      flush: "post"
    }), nt(() => {
      e.motionNodes && e.onMotionStart();
    }), yt(() => {
      e.motionNodes && s();
    }), () => {
      const {
        motion: c,
        motionNodes: u,
        motionType: d,
        active: f,
        eventKey: p
      } = e, m = $R(e, ["motion", "motionNodes", "motionType", "active", "eventKey"]);
      return u ? $(Vn, Q(Q({}, i.value), {}, {
        appear: d === "show",
        onAfterAppear: (v) => s(v, "appear"),
        onAfterLeave: (v) => s(v, "leave")
      }), {
        default: () => [_t($("div", {
          class: `${r.value.prefixCls}-treenode-motion`
        }, [u.map((v) => {
          const h = $R(v.data, []), {
            title: g,
            key: y,
            isStart: b,
            isEnd: C
          } = v;
          return delete h.children, $(z2, Q(Q({}, h), {}, {
            title: g,
            active: f,
            data: v.data,
            key: y,
            eventKey: y,
            isStart: b,
            isEnd: C
          }), o);
        })]), [[Jt, l.value]])]
      }) : $(z2, Q(Q({
        class: n.class,
        style: n.style
      }, m), {}, {
        active: f,
        eventKey: p
      }), o);
    };
  }
});
function XKe() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  const n = e.length, o = t.length;
  if (Math.abs(n - o) !== 1)
    return {
      add: !1,
      key: null
    };
  function l(r, a) {
    const i = /* @__PURE__ */ new Map();
    r.forEach((c) => {
      i.set(c, !0);
    });
    const s = a.filter((c) => !i.has(c));
    return s.length === 1 ? s[0] : null;
  }
  return n < o ? {
    add: !0,
    key: l(e, t)
  } : {
    add: !1,
    key: l(t, e)
  };
}
function xR(e, t, n) {
  const o = e.findIndex((a) => a.key === n), l = e[o + 1], r = t.findIndex((a) => a.key === n);
  if (l) {
    const a = t.findIndex((i) => i.key === l.key);
    return t.slice(r + 1, a);
  }
  return t.slice(r + 1);
}
var ER = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const OR = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
}, qKe = () => {
}, td = `RC_TREE_MOTION_${Math.random()}`, pE = {
  key: td
}, FG = {
  key: td,
  level: 0,
  index: 0,
  pos: "0",
  node: pE,
  nodes: [pE]
}, _R = {
  parent: null,
  children: [],
  pos: FG.pos,
  data: pE,
  title: null,
  key: td,
  /** Hold empty list here since we do not use it */
  isStart: [],
  isEnd: []
};
function IR(e, t, n, o) {
  return t === !1 || !n ? e : e.slice(0, Math.ceil(n / o) + 1);
}
function TR(e) {
  const {
    key: t,
    pos: n
  } = e;
  return Dh(t, n);
}
function JKe(e) {
  let t = String(e.key), n = e;
  for (; n.parent; )
    n = n.parent, t = `${n.key} > ${t}`;
  return t;
}
const ZKe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "NodeList",
  inheritAttrs: !1,
  props: NLe,
  setup(e, t) {
    let {
      expose: n,
      attrs: o
    } = t;
    const l = /* @__PURE__ */ H(), r = /* @__PURE__ */ H(), {
      expandedKeys: a,
      flattenNodes: i
    } = bK();
    n({
      scrollTo: (v) => {
        l.value.scrollTo(v);
      },
      getIndentWidth: () => r.value.offsetWidth
    });
    const s = /* @__PURE__ */ Ce(i.value), c = /* @__PURE__ */ Ce([]), u = /* @__PURE__ */ H(null);
    function d() {
      s.value = i.value, c.value = [], u.value = null, e.onListChangeEnd();
    }
    const f = LT();
    pe([() => a.value.slice(), i], (v, h) => {
      let [g, y] = v, [b, C] = h;
      const w = XKe(b, g);
      if (w.key !== null) {
        const {
          virtual: x,
          height: E,
          itemHeight: I
        } = e;
        if (w.add) {
          const T = C.findIndex((N) => {
            let {
              key: R
            } = N;
            return R === w.key;
          }), P = IR(xR(C, y, w.key), x, E, I), k = C.slice();
          k.splice(T + 1, 0, _R), s.value = k, c.value = P, u.value = "show";
        } else {
          const T = y.findIndex((N) => {
            let {
              key: R
            } = N;
            return R === w.key;
          }), P = IR(xR(y, C, w.key), x, E, I), k = y.slice();
          k.splice(T + 1, 0, _R), s.value = k, c.value = P, u.value = "hide";
        }
      } else C !== y && (s.value = y);
    }), pe(() => f.value.dragging, (v) => {
      v || d();
    });
    const p = O(() => e.motion === void 0 ? s.value : i.value), m = () => {
      e.onActiveChange(null);
    };
    return () => {
      const v = _(_({}, e), o), {
        prefixCls: h,
        selectable: g,
        checkable: y,
        disabled: b,
        motion: C,
        height: w,
        itemHeight: x,
        virtual: E,
        focusable: I,
        activeItem: T,
        focused: P,
        tabindex: k,
        onKeydown: N,
        onFocus: R,
        onBlur: z,
        onListChangeStart: D,
        onListChangeEnd: F
      } = v, M = ER(v, ["prefixCls", "selectable", "checkable", "disabled", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabindex", "onKeydown", "onFocus", "onBlur", "onListChangeStart", "onListChangeEnd"]);
      return $(Ge, null, [P && T && $("span", {
        style: OR,
        "aria-live": "assertive"
      }, [JKe(T)]), $("div", null, [$("input", {
        style: OR,
        disabled: I === !1 || b,
        tabindex: I !== !1 ? k : null,
        onKeydown: N,
        onFocus: R,
        onBlur: z,
        value: "",
        onChange: qKe,
        "aria-label": "for screen reader"
      }, null)]), $("div", {
        class: `${h}-treenode`,
        "aria-hidden": !0,
        style: {
          position: "absolute",
          pointerEvents: "none",
          visibility: "hidden",
          height: 0,
          overflow: "hidden"
        }
      }, [$("div", {
        class: `${h}-indent`
      }, [$("div", {
        ref: r,
        class: `${h}-indent-unit`
      }, null)])]), $(_j, Q(Q({}, pn(M, ["onActiveChange"])), {}, {
        data: p.value,
        itemKey: TR,
        height: w,
        fullHeight: !1,
        virtual: E,
        itemHeight: x,
        prefixCls: `${h}-list`,
        ref: l,
        onVisibleChange: (A, L) => {
          const B = new Set(A);
          L.filter((j) => !B.has(j)).some((j) => TR(j) === td) && d();
        }
      }), {
        default: (A) => {
          const {
            pos: L
          } = A, B = ER(A.data, []), {
            title: V,
            key: j,
            isStart: W,
            isEnd: Y
          } = A, U = Dh(j, L);
          return delete B.key, delete B.children, $(YKe, Q(Q({}, B), {}, {
            eventKey: U,
            title: V,
            active: !!T && j === T.key,
            data: A.data,
            isStart: W,
            isEnd: Y,
            motion: C,
            motionNodes: j === td ? c.value : null,
            motionType: u.value,
            onMotionStart: D,
            onMotionEnd: d,
            onMousemove: m
          }), null);
        }
      })]);
    };
  }
});
function QKe(e) {
  let {
    dropPosition: t,
    dropLevelOffset: n,
    indent: o
  } = e;
  const l = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: "2px"
  };
  switch (t) {
    case -1:
      l.top = 0, l.left = `${-n * o}px`;
      break;
    case 1:
      l.bottom = 0, l.left = `${-n * o}px`;
      break;
    case 0:
      l.bottom = 0, l.left = `${o}`;
      break;
  }
  return $("div", {
    style: l
  }, null);
}
const eUe = 10, VG = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Tree",
  inheritAttrs: !1,
  props: sn(SK(), {
    prefixCls: "vc-tree",
    showLine: !1,
    showIcon: !0,
    selectable: !0,
    multiple: !1,
    checkable: !1,
    disabled: !1,
    checkStrictly: !1,
    draggable: !1,
    expandAction: !1,
    defaultExpandParent: !0,
    autoExpandParent: !1,
    defaultExpandAll: !1,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    dropIndicatorRender: QKe,
    allowDrop: () => !0
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: l
    } = t;
    const r = /* @__PURE__ */ Ce(!1);
    let a = {};
    const i = /* @__PURE__ */ Ce(), s = /* @__PURE__ */ Ce([]), c = /* @__PURE__ */ Ce([]), u = /* @__PURE__ */ Ce([]), d = /* @__PURE__ */ Ce([]), f = /* @__PURE__ */ Ce([]), p = /* @__PURE__ */ Ce([]), m = {}, v = /* @__PURE__ */ kt({
      draggingNodeKey: null,
      dragChildrenKeys: [],
      // dropTargetKey is the key of abstract-drop-node
      // the abstract-drop-node is the real drop node when drag and drop
      // not the DOM drag over node
      dropTargetKey: null,
      dropPosition: null,
      dropContainerKey: null,
      dropLevelOffset: null,
      dropTargetPos: null,
      dropAllowed: !0,
      // the abstract-drag-over-node
      // if mouse is on the bottom of top dom node or no the top of the bottom dom node
      // abstract-drag-over-node is the top node
      dragOverNodeKey: null
    }), h = /* @__PURE__ */ Ce([]);
    pe([() => e.treeData, () => e.children], () => {
      h.value = e.treeData !== void 0 ? e.treeData.slice() : j2(/* @__PURE__ */ Wt(e.children));
    }, {
      immediate: !0,
      deep: !0
    });
    const g = /* @__PURE__ */ Ce({}), y = /* @__PURE__ */ Ce(!1), b = /* @__PURE__ */ Ce(null), C = /* @__PURE__ */ Ce(!1), w = O(() => LS(e.fieldNames)), x = /* @__PURE__ */ Ce();
    let E = null, I = null, T = null;
    const P = O(() => ({
      expandedKeysSet: k.value,
      selectedKeysSet: N.value,
      loadedKeysSet: R.value,
      loadingKeysSet: z.value,
      checkedKeysSet: D.value,
      halfCheckedKeysSet: F.value,
      dragOverNodeKey: v.dragOverNodeKey,
      dropPosition: v.dropPosition,
      keyEntities: g.value
    })), k = O(() => new Set(p.value)), N = O(() => new Set(s.value)), R = O(() => new Set(d.value)), z = O(() => new Set(f.value)), D = O(() => new Set(c.value)), F = O(() => new Set(u.value));
    Ot(() => {
      if (h.value) {
        const Pe = Lh(h.value, {
          fieldNames: w.value
        });
        g.value = _({
          [td]: FG
        }, Pe.keyEntities);
      }
    });
    let M = !1;
    pe(
      [() => e.expandedKeys, () => e.autoExpandParent, g],
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (Pe, Re) => {
        let [Le, Ue] = Pe, [Ae, De] = Re, _e = p.value;
        if (e.expandedKeys !== void 0 || M && Ue !== De)
          _e = e.autoExpandParent || !M && e.defaultExpandParent ? H2(e.expandedKeys, g.value) : e.expandedKeys;
        else if (!M && e.defaultExpandAll) {
          const Ze = _({}, g.value);
          delete Ze[td], _e = Object.keys(Ze).map((dt) => Ze[dt].key);
        } else !M && e.defaultExpandedKeys && (_e = e.autoExpandParent || e.defaultExpandParent ? H2(e.defaultExpandedKeys, g.value) : e.defaultExpandedKeys);
        _e && (p.value = _e), M = !0;
      },
      {
        immediate: !0
      }
    );
    const A = /* @__PURE__ */ Ce([]);
    Ot(() => {
      A.value = VLe(h.value, p.value, w.value);
    }), Ot(() => {
      e.selectable && (e.selectedKeys !== void 0 ? s.value = K6(e.selectedKeys, e) : !M && e.defaultSelectedKeys && (s.value = K6(e.defaultSelectedKeys, e)));
    });
    const {
      maxLevel: L,
      levelEntities: B
    } = zS(g);
    Ot(() => {
      if (e.checkable) {
        let Pe;
        if (e.checkedKeys !== void 0 ? Pe = Hw(e.checkedKeys) || {} : !M && e.defaultCheckedKeys ? Pe = Hw(e.defaultCheckedKeys) || {} : h.value && (Pe = Hw(e.checkedKeys) || {
          checkedKeys: c.value,
          halfCheckedKeys: u.value
        }), Pe) {
          let {
            checkedKeys: Re = [],
            halfCheckedKeys: Le = []
          } = Pe;
          e.checkStrictly || ({
            checkedKeys: Re,
            halfCheckedKeys: Le
          } = oa(Re, !0, g.value, L.value, B.value)), c.value = Re, u.value = Le;
        }
      }
    }), Ot(() => {
      e.loadedKeys && (d.value = e.loadedKeys);
    });
    const V = () => {
      _(v, {
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: !1
      });
    }, j = (Pe) => {
      x.value.scrollTo(Pe);
    };
    pe(() => e.activeKey, () => {
      e.activeKey !== void 0 && (b.value = e.activeKey);
    }, {
      immediate: !0
    }), pe(b, (Pe) => {
      Ke(() => {
        Pe !== null && j({
          key: Pe
        });
      });
    }, {
      immediate: !0,
      flush: "post"
    });
    const W = (Pe) => {
      e.expandedKeys === void 0 && (p.value = Pe);
    }, Y = () => {
      v.draggingNodeKey !== null && _(v, {
        draggingNodeKey: null,
        dropPosition: null,
        dropContainerKey: null,
        dropTargetKey: null,
        dropLevelOffset: null,
        dropAllowed: !0,
        dragOverNodeKey: null
      }), E = null, T = null;
    }, U = (Pe, Re) => {
      const {
        onDragend: Le
      } = e;
      v.dragOverNodeKey = null, Y(), Le == null || Le({
        event: Pe,
        node: Re.eventData
      }), I = null;
    }, te = (Pe) => {
      U(Pe, null), window.removeEventListener("dragend", te);
    }, J = (Pe, Re) => {
      const {
        onDragstart: Le
      } = e, {
        eventKey: Ue,
        eventData: Ae
      } = Re;
      I = Re, E = {
        x: Pe.clientX,
        y: Pe.clientY
      };
      const De = oi(p.value, Ue);
      v.draggingNodeKey = Ue, v.dragChildrenKeys = DLe(Ue, g.value), i.value = x.value.getIndentWidth(), W(De), window.addEventListener("dragend", te), Le && Le({
        event: Pe,
        node: Ae
      });
    }, re = (Pe, Re) => {
      const {
        onDragenter: Le,
        onExpand: Ue,
        allowDrop: Ae,
        direction: De
      } = e, {
        pos: _e,
        eventKey: Ze
      } = Re;
      if (T !== Ze && (T = Ze), !I) {
        V();
        return;
      }
      const {
        dropPosition: dt,
        dropLevelOffset: Tt,
        dropTargetKey: jt,
        dropContainerKey: Qt,
        dropTargetPos: je,
        dropAllowed: lt,
        dragOverNodeKey: Ct
      } = W6(Pe, I, Re, i.value, E, Ae, A.value, g.value, k.value, De);
      if (
        // don't allow drop inside its children
        v.dragChildrenKeys.indexOf(jt) !== -1 || // don't allow drop when drop is not allowed caculated by calcDropPosition
        !lt
      ) {
        V();
        return;
      }
      if (a || (a = {}), Object.keys(a).forEach((vn) => {
        clearTimeout(a[vn]);
      }), I.eventKey !== Re.eventKey && (a[_e] = window.setTimeout(() => {
        if (v.draggingNodeKey === null) return;
        let vn = p.value.slice();
        const tn = g.value[Re.eventKey];
        tn && (tn.children || []).length && (vn = Ki(p.value, Re.eventKey)), W(vn), Ue && Ue(vn, {
          node: Re.eventData,
          expanded: !0,
          nativeEvent: Pe
        });
      }, 800)), I.eventKey === jt && Tt === 0) {
        V();
        return;
      }
      _(v, {
        dragOverNodeKey: Ct,
        dropPosition: dt,
        dropLevelOffset: Tt,
        dropTargetKey: jt,
        dropContainerKey: Qt,
        dropTargetPos: je,
        dropAllowed: lt
      }), Le && Le({
        event: Pe,
        node: Re.eventData,
        expandedKeys: p.value
      });
    }, oe = (Pe, Re) => {
      const {
        onDragover: Le,
        allowDrop: Ue,
        direction: Ae
      } = e;
      if (!I)
        return;
      const {
        dropPosition: De,
        dropLevelOffset: _e,
        dropTargetKey: Ze,
        dropContainerKey: dt,
        dropAllowed: Tt,
        dropTargetPos: jt,
        dragOverNodeKey: Qt
      } = W6(Pe, I, Re, i.value, E, Ue, A.value, g.value, k.value, Ae);
      v.dragChildrenKeys.indexOf(Ze) !== -1 || !Tt || (I.eventKey === Ze && _e === 0 ? v.dropPosition === null && v.dropLevelOffset === null && v.dropTargetKey === null && v.dropContainerKey === null && v.dropTargetPos === null && v.dropAllowed === !1 && v.dragOverNodeKey === null || V() : De === v.dropPosition && _e === v.dropLevelOffset && Ze === v.dropTargetKey && dt === v.dropContainerKey && jt === v.dropTargetPos && Tt === v.dropAllowed && Qt === v.dragOverNodeKey || _(v, {
        dropPosition: De,
        dropLevelOffset: _e,
        dropTargetKey: Ze,
        dropContainerKey: dt,
        dropTargetPos: jt,
        dropAllowed: Tt,
        dragOverNodeKey: Qt
      }), Le && Le({
        event: Pe,
        node: Re.eventData
      }));
    }, q = (Pe, Re) => {
      T === Re.eventKey && !Pe.currentTarget.contains(Pe.relatedTarget) && (V(), T = null);
      const {
        onDragleave: Le
      } = e;
      Le && Le({
        event: Pe,
        node: Re.eventData
      });
    }, K = function(Pe, Re) {
      let Le = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      var Ue;
      const {
        dragChildrenKeys: Ae,
        dropPosition: De,
        dropTargetKey: _e,
        dropTargetPos: Ze,
        dropAllowed: dt
      } = v;
      if (!dt) return;
      const {
        onDrop: Tt
      } = e;
      if (v.dragOverNodeKey = null, Y(), _e === null) return;
      const jt = _(_({}, Db(_e, /* @__PURE__ */ Wt(P.value))), {
        active: ((Ue = ie.value) === null || Ue === void 0 ? void 0 : Ue.key) === _e,
        data: g.value[_e].node
      }), Qt = Ae.indexOf(_e) !== -1;
      bn(!Qt, "Can not drop to dragNode's children node. Maybe this is a bug of ant-design-vue. Please report an issue.");
      const je = BT(Ze), lt = {
        event: Pe,
        node: Lb(jt),
        dragNode: I ? I.eventData : null,
        dragNodesKeys: [I.eventKey].concat(Ae),
        dropToGap: De !== 0,
        dropPosition: De + Number(je[je.length - 1])
      };
      Le || Tt == null || Tt(lt), I = null;
    }, se = (Pe, Re) => {
      const {
        expanded: Le,
        key: Ue
      } = Re, Ae = A.value.filter((_e) => _e.key === Ue)[0], De = Lb(_(_({}, Db(Ue, P.value)), {
        data: Ae.data
      }));
      W(Le ? oi(p.value, Ue) : Ki(p.value, Ue)), xe(Pe, De);
    }, Z = (Pe, Re) => {
      const {
        onClick: Le,
        expandAction: Ue
      } = e;
      Ue === "click" && se(Pe, Re), Le && Le(Pe, Re);
    }, ee = (Pe, Re) => {
      const {
        onDblclick: Le,
        expandAction: Ue
      } = e;
      (Ue === "doubleclick" || Ue === "dblclick") && se(Pe, Re), Le && Le(Pe, Re);
    }, fe = (Pe, Re) => {
      let Le = s.value;
      const {
        onSelect: Ue,
        multiple: Ae
      } = e, {
        selected: De
      } = Re, _e = Re[w.value.key], Ze = !De;
      Ze ? Ae ? Le = Ki(Le, _e) : Le = [_e] : Le = oi(Le, _e);
      const dt = g.value, Tt = Le.map((jt) => {
        const Qt = dt[jt];
        return Qt ? Qt.node : null;
      }).filter((jt) => jt);
      e.selectedKeys === void 0 && (s.value = Le), Ue && Ue(Le, {
        event: "select",
        selected: Ze,
        node: Re,
        selectedNodes: Tt,
        nativeEvent: Pe
      });
    }, me = (Pe, Re, Le) => {
      const {
        checkStrictly: Ue,
        onCheck: Ae
      } = e, De = Re[w.value.key];
      let _e;
      const Ze = {
        event: "check",
        node: Re,
        checked: Le,
        nativeEvent: Pe
      }, dt = g.value;
      if (Ue) {
        const Tt = Le ? Ki(c.value, De) : oi(c.value, De), jt = oi(u.value, De);
        _e = {
          checked: Tt,
          halfChecked: jt
        }, Ze.checkedNodes = Tt.map((Qt) => dt[Qt]).filter((Qt) => Qt).map((Qt) => Qt.node), e.checkedKeys === void 0 && (c.value = Tt);
      } else {
        let {
          checkedKeys: Tt,
          halfCheckedKeys: jt
        } = oa([...c.value, De], !0, dt, L.value, B.value);
        if (!Le) {
          const Qt = new Set(Tt);
          Qt.delete(De), {
            checkedKeys: Tt,
            halfCheckedKeys: jt
          } = oa(Array.from(Qt), {
            halfCheckedKeys: jt
          }, dt, L.value, B.value);
        }
        _e = Tt, Ze.checkedNodes = [], Ze.checkedNodesPositions = [], Ze.halfCheckedKeys = jt, Tt.forEach((Qt) => {
          const je = dt[Qt];
          if (!je) return;
          const {
            node: lt,
            pos: Ct
          } = je;
          Ze.checkedNodes.push(lt), Ze.checkedNodesPositions.push({
            node: lt,
            pos: Ct
          });
        }), e.checkedKeys === void 0 && (c.value = Tt, u.value = jt);
      }
      Ae && Ae(_e, Ze);
    }, ge = (Pe) => {
      const Re = Pe[w.value.key], Le = new Promise((Ue, Ae) => {
        const {
          loadData: De,
          onLoad: _e
        } = e;
        if (!De || R.value.has(Re) || z.value.has(Re))
          return null;
        De(Pe).then(() => {
          const dt = Ki(d.value, Re), Tt = oi(f.value, Re);
          _e && _e(dt, {
            event: "load",
            node: Pe
          }), e.loadedKeys === void 0 && (d.value = dt), f.value = Tt, Ue();
        }).catch((dt) => {
          const Tt = oi(f.value, Re);
          if (f.value = Tt, m[Re] = (m[Re] || 0) + 1, m[Re] >= eUe) {
            bn(!1, "Retry for `loadData` many times but still failed. No more retry.");
            const jt = Ki(d.value, Re);
            e.loadedKeys === void 0 && (d.value = jt), Ue();
          }
          Ae(dt);
        }), f.value = Ki(f.value, Re);
      });
      return Le.catch(() => {
      }), Le;
    }, he = (Pe, Re) => {
      const {
        onMouseenter: Le
      } = e;
      Le && Le({
        event: Pe,
        node: Re
      });
    }, $e = (Pe, Re) => {
      const {
        onMouseleave: Le
      } = e;
      Le && Le({
        event: Pe,
        node: Re
      });
    }, ne = (Pe, Re) => {
      const {
        onRightClick: Le
      } = e;
      Le && (Pe.preventDefault(), Le({
        event: Pe,
        node: Re
      }));
    }, ae = (Pe) => {
      const {
        onFocus: Re
      } = e;
      y.value = !0, Re && Re(Pe);
    }, ce = (Pe) => {
      const {
        onBlur: Re
      } = e;
      y.value = !1, be(null), Re && Re(Pe);
    }, xe = (Pe, Re) => {
      let Le = p.value;
      const {
        onExpand: Ue,
        loadData: Ae
      } = e, {
        expanded: De
      } = Re, _e = Re[w.value.key];
      if (C.value)
        return;
      const Ze = Le.indexOf(_e), dt = !De;
      if (bn(De && Ze !== -1 || !De && Ze === -1, "Expand state not sync with index check"), dt ? Le = Ki(Le, _e) : Le = oi(Le, _e), W(Le), Ue && Ue(Le, {
        node: Re,
        expanded: dt,
        nativeEvent: Pe
      }), dt && Ae) {
        const Tt = ge(Re);
        Tt && Tt.then(() => {
        }).catch((jt) => {
          const Qt = oi(p.value, _e);
          W(Qt), Promise.reject(jt);
        });
      }
    }, Te = () => {
      C.value = !0;
    }, Se = () => {
      setTimeout(() => {
        C.value = !1;
      });
    }, be = (Pe) => {
      const {
        onActiveChange: Re
      } = e;
      b.value !== Pe && (e.activeKey !== void 0 && (b.value = Pe), Pe !== null && j({
        key: Pe
      }), Re && Re(Pe));
    }, ie = O(() => b.value === null ? null : A.value.find((Pe) => {
      let {
        key: Re
      } = Pe;
      return Re === b.value;
    }) || null), we = (Pe) => {
      let Re = A.value.findIndex((Ue) => {
        let {
          key: Ae
        } = Ue;
        return Ae === b.value;
      });
      Re === -1 && Pe < 0 && (Re = A.value.length), Re = (Re + Pe + A.value.length) % A.value.length;
      const Le = A.value[Re];
      if (Le) {
        const {
          key: Ue
        } = Le;
        be(Ue);
      } else
        be(null);
    }, Ne = O(() => Lb(_(_({}, Db(b.value, P.value)), {
      data: ie.value.data,
      active: !0
    }))), tt = (Pe) => {
      const {
        onKeydown: Re,
        checkable: Le,
        selectable: Ue
      } = e;
      switch (Pe.which) {
        case ot.UP: {
          we(-1), Pe.preventDefault();
          break;
        }
        case ot.DOWN: {
          we(1), Pe.preventDefault();
          break;
        }
      }
      const Ae = ie.value;
      if (Ae && Ae.data) {
        const De = Ae.data.isLeaf === !1 || !!(Ae.data.children || []).length, _e = Ne.value;
        switch (Pe.which) {
          case ot.LEFT: {
            De && k.value.has(b.value) ? xe({}, _e) : Ae.parent && be(Ae.parent.key), Pe.preventDefault();
            break;
          }
          case ot.RIGHT: {
            De && !k.value.has(b.value) ? xe({}, _e) : Ae.children && Ae.children.length && be(Ae.children[0].key), Pe.preventDefault();
            break;
          }
          case ot.ENTER:
          case ot.SPACE: {
            Le && !_e.disabled && _e.checkable !== !1 && !_e.disableCheckbox ? me({}, _e, !D.value.has(b.value)) : !Le && Ue && !_e.disabled && _e.selectable !== !1 && fe({}, _e);
            break;
          }
        }
      }
      Re && Re(Pe);
    };
    return l({
      onNodeExpand: xe,
      scrollTo: j,
      onKeydown: tt,
      selectedKeys: O(() => s.value),
      checkedKeys: O(() => c.value),
      halfCheckedKeys: O(() => u.value),
      loadedKeys: O(() => d.value),
      loadingKeys: O(() => f.value),
      expandedKeys: O(() => p.value)
    }), Uo(() => {
      window.removeEventListener("dragend", te), r.value = !0;
    }), PLe({
      expandedKeys: p,
      selectedKeys: s,
      loadedKeys: d,
      loadingKeys: f,
      checkedKeys: c,
      halfCheckedKeys: u,
      expandedKeysSet: k,
      selectedKeysSet: N,
      loadedKeysSet: R,
      loadingKeysSet: z,
      checkedKeysSet: D,
      halfCheckedKeysSet: F,
      flattenNodes: A
    }), () => {
      const {
        // focused,
        // flattenNodes,
        // keyEntities,
        draggingNodeKey: Pe,
        // activeKey,
        dropLevelOffset: Re,
        dropContainerKey: Le,
        dropTargetKey: Ue,
        dropPosition: Ae,
        dragOverNodeKey: De
        // indent,
      } = v, {
        prefixCls: _e,
        showLine: Ze,
        focusable: dt,
        tabindex: Tt = 0,
        selectable: jt,
        showIcon: Qt,
        icon: je = o.icon,
        switcherIcon: lt,
        draggable: Ct,
        checkable: vn,
        checkStrictly: tn,
        disabled: ct,
        motion: pt,
        loadData: Lt,
        filterTreeNode: Gn,
        height: To,
        itemHeight: st,
        virtual: Yt,
        dropIndicatorRender: Kt,
        onContextmenu: Ln,
        onScroll: Zn,
        direction: ho,
        rootClassName: ul,
        rootStyle: zo
      } = e, {
        class: ir,
        style: hl
      } = n, Go = Mc(_(_({}, e), n), {
        aria: !0,
        data: !0
      });
      let He;
      return Ct ? typeof Ct == "object" ? He = Ct : typeof Ct == "function" ? He = {
        nodeDraggable: Ct
      } : He = {} : He = !1, $(TLe, {
        value: {
          prefixCls: _e,
          selectable: jt,
          showIcon: Qt,
          icon: je,
          switcherIcon: lt,
          draggable: He,
          draggingNodeKey: Pe,
          checkable: vn,
          customCheckable: o.checkable,
          checkStrictly: tn,
          disabled: ct,
          keyEntities: g.value,
          dropLevelOffset: Re,
          dropContainerKey: Le,
          dropTargetKey: Ue,
          dropPosition: Ae,
          dragOverNodeKey: De,
          dragging: Pe !== null,
          indent: i.value,
          direction: ho,
          dropIndicatorRender: Kt,
          loadData: Lt,
          filterTreeNode: Gn,
          onNodeClick: Z,
          onNodeDoubleClick: ee,
          onNodeExpand: xe,
          onNodeSelect: fe,
          onNodeCheck: me,
          onNodeLoad: ge,
          onNodeMouseEnter: he,
          onNodeMouseLeave: $e,
          onNodeContextMenu: ne,
          onNodeDragStart: J,
          onNodeDragEnter: re,
          onNodeDragOver: oe,
          onNodeDragLeave: q,
          onNodeDragEnd: U,
          onNodeDrop: K,
          slots: o
        }
      }, {
        default: () => [$("div", {
          role: "tree",
          class: ke(_e, ir, ul, {
            [`${_e}-show-line`]: Ze,
            [`${_e}-focused`]: y.value,
            [`${_e}-active-focused`]: b.value !== null
          }),
          style: zo
        }, [$(ZKe, Q({
          ref: x,
          prefixCls: _e,
          style: hl,
          disabled: ct,
          selectable: jt,
          checkable: !!vn,
          motion: pt,
          height: To,
          itemHeight: st,
          virtual: Yt,
          focusable: dt,
          focused: y.value,
          tabindex: Tt,
          activeItem: ie.value,
          onFocus: ae,
          onBlur: ce,
          onKeydown: tt,
          onActiveChange: be,
          onListChangeStart: Te,
          onListChangeEnd: Se,
          onContextmenu: Ln,
          onScroll: Zn
        }, Go), null)])]
      });
    };
  }
});
var tUe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, name: "file", theme: "outlined" };
function PR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      nUe(e, l, n[l]);
    });
  }
  return e;
}
function nUe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var oC = function(t, n) {
  var o = PR({}, t, n.attrs);
  return $(cn, PR({}, o, {
    icon: tUe
  }), null);
};
oC.displayName = "FileOutlined";
oC.inheritAttrs = !1;
var oUe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { tag: "path", attrs: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "minus-square", theme: "outlined" };
function kR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      lUe(e, l, n[l]);
    });
  }
  return e;
}
function lUe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var EP = function(t, n) {
  var o = kR({}, t, n.attrs);
  return $(cn, kR({}, o, {
    icon: oUe
  }), null);
};
EP.displayName = "MinusSquareOutlined";
EP.inheritAttrs = !1;
var rUe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { tag: "path", attrs: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "plus-square", theme: "outlined" };
function NR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      aUe(e, l, n[l]);
    });
  }
  return e;
}
function aUe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var OP = function(t, n) {
  var o = NR({}, t, n.attrs);
  return $(cn, NR({}, o, {
    icon: rUe
  }), null);
};
OP.displayName = "PlusSquareOutlined";
OP.inheritAttrs = !1;
var iUe = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, name: "caret-down", theme: "filled" };
function MR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      sUe(e, l, n[l]);
    });
  }
  return e;
}
function sUe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var _P = function(t, n) {
  var o = MR({}, t, n.attrs);
  return $(cn, MR({}, o, {
    icon: iUe
  }), null);
};
_P.displayName = "CaretDownFilled";
_P.inheritAttrs = !1;
function zG(e, t, n, o, l) {
  const {
    isLeaf: r,
    expanded: a,
    loading: i
  } = n;
  let s = t;
  if (i)
    return $(ar, {
      class: `${e}-switcher-loading-icon`
    }, null);
  let c;
  l && typeof l == "object" && (c = l.showLeafIcon);
  let u = null;
  const d = `${e}-switcher-icon`;
  return r ? l ? c && o ? o(n) : (typeof l == "object" && !c ? u = $("span", {
    class: `${e}-switcher-leaf-line`
  }, null) : u = $(oC, {
    class: `${e}-switcher-line-icon`
  }, null), u) : null : (u = $(_P, {
    class: d
  }, null), l && (u = a ? $(EP, {
    class: `${e}-switcher-line-icon`
  }, null) : $(OP, {
    class: `${e}-switcher-line-icon`
  }, null)), typeof t == "function" ? s = t(_(_({}, n), {
    defaultIcon: u,
    switcherCls: d
  })) : Io(s) && (s = No(s, {
    class: d
  })), s || u);
}
const AR = 4;
function cUe(e) {
  const {
    dropPosition: t,
    dropLevelOffset: n,
    prefixCls: o,
    indent: l,
    direction: r = "ltr"
  } = e, a = r === "ltr" ? "left" : "right", i = r === "ltr" ? "right" : "left", s = {
    [a]: `${-n * l + AR}px`,
    [i]: 0
  };
  switch (t) {
    case -1:
      s.top = "-3px";
      break;
    case 1:
      s.bottom = "-3px";
      break;
    default:
      s.bottom = "-3px", s[a] = `${l + AR}px`;
      break;
  }
  return $("div", {
    style: s,
    class: `${o}-drop-indicator`
  }, null);
}
const uUe = new mn("ant-tree-node-fx-do-not-use", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
}), dUe = (e, t) => ({
  [`.${e}-switcher-icon`]: {
    display: "inline-block",
    fontSize: 10,
    verticalAlign: "baseline",
    svg: {
      transition: `transform ${t.motionDurationSlow}`
    }
  }
}), fUe = (e, t) => ({
  [`.${e}-drop-indicator`]: {
    position: "absolute",
    // it should displayed over the following node
    zIndex: 1,
    height: 2,
    backgroundColor: t.colorPrimary,
    borderRadius: 1,
    pointerEvents: "none",
    "&:after": {
      position: "absolute",
      top: -3,
      insetInlineStart: -6,
      width: 8,
      height: 8,
      backgroundColor: "transparent",
      border: `${t.lineWidthBold}px solid ${t.colorPrimary}`,
      borderRadius: "50%",
      content: '""'
    }
  }
}), pUe = (e, t) => {
  const {
    treeCls: n,
    treeNodeCls: o,
    treeNodePadding: l,
    treeTitleHeight: r
  } = t, a = (r - t.fontSizeLG) / 2, i = t.paddingXS;
  return {
    [n]: _(_({}, nn(t)), {
      background: t.colorBgContainer,
      borderRadius: t.borderRadius,
      transition: `background-color ${t.motionDurationSlow}`,
      [`&${n}-rtl`]: {
        // >>> Switcher
        [`${n}-switcher`]: {
          "&_close": {
            [`${n}-switcher-icon`]: {
              svg: {
                transform: "rotate(90deg)"
              }
            }
          }
        }
      },
      [`&-focused:not(:hover):not(${n}-active-focused)`]: _({}, bs(t)),
      // =================== Virtual List ===================
      [`${n}-list-holder-inner`]: {
        alignItems: "flex-start"
      },
      [`&${n}-block-node`]: {
        [`${n}-list-holder-inner`]: {
          alignItems: "stretch",
          // >>> Title
          [`${n}-node-content-wrapper`]: {
            flex: "auto"
          },
          // >>> Drag
          [`${o}.dragging`]: {
            position: "relative",
            "&:after": {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: l,
              insetInlineStart: 0,
              border: `1px solid ${t.colorPrimary}`,
              opacity: 0,
              animationName: uUe,
              animationDuration: t.motionDurationSlow,
              animationPlayState: "running",
              animationFillMode: "forwards",
              content: '""',
              pointerEvents: "none"
            }
          }
        }
      },
      // ===================== TreeNode =====================
      [`${o}`]: {
        display: "flex",
        alignItems: "flex-start",
        padding: `0 0 ${l}px 0`,
        outline: "none",
        "&-rtl": {
          direction: "rtl"
        },
        // Disabled
        "&-disabled": {
          // >>> Title
          [`${n}-node-content-wrapper`]: {
            color: t.colorTextDisabled,
            cursor: "not-allowed",
            "&:hover": {
              background: "transparent"
            }
          }
        },
        [`&-active ${n}-node-content-wrapper`]: _({}, bs(t)),
        [`&:not(${o}-disabled).filter-node ${n}-title`]: {
          color: "inherit",
          fontWeight: 500
        },
        "&-draggable": {
          [`${n}-draggable-icon`]: {
            width: r,
            lineHeight: `${r}px`,
            textAlign: "center",
            visibility: "visible",
            opacity: 0.2,
            transition: `opacity ${t.motionDurationSlow}`,
            [`${o}:hover &`]: {
              opacity: 0.45
            }
          },
          [`&${o}-disabled`]: {
            [`${n}-draggable-icon`]: {
              visibility: "hidden"
            }
          }
        }
      },
      // >>> Indent
      [`${n}-indent`]: {
        alignSelf: "stretch",
        whiteSpace: "nowrap",
        userSelect: "none",
        "&-unit": {
          display: "inline-block",
          width: r
        }
      },
      // >>> Drag Handler
      [`${n}-draggable-icon`]: {
        visibility: "hidden"
      },
      // >>> Switcher
      [`${n}-switcher`]: _(_({}, dUe(e, t)), {
        position: "relative",
        flex: "none",
        alignSelf: "stretch",
        width: r,
        margin: 0,
        lineHeight: `${r}px`,
        textAlign: "center",
        cursor: "pointer",
        userSelect: "none",
        "&-noop": {
          cursor: "default"
        },
        "&_close": {
          [`${n}-switcher-icon`]: {
            svg: {
              transform: "rotate(-90deg)"
            }
          }
        },
        "&-loading-icon": {
          color: t.colorPrimary
        },
        "&-leaf-line": {
          position: "relative",
          zIndex: 1,
          display: "inline-block",
          width: "100%",
          height: "100%",
          // https://github.com/ant-design/ant-design/issues/31884
          "&:before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: r / 2,
            bottom: -l,
            marginInlineStart: -1,
            borderInlineEnd: `1px solid ${t.colorBorder}`,
            content: '""'
          },
          "&:after": {
            position: "absolute",
            width: r / 2 * 0.8,
            height: r / 2,
            borderBottom: `1px solid ${t.colorBorder}`,
            content: '""'
          }
        }
      }),
      // >>> Checkbox
      [`${n}-checkbox`]: {
        top: "initial",
        marginInlineEnd: i,
        marginBlockStart: a
      },
      // >>> Title
      // add `${treeCls}-checkbox + span` to cover checkbox `${checkboxCls} + span`
      [`${n}-node-content-wrapper, ${n}-checkbox + span`]: {
        position: "relative",
        zIndex: "auto",
        minHeight: r,
        margin: 0,
        padding: `0 ${t.paddingXS / 2}px`,
        color: "inherit",
        lineHeight: `${r}px`,
        background: "transparent",
        borderRadius: t.borderRadius,
        cursor: "pointer",
        transition: `all ${t.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`,
        "&:hover": {
          backgroundColor: t.controlItemBgHover
        },
        [`&${n}-node-selected`]: {
          backgroundColor: t.controlItemBgActive
        },
        // Icon
        [`${n}-iconEle`]: {
          display: "inline-block",
          width: r,
          height: r,
          lineHeight: `${r}px`,
          textAlign: "center",
          verticalAlign: "top",
          "&:empty": {
            display: "none"
          }
        }
      },
      // https://github.com/ant-design/ant-design/issues/28217
      [`${n}-unselectable ${n}-node-content-wrapper:hover`]: {
        backgroundColor: "transparent"
      },
      // ==================== Draggable =====================
      [`${n}-node-content-wrapper`]: _({
        lineHeight: `${r}px`,
        userSelect: "none"
      }, fUe(e, t)),
      [`${o}.drop-container`]: {
        "> [draggable]": {
          boxShadow: `0 0 0 2px ${t.colorPrimary}`
        }
      },
      // ==================== Show Line =====================
      "&-show-line": {
        // ================ Indent lines ================
        [`${n}-indent`]: {
          "&-unit": {
            position: "relative",
            height: "100%",
            "&:before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: r / 2,
              bottom: -l,
              borderInlineEnd: `1px solid ${t.colorBorder}`,
              content: '""'
            },
            "&-end": {
              "&:before": {
                display: "none"
              }
            }
          }
        },
        // ============== Cover Background ==============
        [`${n}-switcher`]: {
          background: "transparent",
          "&-line-icon": {
            // https://github.com/ant-design/ant-design/issues/32813
            verticalAlign: "-0.15em"
          }
        }
      },
      [`${o}-leaf-last`]: {
        [`${n}-switcher`]: {
          "&-leaf-line": {
            "&:before": {
              top: "auto !important",
              bottom: "auto !important",
              height: `${r / 2}px !important`
            }
          }
        }
      }
    })
  };
}, vUe = (e) => {
  const {
    treeCls: t,
    treeNodeCls: n,
    treeNodePadding: o
  } = e;
  return {
    [`${t}${t}-directory`]: {
      // ================== TreeNode ==================
      [n]: {
        position: "relative",
        // Hover color
        "&:before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: o,
          insetInlineStart: 0,
          transition: `background-color ${e.motionDurationMid}`,
          content: '""',
          pointerEvents: "none"
        },
        "&:hover": {
          "&:before": {
            background: e.controlItemBgHover
          }
        },
        // Elements
        "> *": {
          zIndex: 1
        },
        // >>> Switcher
        [`${t}-switcher`]: {
          transition: `color ${e.motionDurationMid}`
        },
        // >>> Title
        [`${t}-node-content-wrapper`]: {
          borderRadius: 0,
          userSelect: "none",
          "&:hover": {
            background: "transparent"
          },
          [`&${t}-node-selected`]: {
            color: e.colorTextLightSolid,
            background: "transparent"
          }
        },
        // ============= Selected =============
        "&-selected": {
          "\n            &:hover::before,\n            &::before\n          ": {
            background: e.colorPrimary
          },
          // >>> Switcher
          [`${t}-switcher`]: {
            color: e.colorTextLightSolid
          },
          // >>> Title
          [`${t}-node-content-wrapper`]: {
            color: e.colorTextLightSolid,
            background: "transparent"
          }
        }
      }
    }
  };
}, HG = (e, t) => {
  const n = `.${e}`, o = `${n}-treenode`, l = t.paddingXS / 2, r = t.controlHeightSM, a = Vt(t, {
    treeCls: n,
    treeNodeCls: o,
    treeNodePadding: l,
    treeTitleHeight: r
  });
  return [
    // Basic
    pUe(e, a),
    // Directory
    vUe(a)
  ];
}, mUe = Zt("Tree", (e, t) => {
  let {
    prefixCls: n
  } = t;
  return [{
    [e.componentCls]: KS(`${n}-checkbox`, e)
  }, HG(n, e), Ih(e)];
}), jG = () => {
  const e = SK();
  return _(_({}, e), {
    showLine: zt([Boolean, Object]),
    /**  */
    multiple: Qe(),
    /**  */
    autoExpandParent: Qe(),
    /** checkable*/
    checkStrictly: Qe(),
    /**  */
    checkable: Qe(),
    /**  */
    disabled: Qe(),
    /**  */
    defaultExpandAll: Qe(),
    /**  */
    defaultExpandParent: Qe(),
    /**  */
    defaultExpandedKeys: $n(),
    /**  */
    expandedKeys: $n(),
    /**  */
    checkedKeys: zt([Array, Object]),
    /**  */
    defaultCheckedKeys: $n(),
    /**  */
    selectedKeys: $n(),
    /**  */
    defaultSelectedKeys: $n(),
    selectable: Qe(),
    loadedKeys: $n(),
    draggable: Qe(),
    showIcon: Qe(),
    icon: Fe(),
    switcherIcon: de.any,
    prefixCls: String,
    /**
     * @default{title,key,children}
     * deprecated, please use `fieldNames` instead
     * treeNode title,key,childrentreeData
     */
    replaceFields: Nt(),
    blockNode: Qe(),
    openAnimation: de.any,
    onDoubleclick: e.onDblclick,
    "onUpdate:selectedKeys": Fe(),
    "onUpdate:checkedKeys": Fe(),
    "onUpdate:expandedKeys": Fe()
  });
}, Qb = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ATree",
  inheritAttrs: !1,
  props: sn(jG(), {
    checkable: !1,
    selectable: !0,
    showIcon: !1,
    blockNode: !1
  }),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      emit: l,
      slots: r
    } = t;
    bn(!(e.treeData === void 0 && r.default), "`children` of Tree is deprecated. Please use `treeData` instead.");
    const {
      prefixCls: a,
      direction: i,
      virtual: s
    } = bt("tree", e), [c, u] = mUe(a), d = /* @__PURE__ */ H();
    o({
      treeRef: d,
      onNodeExpand: function() {
        var h;
        (h = d.value) === null || h === void 0 || h.onNodeExpand(...arguments);
      },
      scrollTo: (h) => {
        var g;
        (g = d.value) === null || g === void 0 || g.scrollTo(h);
      },
      selectedKeys: O(() => {
        var h;
        return (h = d.value) === null || h === void 0 ? void 0 : h.selectedKeys;
      }),
      checkedKeys: O(() => {
        var h;
        return (h = d.value) === null || h === void 0 ? void 0 : h.checkedKeys;
      }),
      halfCheckedKeys: O(() => {
        var h;
        return (h = d.value) === null || h === void 0 ? void 0 : h.halfCheckedKeys;
      }),
      loadedKeys: O(() => {
        var h;
        return (h = d.value) === null || h === void 0 ? void 0 : h.loadedKeys;
      }),
      loadingKeys: O(() => {
        var h;
        return (h = d.value) === null || h === void 0 ? void 0 : h.loadingKeys;
      }),
      expandedKeys: O(() => {
        var h;
        return (h = d.value) === null || h === void 0 ? void 0 : h.expandedKeys;
      })
    }), Ot(() => {
      un(e.replaceFields === void 0, "Tree", "`replaceFields` is deprecated, please use fieldNames instead");
    });
    const p = (h, g) => {
      l("update:checkedKeys", h), l("check", h, g);
    }, m = (h, g) => {
      l("update:expandedKeys", h), l("expand", h, g);
    }, v = (h, g) => {
      l("update:selectedKeys", h), l("select", h, g);
    };
    return () => {
      const {
        showIcon: h,
        showLine: g,
        switcherIcon: y = r.switcherIcon,
        icon: b = r.icon,
        blockNode: C,
        checkable: w,
        selectable: x,
        fieldNames: E = e.replaceFields,
        motion: I = e.openAnimation,
        itemHeight: T = 28,
        onDoubleclick: P,
        onDblclick: k
      } = e, N = _(_(_({}, n), pn(e, ["onUpdate:checkedKeys", "onUpdate:expandedKeys", "onUpdate:selectedKeys", "onDoubleclick"])), {
        showLine: !!g,
        dropIndicatorRender: cUe,
        fieldNames: E,
        icon: b,
        itemHeight: T
      }), R = r.default ? mo(r.default()) : void 0;
      return c($(VG, Q(Q({}, N), {}, {
        virtual: s.value,
        motion: I,
        ref: d,
        prefixCls: a.value,
        class: ke({
          [`${a.value}-icon-hide`]: !h,
          [`${a.value}-block-node`]: C,
          [`${a.value}-unselectable`]: !x,
          [`${a.value}-rtl`]: i.value === "rtl"
        }, n.class, u.value),
        direction: i.value,
        checkable: w,
        selectable: x,
        switcherIcon: (z) => zG(a.value, y, z, r.leafIcon, g),
        onCheck: p,
        onExpand: m,
        onSelect: v,
        onDblclick: k || P,
        children: R
      }), _(_({}, r), {
        checkable: () => $("span", {
          class: `${a.value}-checkbox-inner`
        }, null)
      })));
    };
  }
});
var hUe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, name: "folder-open", theme: "outlined" };
function RR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      gUe(e, l, n[l]);
    });
  }
  return e;
}
function gUe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var IP = function(t, n) {
  var o = RR({}, t, n.attrs);
  return $(cn, RR({}, o, {
    icon: hUe
  }), null);
};
IP.displayName = "FolderOpenOutlined";
IP.inheritAttrs = !1;
var bUe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, name: "folder", theme: "outlined" };
function DR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      yUe(e, l, n[l]);
    });
  }
  return e;
}
function yUe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var TP = function(t, n) {
  var o = DR({}, t, n.attrs);
  return $(cn, DR({}, o, {
    icon: bUe
  }), null);
};
TP.displayName = "FolderOutlined";
TP.inheritAttrs = !1;
var Gi;
(function(e) {
  e[e.None = 0] = "None", e[e.Start = 1] = "Start", e[e.End = 2] = "End";
})(Gi || (Gi = {}));
function PP(e, t, n) {
  function o(l) {
    const r = l[t.key], a = l[t.children];
    n(r, l) !== !1 && PP(a || [], t, n);
  }
  e.forEach(o);
}
function SUe(e) {
  let {
    treeData: t,
    expandedKeys: n,
    startKey: o,
    endKey: l,
    fieldNames: r = {
      title: "title",
      key: "key",
      children: "children"
    }
  } = e;
  const a = [];
  let i = Gi.None;
  if (o && o === l)
    return [o];
  if (!o || !l)
    return [];
  function s(c) {
    return c === o || c === l;
  }
  return PP(t, r, (c) => {
    if (i === Gi.End)
      return !1;
    if (s(c)) {
      if (a.push(c), i === Gi.None)
        i = Gi.Start;
      else if (i === Gi.Start)
        return i = Gi.End, !1;
    } else i === Gi.Start && a.push(c);
    return n.includes(c);
  }), a;
}
function a$(e, t, n) {
  const o = [...t], l = [];
  return PP(e, n, (r, a) => {
    const i = o.indexOf(r);
    return i !== -1 && (l.push(a), o.splice(i, 1)), !!o.length;
  }), l;
}
var CUe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const wUe = () => _(_({}, jG()), {
  expandAction: zt([Boolean, String])
});
function $Ue(e) {
  const {
    isLeaf: t,
    expanded: n
  } = e;
  return $(t ? oC : n ? IP : TP, null, null);
}
const e0 = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ADirectoryTree",
  inheritAttrs: !1,
  props: sn(wUe(), {
    showIcon: !0,
    expandAction: "click"
  }),
  slots: Object,
  // emits: [
  //   'update:selectedKeys',
  //   'update:checkedKeys',
  //   'update:expandedKeys',
  //   'expand',
  //   'select',
  //   'check',
  //   'doubleclick',
  //   'dblclick',
  //   'click',
  // ],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: l,
      expose: r
    } = t;
    var a;
    const i = /* @__PURE__ */ H(e.treeData || j2(mo((a = o.default) === null || a === void 0 ? void 0 : a.call(o))));
    pe(() => e.treeData, () => {
      i.value = e.treeData;
    }), $o(() => {
      Ke(() => {
        var T;
        e.treeData === void 0 && o.default && (i.value = j2(mo((T = o.default) === null || T === void 0 ? void 0 : T.call(o))));
      });
    });
    const s = /* @__PURE__ */ H(), c = /* @__PURE__ */ H(), u = O(() => LS(e.fieldNames)), d = /* @__PURE__ */ H();
    r({
      scrollTo: (T) => {
        var P;
        (P = d.value) === null || P === void 0 || P.scrollTo(T);
      },
      selectedKeys: O(() => {
        var T;
        return (T = d.value) === null || T === void 0 ? void 0 : T.selectedKeys;
      }),
      checkedKeys: O(() => {
        var T;
        return (T = d.value) === null || T === void 0 ? void 0 : T.checkedKeys;
      }),
      halfCheckedKeys: O(() => {
        var T;
        return (T = d.value) === null || T === void 0 ? void 0 : T.halfCheckedKeys;
      }),
      loadedKeys: O(() => {
        var T;
        return (T = d.value) === null || T === void 0 ? void 0 : T.loadedKeys;
      }),
      loadingKeys: O(() => {
        var T;
        return (T = d.value) === null || T === void 0 ? void 0 : T.loadingKeys;
      }),
      expandedKeys: O(() => {
        var T;
        return (T = d.value) === null || T === void 0 ? void 0 : T.expandedKeys;
      })
    });
    const p = () => {
      const {
        keyEntities: T
      } = Lh(i.value, {
        fieldNames: u.value
      });
      let P;
      return e.defaultExpandAll ? P = Object.keys(T) : e.defaultExpandParent ? P = H2(e.expandedKeys || e.defaultExpandedKeys || [], T) : P = e.expandedKeys || e.defaultExpandedKeys, P;
    }, m = /* @__PURE__ */ H(e.selectedKeys || e.defaultSelectedKeys || []), v = /* @__PURE__ */ H(p());
    pe(() => e.selectedKeys, () => {
      e.selectedKeys !== void 0 && (m.value = e.selectedKeys);
    }, {
      immediate: !0
    }), pe(() => e.expandedKeys, () => {
      e.expandedKeys !== void 0 && (v.value = e.expandedKeys);
    }, {
      immediate: !0
    });
    const g = Dr((T, P) => {
      const {
        isLeaf: k
      } = P;
      k || T.shiftKey || T.metaKey || T.ctrlKey || d.value.onNodeExpand(T, P);
    }, 200, {
      leading: !0
    }), y = (T, P) => {
      e.expandedKeys === void 0 && (v.value = T), l("update:expandedKeys", T), l("expand", T, P);
    }, b = (T, P) => {
      const {
        expandAction: k
      } = e;
      k === "click" && g(T, P), l("click", T, P);
    }, C = (T, P) => {
      const {
        expandAction: k
      } = e;
      (k === "dblclick" || k === "doubleclick") && g(T, P), l("doubleclick", T, P), l("dblclick", T, P);
    }, w = (T, P) => {
      const {
        multiple: k
      } = e, {
        node: N,
        nativeEvent: R
      } = P, z = N[u.value.key], D = _(_({}, P), {
        selected: !0
      }), F = (R == null ? void 0 : R.ctrlKey) || (R == null ? void 0 : R.metaKey), M = R == null ? void 0 : R.shiftKey;
      let A;
      k && F ? (A = T, s.value = z, c.value = A, D.selectedNodes = a$(i.value, A, u.value)) : k && M ? (A = Array.from(/* @__PURE__ */ new Set([...c.value || [], ...SUe({
        treeData: i.value,
        expandedKeys: v.value,
        startKey: z,
        endKey: s.value,
        fieldNames: u.value
      })])), D.selectedNodes = a$(i.value, A, u.value)) : (A = [z], s.value = z, c.value = A, D.selectedNodes = a$(i.value, A, u.value)), l("update:selectedKeys", A), l("select", A, D), e.selectedKeys === void 0 && (m.value = A);
    }, x = (T, P) => {
      l("update:checkedKeys", T), l("check", T, P);
    }, {
      prefixCls: E,
      direction: I
    } = bt("tree", e);
    return () => {
      const T = ke(`${E.value}-directory`, {
        [`${E.value}-directory-rtl`]: I.value === "rtl"
      }, n.class), {
        icon: P = o.icon,
        blockNode: k = !0
      } = e, N = CUe(e, ["icon", "blockNode"]);
      return $(Qb, Q(Q(Q({}, n), {}, {
        icon: P || $Ue,
        ref: d,
        blockNode: k
      }, N), {}, {
        prefixCls: E.value,
        class: T,
        expandedKeys: v.value,
        selectedKeys: m.value,
        onSelect: w,
        onClick: b,
        onDblclick: C,
        onExpand: y,
        onCheck: x
      }), o);
    };
  }
}), t0 = z2, WG = _(Qb, {
  DirectoryTree: e0,
  TreeNode: t0,
  install: (e) => (e.component(Qb.name, Qb), e.component(t0.name, t0), e.component(e0.name, e0), e)
});
function LR(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  const o = /* @__PURE__ */ new Set();
  function l(r, a) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const s = o.has(r);
    if (pr(!s, "Warning: There may be circular references"), s)
      return !1;
    if (r === a)
      return !0;
    if (n && i > 1)
      return !1;
    o.add(r);
    const c = i + 1;
    if (Array.isArray(r)) {
      if (!Array.isArray(a) || r.length !== a.length)
        return !1;
      for (let u = 0; u < r.length; u++)
        if (!l(r[u], a[u], c))
          return !1;
      return !0;
    }
    if (r && a && typeof r == "object" && typeof a == "object") {
      const u = Object.keys(r);
      return u.length !== Object.keys(a).length ? !1 : u.every((d) => l(r[d], a[d], c));
    }
    return !1;
  }
  return l(e, t);
}
const {
  SubMenu: xUe,
  Item: EUe
} = Do;
function OUe(e) {
  return e.some((t) => {
    let {
      children: n
    } = t;
    return n && n.length > 0;
  });
}
function KG(e, t) {
  return typeof t == "string" || typeof t == "number" ? t == null ? void 0 : t.toString().toLowerCase().includes(e.trim().toLowerCase()) : !1;
}
function UG(e) {
  let {
    filters: t,
    prefixCls: n,
    filteredKeys: o,
    filterMultiple: l,
    searchValue: r,
    filterSearch: a
  } = e;
  return t.map((i, s) => {
    const c = String(i.value);
    if (i.children)
      return $(xUe, {
        key: c || s,
        title: i.text,
        popupClassName: `${n}-dropdown-submenu`
      }, {
        default: () => [UG({
          filters: i.children,
          prefixCls: n,
          filteredKeys: o,
          filterMultiple: l,
          searchValue: r,
          filterSearch: a
        })]
      });
    const u = l ? la : Jl, d = $(EUe, {
      key: i.value !== void 0 ? c : s
    }, {
      default: () => [$(u, {
        checked: o.includes(c)
      }, null), $("span", null, [i.text])]
    });
    return r.trim() ? typeof a == "function" ? a(r, i) ? d : void 0 : KG(r, i.text) ? d : void 0 : d;
  });
}
const _Ue = /* @__PURE__ */ le({
  name: "FilterDropdown",
  props: ["tablePrefixCls", "prefixCls", "dropdownPrefixCls", "column", "filterState", "filterMultiple", "filterMode", "filterSearch", "columnKey", "triggerFilter", "locale", "getPopupContainer"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = yP(), l = O(() => {
      var j;
      return (j = e.filterMode) !== null && j !== void 0 ? j : "menu";
    }), r = O(() => {
      var j;
      return (j = e.filterSearch) !== null && j !== void 0 ? j : !1;
    }), a = O(() => e.column.filterDropdownOpen || e.column.filterDropdownVisible), i = O(() => e.column.onFilterDropdownOpenChange || e.column.onFilterDropdownVisibleChange);
    process.env.NODE_ENV !== "production" && [["filterDropdownVisible", "filterDropdownOpen", e.column.filterDropdownVisible], ["onFilterDropdownVisibleChange", "onFilterDropdownOpenChange", e.column.onFilterDropdownVisibleChange]].forEach((j) => {
      let [W, Y, U] = j;
      un(U == null, "Table", `\`${W}\` is deprecated. Please use \`${Y}\` instead.`);
    });
    const s = /* @__PURE__ */ Ce(!1), c = O(() => {
      var j;
      return !!(e.filterState && (!((j = e.filterState.filteredKeys) === null || j === void 0) && j.length || e.filterState.forceFiltered));
    }), u = O(() => {
      var j;
      return lC((j = e.column) === null || j === void 0 ? void 0 : j.filters);
    }), d = O(() => {
      const {
        filterDropdown: j,
        slots: W = {},
        customFilterDropdown: Y
      } = e.column;
      return j || W.filterDropdown && o.value[W.filterDropdown] || Y && o.value.customFilterDropdown;
    }), f = O(() => {
      const {
        filterIcon: j,
        slots: W = {}
      } = e.column;
      return j || W.filterIcon && o.value[W.filterIcon] || o.value.customFilterIcon;
    }), p = (j) => {
      var W;
      s.value = j, (W = i.value) === null || W === void 0 || W.call(i, j);
    }, m = O(() => typeof a.value == "boolean" ? a.value : s.value), v = O(() => {
      var j;
      return (j = e.filterState) === null || j === void 0 ? void 0 : j.filteredKeys;
    }), h = /* @__PURE__ */ Ce([]), g = (j) => {
      let {
        selectedKeys: W
      } = j;
      h.value = W;
    }, y = (j, W) => {
      let {
        node: Y,
        checked: U
      } = W;
      e.filterMultiple ? g({
        selectedKeys: j
      }) : g({
        selectedKeys: U && Y.key ? [Y.key] : []
      });
    };
    pe(v, () => {
      s.value && g({
        selectedKeys: v.value || []
      });
    }, {
      immediate: !0
    });
    const b = /* @__PURE__ */ Ce([]), C = /* @__PURE__ */ Ce(), w = (j) => {
      C.value = setTimeout(() => {
        b.value = j;
      });
    }, x = () => {
      clearTimeout(C.value);
    };
    yt(() => {
      clearTimeout(C.value);
    });
    const E = /* @__PURE__ */ Ce(""), I = (j) => {
      const {
        value: W
      } = j.target;
      E.value = W;
    };
    pe(s, () => {
      s.value || (E.value = "");
    });
    const T = (j) => {
      const {
        column: W,
        columnKey: Y,
        filterState: U
      } = e, te = j && j.length ? j : null;
      if (te === null && (!U || !U.filteredKeys) || LR(te, U == null ? void 0 : U.filteredKeys, !0))
        return null;
      e.triggerFilter({
        column: W,
        key: Y,
        filteredKeys: te
      });
    }, P = () => {
      p(!1), T(h.value);
    }, k = function() {
      let {
        confirm: j,
        closeDropdown: W
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        confirm: !1,
        closeDropdown: !1
      };
      j && T([]), W && p(!1), E.value = "", e.column.filterResetToDefaultFilteredValue ? h.value = (e.column.defaultFilteredValue || []).map((Y) => String(Y)) : h.value = [];
    }, N = function() {
      let {
        closeDropdown: j
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        closeDropdown: !0
      };
      j && p(!1), T(h.value);
    }, R = (j) => {
      j && v.value !== void 0 && (h.value = v.value || []), p(j), !j && !d.value && P();
    }, {
      direction: z
    } = bt("", e), D = (j) => {
      if (j.target.checked) {
        const W = u.value;
        h.value = W;
      } else
        h.value = [];
    }, F = (j) => {
      let {
        filters: W
      } = j;
      return (W || []).map((Y, U) => {
        const te = String(Y.value), J = {
          title: Y.text,
          key: Y.value !== void 0 ? te : U
        };
        return Y.children && (J.children = F({
          filters: Y.children
        })), J;
      });
    }, M = (j) => {
      var W;
      return _(_({}, j), {
        text: j.title,
        value: j.key,
        children: ((W = j.children) === null || W === void 0 ? void 0 : W.map((Y) => M(Y))) || []
      });
    }, A = O(() => F({
      filters: e.column.filters
    })), L = O(() => ke({
      [`${e.dropdownPrefixCls}-menu-without-submenu`]: !OUe(e.column.filters || [])
    })), B = () => {
      const j = h.value, {
        column: W,
        locale: Y,
        tablePrefixCls: U,
        filterMultiple: te,
        dropdownPrefixCls: J,
        getPopupContainer: re,
        prefixCls: oe
      } = e;
      return (W.filters || []).length === 0 ? $(qs, {
        image: qs.PRESENTED_IMAGE_SIMPLE,
        description: Y.filterEmptyText,
        imageStyle: {
          height: 24
        },
        style: {
          margin: 0,
          padding: "16px 0"
        }
      }, null) : l.value === "tree" ? $(Ge, null, [$(wR, {
        filterSearch: r.value,
        value: E.value,
        onChange: I,
        tablePrefixCls: U,
        locale: Y
      }, null), $("div", {
        class: `${U}-filter-dropdown-tree`
      }, [te ? $(la, {
        class: `${U}-filter-dropdown-checkall`,
        onChange: D,
        checked: j.length === u.value.length,
        indeterminate: j.length > 0 && j.length < u.value.length
      }, {
        default: () => [Y.filterCheckall]
      }) : null, $(WG, {
        checkable: !0,
        selectable: !1,
        blockNode: !0,
        multiple: te,
        checkStrictly: !te,
        class: `${J}-menu`,
        onCheck: y,
        checkedKeys: j,
        selectedKeys: j,
        showIcon: !1,
        treeData: A.value,
        autoExpandParent: !0,
        defaultExpandAll: !0,
        filterTreeNode: E.value.trim() ? (q) => typeof r.value == "function" ? r.value(E.value, M(q)) : KG(E.value, q.title) : void 0
      }, null)])]) : $(Ge, null, [$(wR, {
        filterSearch: r.value,
        value: E.value,
        onChange: I,
        tablePrefixCls: U,
        locale: Y
      }, null), $(Do, {
        multiple: te,
        prefixCls: `${J}-menu`,
        class: L.value,
        onClick: x,
        onSelect: g,
        onDeselect: g,
        selectedKeys: j,
        getPopupContainer: re,
        openKeys: b.value,
        onOpenChange: w
      }, {
        default: () => UG({
          filters: W.filters || [],
          filterSearch: r.value,
          prefixCls: oe,
          filteredKeys: h.value,
          filterMultiple: te,
          searchValue: E.value
        })
      })]);
    }, V = O(() => {
      const j = h.value;
      return e.column.filterResetToDefaultFilteredValue ? LR((e.column.defaultFilteredValue || []).map((W) => String(W)), j, !0) : j.length === 0;
    });
    return () => {
      var j;
      const {
        tablePrefixCls: W,
        prefixCls: Y,
        column: U,
        dropdownPrefixCls: te,
        locale: J,
        getPopupContainer: re
      } = e;
      let oe;
      typeof d.value == "function" ? oe = d.value({
        prefixCls: `${te}-custom`,
        setSelectedKeys: (se) => g({
          selectedKeys: se
        }),
        selectedKeys: h.value,
        confirm: N,
        clearFilters: k,
        filters: U.filters,
        visible: m.value,
        column: U.__originColumn__,
        close: () => {
          p(!1);
        }
      }) : d.value ? oe = d.value : oe = $(Ge, null, [B(), $("div", {
        class: `${Y}-dropdown-btns`
      }, [$(ko, {
        type: "link",
        size: "small",
        disabled: V.value,
        onClick: () => k()
      }, {
        default: () => [J.filterReset]
      }), $(ko, {
        type: "primary",
        size: "small",
        onClick: P
      }, {
        default: () => [J.filterConfirm]
      })])]);
      const q = $(GKe, {
        class: `${Y}-dropdown`
      }, {
        default: () => [oe]
      });
      let K;
      return typeof f.value == "function" ? K = f.value({
        filtered: c.value,
        column: U.__originColumn__
      }) : f.value ? K = f.value : K = $(xP, null, null), $("div", {
        class: `${Y}-column`
      }, [$("span", {
        class: `${W}-column-title`
      }, [(j = n.default) === null || j === void 0 ? void 0 : j.call(n)]), $(Ia, {
        overlay: q,
        trigger: ["click"],
        open: m.value,
        onOpenChange: R,
        getPopupContainer: re,
        placement: z.value === "rtl" ? "bottomLeft" : "bottomRight"
      }, {
        default: () => [$("span", {
          role: "button",
          tabindex: -1,
          class: ke(`${Y}-trigger`, {
            active: c.value
          }),
          onClick: (se) => {
            se.stopPropagation();
          }
        }, [K])]
      })]);
    };
  }
});
function vE(e, t, n) {
  let o = [];
  return (e || []).forEach((l, r) => {
    var a, i;
    const s = zh(r, n), c = l.filterDropdown || ((a = l == null ? void 0 : l.slots) === null || a === void 0 ? void 0 : a.filterDropdown) || l.customFilterDropdown;
    if (l.filters || c || "onFilter" in l)
      if ("filteredValue" in l) {
        let u = l.filteredValue;
        c || (u = (i = u == null ? void 0 : u.map(String)) !== null && i !== void 0 ? i : u), o.push({
          column: l,
          key: ed(l, s),
          filteredKeys: u,
          forceFiltered: l.filtered
        });
      } else
        o.push({
          column: l,
          key: ed(l, s),
          filteredKeys: t && l.defaultFilteredValue ? l.defaultFilteredValue : void 0,
          forceFiltered: l.filtered
        });
    "children" in l && (o = [...o, ...vE(l.children, t, s)]);
  }), o;
}
function GG(e, t, n, o, l, r, a, i) {
  return n.map((s, c) => {
    var u;
    const d = zh(c, i), {
      filterMultiple: f = !0,
      filterMode: p,
      filterSearch: m
    } = s;
    let v = s;
    const h = s.filterDropdown || ((u = s == null ? void 0 : s.slots) === null || u === void 0 ? void 0 : u.filterDropdown) || s.customFilterDropdown;
    if (v.filters || h) {
      const g = ed(v, d), y = o.find((b) => {
        let {
          key: C
        } = b;
        return g === C;
      });
      v = _(_({}, v), {
        title: (b) => $(_Ue, {
          tablePrefixCls: e,
          prefixCls: `${e}-filter`,
          dropdownPrefixCls: t,
          column: v,
          columnKey: g,
          filterState: y,
          filterMultiple: f,
          filterMode: p,
          filterSearch: m,
          triggerFilter: r,
          locale: l,
          getPopupContainer: a
        }, {
          default: () => [$P(s.title, b)]
        })
      });
    }
    return "children" in v && (v = _(_({}, v), {
      children: GG(e, t, v.children, o, l, r, a, d)
    })), v;
  });
}
function lC(e) {
  let t = [];
  return (e || []).forEach((n) => {
    let {
      value: o,
      children: l
    } = n;
    t.push(o), l && (t = [...t, ...lC(l)]);
  }), t;
}
function BR(e) {
  const t = {};
  return e.forEach((n) => {
    let {
      key: o,
      filteredKeys: l,
      column: r
    } = n;
    var a;
    const i = r.filterDropdown || ((a = r == null ? void 0 : r.slots) === null || a === void 0 ? void 0 : a.filterDropdown) || r.customFilterDropdown, {
      filters: s
    } = r;
    if (i)
      t[o] = l || null;
    else if (Array.isArray(l)) {
      const c = lC(s);
      t[o] = c.filter((u) => l.includes(String(u)));
    } else
      t[o] = null;
  }), t;
}
function FR(e, t) {
  return t.reduce((n, o) => {
    const {
      column: {
        onFilter: l,
        filters: r
      },
      filteredKeys: a
    } = o;
    return l && a && a.length ? n.filter((i) => a.some((s) => {
      const c = lC(r), u = c.findIndex((f) => String(f) === String(s)), d = u !== -1 ? c[u] : s;
      return l(d, i);
    })) : n;
  }, e);
}
function YG(e) {
  return e.flatMap((t) => "children" in t ? [t, ...YG(t.children || [])] : [t]);
}
function IUe(e) {
  let {
    prefixCls: t,
    dropdownPrefixCls: n,
    mergedColumns: o,
    locale: l,
    onFilterChange: r,
    getPopupContainer: a
  } = e;
  const i = O(() => YG(o.value)), [s, c] = Bn(vE(i.value, !0)), u = O(() => {
    const m = vE(i.value, !1);
    if (m.length === 0)
      return m;
    let v = !0, h = !0;
    if (m.forEach((g) => {
      let {
        filteredKeys: y
      } = g;
      y !== void 0 ? v = !1 : h = !1;
    }), v) {
      const g = (i.value || []).map((y, b) => ed(y, zh(b)));
      return s.value.filter((y) => {
        let {
          key: b
        } = y;
        return g.includes(b);
      }).map((y) => {
        const b = i.value[g.findIndex((C) => C === y.key)];
        return _(_({}, y), {
          column: _(_({}, y.column), b),
          forceFiltered: b.filtered
        });
      });
    }
    return un(h, "Table", "Columns should all contain `filteredValue` or not contain `filteredValue`."), m;
  }), d = O(() => BR(u.value)), f = (m) => {
    const v = u.value.filter((h) => {
      let {
        key: g
      } = h;
      return g !== m.key;
    });
    v.push(m), c(v), r(BR(v), v);
  };
  return [(m) => GG(t.value, n.value, m, u.value, l.value, f, a.value), u, d];
}
function XG(e, t) {
  return e.map((n) => {
    const o = _({}, n);
    return o.title = $P(o.title, t), "children" in o && (o.children = XG(o.children, t)), o;
  });
}
function TUe(e) {
  return [(n) => XG(n, e.value)];
}
function PUe(e) {
  return function(n) {
    let {
      prefixCls: o,
      onExpand: l,
      record: r,
      expanded: a,
      expandable: i
    } = n;
    const s = `${o}-row-expand-icon`;
    return $("button", {
      type: "button",
      onClick: (c) => {
        l(r, c), c.stopPropagation();
      },
      class: ke(s, {
        [`${s}-spaced`]: !i,
        [`${s}-expanded`]: i && a,
        [`${s}-collapsed`]: i && !a
      }),
      "aria-label": a ? e.collapse : e.expand,
      "aria-expanded": a
    }, null);
  };
}
function qG(e, t) {
  const n = t.value;
  return e.map((o) => {
    var l;
    if (o === ha || o === ai) return o;
    const r = _({}, o), {
      slots: a = {}
    } = r;
    return r.__originColumn__ = o, un(!("slots" in r), "Table", "`column.slots` is deprecated. Please use `v-slot:headerCell` `v-slot:bodyCell` instead."), Object.keys(a).forEach((i) => {
      const s = a[i];
      r[i] === void 0 && n[s] && (r[i] = n[s]);
    }), t.value.headerCell && !(!((l = o.slots) === null || l === void 0) && l.title) && (r.title = fS(t.value, "headerCell", {
      title: o.title,
      column: o
    }, () => [o.title])), "children" in r && Array.isArray(r.children) && (r.children = qG(r.children, t)), r;
  });
}
function kUe(e) {
  return [(n) => qG(n, e)];
}
const NUe = (e) => {
  const {
    componentCls: t
  } = e, n = `${e.lineWidth}px ${e.lineType} ${e.tableBorderColor}`, o = (l, r, a) => ({
    [`&${t}-${l}`]: {
      [`> ${t}-container`]: {
        [`> ${t}-content, > ${t}-body`]: {
          "> table > tbody > tr > td": {
            [`> ${t}-expanded-row-fixed`]: {
              margin: `-${r}px -${a + e.lineWidth}px`
            }
          }
        }
      }
    }
  });
  return {
    [`${t}-wrapper`]: {
      [`${t}${t}-bordered`]: _(_(_({
        // ============================ Title =============================
        [`> ${t}-title`]: {
          border: n,
          borderBottom: 0
        },
        // ============================ Content ============================
        [`> ${t}-container`]: {
          borderInlineStart: n,
          [`
            > ${t}-content,
            > ${t}-header,
            > ${t}-body,
            > ${t}-summary
          `]: {
            "> table": {
              // ============================= Cell =============================
              "\n                > thead > tr > th,\n                > tbody > tr > td,\n                > tfoot > tr > th,\n                > tfoot > tr > td\n              ": {
                borderInlineEnd: n
              },
              // ============================ Header ============================
              "> thead": {
                "> tr:not(:last-child) > th": {
                  borderBottom: n
                },
                "> tr > th::before": {
                  backgroundColor: "transparent !important"
                }
              },
              // Fixed right should provides additional border
              "\n                > thead > tr,\n                > tbody > tr,\n                > tfoot > tr\n              ": {
                [`> ${t}-cell-fix-right-first::after`]: {
                  borderInlineEnd: n
                }
              },
              // ========================== Expandable ==========================
              "> tbody > tr > td": {
                [`> ${t}-expanded-row-fixed`]: {
                  margin: `-${e.tablePaddingVertical}px -${e.tablePaddingHorizontal + e.lineWidth}px`,
                  "&::after": {
                    position: "absolute",
                    top: 0,
                    insetInlineEnd: e.lineWidth,
                    bottom: 0,
                    borderInlineEnd: n,
                    content: '""'
                  }
                }
              }
            }
          },
          [`
            > ${t}-content,
            > ${t}-header
          `]: {
            "> table": {
              borderTop: n
            }
          }
        },
        // ============================ Scroll ============================
        [`&${t}-scroll-horizontal`]: {
          [`> ${t}-container > ${t}-body`]: {
            "> table > tbody": {
              [`
                > tr${t}-expanded-row,
                > tr${t}-placeholder
              `]: {
                "> td": {
                  borderInlineEnd: 0
                }
              }
            }
          }
        }
      }, o("middle", e.tablePaddingVerticalMiddle, e.tablePaddingHorizontalMiddle)), o("small", e.tablePaddingVerticalSmall, e.tablePaddingHorizontalSmall)), {
        // ============================ Footer ============================
        [`> ${t}-footer`]: {
          border: n,
          borderTop: 0
        }
      }),
      // ============================ Nested ============================
      [`${t}-cell`]: {
        [`${t}-container:first-child`]: {
          // :first-child to avoid the case when bordered and title is set
          borderTop: 0
        },
        // https://github.com/ant-design/ant-design/issues/35577
        "&-scrollbar:not([rowspan])": {
          boxShadow: `0 ${e.lineWidth}px 0 ${e.lineWidth}px ${e.tableHeaderBg}`
        }
      }
    }
  };
}, MUe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-wrapper`]: {
      [`${t}-cell-ellipsis`]: _(_({}, Fo), {
        wordBreak: "keep-all",
        // Fixed first or last should special process
        [`
          &${t}-cell-fix-left-last,
          &${t}-cell-fix-right-first
        `]: {
          overflow: "visible",
          [`${t}-cell-content`]: {
            display: "block",
            overflow: "hidden",
            textOverflow: "ellipsis"
          }
        },
        [`${t}-column-title`]: {
          overflow: "hidden",
          textOverflow: "ellipsis",
          wordBreak: "keep-all"
        }
      })
    }
  };
}, AUe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-wrapper`]: {
      [`${t}-tbody > tr${t}-placeholder`]: {
        textAlign: "center",
        color: e.colorTextDisabled,
        "&:hover > td": {
          background: e.colorBgContainer
        }
      }
    }
  };
}, RUe = (e) => {
  const {
    componentCls: t,
    antCls: n,
    controlInteractiveSize: o,
    motionDurationSlow: l,
    lineWidth: r,
    paddingXS: a,
    lineType: i,
    tableBorderColor: s,
    tableExpandIconBg: c,
    tableExpandColumnWidth: u,
    borderRadius: d,
    fontSize: f,
    fontSizeSM: p,
    lineHeight: m,
    tablePaddingVertical: v,
    tablePaddingHorizontal: h,
    tableExpandedRowBg: g,
    paddingXXS: y
  } = e, b = o / 2 - r, C = b * 2 + r * 3, w = `${r}px ${i} ${s}`, x = y - r;
  return {
    [`${t}-wrapper`]: {
      [`${t}-expand-icon-col`]: {
        width: u
      },
      [`${t}-row-expand-icon-cell`]: {
        textAlign: "center",
        [`${t}-row-expand-icon`]: {
          display: "inline-flex",
          float: "none",
          verticalAlign: "sub"
        }
      },
      [`${t}-row-indent`]: {
        height: 1,
        float: "left"
      },
      [`${t}-row-expand-icon`]: _(_({}, cS(e)), {
        position: "relative",
        float: "left",
        boxSizing: "border-box",
        width: C,
        height: C,
        padding: 0,
        color: "inherit",
        lineHeight: `${C}px`,
        background: c,
        border: w,
        borderRadius: d,
        transform: `scale(${o / C})`,
        transition: `all ${l}`,
        userSelect: "none",
        "&:focus, &:hover, &:active": {
          borderColor: "currentcolor"
        },
        "&::before, &::after": {
          position: "absolute",
          background: "currentcolor",
          transition: `transform ${l} ease-out`,
          content: '""'
        },
        "&::before": {
          top: b,
          insetInlineEnd: x,
          insetInlineStart: x,
          height: r
        },
        "&::after": {
          top: x,
          bottom: x,
          insetInlineStart: b,
          width: r,
          transform: "rotate(90deg)"
        },
        // Motion effect
        "&-collapsed::before": {
          transform: "rotate(-180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        },
        "&-spaced": {
          "&::before, &::after": {
            display: "none",
            content: "none"
          },
          background: "transparent",
          border: 0,
          visibility: "hidden"
        }
      }),
      [`${t}-row-indent + ${t}-row-expand-icon`]: {
        marginTop: (f * m - r * 3) / 2 - Math.ceil((p * 1.4 - r * 3) / 2),
        marginInlineEnd: a
      },
      [`tr${t}-expanded-row`]: {
        "&, &:hover": {
          "> td": {
            background: g
          }
        },
        // https://github.com/ant-design/ant-design/issues/25573
        [`${n}-descriptions-view`]: {
          display: "flex",
          table: {
            flex: "auto",
            width: "auto"
          }
        }
      },
      // With fixed
      [`${t}-expanded-row-fixed`]: {
        position: "relative",
        margin: `-${v}px -${h}px`,
        padding: `${v}px ${h}px`
      }
    }
  };
}, DUe = (e) => {
  const {
    componentCls: t,
    antCls: n,
    iconCls: o,
    tableFilterDropdownWidth: l,
    tableFilterDropdownSearchWidth: r,
    paddingXXS: a,
    paddingXS: i,
    colorText: s,
    lineWidth: c,
    lineType: u,
    tableBorderColor: d,
    tableHeaderIconColor: f,
    fontSizeSM: p,
    tablePaddingHorizontal: m,
    borderRadius: v,
    motionDurationSlow: h,
    colorTextDescription: g,
    colorPrimary: y,
    tableHeaderFilterActiveBg: b,
    colorTextDisabled: C,
    tableFilterDropdownBg: w,
    tableFilterDropdownHeight: x,
    controlItemBgHover: E,
    controlItemBgActive: I,
    boxShadowSecondary: T
  } = e, P = `${n}-dropdown`, k = `${t}-filter-dropdown`, N = `${n}-tree`, R = `${c}px ${u} ${d}`;
  return [
    {
      [`${t}-wrapper`]: {
        [`${t}-filter-column`]: {
          display: "flex",
          justifyContent: "space-between"
        },
        [`${t}-filter-trigger`]: {
          position: "relative",
          display: "flex",
          alignItems: "center",
          marginBlock: -a,
          marginInline: `${a}px ${-m / 2}px`,
          padding: `0 ${a}px`,
          color: f,
          fontSize: p,
          borderRadius: v,
          cursor: "pointer",
          transition: `all ${h}`,
          "&:hover": {
            color: g,
            background: b
          },
          "&.active": {
            color: y
          }
        }
      }
    },
    {
      // Dropdown
      [`${n}-dropdown`]: {
        [k]: _(_({}, nn(e)), {
          minWidth: l,
          backgroundColor: w,
          borderRadius: v,
          boxShadow: T,
          // Reset menu
          [`${P}-menu`]: {
            // https://github.com/ant-design/ant-design/issues/4916
            // https://github.com/ant-design/ant-design/issues/19542
            maxHeight: x,
            overflowX: "hidden",
            border: 0,
            boxShadow: "none",
            "&:empty::after": {
              display: "block",
              padding: `${i}px 0`,
              color: C,
              fontSize: p,
              textAlign: "center",
              content: '"Not Found"'
            }
          },
          [`${k}-tree`]: {
            paddingBlock: `${i}px 0`,
            paddingInline: i,
            [N]: {
              padding: 0
            },
            [`${N}-treenode ${N}-node-content-wrapper:hover`]: {
              backgroundColor: E
            },
            [`${N}-treenode-checkbox-checked ${N}-node-content-wrapper`]: {
              "&, &:hover": {
                backgroundColor: I
              }
            }
          },
          [`${k}-search`]: {
            padding: i,
            borderBottom: R,
            "&-input": {
              input: {
                minWidth: r
              },
              [o]: {
                color: C
              }
            }
          },
          [`${k}-checkall`]: {
            width: "100%",
            marginBottom: a,
            marginInlineStart: a
          },
          // Operation
          [`${k}-btns`]: {
            display: "flex",
            justifyContent: "space-between",
            padding: `${i - c}px ${i}px`,
            overflow: "hidden",
            backgroundColor: "inherit",
            borderTop: R
          }
        })
      }
    },
    // Dropdown Menu & SubMenu
    {
      // submenu of table filter dropdown
      [`${n}-dropdown ${k}, ${k}-submenu`]: {
        // Checkbox
        [`${n}-checkbox-wrapper + span`]: {
          paddingInlineStart: i,
          color: s
        },
        "> ul": {
          maxHeight: "calc(100vh - 130px)",
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    }
  ];
}, LUe = (e) => {
  const {
    componentCls: t,
    lineWidth: n,
    colorSplit: o,
    motionDurationSlow: l,
    zIndexTableFixed: r,
    tableBg: a,
    zIndexTableSticky: i
  } = e, s = o;
  return {
    [`${t}-wrapper`]: {
      [`
        ${t}-cell-fix-left,
        ${t}-cell-fix-right
      `]: {
        position: "sticky !important",
        zIndex: r,
        background: a
      },
      [`
        ${t}-cell-fix-left-first::after,
        ${t}-cell-fix-left-last::after
      `]: {
        position: "absolute",
        top: 0,
        right: {
          _skip_check_: !0,
          value: 0
        },
        bottom: -n,
        width: 30,
        transform: "translateX(100%)",
        transition: `box-shadow ${l}`,
        content: '""',
        pointerEvents: "none"
      },
      [`${t}-cell-fix-left-all::after`]: {
        display: "none"
      },
      [`
        ${t}-cell-fix-right-first::after,
        ${t}-cell-fix-right-last::after
      `]: {
        position: "absolute",
        top: 0,
        bottom: -n,
        left: {
          _skip_check_: !0,
          value: 0
        },
        width: 30,
        transform: "translateX(-100%)",
        transition: `box-shadow ${l}`,
        content: '""',
        pointerEvents: "none"
      },
      [`${t}-container`]: {
        "&::before, &::after": {
          position: "absolute",
          top: 0,
          bottom: 0,
          zIndex: i + 1,
          width: 30,
          transition: `box-shadow ${l}`,
          content: '""',
          pointerEvents: "none"
        },
        "&::before": {
          insetInlineStart: 0
        },
        "&::after": {
          insetInlineEnd: 0
        }
      },
      [`${t}-ping-left`]: {
        [`&:not(${t}-has-fix-left) ${t}-container`]: {
          position: "relative",
          "&::before": {
            boxShadow: `inset 10px 0 8px -8px ${s}`
          }
        },
        [`
          ${t}-cell-fix-left-first::after,
          ${t}-cell-fix-left-last::after
        `]: {
          boxShadow: `inset 10px 0 8px -8px ${s}`
        },
        [`${t}-cell-fix-left-last::before`]: {
          backgroundColor: "transparent !important"
        }
      },
      [`${t}-ping-right`]: {
        [`&:not(${t}-has-fix-right) ${t}-container`]: {
          position: "relative",
          "&::after": {
            boxShadow: `inset -10px 0 8px -8px ${s}`
          }
        },
        [`
          ${t}-cell-fix-right-first::after,
          ${t}-cell-fix-right-last::after
        `]: {
          boxShadow: `inset -10px 0 8px -8px ${s}`
        }
      }
    }
  };
}, BUe = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e;
  return {
    [`${t}-wrapper`]: {
      // ========================== Pagination ==========================
      [`${t}-pagination${n}-pagination`]: {
        margin: `${e.margin}px 0`
      },
      [`${t}-pagination`]: {
        display: "flex",
        flexWrap: "wrap",
        rowGap: e.paddingXS,
        "> *": {
          flex: "none"
        },
        "&-left": {
          justifyContent: "flex-start"
        },
        "&-center": {
          justifyContent: "center"
        },
        "&-right": {
          justifyContent: "flex-end"
        }
      }
    }
  };
}, FUe = (e) => {
  const {
    componentCls: t,
    tableRadius: n
  } = e;
  return {
    [`${t}-wrapper`]: {
      [t]: {
        // https://github.com/ant-design/ant-design/issues/39115#issuecomment-1362314574
        [`${t}-title, ${t}-header`]: {
          borderRadius: `${n}px ${n}px 0 0`
        },
        [`${t}-title + ${t}-container`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0,
          table: {
            borderRadius: 0,
            "> thead > tr:first-child": {
              "th:first-child": {
                borderRadius: 0
              },
              "th:last-child": {
                borderRadius: 0
              }
            }
          }
        },
        "&-container": {
          borderStartStartRadius: n,
          borderStartEndRadius: n,
          "table > thead > tr:first-child": {
            "> *:first-child": {
              borderStartStartRadius: n
            },
            "> *:last-child": {
              borderStartEndRadius: n
            }
          }
        },
        "&-footer": {
          borderRadius: `0 0 ${n}px ${n}px`
        }
      }
    }
  };
}, VUe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-wrapper-rtl`]: {
      direction: "rtl",
      table: {
        direction: "rtl"
      },
      [`${t}-pagination-left`]: {
        justifyContent: "flex-end"
      },
      [`${t}-pagination-right`]: {
        justifyContent: "flex-start"
      },
      [`${t}-row-expand-icon`]: {
        "&::after": {
          transform: "rotate(-90deg)"
        },
        "&-collapsed::before": {
          transform: "rotate(180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        }
      }
    }
  };
}, zUe = (e) => {
  const {
    componentCls: t,
    antCls: n,
    iconCls: o,
    fontSizeIcon: l,
    paddingXS: r,
    tableHeaderIconColor: a,
    tableHeaderIconColorHover: i
  } = e;
  return {
    [`${t}-wrapper`]: {
      // ========================== Selections ==========================
      [`${t}-selection-col`]: {
        width: e.tableSelectionColumnWidth
      },
      [`${t}-bordered ${t}-selection-col`]: {
        width: e.tableSelectionColumnWidth + r * 2
      },
      [`
        table tr th${t}-selection-column,
        table tr td${t}-selection-column
      `]: {
        paddingInlineEnd: e.paddingXS,
        paddingInlineStart: e.paddingXS,
        textAlign: "center",
        [`${n}-radio-wrapper`]: {
          marginInlineEnd: 0
        }
      },
      [`table tr th${t}-selection-column${t}-cell-fix-left`]: {
        zIndex: e.zIndexTableFixed + 1
      },
      [`table tr th${t}-selection-column::after`]: {
        backgroundColor: "transparent !important"
      },
      [`${t}-selection`]: {
        position: "relative",
        display: "inline-flex",
        flexDirection: "column"
      },
      [`${t}-selection-extra`]: {
        position: "absolute",
        top: 0,
        zIndex: 1,
        cursor: "pointer",
        transition: `all ${e.motionDurationSlow}`,
        marginInlineStart: "100%",
        paddingInlineStart: `${e.tablePaddingHorizontal / 4}px`,
        [o]: {
          color: a,
          fontSize: l,
          verticalAlign: "baseline",
          "&:hover": {
            color: i
          }
        }
      }
    }
  };
}, HUe = (e) => {
  const {
    componentCls: t
  } = e, n = (o, l, r, a) => ({
    [`${t}${t}-${o}`]: {
      fontSize: a,
      [`
        ${t}-title,
        ${t}-footer,
        ${t}-thead > tr > th,
        ${t}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: {
        padding: `${l}px ${r}px`
      },
      [`${t}-filter-trigger`]: {
        marginInlineEnd: `-${r / 2}px`
      },
      [`${t}-expanded-row-fixed`]: {
        margin: `-${l}px -${r}px`
      },
      [`${t}-tbody`]: {
        // ========================= Nest Table ===========================
        [`${t}-wrapper:only-child ${t}`]: {
          marginBlock: `-${l}px`,
          marginInline: `${e.tableExpandColumnWidth - r}px -${r}px`
        }
      },
      // https://github.com/ant-design/ant-design/issues/35167
      [`${t}-selection-column`]: {
        paddingInlineStart: `${r / 4}px`
      }
    }
  });
  return {
    [`${t}-wrapper`]: _(_({}, n("middle", e.tablePaddingVerticalMiddle, e.tablePaddingHorizontalMiddle, e.tableFontSizeMiddle)), n("small", e.tablePaddingVerticalSmall, e.tablePaddingHorizontalSmall, e.tableFontSizeSmall))
  };
}, jUe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-wrapper ${t}-resize-handle`]: {
      position: "absolute",
      top: 0,
      height: "100% !important",
      bottom: 0,
      left: " auto !important",
      right: " -8px",
      cursor: "col-resize",
      touchAction: "none",
      userSelect: "auto",
      width: "16px",
      zIndex: 1,
      "&-line": {
        display: "block",
        width: "1px",
        marginLeft: "7px",
        height: "100% !important",
        backgroundColor: e.colorPrimary,
        opacity: 0
      },
      "&:hover &-line": {
        opacity: 1
      }
    },
    [`${t}-wrapper  ${t}-resize-handle.dragging`]: {
      overflow: "hidden",
      [`${t}-resize-handle-line`]: {
        opacity: 1
      },
      "&:before": {
        position: "absolute",
        top: 0,
        bottom: 0,
        content: '" "',
        width: "200vw",
        transform: "translateX(-50%)",
        opacity: 0
      }
    }
  };
}, WUe = (e) => {
  const {
    componentCls: t,
    marginXXS: n,
    fontSizeIcon: o,
    tableHeaderIconColor: l,
    tableHeaderIconColorHover: r
  } = e;
  return {
    [`${t}-wrapper`]: {
      [`${t}-thead th${t}-column-has-sorters`]: {
        outline: "none",
        cursor: "pointer",
        transition: `all ${e.motionDurationSlow}`,
        "&:hover": {
          background: e.tableHeaderSortHoverBg,
          "&::before": {
            backgroundColor: "transparent !important"
          }
        },
        "&:focus-visible": {
          color: e.colorPrimary
        },
        // https://github.com/ant-design/ant-design/issues/30969
        [`
          &${t}-cell-fix-left:hover,
          &${t}-cell-fix-right:hover
        `]: {
          background: e.tableFixedHeaderSortActiveBg
        }
      },
      [`${t}-thead th${t}-column-sort`]: {
        background: e.tableHeaderSortBg,
        "&::before": {
          backgroundColor: "transparent !important"
        }
      },
      [`td${t}-column-sort`]: {
        background: e.tableBodySortBg
      },
      [`${t}-column-title`]: {
        position: "relative",
        zIndex: 1,
        flex: 1
      },
      [`${t}-column-sorters`]: {
        display: "flex",
        flex: "auto",
        alignItems: "center",
        justifyContent: "space-between",
        "&::after": {
          position: "absolute",
          inset: 0,
          width: "100%",
          height: "100%",
          content: '""'
        }
      },
      [`${t}-column-sorter`]: {
        marginInlineStart: n,
        color: l,
        fontSize: 0,
        transition: `color ${e.motionDurationSlow}`,
        "&-inner": {
          display: "inline-flex",
          flexDirection: "column",
          alignItems: "center"
        },
        "&-up, &-down": {
          fontSize: o,
          "&.active": {
            color: e.colorPrimary
          }
        },
        [`${t}-column-sorter-up + ${t}-column-sorter-down`]: {
          marginTop: "-0.3em"
        }
      },
      [`${t}-column-sorters:hover ${t}-column-sorter`]: {
        color: r
      }
    }
  };
}, KUe = (e) => {
  const {
    componentCls: t,
    opacityLoading: n,
    tableScrollThumbBg: o,
    tableScrollThumbBgHover: l,
    tableScrollThumbSize: r,
    tableScrollBg: a,
    zIndexTableSticky: i
  } = e, s = `${e.lineWidth}px ${e.lineType} ${e.tableBorderColor}`;
  return {
    [`${t}-wrapper`]: {
      [`${t}-sticky`]: {
        "&-holder": {
          position: "sticky",
          zIndex: i,
          background: e.colorBgContainer
        },
        "&-scroll": {
          position: "sticky",
          bottom: 0,
          height: `${r}px !important`,
          zIndex: i,
          display: "flex",
          alignItems: "center",
          background: a,
          borderTop: s,
          opacity: n,
          "&:hover": {
            transformOrigin: "center bottom"
          },
          // fake scrollbar style of sticky
          "&-bar": {
            height: r,
            backgroundColor: o,
            borderRadius: 100,
            transition: `all ${e.motionDurationSlow}, transform none`,
            position: "absolute",
            bottom: 0,
            "&:hover, &-active": {
              backgroundColor: l
            }
          }
        }
      }
    }
  };
}, VR = (e) => {
  const {
    componentCls: t,
    lineWidth: n,
    tableBorderColor: o
  } = e, l = `${n}px ${e.lineType} ${o}`;
  return {
    [`${t}-wrapper`]: {
      [`${t}-summary`]: {
        position: "relative",
        zIndex: e.zIndexTableFixed,
        background: e.tableBg,
        "> tr": {
          "> th, > td": {
            borderBottom: l
          }
        }
      },
      [`div${t}-summary`]: {
        boxShadow: `0 -${n}px 0 ${o}`
      }
    }
  };
}, UUe = (e) => {
  const {
    componentCls: t,
    fontWeightStrong: n,
    tablePaddingVertical: o,
    tablePaddingHorizontal: l,
    lineWidth: r,
    lineType: a,
    tableBorderColor: i,
    tableFontSize: s,
    tableBg: c,
    tableRadius: u,
    tableHeaderTextColor: d,
    motionDurationMid: f,
    tableHeaderBg: p,
    tableHeaderCellSplitColor: m,
    tableRowHoverBg: v,
    tableSelectedRowBg: h,
    tableSelectedRowHoverBg: g,
    tableFooterTextColor: y,
    tableFooterBg: b,
    paddingContentVerticalLG: C
  } = e, w = `${r}px ${a} ${i}`;
  return {
    [`${t}-wrapper`]: _(_({
      clear: "both",
      maxWidth: "100%"
    }, ja()), {
      [t]: _(_({}, nn(e)), {
        fontSize: s,
        background: c,
        borderRadius: `${u}px ${u}px 0 0`
      }),
      // https://github.com/ant-design/ant-design/issues/17611
      table: {
        width: "100%",
        textAlign: "start",
        borderRadius: `${u}px ${u}px 0 0`,
        borderCollapse: "separate",
        borderSpacing: 0
      },
      // ============================= Cell =============================
      [`
          ${t}-thead > tr > th,
          ${t}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
        position: "relative",
        padding: `${C}px ${l}px`,
        overflowWrap: "break-word"
      },
      // ============================ Title =============================
      [`${t}-title`]: {
        padding: `${o}px ${l}px`
      },
      // ============================ Header ============================
      [`${t}-thead`]: {
        "\n          > tr > th,\n          > tr > td\n        ": {
          position: "relative",
          color: d,
          fontWeight: n,
          textAlign: "start",
          background: p,
          borderBottom: w,
          transition: `background ${f} ease`,
          "&[colspan]:not([colspan='1'])": {
            textAlign: "center"
          },
          [`&:not(:last-child):not(${t}-selection-column):not(${t}-row-expand-icon-cell):not([colspan])::before`]: {
            position: "absolute",
            top: "50%",
            insetInlineEnd: 0,
            width: 1,
            height: "1.6em",
            backgroundColor: m,
            transform: "translateY(-50%)",
            transition: `background-color ${f}`,
            content: '""'
          }
        },
        "> tr:not(:last-child) > th[colspan]": {
          borderBottom: 0
        }
      },
      // ============================ Body ============================
      // Borderless Table has unique hover style, which would be implemented with `borderTop`.
      [`${t}:not(${t}-bordered)`]: {
        [`${t}-tbody`]: {
          "> tr": {
            "> td": {
              borderTop: w,
              borderBottom: "transparent"
            },
            "&:last-child > td": {
              borderBottom: w
            },
            [`&:first-child > td,
              &${t}-measure-row + tr > td`]: {
              borderTop: "none",
              borderTopColor: "transparent"
            }
          }
        }
      },
      // Bordered Table remains simple `borderBottom`.
      // Ref issue: https://github.com/ant-design/ant-design/issues/38724
      [`${t}${t}-bordered`]: {
        [`${t}-tbody`]: {
          "> tr": {
            "> td": {
              borderBottom: w
            }
          }
        }
      },
      [`${t}-tbody`]: {
        "> tr": {
          "> td": {
            transition: `background ${f}, border-color ${f}`,
            // ========================= Nest Table ===========================
            [`
              > ${t}-wrapper:only-child,
              > ${t}-expanded-row-fixed > ${t}-wrapper:only-child
            `]: {
              [t]: {
                marginBlock: `-${o}px`,
                marginInline: `${e.tableExpandColumnWidth - l}px -${l}px`,
                [`${t}-tbody > tr:last-child > td`]: {
                  borderBottom: 0,
                  "&:first-child, &:last-child": {
                    borderRadius: 0
                  }
                }
              }
            }
          },
          [`
            &${t}-row:hover > td,
            > td${t}-cell-row-hover
          `]: {
            background: v
          },
          [`&${t}-row-selected`]: {
            "> td": {
              background: h
            },
            "&:hover > td": {
              background: g
            }
          }
        }
      },
      // ============================ Footer ============================
      [`${t}-footer`]: {
        padding: `${o}px ${l}px`,
        color: y,
        background: b
      }
    })
  };
}, GUe = Zt("Table", (e) => {
  const {
    controlItemBgActive: t,
    controlItemBgActiveHover: n,
    colorTextPlaceholder: o,
    colorTextHeading: l,
    colorSplit: r,
    colorBorderSecondary: a,
    fontSize: i,
    padding: s,
    paddingXS: c,
    paddingSM: u,
    controlHeight: d,
    colorFillAlter: f,
    colorIcon: p,
    colorIconHover: m,
    opacityLoading: v,
    colorBgContainer: h,
    borderRadiusLG: g,
    colorFillContent: y,
    colorFillSecondary: b,
    controlInteractiveSize: C
  } = e, w = new xn(p), x = new xn(m), E = t, I = 2, T = new xn(b).onBackground(h).toHexString(), P = new xn(y).onBackground(h).toHexString(), k = new xn(f).onBackground(h).toHexString(), N = Vt(e, {
    tableFontSize: i,
    tableBg: h,
    tableRadius: g,
    tablePaddingVertical: s,
    tablePaddingHorizontal: s,
    tablePaddingVerticalMiddle: u,
    tablePaddingHorizontalMiddle: c,
    tablePaddingVerticalSmall: c,
    tablePaddingHorizontalSmall: c,
    tableBorderColor: a,
    tableHeaderTextColor: l,
    tableHeaderBg: k,
    tableFooterTextColor: l,
    tableFooterBg: k,
    tableHeaderCellSplitColor: a,
    tableHeaderSortBg: T,
    tableHeaderSortHoverBg: P,
    tableHeaderIconColor: w.clone().setAlpha(w.getAlpha() * v).toRgbString(),
    tableHeaderIconColorHover: x.clone().setAlpha(x.getAlpha() * v).toRgbString(),
    tableBodySortBg: k,
    tableFixedHeaderSortActiveBg: T,
    tableHeaderFilterActiveBg: y,
    tableFilterDropdownBg: h,
    tableRowHoverBg: k,
    tableSelectedRowBg: E,
    tableSelectedRowHoverBg: n,
    zIndexTableFixed: I,
    zIndexTableSticky: I + 1,
    tableFontSizeMiddle: i,
    tableFontSizeSmall: i,
    tableSelectionColumnWidth: d,
    tableExpandIconBg: h,
    tableExpandColumnWidth: C + 2 * e.padding,
    tableExpandedRowBg: f,
    // Dropdown
    tableFilterDropdownWidth: 120,
    tableFilterDropdownHeight: 264,
    tableFilterDropdownSearchWidth: 140,
    // Virtual Scroll Bar
    tableScrollThumbSize: 8,
    tableScrollThumbBg: o,
    tableScrollThumbBgHover: l,
    tableScrollBg: r
  });
  return [UUe(N), BUe(N), VR(N), WUe(N), DUe(N), NUe(N), FUe(N), RUe(N), VR(N), AUe(N), zUe(N), LUe(N), KUe(N), MUe(N), HUe(N), jUe(N), VUe(N)];
}), YUe = [], JG = () => ({
  prefixCls: At(),
  columns: $n(),
  rowKey: zt([String, Function]),
  tableLayout: At(),
  rowClassName: zt([String, Function]),
  title: Fe(),
  footer: Fe(),
  id: At(),
  showHeader: Qe(),
  components: Nt(),
  customRow: Fe(),
  customHeaderRow: Fe(),
  direction: At(),
  expandFixed: zt([Boolean, String]),
  expandColumnWidth: Number,
  expandedRowKeys: $n(),
  defaultExpandedRowKeys: $n(),
  expandedRowRender: Fe(),
  expandRowByClick: Qe(),
  expandIcon: Fe(),
  onExpand: Fe(),
  onExpandedRowsChange: Fe(),
  "onUpdate:expandedRowKeys": Fe(),
  defaultExpandAllRows: Qe(),
  indentSize: Number,
  /** @deprecated Please use `EXPAND_COLUMN` in `columns` directly */
  expandIconColumnIndex: Number,
  showExpandColumn: Qe(),
  expandedRowClassName: Fe(),
  childrenColumnName: At(),
  rowExpandable: Fe(),
  sticky: zt([Boolean, Object]),
  dropdownPrefixCls: String,
  dataSource: $n(),
  pagination: zt([Boolean, Object]),
  loading: zt([Boolean, Object]),
  size: At(),
  bordered: Qe(),
  locale: Nt(),
  onChange: Fe(),
  onResizeColumn: Fe(),
  rowSelection: Nt(),
  getPopupContainer: Fe(),
  scroll: Nt(),
  sortDirections: $n(),
  showSorterTooltip: zt([Boolean, Object], !0),
  transformCellText: Fe()
}), XUe = /* @__PURE__ */ le({
  name: "InternalTable",
  inheritAttrs: !1,
  props: sn(_(_({}, JG()), {
    contextSlots: Nt()
  }), {
    rowKey: "key"
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: l,
      emit: r
    } = t;
    un(!(typeof e.rowKey == "function" && e.rowKey.length > 1), "Table", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected."), zWe(O(() => e.contextSlots)), HWe({
      onResizeColumn: (me, ge) => {
        r("resizeColumn", me, ge);
      }
    });
    const a = Dp(), i = O(() => {
      const me = new Set(Object.keys(a.value).filter((ge) => a.value[ge]));
      return e.columns.filter((ge) => !ge.responsive || ge.responsive.some((he) => me.has(he)));
    }), {
      size: s,
      renderEmpty: c,
      direction: u,
      prefixCls: d,
      configProvider: f
    } = bt("table", e), [p, m] = GUe(d), v = O(() => {
      var me;
      return e.transformCellText || ((me = f.transformCellText) === null || me === void 0 ? void 0 : me.value);
    }), [h] = fa("Table", rr.Table, /* @__PURE__ */ ft(e, "locale")), g = O(() => e.dataSource || YUe), y = O(() => f.getPrefixCls("dropdown", e.dropdownPrefixCls)), b = O(() => e.childrenColumnName || "children"), C = O(() => g.value.some((me) => me == null ? void 0 : me[b.value]) ? "nest" : e.expandedRowRender ? "row" : null), w = /* @__PURE__ */ kt({
      body: null
    }), x = (me) => {
      _(w, me);
    }, E = O(() => typeof e.rowKey == "function" ? e.rowKey : (me) => me == null ? void 0 : me[e.rowKey]), [I] = AKe(g, b, E), T = {}, P = function(me, ge) {
      let he = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      const {
        pagination: $e,
        scroll: ne,
        onChange: ae
      } = e, ce = _(_({}, T), me);
      he && (T.resetPagination(), ce.pagination.current && (ce.pagination.current = 1), $e && $e.onChange && $e.onChange(1, ce.pagination.pageSize)), ne && ne.scrollToFirstRowOnChange !== !1 && w.body && vI(0, {
        getContainer: () => w.body
      }), ae == null || ae(ce.pagination, ce.filters, ce.sorter, {
        currentDataSource: FR(fE(g.value, ce.sorterStates, b.value), ce.filterStates),
        action: ge
      });
    }, k = (me, ge) => {
      P({
        sorter: me,
        sorterStates: ge
      }, "sort", !1);
    }, [N, R, z, D] = jKe({
      prefixCls: d,
      mergedColumns: i,
      onSorterChange: k,
      sortDirections: O(() => e.sortDirections || ["ascend", "descend"]),
      tableLocale: h,
      showSorterTooltip: /* @__PURE__ */ ft(e, "showSorterTooltip")
    }), F = O(() => fE(g.value, R.value, b.value)), M = (me, ge) => {
      P({
        filters: me,
        filterStates: ge
      }, "filter", !0);
    }, [A, L, B] = IUe({
      prefixCls: d,
      locale: h,
      dropdownPrefixCls: y,
      mergedColumns: i,
      onFilterChange: M,
      getPopupContainer: /* @__PURE__ */ ft(e, "getPopupContainer")
    }), V = O(() => FR(F.value, L.value)), [j] = kUe(/* @__PURE__ */ ft(e, "contextSlots")), W = O(() => {
      const me = {}, ge = B.value;
      return Object.keys(ge).forEach((he) => {
        ge[he] !== null && (me[he] = ge[he]);
      }), _(_({}, z.value), {
        filters: me
      });
    }), [Y] = TUe(W), U = (me, ge) => {
      P({
        pagination: _(_({}, T.pagination), {
          current: me,
          pageSize: ge
        })
      }, "paginate");
    }, [te, J] = MKe(O(() => V.value.length), /* @__PURE__ */ ft(e, "pagination"), U);
    Ot(() => {
      T.sorter = D.value, T.sorterStates = R.value, T.filters = B.value, T.filterStates = L.value, T.pagination = e.pagination === !1 ? {} : NKe(te.value, e.pagination), T.resetPagination = J;
    });
    const re = O(() => {
      if (e.pagination === !1 || !te.value.pageSize)
        return V.value;
      const {
        current: me = 1,
        total: ge,
        pageSize: he = iE
      } = te.value;
      return un(me > 0, "Table", "`current` should be positive number."), V.value.length < ge ? V.value.length > he ? V.value.slice((me - 1) * he, me * he) : V.value : V.value.slice((me - 1) * he, me * he);
    });
    Ot(() => {
      Ke(() => {
        const {
          total: me,
          pageSize: ge = iE
        } = te.value;
        V.value.length < me && V.value.length > ge && un(!1, "Table", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode.");
      });
    }, {
      flush: "post"
    });
    const oe = O(() => e.showExpandColumn === !1 ? -1 : C.value === "nest" && e.expandIconColumnIndex === void 0 ? e.rowSelection ? 1 : 0 : e.expandIconColumnIndex > 0 && e.rowSelection ? e.expandIconColumnIndex - 1 : e.expandIconColumnIndex), q = /* @__PURE__ */ H();
    pe(() => e.rowSelection, () => {
      q.value = e.rowSelection ? _({}, e.rowSelection) : e.rowSelection;
    }, {
      deep: !0,
      immediate: !0
    });
    const [K, se] = DKe(q, {
      prefixCls: d,
      data: V,
      pageData: re,
      getRowKey: E,
      getRecordByKey: I,
      expandType: C,
      childrenColumnName: b,
      locale: h,
      getPopupContainer: O(() => e.getPopupContainer)
    }), Z = (me, ge, he) => {
      let $e;
      const {
        rowClassName: ne
      } = e;
      return typeof ne == "function" ? $e = ke(ne(me, ge, he)) : $e = ke(ne), ke({
        [`${d.value}-row-selected`]: se.value.has(E.value(me, ge))
      }, $e);
    };
    l({
      selectedKeySet: se
    });
    const ee = O(() => typeof e.indentSize == "number" ? e.indentSize : 15), fe = (me) => Y(K(A(N(j(me)))));
    return () => {
      var me;
      const {
        expandIcon: ge = o.expandIcon || PUe(h.value),
        pagination: he,
        loading: $e,
        bordered: ne
      } = e;
      let ae, ce;
      if (he !== !1 && (!((me = te.value) === null || me === void 0) && me.total)) {
        let be;
        te.value.size ? be = te.value.size : be = s.value === "small" || s.value === "middle" ? "small" : void 0;
        const ie = (tt) => $(ZS, Q(Q({}, te.value), {}, {
          class: [`${d.value}-pagination ${d.value}-pagination-${tt}`, te.value.class],
          size: be
        }), null), we = u.value === "rtl" ? "left" : "right", {
          position: Ne
        } = te.value;
        if (Ne !== null && Array.isArray(Ne)) {
          const tt = Ne.find((Le) => Le.includes("top")), Pe = Ne.find((Le) => Le.includes("bottom")), Re = Ne.every((Le) => `${Le}` == "none");
          !tt && !Pe && !Re && (ce = ie(we)), tt && (ae = ie(tt.toLowerCase().replace("top", ""))), Pe && (ce = ie(Pe.toLowerCase().replace("bottom", "")));
        } else
          ce = ie(we);
      }
      let xe;
      typeof $e == "boolean" ? xe = {
        spinning: $e
      } : typeof $e == "object" && (xe = _({
        spinning: !0
      }, $e));
      const Te = ke(`${d.value}-wrapper`, {
        [`${d.value}-wrapper-rtl`]: u.value === "rtl"
      }, n.class, m.value), Se = pn(e, ["columns"]);
      return p($("div", {
        class: Te,
        style: n.style
      }, [$(yi, Q({
        spinning: !1
      }, xe), {
        default: () => [ae, $(PKe, Q(Q(Q({}, n), Se), {}, {
          expandedRowKeys: e.expandedRowKeys,
          defaultExpandedRowKeys: e.defaultExpandedRowKeys,
          expandIconColumnIndex: oe.value,
          indentSize: ee.value,
          expandIcon: ge,
          columns: i.value,
          direction: u.value,
          prefixCls: d.value,
          class: ke({
            [`${d.value}-middle`]: s.value === "middle",
            [`${d.value}-small`]: s.value === "small",
            [`${d.value}-bordered`]: ne,
            [`${d.value}-empty`]: g.value.length === 0
          }),
          data: re.value,
          rowKey: E.value,
          rowClassName: Z,
          internalHooks: aE,
          internalRefs: w,
          onUpdateInternalRefs: x,
          transformColumns: fe,
          transformCellText: v.value
        }), _(_({}, o), {
          emptyText: () => {
            var be, ie;
            return ((be = o.emptyText) === null || be === void 0 ? void 0 : be.call(o)) || ((ie = e.locale) === null || ie === void 0 ? void 0 : ie.emptyText) || c("Table");
          }
        })), ce]
      })]));
    };
  }
}), i$ = /* @__PURE__ */ le({
  name: "ATable",
  inheritAttrs: !1,
  props: sn(JG(), {
    rowKey: "key"
  }),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: l
    } = t;
    const r = /* @__PURE__ */ H();
    return l({
      table: r
    }), () => {
      var a;
      const i = e.columns || LG((a = o.default) === null || a === void 0 ? void 0 : a.call(o));
      return $(XUe, Q(Q(Q({
        ref: r
      }, n), e), {}, {
        columns: i || [],
        expandedRowRender: o.expandedRowRender || e.expandedRowRender,
        contextSlots: _({}, o)
      }), o);
    };
  }
}), n0 = /* @__PURE__ */ le({
  name: "ATableColumn",
  slots: Object,
  render() {
    return null;
  }
}), o0 = /* @__PURE__ */ le({
  name: "ATableColumnGroup",
  slots: Object,
  __ANT_TABLE_COLUMN_GROUP: !0,
  render() {
    return null;
  }
}), Yy = bKe, Xy = CKe, l0 = _(wKe, {
  Cell: Xy,
  Row: Yy,
  name: "ATableSummary"
}), qUe = _(i$, {
  SELECTION_ALL: sE,
  SELECTION_INVERT: cE,
  SELECTION_NONE: uE,
  SELECTION_COLUMN: ha,
  EXPAND_COLUMN: ai,
  Column: n0,
  ColumnGroup: o0,
  Summary: l0,
  install: (e) => (e.component(l0.name, l0), e.component(Xy.name, Xy), e.component(Yy.name, Yy), e.component(i$.name, i$), e.component(n0.name, n0), e.component(o0.name, o0), e)
}), JUe = {
  prefixCls: String,
  placeholder: String,
  value: String,
  handleClear: Function,
  disabled: {
    type: Boolean,
    default: void 0
  },
  onChange: Function
}, ZUe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Search",
  inheritAttrs: !1,
  props: sn(JUe, {
    placeholder: ""
  }),
  emits: ["change"],
  setup(e, t) {
    let {
      emit: n
    } = t;
    const o = (l) => {
      var r;
      n("change", l), l.target.value === "" && ((r = e.handleClear) === null || r === void 0 || r.call(e));
    };
    return () => {
      const {
        placeholder: l,
        value: r,
        prefixCls: a,
        disabled: i
      } = e;
      return $(Yo, {
        placeholder: l,
        class: a,
        value: r,
        onChange: o,
        disabled: i,
        allowClear: !0
      }, {
        prefix: () => $(Mp, null, null)
      });
    };
  }
});
var QUe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, name: "delete", theme: "outlined" };
function zR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      eGe(e, l, n[l]);
    });
  }
  return e;
}
function eGe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var rC = function(t, n) {
  var o = zR({}, t, n.attrs);
  return $(cn, zR({}, o, {
    icon: QUe
  }), null);
};
rC.displayName = "DeleteOutlined";
rC.inheritAttrs = !1;
function tGe() {
}
const nGe = {
  renderedText: de.any,
  renderedEl: de.any,
  item: de.any,
  checked: Qe(),
  prefixCls: String,
  disabled: Qe(),
  showRemove: Qe(),
  onClick: Function,
  onRemove: Function
}, oGe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ListItem",
  inheritAttrs: !1,
  props: nGe,
  emits: ["click", "remove"],
  setup(e, t) {
    let {
      emit: n
    } = t;
    return () => {
      const {
        renderedText: o,
        renderedEl: l,
        item: r,
        checked: a,
        disabled: i,
        prefixCls: s,
        showRemove: c
      } = e, u = ke({
        [`${s}-content-item`]: !0,
        [`${s}-content-item-disabled`]: i || r.disabled
      });
      let d;
      return (typeof o == "string" || typeof o == "number") && (d = String(o)), $(sd, {
        componentName: "Transfer",
        defaultLocale: rr.Transfer
      }, {
        default: (f) => {
          const p = $("span", {
            class: `${s}-content-item-text`
          }, [l]);
          return c ? $("li", {
            class: u,
            title: d
          }, [p, $(Ky, {
            disabled: i || r.disabled,
            class: `${s}-content-item-remove`,
            "aria-label": f.remove,
            onClick: () => {
              n("remove", r);
            }
          }, {
            default: () => [$(rC, null, null)]
          })]) : $("li", {
            class: u,
            title: d,
            onClick: i || r.disabled ? tGe : () => {
              n("click", r);
            }
          }, [$(la, {
            class: `${s}-checkbox`,
            checked: a,
            disabled: i || r.disabled
          }, null), p]);
        }
      });
    };
  }
}), lGe = {
  prefixCls: String,
  filteredRenderItems: de.array.def([]),
  selectedKeys: de.array,
  disabled: Qe(),
  showRemove: Qe(),
  pagination: de.any,
  onItemSelect: Function,
  onScroll: Function,
  onItemRemove: Function
};
function rGe(e) {
  if (!e)
    return null;
  const t = {
    pageSize: 10,
    simple: !0,
    showSizeChanger: !1,
    showLessItems: !1
  };
  return typeof e == "object" ? _(_({}, t), e) : t;
}
const aGe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ListBody",
  inheritAttrs: !1,
  props: lGe,
  emits: ["itemSelect", "itemRemove", "scroll"],
  setup(e, t) {
    let {
      emit: n,
      expose: o
    } = t;
    const l = /* @__PURE__ */ H(1), r = (d) => {
      const {
        selectedKeys: f
      } = e, p = f.indexOf(d.key) >= 0;
      n("itemSelect", d.key, !p);
    }, a = (d) => {
      n("itemRemove", [d.key]);
    }, i = (d) => {
      n("scroll", d);
    }, s = O(() => rGe(e.pagination));
    pe([s, () => e.filteredRenderItems], () => {
      if (s.value) {
        const d = Math.ceil(e.filteredRenderItems.length / s.value.pageSize);
        l.value = Math.min(l.value, d);
      }
    }, {
      immediate: !0
    });
    const c = O(() => {
      const {
        filteredRenderItems: d
      } = e;
      let f = d;
      return s.value && (f = d.slice((l.value - 1) * s.value.pageSize, l.value * s.value.pageSize)), f;
    }), u = (d) => {
      l.value = d;
    };
    return o({
      items: c
    }), () => {
      const {
        prefixCls: d,
        filteredRenderItems: f,
        selectedKeys: p,
        disabled: m,
        showRemove: v
      } = e;
      let h = null;
      s.value && (h = $(ZS, {
        simple: s.value.simple,
        showSizeChanger: s.value.showSizeChanger,
        showLessItems: s.value.showLessItems,
        size: "small",
        disabled: m,
        class: `${d}-pagination`,
        total: f.length,
        pageSize: s.value.pageSize,
        current: l.value,
        onChange: u
      }, null));
      const g = c.value.map((y) => {
        let {
          renderedEl: b,
          renderedText: C,
          item: w
        } = y;
        const {
          disabled: x
        } = w, E = p.indexOf(w.key) >= 0;
        return $(oGe, {
          disabled: m || x,
          key: w.key,
          item: w,
          renderedText: C,
          renderedEl: b,
          checked: E,
          prefixCls: d,
          onClick: r,
          onRemove: a,
          showRemove: v
        }, null);
      });
      return $(Ge, null, [$("ul", {
        class: ke(`${d}-content`, {
          [`${d}-content-show-remove`]: v
        }),
        onScroll: i
      }, [g]), h]);
    };
  }
}), mE = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.forEach((n, o) => {
    t.set(n, o);
  }), t;
}, iGe = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.forEach((n, o) => {
    let {
      disabled: l,
      key: r
    } = n;
    l && t.set(r, o);
  }), t;
}, sGe = () => null;
function cGe(e) {
  return !!(e && !Io(e) && Object.prototype.toString.call(e) === "[object Object]");
}
function Kg(e) {
  return e.filter((t) => !t.disabled).map((t) => t.key);
}
const uGe = {
  prefixCls: String,
  dataSource: $n([]),
  filter: String,
  filterOption: Function,
  checkedKeys: de.arrayOf(de.string),
  handleFilter: Function,
  handleClear: Function,
  renderItem: Function,
  showSearch: Qe(!1),
  searchPlaceholder: String,
  notFoundContent: de.any,
  itemUnit: String,
  itemsUnit: String,
  renderList: de.any,
  disabled: Qe(),
  direction: At(),
  showSelectAll: Qe(),
  remove: String,
  selectAll: String,
  selectCurrent: String,
  selectInvert: String,
  removeAll: String,
  removeCurrent: String,
  selectAllLabel: de.any,
  showRemove: Qe(),
  pagination: de.any,
  onItemSelect: Function,
  onItemSelectAll: Function,
  onItemRemove: Function,
  onScroll: Function
}, HR = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "TransferList",
  inheritAttrs: !1,
  props: uGe,
  // emits: ['scroll', 'itemSelectAll', 'itemRemove', 'itemSelect'],
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const l = /* @__PURE__ */ H(""), r = /* @__PURE__ */ H(), a = /* @__PURE__ */ H(), i = (w, x) => {
      let E = w ? w(x) : null;
      const I = !!E && mo(E).length > 0;
      return I || (E = $(aGe, Q(Q({}, x), {}, {
        ref: a
      }), null)), {
        customize: I,
        bodyContent: E
      };
    }, s = (w) => {
      const {
        renderItem: x = sGe
      } = e, E = x(w), I = cGe(E);
      return {
        renderedText: I ? E.value : E,
        renderedEl: I ? E.label : E,
        item: w
      };
    }, c = /* @__PURE__ */ H([]), u = /* @__PURE__ */ H([]);
    Ot(() => {
      const w = [], x = [];
      e.dataSource.forEach((E) => {
        const I = s(E), {
          renderedText: T
        } = I;
        if (l.value && l.value.trim() && !g(T, E))
          return null;
        w.push(E), x.push(I);
      }), c.value = w, u.value = x;
    });
    const d = O(() => {
      const {
        checkedKeys: w
      } = e;
      if (w.length === 0)
        return "none";
      const x = mE(w);
      return c.value.every((E) => x.has(E.key) || !!E.disabled) ? "all" : "part";
    }), f = O(() => Kg(c.value)), p = (w, x) => Array.from(/* @__PURE__ */ new Set([...w, ...e.checkedKeys])).filter((E) => x.indexOf(E) === -1), m = (w) => {
      let {
        disabled: x,
        prefixCls: E
      } = w;
      var I;
      const T = d.value === "all";
      return $(la, {
        disabled: ((I = e.dataSource) === null || I === void 0 ? void 0 : I.length) === 0 || x,
        checked: T,
        indeterminate: d.value === "part",
        class: `${E}-checkbox`,
        onChange: () => {
          const k = f.value;
          e.onItemSelectAll(p(T ? [] : k, T ? e.checkedKeys : []));
        }
      }, null);
    }, v = (w) => {
      var x;
      const {
        target: {
          value: E
        }
      } = w;
      l.value = E, (x = e.handleFilter) === null || x === void 0 || x.call(e, w);
    }, h = (w) => {
      var x;
      l.value = "", (x = e.handleClear) === null || x === void 0 || x.call(e, w);
    }, g = (w, x) => {
      const {
        filterOption: E
      } = e;
      return E ? E(l.value, x) : w.includes(l.value);
    }, y = (w, x) => {
      const {
        itemsUnit: E,
        itemUnit: I,
        selectAllLabel: T
      } = e;
      if (T)
        return typeof T == "function" ? T({
          selectedCount: w,
          totalCount: x
        }) : T;
      const P = x > 1 ? E : I;
      return $(Ge, null, [(w > 0 ? `${w}/` : "") + x, Ft(" "), P]);
    }, b = O(() => Array.isArray(e.notFoundContent) ? e.notFoundContent[e.direction === "left" ? 0 : 1] : e.notFoundContent), C = (w, x, E, I, T, P) => {
      const k = T ? $("div", {
        class: `${w}-body-search-wrapper`
      }, [$(ZUe, {
        prefixCls: `${w}-search`,
        onChange: v,
        handleClear: h,
        placeholder: x,
        value: l.value,
        disabled: P
      }, null)]) : null;
      let N;
      const {
        onEvents: R
      } = nI(n), {
        bodyContent: z,
        customize: D
      } = i(I, _(_(_({}, e), {
        filteredItems: c.value,
        filteredRenderItems: u.value,
        selectedKeys: E
      }), R));
      return D ? N = $("div", {
        class: `${w}-body-customize-wrapper`
      }, [z]) : N = c.value.length ? z : $("div", {
        class: `${w}-body-not-found`
      }, [b.value]), $("div", {
        class: T ? `${w}-body ${w}-body-with-search` : `${w}-body`,
        ref: r
      }, [k, N]);
    };
    return () => {
      var w, x;
      const {
        prefixCls: E,
        checkedKeys: I,
        disabled: T,
        showSearch: P,
        searchPlaceholder: k,
        selectAll: N,
        selectCurrent: R,
        selectInvert: z,
        removeAll: D,
        removeCurrent: F,
        renderList: M,
        onItemSelectAll: A,
        onItemRemove: L,
        showSelectAll: B = !0,
        showRemove: V,
        pagination: j
      } = e, W = (w = o.footer) === null || w === void 0 ? void 0 : w.call(o, _({}, e)), Y = ke(E, {
        [`${E}-with-pagination`]: !!j,
        [`${E}-with-footer`]: !!W
      }), U = C(E, k, I, M, P, T), te = W ? $("div", {
        class: `${E}-footer`
      }, [W]) : null, J = !V && !j && m({
        disabled: T,
        prefixCls: E
      });
      let re = null;
      V ? re = $(Do, null, {
        default: () => [j && $(Do.Item, {
          key: "removeCurrent",
          onClick: () => {
            const q = Kg((a.value.items || []).map((K) => K.item));
            L == null || L(q);
          }
        }, {
          default: () => [F]
        }), $(Do.Item, {
          key: "removeAll",
          onClick: () => {
            L == null || L(f.value);
          }
        }, {
          default: () => [D]
        })]
      }) : re = $(Do, null, {
        default: () => [$(Do.Item, {
          key: "selectAll",
          onClick: () => {
            const q = f.value;
            A(p(q, []));
          }
        }, {
          default: () => [N]
        }), j && $(Do.Item, {
          onClick: () => {
            const q = Kg((a.value.items || []).map((K) => K.item));
            A(p(q, []));
          }
        }, {
          default: () => [R]
        }), $(Do.Item, {
          key: "selectInvert",
          onClick: () => {
            let q;
            j ? q = Kg((a.value.items || []).map((ee) => ee.item)) : q = f.value;
            const K = new Set(I), se = [], Z = [];
            q.forEach((ee) => {
              K.has(ee) ? Z.push(ee) : se.push(ee);
            }), A(p(se, Z));
          }
        }, {
          default: () => [z]
        })]
      });
      const oe = $(Ia, {
        class: `${E}-header-dropdown`,
        overlay: re,
        disabled: T
      }, {
        default: () => [$(pd, null, null)]
      });
      return $("div", {
        class: Y,
        style: n.style
      }, [$("div", {
        class: `${E}-header`
      }, [B ? $(Ge, null, [J, oe]) : null, $("span", {
        class: `${E}-header-selected`
      }, [$("span", null, [y(I.length, c.value.length)]), $("span", {
        class: `${E}-header-title`
      }, [(x = o.titleText) === null || x === void 0 ? void 0 : x.call(o)])])]), U, te]);
    };
  }
});
function jR() {
}
const kP = (e) => {
  const {
    disabled: t,
    moveToLeft: n = jR,
    moveToRight: o = jR,
    leftArrowText: l = "",
    rightArrowText: r = "",
    leftActive: a,
    rightActive: i,
    class: s,
    style: c,
    direction: u,
    oneWay: d
  } = e;
  return $("div", {
    class: s,
    style: c
  }, [$(ko, {
    type: "primary",
    size: "small",
    disabled: t || !i,
    onClick: o,
    icon: $(u !== "rtl" ? Br : Ii, null, null)
  }, {
    default: () => [r]
  }), !d && $(ko, {
    type: "primary",
    size: "small",
    disabled: t || !a,
    onClick: n,
    icon: $(u !== "rtl" ? Ii : Br, null, null)
  }, {
    default: () => [l]
  })]);
};
kP.displayName = "Operation";
kP.inheritAttrs = !1;
const dGe = (e) => {
  const {
    antCls: t,
    componentCls: n,
    listHeight: o,
    controlHeightLG: l,
    marginXXS: r,
    margin: a
  } = e, i = `${t}-table`, s = `${t}-input`;
  return {
    [`${n}-customize-list`]: {
      [`${n}-list`]: {
        flex: "1 1 50%",
        width: "auto",
        height: "auto",
        minHeight: o
      },
      // =================== Hook Components ===================
      [`${i}-wrapper`]: {
        [`${i}-small`]: {
          border: 0,
          borderRadius: 0,
          [`${i}-selection-column`]: {
            width: l,
            minWidth: l
          }
        },
        [`${i}-pagination${i}-pagination`]: {
          margin: `${a}px 0 ${r}px`
        }
      },
      [`${s}[disabled]`]: {
        backgroundColor: "transparent"
      }
    }
  };
}, WR = (e, t) => {
  const {
    componentCls: n,
    colorBorder: o
  } = e;
  return {
    [`${n}-list`]: {
      borderColor: t,
      "&-search:not([disabled])": {
        borderColor: o
      }
    }
  };
}, fGe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-status-error`]: _({}, WR(e, e.colorError)),
    [`${t}-status-warning`]: _({}, WR(e, e.colorWarning))
  };
}, pGe = (e) => {
  const {
    componentCls: t,
    colorBorder: n,
    colorSplit: o,
    lineWidth: l,
    transferItemHeight: r,
    transferHeaderHeight: a,
    transferHeaderVerticalPadding: i,
    transferItemPaddingVertical: s,
    controlItemBgActive: c,
    controlItemBgActiveHover: u,
    colorTextDisabled: d,
    listHeight: f,
    listWidth: p,
    listWidthLG: m,
    fontSizeIcon: v,
    marginXS: h,
    paddingSM: g,
    lineType: y,
    iconCls: b,
    motionDurationSlow: C
  } = e;
  return {
    display: "flex",
    flexDirection: "column",
    width: p,
    height: f,
    border: `${l}px ${y} ${n}`,
    borderRadius: e.borderRadiusLG,
    "&-with-pagination": {
      width: m,
      height: "auto"
    },
    "&-search": {
      [`${b}-search`]: {
        color: d
      }
    },
    "&-header": {
      display: "flex",
      flex: "none",
      alignItems: "center",
      height: a,
      // border-top is on the transfer dom. We should minus 1px for this
      padding: `${i - l}px ${g}px ${i}px`,
      color: e.colorText,
      background: e.colorBgContainer,
      borderBottom: `${l}px ${y} ${o}`,
      borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`,
      "> *:not(:last-child)": {
        marginInlineEnd: 4
        // This is magic and fixed number, DO NOT use token since it may change.
      },
      "> *": {
        flex: "none"
      },
      "&-title": _(_({}, Fo), {
        flex: "auto",
        textAlign: "end"
      }),
      "&-dropdown": _(_({}, cd()), {
        fontSize: v,
        transform: "translateY(10%)",
        cursor: "pointer",
        "&[disabled]": {
          cursor: "not-allowed"
        }
      })
    },
    "&-body": {
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      overflow: "hidden",
      fontSize: e.fontSize,
      "&-search-wrapper": {
        position: "relative",
        flex: "none",
        padding: g
      }
    },
    "&-content": {
      flex: "auto",
      margin: 0,
      padding: 0,
      overflow: "auto",
      listStyle: "none",
      "&-item": {
        display: "flex",
        alignItems: "center",
        minHeight: r,
        padding: `${s}px ${g}px`,
        transition: `all ${C}`,
        "> *:not(:last-child)": {
          marginInlineEnd: h
        },
        "> *": {
          flex: "none"
        },
        "&-text": _(_({}, Fo), {
          flex: "auto"
        }),
        "&-remove": {
          position: "relative",
          color: n,
          cursor: "pointer",
          transition: `all ${C}`,
          "&:hover": {
            color: e.colorLinkHover
          },
          "&::after": {
            position: "absolute",
            insert: `-${s}px -50%`,
            content: '""'
          }
        },
        [`&:not(${t}-list-content-item-disabled)`]: {
          "&:hover": {
            backgroundColor: e.controlItemBgHover,
            cursor: "pointer"
          },
          [`&${t}-list-content-item-checked:hover`]: {
            backgroundColor: u
          }
        },
        "&-checked": {
          backgroundColor: c
        },
        "&-disabled": {
          color: d,
          cursor: "not-allowed"
        }
      },
      // Do not change hover style when `oneWay` mode
      [`&-show-remove ${t}-list-content-item:not(${t}-list-content-item-disabled):hover`]: {
        background: "transparent",
        cursor: "default"
      }
    },
    "&-pagination": {
      padding: `${e.paddingXS}px 0`,
      textAlign: "end",
      borderTop: `${l}px ${y} ${o}`
    },
    "&-body-not-found": {
      flex: "none",
      width: "100%",
      margin: "auto 0",
      color: d,
      textAlign: "center"
    },
    "&-footer": {
      borderTop: `${l}px ${y} ${o}`
    },
    "&-checkbox": {
      lineHeight: 1
    }
  };
}, vGe = (e) => {
  const {
    antCls: t,
    iconCls: n,
    componentCls: o,
    transferHeaderHeight: l,
    marginXS: r,
    marginXXS: a,
    fontSizeIcon: i,
    fontSize: s,
    lineHeight: c
  } = e;
  return {
    [o]: _(_({}, nn(e)), {
      position: "relative",
      display: "flex",
      alignItems: "stretch",
      [`${o}-disabled`]: {
        [`${o}-list`]: {
          background: e.colorBgContainerDisabled
        }
      },
      [`${o}-list`]: pGe(e),
      [`${o}-operation`]: {
        display: "flex",
        flex: "none",
        flexDirection: "column",
        alignSelf: "center",
        margin: `0 ${r}px`,
        verticalAlign: "middle",
        [`${t}-btn`]: {
          display: "block",
          "&:first-child": {
            marginBottom: a
          },
          [n]: {
            fontSize: i
          }
        }
      },
      [`${t}-empty-image`]: {
        maxHeight: l / 2 - Math.round(s * c)
      }
    })
  };
}, mGe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl"
    }
  };
}, hGe = Zt("Transfer", (e) => {
  const {
    fontSize: t,
    lineHeight: n,
    lineWidth: o,
    controlHeightLG: l,
    controlHeight: r
  } = e, a = Math.round(t * n), i = l, s = r, c = Vt(e, {
    transferItemHeight: s,
    transferHeaderHeight: i,
    transferHeaderVerticalPadding: Math.ceil((i - o - a) / 2),
    transferItemPaddingVertical: (s - a) / 2
  });
  return [vGe(c), dGe(c), fGe(c), mGe(c)];
}, {
  listWidth: 180,
  listHeight: 200,
  listWidthLG: 250
}), gGe = () => ({
  id: String,
  prefixCls: String,
  dataSource: $n([]),
  disabled: Qe(),
  targetKeys: $n(),
  selectedKeys: $n(),
  render: Fe(),
  listStyle: zt([Function, Object], () => ({})),
  operationStyle: Nt(void 0),
  titles: $n(),
  operations: $n(),
  showSearch: Qe(!1),
  filterOption: Fe(),
  searchPlaceholder: String,
  notFoundContent: de.any,
  locale: Nt(),
  rowKey: Fe(),
  showSelectAll: Qe(),
  selectAllLabels: $n(),
  children: Fe(),
  oneWay: Qe(),
  pagination: zt([Object, Boolean]),
  status: At(),
  onChange: Fe(),
  onSelectChange: Fe(),
  onSearch: Fe(),
  onScroll: Fe(),
  "onUpdate:targetKeys": Fe(),
  "onUpdate:selectedKeys": Fe()
}), bGe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ATransfer",
  inheritAttrs: !1,
  props: gGe(),
  slots: Object,
  // emits: ['update:targetKeys', 'update:selectedKeys', 'change', 'search', 'scroll', 'selectChange'],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      slots: l,
      expose: r
    } = t;
    const {
      configProvider: a,
      prefixCls: i,
      direction: s
    } = bt("transfer", e), [c, u] = hGe(i), d = /* @__PURE__ */ H([]), f = /* @__PURE__ */ H([]), p = Ko(), m = sl.useInject(), v = O(() => Ja(m.status, e.status));
    pe(() => e.selectedKeys, () => {
      var U, te;
      d.value = ((U = e.selectedKeys) === null || U === void 0 ? void 0 : U.filter((J) => e.targetKeys.indexOf(J) === -1)) || [], f.value = ((te = e.selectedKeys) === null || te === void 0 ? void 0 : te.filter((J) => e.targetKeys.indexOf(J) > -1)) || [];
    }, {
      immediate: !0
    });
    const h = (U, te) => {
      const J = {
        notFoundContent: te("Transfer")
      }, re = Wo(l, e, "notFoundContent");
      return re && (J.notFoundContent = re), e.searchPlaceholder !== void 0 && (J.searchPlaceholder = e.searchPlaceholder), _(_(_({}, U), J), e.locale);
    }, g = (U) => {
      const {
        targetKeys: te = [],
        dataSource: J = []
      } = e, re = U === "right" ? d.value : f.value, oe = iGe(J), q = re.filter((ee) => !oe.has(ee)), K = mE(q), se = U === "right" ? q.concat(te) : te.filter((ee) => !K.has(ee)), Z = U === "right" ? "left" : "right";
      U === "right" ? d.value = [] : f.value = [], n("update:targetKeys", se), E(Z, []), n("change", se, U, q), p.onFieldChange();
    }, y = () => {
      g("left");
    }, b = () => {
      g("right");
    }, C = (U, te) => {
      E(U, te);
    }, w = (U) => C("left", U), x = (U) => C("right", U), E = (U, te) => {
      U === "left" ? (e.selectedKeys || (d.value = te), n("update:selectedKeys", [...te, ...f.value]), n("selectChange", te, /* @__PURE__ */ Wt(f.value))) : (e.selectedKeys || (f.value = te), n("update:selectedKeys", [...te, ...d.value]), n("selectChange", /* @__PURE__ */ Wt(d.value), te));
    }, I = (U, te) => {
      const J = te.target.value;
      n("search", U, J);
    }, T = (U) => {
      I("left", U);
    }, P = (U) => {
      I("right", U);
    }, k = (U) => {
      n("search", U, "");
    }, N = () => {
      k("left");
    }, R = () => {
      k("right");
    }, z = (U, te, J) => {
      const re = U === "left" ? [...d.value] : [...f.value], oe = re.indexOf(te);
      oe > -1 && re.splice(oe, 1), J && re.push(te), E(U, re);
    }, D = (U, te) => z("left", U, te), F = (U, te) => z("right", U, te), M = (U) => {
      const {
        targetKeys: te = []
      } = e, J = te.filter((re) => !U.includes(re));
      n("update:targetKeys", J), n("change", J, "left", [...U]);
    }, A = (U, te) => {
      n("scroll", U, te);
    }, L = (U) => {
      A("left", U);
    }, B = (U) => {
      A("right", U);
    }, V = (U, te) => typeof U == "function" ? U({
      direction: te
    }) : U, j = /* @__PURE__ */ H([]), W = /* @__PURE__ */ H([]);
    Ot(() => {
      const {
        dataSource: U,
        rowKey: te,
        targetKeys: J = []
      } = e, re = [], oe = new Array(J.length), q = mE(J);
      U.forEach((K) => {
        te && (K.key = te(K)), q.has(K.key) ? oe[q.get(K.key)] = K : re.push(K);
      }), j.value = re, W.value = oe;
    }), r({
      handleSelectChange: E
    });
    const Y = (U) => {
      var te, J, re, oe, q, K;
      const {
        disabled: se,
        operations: Z = [],
        showSearch: ee,
        listStyle: fe,
        operationStyle: me,
        filterOption: ge,
        showSelectAll: he,
        selectAllLabels: $e = [],
        oneWay: ne,
        pagination: ae,
        id: ce = p.id.value
      } = e, {
        class: xe,
        style: Te
      } = o, Se = l.children, be = !Se && ae, ie = a.renderEmpty, we = h(U, ie), {
        footer: Ne
      } = l, tt = e.render || l.render, Pe = f.value.length > 0, Re = d.value.length > 0, Le = ke(i.value, xe, {
        [`${i.value}-disabled`]: se,
        [`${i.value}-customize-list`]: !!Se,
        [`${i.value}-rtl`]: s.value === "rtl"
      }, Ll(i.value, v.value, m.hasFeedback), u.value), Ue = e.titles, Ae = (re = (te = Ue && Ue[0]) !== null && te !== void 0 ? te : (J = l.leftTitle) === null || J === void 0 ? void 0 : J.call(l)) !== null && re !== void 0 ? re : (we.titles || ["", ""])[0], De = (K = (oe = Ue && Ue[1]) !== null && oe !== void 0 ? oe : (q = l.rightTitle) === null || q === void 0 ? void 0 : q.call(l)) !== null && K !== void 0 ? K : (we.titles || ["", ""])[1];
      return $("div", Q(Q({}, o), {}, {
        class: Le,
        style: Te,
        id: ce
      }), [$(HR, Q({
        key: "leftList",
        prefixCls: `${i.value}-list`,
        dataSource: j.value,
        filterOption: ge,
        style: V(fe, "left"),
        checkedKeys: d.value,
        handleFilter: T,
        handleClear: N,
        onItemSelect: D,
        onItemSelectAll: w,
        renderItem: tt,
        showSearch: ee,
        renderList: Se,
        onScroll: L,
        disabled: se,
        direction: s.value === "rtl" ? "right" : "left",
        showSelectAll: he,
        selectAllLabel: $e[0] || l.leftSelectAllLabel,
        pagination: be
      }, we), {
        titleText: () => Ae,
        footer: Ne
      }), $(kP, {
        key: "operation",
        class: `${i.value}-operation`,
        rightActive: Re,
        rightArrowText: Z[0],
        moveToRight: b,
        leftActive: Pe,
        leftArrowText: Z[1],
        moveToLeft: y,
        style: me,
        disabled: se,
        direction: s.value,
        oneWay: ne
      }, null), $(HR, Q({
        key: "rightList",
        prefixCls: `${i.value}-list`,
        dataSource: W.value,
        filterOption: ge,
        style: V(fe, "right"),
        checkedKeys: f.value,
        handleFilter: P,
        handleClear: R,
        onItemSelect: F,
        onItemSelectAll: x,
        onItemRemove: M,
        renderItem: tt,
        showSearch: ee,
        renderList: Se,
        onScroll: B,
        disabled: se,
        direction: s.value === "rtl" ? "left" : "right",
        showSelectAll: he,
        selectAllLabel: $e[1] || l.rightSelectAllLabel,
        showRemove: ne,
        pagination: be
      }, we), {
        titleText: () => De,
        footer: Ne
      })]);
    };
    return () => c($(sd, {
      componentName: "Transfer",
      defaultLocale: rr.Transfer,
      children: Y
    }, null));
  }
}), yGe = po(bGe);
function ZG(e) {
  return Array.isArray(e) ? e : e !== void 0 ? [e] : [];
}
function SGe(e) {
  const {
    label: t,
    value: n,
    children: o
  } = e || {}, l = n || "value";
  return {
    _title: t ? [t] : ["title", "label"],
    value: l,
    key: l,
    children: o || "children"
  };
}
function hE(e) {
  return e.disabled || e.disableCheckbox || e.checkable === !1;
}
function CGe(e, t) {
  const n = [];
  function o(l) {
    l.forEach((r) => {
      n.push(r[t.value]);
      const a = r[t.children];
      a && o(a);
    });
  }
  return o(e), n;
}
function gE(e) {
  return e == null;
}
const QG = Symbol("TreeSelectContextPropsKey");
function wGe(e) {
  return at(QG, e);
}
function $Ge() {
  return ze(QG, {});
}
const xGe = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
}, EGe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: !1,
  setup(e, t) {
    let {
      slots: n,
      expose: o
    } = t;
    const l = Oh(), r = mS(), a = $Ge(), i = /* @__PURE__ */ H(), s = PI(() => a.treeData, [() => l.open, () => a.treeData], (w) => w[0]), c = O(() => {
      const {
        checkable: w,
        halfCheckedKeys: x,
        checkedKeys: E
      } = r;
      return w ? {
        checked: E,
        halfChecked: x
      } : null;
    });
    pe(() => l.open, () => {
      Ke(() => {
        var w;
        l.open && !l.multiple && r.checkedKeys.length && ((w = i.value) === null || w === void 0 || w.scrollTo({
          key: r.checkedKeys[0]
        }));
      });
    }, {
      immediate: !0,
      flush: "post"
    });
    const u = O(() => String(l.searchValue).toLowerCase()), d = (w) => u.value ? String(w[r.treeNodeFilterProp]).toLowerCase().includes(u.value) : !1, f = /* @__PURE__ */ Ce(r.treeDefaultExpandedKeys), p = /* @__PURE__ */ Ce(null);
    pe(() => l.searchValue, () => {
      l.searchValue && (p.value = CGe(/* @__PURE__ */ Wt(a.treeData), /* @__PURE__ */ Wt(a.fieldNames)));
    }, {
      immediate: !0
    });
    const m = O(() => r.treeExpandedKeys ? r.treeExpandedKeys.slice() : l.searchValue ? p.value : f.value), v = (w) => {
      var x;
      f.value = w, p.value = w, (x = r.onTreeExpand) === null || x === void 0 || x.call(r, w);
    }, h = (w) => {
      w.preventDefault();
    }, g = (w, x) => {
      let {
        node: E
      } = x;
      var I, T;
      const {
        checkable: P,
        checkedKeys: k
      } = r;
      P && hE(E) || ((I = a.onSelect) === null || I === void 0 || I.call(a, E.key, {
        selected: !k.includes(E.key)
      }), l.multiple || (T = l.toggleOpen) === null || T === void 0 || T.call(l, !1));
    }, y = /* @__PURE__ */ H(null), b = O(() => r.keyEntities[y.value]), C = (w) => {
      y.value = w;
    };
    return o({
      scrollTo: function() {
        for (var w, x, E = arguments.length, I = new Array(E), T = 0; T < E; T++)
          I[T] = arguments[T];
        return (x = (w = i.value) === null || w === void 0 ? void 0 : w.scrollTo) === null || x === void 0 ? void 0 : x.call(w, ...I);
      },
      onKeydown: (w) => {
        var x;
        const {
          which: E
        } = w;
        switch (E) {
          case ot.UP:
          case ot.DOWN:
          case ot.LEFT:
          case ot.RIGHT:
            (x = i.value) === null || x === void 0 || x.onKeydown(w);
            break;
          case ot.ENTER: {
            if (b.value) {
              const {
                selectable: I,
                value: T
              } = b.value.node || {};
              I !== !1 && g(null, {
                node: {
                  key: y.value
                },
                selected: !r.checkedKeys.includes(T)
              });
            }
            break;
          }
          case ot.ESC:
            l.toggleOpen(!1);
        }
      },
      onKeyup: () => {
      }
    }), () => {
      var w;
      const {
        prefixCls: x,
        multiple: E,
        searchValue: I,
        open: T,
        notFoundContent: P = (w = n.notFoundContent) === null || w === void 0 ? void 0 : w.call(n)
      } = l, {
        listHeight: k,
        listItemHeight: N,
        virtual: R,
        dropdownMatchSelectWidth: z,
        treeExpandAction: D
      } = a, {
        checkable: F,
        treeDefaultExpandAll: M,
        treeIcon: A,
        showTreeIcon: L,
        switcherIcon: B,
        treeLine: V,
        loadData: j,
        treeLoadedKeys: W,
        treeMotion: Y,
        onTreeLoad: U,
        checkedKeys: te
      } = r;
      if (s.value.length === 0)
        return $("div", {
          role: "listbox",
          class: `${x}-empty`,
          onMousedown: h
        }, [P]);
      const J = {
        fieldNames: a.fieldNames
      };
      return W && (J.loadedKeys = W), m.value && (J.expandedKeys = m.value), $("div", {
        onMousedown: h
      }, [b.value && T && $("span", {
        style: xGe,
        "aria-live": "assertive"
      }, [b.value.node.value]), $(VG, Q(Q({
        ref: i,
        focusable: !1,
        prefixCls: `${x}-tree`,
        treeData: s.value,
        height: k,
        itemHeight: N,
        virtual: R !== !1 && z !== !1,
        multiple: E,
        icon: A,
        showIcon: L,
        switcherIcon: B,
        showLine: V,
        loadData: I ? null : j,
        motion: Y,
        activeKey: y.value,
        checkable: F,
        checkStrictly: !0,
        checkedKeys: c.value,
        selectedKeys: F ? [] : te,
        defaultExpandAll: M
      }, J), {}, {
        onActiveChange: C,
        onSelect: g,
        onCheck: g,
        onExpand: v,
        onLoad: U,
        filterTreeNode: d,
        expandAction: D
      }), _(_({}, n), {
        checkable: r.customSlots.treeCheckable
      }))]);
    };
  }
}), OGe = "SHOW_ALL", eY = "SHOW_PARENT", NP = "SHOW_CHILD";
function KR(e, t, n, o) {
  const l = new Set(e);
  return t === NP ? e.filter((r) => {
    const a = n[r];
    return !(a && a.children && a.children.some((i) => {
      let {
        node: s
      } = i;
      return l.has(s[o.value]);
    }) && a.children.every((i) => {
      let {
        node: s
      } = i;
      return hE(s) || l.has(s[o.value]);
    }));
  }) : t === eY ? e.filter((r) => {
    const a = n[r], i = a ? a.parent : null;
    return !(i && !hE(i.node) && l.has(i.key));
  }) : e;
}
const Fp = () => null;
Fp.inheritAttrs = !1;
Fp.displayName = "ATreeSelectNode";
Fp.isTreeSelectNode = !0;
var _Ge = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function IGe(e) {
  return e && e.type && e.type.isTreeSelectNode;
}
function TGe(e) {
  function t() {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return mo(n).map((o) => {
      var l, r, a;
      if (!IGe(o))
        return bn(!o, "TreeSelect/TreeSelectNode can only accept TreeSelectNode as children."), null;
      const i = o.children || {}, s = o.key, c = {};
      for (const [E, I] of Object.entries(o.props))
        c[Tp(E)] = I;
      const {
        isLeaf: u,
        checkable: d,
        selectable: f,
        disabled: p,
        disableCheckbox: m
      } = c, v = {
        isLeaf: u || u === "" || void 0,
        checkable: d || d === "" || void 0,
        selectable: f || f === "" || void 0,
        disabled: p || p === "" || void 0,
        disableCheckbox: m || m === "" || void 0
      }, h = _(_({}, c), v), {
        title: g = (l = i.title) === null || l === void 0 ? void 0 : l.call(i, h),
        switcherIcon: y = (r = i.switcherIcon) === null || r === void 0 ? void 0 : r.call(i, h)
      } = c, b = _Ge(c, ["title", "switcherIcon"]), C = (a = i.default) === null || a === void 0 ? void 0 : a.call(i), w = _(_(_({}, b), {
        title: g,
        switcherIcon: y,
        key: s,
        isLeaf: u
      }), v), x = t(C);
      return x.length && (w.children = x), w;
    });
  }
  return t(e);
}
function bE(e) {
  if (!e)
    return e;
  const t = _({}, e);
  return "props" in t || Object.defineProperty(t, "props", {
    get() {
      return bn(!1, "New `vc-tree-select` not support return node instance as argument anymore. Please consider to remove `props` access."), t;
    }
  }), t;
}
function PGe(e, t, n, o, l, r) {
  let a = null, i = null;
  function s() {
    function c(u) {
      let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "0", f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      return u.map((p, m) => {
        const v = `${d}-${m}`, h = p[r.value], g = n.includes(h), y = c(p[r.children] || [], v, g), b = $(Fp, p, {
          default: () => [y.map((C) => C.node)]
        });
        if (t === h && (a = b), g) {
          const C = {
            pos: v,
            node: b,
            children: y
          };
          return f || i.push(C), C;
        }
        return null;
      }).filter((p) => p);
    }
    i || (i = [], c(o), i.sort((u, d) => {
      let {
        node: {
          props: {
            value: f
          }
        }
      } = u, {
        node: {
          props: {
            value: p
          }
        }
      } = d;
      const m = n.indexOf(f), v = n.indexOf(p);
      return m - v;
    }));
  }
  Object.defineProperty(e, "triggerNode", {
    get() {
      return bn(!1, "`triggerNode` is deprecated. Please consider decoupling data with node."), s(), a;
    }
  }), Object.defineProperty(e, "allCheckedNodes", {
    get() {
      return bn(!1, "`allCheckedNodes` is deprecated. Please consider decoupling data with node."), s(), l ? i : i.map((c) => {
        let {
          node: u
        } = c;
        return u;
      });
    }
  });
}
function kGe(e, t) {
  let {
    id: n,
    pId: o,
    rootPId: l
  } = t;
  const r = {}, a = [];
  return e.map((s) => {
    const c = _({}, s), u = c[n];
    return r[u] = c, c.key = c.key || u, c;
  }).forEach((s) => {
    const c = s[o], u = r[c];
    u && (u.children = u.children || [], u.children.push(s)), (c === l || !u && l === null) && a.push(s);
  }), a;
}
function NGe(e, t, n) {
  const o = /* @__PURE__ */ Ce();
  return pe([n, e, t], () => {
    const l = n.value;
    e.value ? o.value = n.value ? kGe(/* @__PURE__ */ Wt(e.value), _({
      id: "id",
      pId: "pId",
      rootPId: null
    }, l !== !0 ? l : {})) : (/* @__PURE__ */ Wt(e.value)).slice() : o.value = TGe(/* @__PURE__ */ Wt(t.value));
  }, {
    immediate: !0,
    deep: !0
  }), o;
}
const MGe = (e) => {
  const t = /* @__PURE__ */ Ce({
    valueLabels: /* @__PURE__ */ new Map()
  }), n = /* @__PURE__ */ Ce();
  return pe(e, () => {
    n.value = /* @__PURE__ */ Wt(e.value);
  }, {
    immediate: !0
  }), [O(() => {
    const {
      valueLabels: l
    } = t.value, r = /* @__PURE__ */ new Map(), a = n.value.map((i) => {
      var s;
      const {
        value: c
      } = i, u = (s = i.label) !== null && s !== void 0 ? s : l.get(c);
      return r.set(c, u), _(_({}, i), {
        label: u
      });
    });
    return t.value.valueLabels = r, a;
  })];
}, AGe = (e, t) => {
  const n = /* @__PURE__ */ Ce(/* @__PURE__ */ new Map()), o = /* @__PURE__ */ Ce({});
  return Ot(() => {
    const l = t.value, r = Lh(e.value, {
      fieldNames: l,
      initWrapper: (a) => _(_({}, a), {
        valueEntities: /* @__PURE__ */ new Map()
      }),
      processEntity: (a, i) => {
        const s = a.node[l.value];
        if (process.env.NODE_ENV !== "production") {
          const c = a.node.key;
          bn(!gE(s), "TreeNode `value` is invalidate: undefined"), bn(!i.valueEntities.has(s), `Same \`value\` exist in the tree: ${s}`), bn(!c || String(c) === String(s), `\`key\` or \`value\` with TreeNode must be the same or you can remove one of them. key: ${c}, value: ${s}.`);
        }
        i.valueEntities.set(s, a);
      }
    });
    n.value = r.valueEntities, o.value = r.keyEntities;
  }), {
    valueEntities: n,
    keyEntities: o
  };
}, RGe = (e, t, n, o, l, r) => {
  const a = /* @__PURE__ */ Ce([]), i = /* @__PURE__ */ Ce([]);
  return Ot(() => {
    let s = e.value.map((d) => {
      let {
        value: f
      } = d;
      return f;
    }), c = t.value.map((d) => {
      let {
        value: f
      } = d;
      return f;
    });
    const u = s.filter((d) => !o.value[d]);
    n.value && ({
      checkedKeys: s,
      halfCheckedKeys: c
    } = oa(s, !0, o.value, l.value, r.value)), a.value = Array.from(/* @__PURE__ */ new Set([...u, ...s])), i.value = c;
  }), [a, i];
}, DGe = (e, t, n) => {
  let {
    treeNodeFilterProp: o,
    filterTreeNode: l,
    fieldNames: r
  } = n;
  return O(() => {
    const {
      children: a
    } = r.value, i = t.value, s = o == null ? void 0 : o.value;
    if (!i || l.value === !1)
      return e.value;
    let c;
    if (typeof l.value == "function")
      c = l.value;
    else {
      const d = i.toUpperCase();
      c = (f, p) => {
        const m = p[s];
        return String(m).toUpperCase().includes(d);
      };
    }
    function u(d) {
      let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      const p = [];
      for (let m = 0, v = d.length; m < v; m++) {
        const h = d[m], g = h[a], y = f || c(i, bE(h)), b = u(g || [], y);
        (y || b.length) && p.push(_(_({}, h), {
          [a]: b
        }));
      }
      return p;
    }
    return u(e.value);
  });
};
function LGe(e) {
  const {
    searchPlaceholder: t,
    treeCheckStrictly: n,
    treeCheckable: o,
    labelInValue: l,
    value: r,
    multiple: a
  } = e;
  bn(!t, "`searchPlaceholder` has been removed, please use `placeholder` instead"), n && l === !1 && bn(!1, "`treeCheckStrictly` will force set `labelInValue` to `true`."), (l || n) && bn(ZG(r).every((i) => i && typeof i == "object" && "value" in i), "Invalid prop `value` supplied to `TreeSelect`. You should use { label: string, value: string | number } or [{ label: string, value: string | number }] instead."), n || a || o ? bn(!r || Array.isArray(r), "`value` should be an array when `TreeSelect` is checkable or multiple.") : bn(!Array.isArray(r), "`value` should not be array when `TreeSelect` is single mode.");
}
function tY() {
  return _(_({}, pn(hS(), ["mode"])), {
    prefixCls: String,
    id: String,
    value: {
      type: [String, Number, Object, Array]
    },
    defaultValue: {
      type: [String, Number, Object, Array]
    },
    onChange: {
      type: Function
    },
    searchValue: String,
    /** @deprecated Use `searchValue` instead */
    inputValue: String,
    onSearch: {
      type: Function
    },
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    filterTreeNode: {
      type: [Boolean, Function],
      default: void 0
    },
    treeNodeFilterProp: String,
    // >>> Select
    onSelect: Function,
    onDeselect: Function,
    showCheckedStrategy: {
      type: String
    },
    treeNodeLabelProp: String,
    fieldNames: {
      type: Object
    },
    // >>> Mode
    multiple: {
      type: Boolean,
      default: void 0
    },
    treeCheckable: {
      type: Boolean,
      default: void 0
    },
    treeCheckStrictly: {
      type: Boolean,
      default: void 0
    },
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    // >>> Data
    treeData: {
      type: Array
    },
    treeDataSimpleMode: {
      type: [Boolean, Object],
      default: void 0
    },
    loadData: {
      type: Function
    },
    treeLoadedKeys: {
      type: Array
    },
    onTreeLoad: {
      type: Function
    },
    // >>> Expanded
    treeDefaultExpandAll: {
      type: Boolean,
      default: void 0
    },
    treeExpandedKeys: {
      type: Array
    },
    treeDefaultExpandedKeys: {
      type: Array
    },
    onTreeExpand: {
      type: Function
    },
    // >>> Options
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    onDropdownVisibleChange: {
      type: Function
    },
    // >>> Tree
    treeLine: {
      type: [Boolean, Object],
      default: void 0
    },
    treeIcon: de.any,
    showTreeIcon: {
      type: Boolean,
      default: void 0
    },
    switcherIcon: de.any,
    treeMotion: de.any,
    children: Array,
    treeExpandAction: String,
    showArrow: {
      type: Boolean,
      default: void 0
    },
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: de.any,
    maxTagPlaceholder: {
      type: Function
    },
    dropdownPopupAlign: de.any,
    customSlots: Object
  });
}
function BGe(e) {
  return !e || typeof e != "object";
}
const FGe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "TreeSelect",
  inheritAttrs: !1,
  props: sn(tY(), {
    treeNodeFilterProp: "value",
    autoClearSearchValue: !0,
    showCheckedStrategy: NP,
    listHeight: 200,
    listItemHeight: 20,
    prefixCls: "vc-tree-select"
  }),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: l
    } = t;
    const r = NI(/* @__PURE__ */ ft(e, "id")), a = O(() => e.treeCheckable && !e.treeCheckStrictly), i = O(() => e.treeCheckable || e.treeCheckStrictly), s = O(() => e.treeCheckStrictly || e.labelInValue), c = O(() => i.value || e.multiple);
    process.env.NODE_ENV !== "production" && Ot(() => {
      LGe(e);
    });
    const u = O(() => SGe(e.fieldNames)), [d, f] = ro("", {
      value: O(() => e.searchValue !== void 0 ? e.searchValue : e.inputValue),
      postState: (ce) => ce || ""
    }), p = (ce) => {
      var xe;
      f(ce), (xe = e.onSearch) === null || xe === void 0 || xe.call(e, ce);
    }, m = NGe(/* @__PURE__ */ ft(e, "treeData"), /* @__PURE__ */ ft(e, "children"), /* @__PURE__ */ ft(e, "treeDataSimpleMode")), {
      keyEntities: v,
      valueEntities: h
    } = AGe(m, u), g = (ce) => {
      const xe = [], Te = [];
      return ce.forEach((Se) => {
        h.value.has(Se) ? Te.push(Se) : xe.push(Se);
      }), {
        missingRawValues: xe,
        existRawValues: Te
      };
    }, y = DGe(m, d, {
      fieldNames: u,
      treeNodeFilterProp: /* @__PURE__ */ ft(e, "treeNodeFilterProp"),
      filterTreeNode: /* @__PURE__ */ ft(e, "filterTreeNode")
    }), b = (ce) => {
      if (ce) {
        if (e.treeNodeLabelProp)
          return ce[e.treeNodeLabelProp];
        const {
          _title: xe
        } = u.value;
        for (let Te = 0; Te < xe.length; Te += 1) {
          const Se = ce[xe[Te]];
          if (Se !== void 0)
            return Se;
        }
      }
    }, C = (ce) => ZG(ce).map((Te) => BGe(Te) ? {
      value: Te
    } : Te), w = (ce) => C(ce).map((Te) => {
      let {
        label: Se
      } = Te;
      const {
        value: be,
        halfChecked: ie
      } = Te;
      let we;
      const Ne = h.value.get(be);
      return Ne && (Se = Se != null ? Se : b(Ne.node), we = Ne.node.disabled), {
        label: Se,
        value: be,
        halfChecked: ie,
        disabled: we
      };
    }), [x, E] = ro(e.defaultValue, {
      value: /* @__PURE__ */ ft(e, "value")
    }), I = O(() => C(x.value)), T = /* @__PURE__ */ Ce([]), P = /* @__PURE__ */ Ce([]);
    Ot(() => {
      const ce = [], xe = [];
      I.value.forEach((Te) => {
        Te.halfChecked ? xe.push(Te) : ce.push(Te);
      }), T.value = ce, P.value = xe;
    });
    const k = O(() => T.value.map((ce) => ce.value)), {
      maxLevel: N,
      levelEntities: R
    } = zS(v), [z, D] = RGe(T, P, a, v, N, R), F = O(() => {
      const Te = KR(z.value, e.showCheckedStrategy, v.value, u.value).map((ie) => {
        var we, Ne, tt;
        return (tt = (Ne = (we = v.value[ie]) === null || we === void 0 ? void 0 : we.node) === null || Ne === void 0 ? void 0 : Ne[u.value.value]) !== null && tt !== void 0 ? tt : ie;
      }).map((ie) => {
        const we = T.value.find((Ne) => Ne.value === ie);
        return {
          value: ie,
          label: we == null ? void 0 : we.label
        };
      }), Se = w(Te), be = Se[0];
      return !c.value && be && gE(be.value) && gE(be.label) ? [] : Se.map((ie) => {
        var we;
        return _(_({}, ie), {
          label: (we = ie.label) !== null && we !== void 0 ? we : ie.value
        });
      });
    }), [M] = MGe(F), A = (ce, xe, Te) => {
      const Se = w(ce);
      if (E(Se), e.autoClearSearchValue && f(""), e.onChange) {
        let be = ce;
        a.value && (be = KR(ce, e.showCheckedStrategy, v.value, u.value).map((Ae) => {
          const De = h.value.get(Ae);
          return De ? De.node[u.value.value] : Ae;
        }));
        const {
          triggerValue: ie,
          selected: we
        } = xe || {
          triggerValue: void 0,
          selected: void 0
        };
        let Ne = be;
        if (e.treeCheckStrictly) {
          const Ue = P.value.filter((Ae) => !be.includes(Ae.value));
          Ne = [...Ne, ...Ue];
        }
        const tt = w(Ne), Pe = {
          // [Legacy] Always return as array contains label & value
          preValue: T.value,
          triggerValue: ie
        };
        let Re = !0;
        (e.treeCheckStrictly || Te === "selection" && !we) && (Re = !1), PGe(Pe, ie, ce, m.value, Re, u.value), i.value ? Pe.checked = we : Pe.selected = we;
        const Le = s.value ? tt : tt.map((Ue) => Ue.value);
        e.onChange(c.value ? Le : Le[0], s.value ? null : tt.map((Ue) => Ue.label), Pe);
      }
    }, L = (ce, xe) => {
      let {
        selected: Te,
        source: Se
      } = xe;
      var be, ie, we;
      const Ne = /* @__PURE__ */ Wt(v.value), tt = /* @__PURE__ */ Wt(h.value), Pe = Ne[ce], Re = Pe == null ? void 0 : Pe.node, Le = (be = Re == null ? void 0 : Re[u.value.value]) !== null && be !== void 0 ? be : ce;
      if (!c.value)
        A([Le], {
          selected: !0,
          triggerValue: Le
        }, "option");
      else {
        let Ue = Te ? [...k.value, Le] : z.value.filter((Ae) => Ae !== Le);
        if (a.value) {
          const {
            missingRawValues: Ae,
            existRawValues: De
          } = g(Ue), _e = De.map((dt) => tt.get(dt).key);
          let Ze;
          Te ? {
            checkedKeys: Ze
          } = oa(_e, !0, Ne, N.value, R.value) : {
            checkedKeys: Ze
          } = oa(_e, {
            halfCheckedKeys: D.value
          }, Ne, N.value, R.value), Ue = [...Ae, ...Ze.map((dt) => Ne[dt].node[u.value.value])];
        }
        A(Ue, {
          selected: Te,
          triggerValue: Le
        }, Se || "option");
      }
      Te || !c.value ? (ie = e.onSelect) === null || ie === void 0 || ie.call(e, Le, bE(Re)) : (we = e.onDeselect) === null || we === void 0 || we.call(e, Le, bE(Re));
    }, B = (ce) => {
      if (e.onDropdownVisibleChange) {
        const xe = {};
        Object.defineProperty(xe, "documentClickClose", {
          get() {
            return bn(!1, "Second param of `onDropdownVisibleChange` has been removed."), !1;
          }
        }), e.onDropdownVisibleChange(ce, xe);
      }
    }, V = (ce, xe) => {
      const Te = ce.map((Se) => Se.value);
      if (xe.type === "clear") {
        A(Te, {}, "selection");
        return;
      }
      xe.values.length && L(xe.values[0].value, {
        selected: !1,
        source: "selection"
      });
    }, {
      treeNodeFilterProp: j,
      // Data
      loadData: W,
      treeLoadedKeys: Y,
      onTreeLoad: U,
      // Expanded
      treeDefaultExpandAll: te,
      treeExpandedKeys: J,
      treeDefaultExpandedKeys: re,
      onTreeExpand: oe,
      // Options
      virtual: q,
      listHeight: K,
      listItemHeight: se,
      // Tree
      treeLine: Z,
      treeIcon: ee,
      showTreeIcon: fe,
      switcherIcon: me,
      treeMotion: ge,
      customSlots: he,
      dropdownMatchSelectWidth: $e,
      treeExpandAction: ne
    } = /* @__PURE__ */ to(e);
    bNe(uy({
      checkable: i,
      loadData: W,
      treeLoadedKeys: Y,
      onTreeLoad: U,
      checkedKeys: z,
      halfCheckedKeys: D,
      treeDefaultExpandAll: te,
      treeExpandedKeys: J,
      treeDefaultExpandedKeys: re,
      onTreeExpand: oe,
      treeIcon: ee,
      treeMotion: ge,
      showTreeIcon: fe,
      switcherIcon: me,
      treeLine: Z,
      treeNodeFilterProp: j,
      keyEntities: v,
      customSlots: he
    })), wGe(uy({
      virtual: q,
      listHeight: K,
      listItemHeight: se,
      treeData: y,
      fieldNames: u,
      onSelect: L,
      dropdownMatchSelectWidth: $e,
      treeExpandAction: ne
    }));
    const ae = /* @__PURE__ */ H();
    return o({
      focus() {
        var ce;
        (ce = ae.value) === null || ce === void 0 || ce.focus();
      },
      blur() {
        var ce;
        (ce = ae.value) === null || ce === void 0 || ce.blur();
      },
      scrollTo(ce) {
        var xe;
        (xe = ae.value) === null || xe === void 0 || xe.scrollTo(ce);
      }
    }), () => {
      var ce;
      const xe = pn(e, [
        "id",
        "prefixCls",
        "customSlots",
        // Value
        "value",
        "defaultValue",
        "onChange",
        "onSelect",
        "onDeselect",
        // Search
        "searchValue",
        "inputValue",
        "onSearch",
        "autoClearSearchValue",
        "filterTreeNode",
        "treeNodeFilterProp",
        // Selector
        "showCheckedStrategy",
        "treeNodeLabelProp",
        //  Mode
        "multiple",
        "treeCheckable",
        "treeCheckStrictly",
        "labelInValue",
        // FieldNames
        "fieldNames",
        // Data
        "treeDataSimpleMode",
        "treeData",
        "children",
        "loadData",
        "treeLoadedKeys",
        "onTreeLoad",
        // Expanded
        "treeDefaultExpandAll",
        "treeExpandedKeys",
        "treeDefaultExpandedKeys",
        "onTreeExpand",
        // Options
        "virtual",
        "listHeight",
        "listItemHeight",
        "onDropdownVisibleChange",
        // Tree
        "treeLine",
        "treeIcon",
        "showTreeIcon",
        "switcherIcon",
        "treeMotion"
      ]);
      return $(TI, Q(Q(Q({
        ref: ae
      }, n), xe), {}, {
        id: r,
        prefixCls: e.prefixCls,
        mode: c.value ? "multiple" : void 0,
        displayValues: M.value,
        onDisplayValuesChange: V,
        searchValue: d.value,
        onSearch: p,
        OptionList: EGe,
        emptyOptions: !m.value.length,
        onDropdownVisibleChange: B,
        tagRender: e.tagRender || l.tagRender,
        dropdownMatchSelectWidth: (ce = e.dropdownMatchSelectWidth) !== null && ce !== void 0 ? ce : !0
      }), l);
    };
  }
}), VGe = (e) => {
  const {
    componentCls: t,
    treePrefixCls: n,
    colorBgElevated: o
  } = e, l = `.${n}`;
  return [
    // ======================================================
    // ==                     Dropdown                     ==
    // ======================================================
    {
      [`${t}-dropdown`]: [
        {
          padding: `${e.paddingXS}px ${e.paddingXS / 2}px`
        },
        // ====================== Tree ======================
        HG(n, Vt(e, {
          colorBgContainer: o
        })),
        {
          [l]: {
            borderRadius: 0,
            "&-list-holder-inner": {
              alignItems: "stretch",
              [`${l}-treenode`]: {
                [`${l}-node-content-wrapper`]: {
                  flex: "auto"
                }
              }
            }
          }
        },
        // ==================== Checkbox ====================
        KS(`${n}-checkbox`, e),
        // ====================== RTL =======================
        {
          "&-rtl": {
            direction: "rtl",
            [`${l}-switcher${l}-switcher_close`]: {
              [`${l}-switcher-icon svg`]: {
                transform: "rotate(90deg)"
              }
            }
          }
        }
      ]
    }
  ];
};
function zGe(e, t) {
  return Zt("TreeSelect", (n) => {
    const o = Vt(n, {
      treePrefixCls: t.value
    });
    return [VGe(o)];
  })(e);
}
const UR = (e, t, n) => n !== void 0 ? n : `${e}-${t}`;
function HGe() {
  return _(_({}, pn(tY(), ["showTreeIcon", "treeMotion", "inputIcon", "getInputElement", "treeLine", "customSlots"])), {
    suffixIcon: de.any,
    size: At(),
    bordered: Qe(),
    treeLine: zt([Boolean, Object]),
    replaceFields: Nt(),
    placement: At(),
    status: At(),
    popupClassName: String,
    /** @deprecated Please use `popupClassName` instead */
    dropdownClassName: String,
    "onUpdate:value": Fe(),
    "onUpdate:treeExpandedKeys": Fe(),
    "onUpdate:searchValue": Fe()
  });
}
const s$ = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ATreeSelect",
  inheritAttrs: !1,
  props: sn(HGe(), {
    choiceTransitionName: "",
    listHeight: 256,
    treeIcon: !1,
    listItemHeight: 26,
    bordered: !0
  }),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: l,
      emit: r
    } = t;
    bn(!(e.treeData === void 0 && o.default), "`children` of TreeSelect is deprecated. Please use `treeData` instead."), un(e.multiple !== !1 || !e.treeCheckable, "TreeSelect", "`multiple` will always be `true` when `treeCheckable` is true"), un(e.replaceFields === void 0, "TreeSelect", "`replaceFields` is deprecated, please use fieldNames instead"), un(!e.dropdownClassName, "TreeSelect", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
    const a = Ko(), i = sl.useInject(), s = O(() => Ja(i.status, e.status)), {
      prefixCls: c,
      renderEmpty: u,
      direction: d,
      virtual: f,
      dropdownMatchSelectWidth: p,
      size: m,
      getPopupContainer: v,
      getPrefixCls: h,
      disabled: g
    } = bt("select", e), {
      compactSize: y,
      compactItemClassnames: b
    } = Rc(c, d), C = O(() => y.value || m.value), w = Cr(), x = O(() => {
      var Y;
      return (Y = g.value) !== null && Y !== void 0 ? Y : w.value;
    }), E = O(() => h()), I = O(() => e.placement !== void 0 ? e.placement : d.value === "rtl" ? "bottomRight" : "bottomLeft"), T = O(() => UR(E.value, xI(I.value), e.transitionName)), P = O(() => UR(E.value, "", e.choiceTransitionName)), k = O(() => h("select-tree", e.prefixCls)), N = O(() => h("tree-select", e.prefixCls)), [R, z] = HI(c), [D] = zGe(N, k), F = O(() => ke(e.popupClassName || e.dropdownClassName, `${N.value}-dropdown`, {
      [`${N.value}-dropdown-rtl`]: d.value === "rtl"
    }, z.value)), M = O(() => !!(e.treeCheckable || e.multiple)), A = O(() => e.showArrow !== void 0 ? e.showArrow : e.loading || !M.value), L = /* @__PURE__ */ H();
    l({
      focus() {
        var Y, U;
        (U = (Y = L.value).focus) === null || U === void 0 || U.call(Y);
      },
      blur() {
        var Y, U;
        (U = (Y = L.value).blur) === null || U === void 0 || U.call(Y);
      }
    });
    const B = function() {
      for (var Y = arguments.length, U = new Array(Y), te = 0; te < Y; te++)
        U[te] = arguments[te];
      r("update:value", U[0]), r("change", ...U), a.onFieldChange();
    }, V = (Y) => {
      r("update:treeExpandedKeys", Y), r("treeExpand", Y);
    }, j = (Y) => {
      r("update:searchValue", Y), r("search", Y);
    }, W = (Y) => {
      r("blur", Y), a.onFieldBlur();
    };
    return () => {
      var Y, U, te;
      const {
        notFoundContent: J = (Y = o.notFoundContent) === null || Y === void 0 ? void 0 : Y.call(o),
        prefixCls: re,
        bordered: oe,
        listHeight: q,
        listItemHeight: K,
        multiple: se,
        treeIcon: Z,
        treeLine: ee,
        showArrow: fe,
        switcherIcon: me = (U = o.switcherIcon) === null || U === void 0 ? void 0 : U.call(o),
        fieldNames: ge = e.replaceFields,
        id: he = a.id.value,
        placeholder: $e = (te = o.placeholder) === null || te === void 0 ? void 0 : te.call(o)
      } = e, {
        isFormItemInput: ne,
        hasFeedback: ae,
        feedbackIcon: ce
      } = i, {
        suffixIcon: xe,
        removeIcon: Te,
        clearIcon: Se
      } = BI(_(_({}, e), {
        multiple: M.value,
        showArrow: A.value,
        hasFeedback: ae,
        feedbackIcon: ce,
        prefixCls: c.value
      }), o);
      let be;
      J !== void 0 ? be = J : be = u("Select");
      const ie = pn(e, ["suffixIcon", "itemIcon", "removeIcon", "clearIcon", "switcherIcon", "bordered", "status", "onUpdate:value", "onUpdate:treeExpandedKeys", "onUpdate:searchValue"]), we = ke(!re && N.value, {
        [`${c.value}-lg`]: C.value === "large",
        [`${c.value}-sm`]: C.value === "small",
        [`${c.value}-rtl`]: d.value === "rtl",
        [`${c.value}-borderless`]: !oe,
        [`${c.value}-in-form-item`]: ne
      }, Ll(c.value, s.value, ae), b.value, n.class, z.value), Ne = {};
      return e.treeData === void 0 && o.default && (Ne.children = Fn(o.default())), R(D($(FGe, Q(Q(Q(Q({}, n), ie), {}, {
        disabled: x.value,
        virtual: f.value,
        dropdownMatchSelectWidth: p.value,
        id: he,
        fieldNames: ge,
        ref: L,
        prefixCls: c.value,
        class: we,
        listHeight: q,
        listItemHeight: K,
        treeLine: !!ee,
        inputIcon: xe,
        multiple: se,
        removeIcon: Te,
        clearIcon: Se,
        switcherIcon: (tt) => zG(k.value, me, tt, o.leafIcon, ee),
        showTreeIcon: Z,
        notFoundContent: be,
        getPopupContainer: v == null ? void 0 : v.value,
        treeMotion: null,
        dropdownClassName: F.value,
        choiceTransitionName: P.value,
        onChange: B,
        onBlur: W,
        onSearch: j,
        onTreeExpand: V
      }, Ne), {}, {
        transitionName: T.value,
        customSlots: _(_({}, o), {
          treeCheckable: () => $("span", {
            class: `${c.value}-tree-checkbox-inner`
          }, null)
        }),
        maxTagPlaceholder: e.maxTagPlaceholder || o.maxTagPlaceholder,
        placement: I.value,
        showArrow: ae || fe,
        placeholder: $e
      }), _(_({}, o), {
        treeCheckable: () => $("span", {
          class: `${c.value}-tree-checkbox-inner`
        }, null)
      }))));
    };
  }
}), yE = Fp, jGe = _(s$, {
  TreeNode: Fp,
  SHOW_ALL: OGe,
  SHOW_PARENT: eY,
  SHOW_CHILD: NP,
  install: (e) => (e.component(s$.name, s$), e.component(yE.displayName, yE), e)
}), c$ = () => ({
  format: String,
  showNow: Qe(),
  showHour: Qe(),
  showMinute: Qe(),
  showSecond: Qe(),
  use12Hours: Qe(),
  hourStep: Number,
  minuteStep: Number,
  secondStep: Number,
  hideDisabledOptions: Qe(),
  popupClassName: String,
  status: At()
});
function WGe(e) {
  const t = gU(e, _(_({}, c$()), {
    order: {
      type: Boolean,
      default: !0
    }
  })), {
    TimePicker: n,
    RangePicker: o
  } = t, l = /* @__PURE__ */ le({
    name: "ATimePicker",
    inheritAttrs: !1,
    props: _(_(_(_({}, By()), vU()), c$()), {
      addon: {
        type: Function
      }
    }),
    slots: Object,
    setup(a, i) {
      let {
        slots: s,
        expose: c,
        emit: u,
        attrs: d
      } = i;
      const f = a, p = Ko();
      un(!(s.addon || f.addon), "TimePicker", "`addon` is deprecated. Please use `v-slot:renderExtraFooter` instead.");
      const m = /* @__PURE__ */ H();
      c({
        focus: () => {
          var C;
          (C = m.value) === null || C === void 0 || C.focus();
        },
        blur: () => {
          var C;
          (C = m.value) === null || C === void 0 || C.blur();
        }
      });
      const v = (C, w) => {
        u("update:value", C), u("change", C, w), p.onFieldChange();
      }, h = (C) => {
        u("update:open", C), u("openChange", C);
      }, g = (C) => {
        u("focus", C);
      }, y = (C) => {
        u("blur", C), p.onFieldBlur();
      }, b = (C) => {
        u("ok", C);
      };
      return () => {
        const {
          id: C = p.id.value
        } = f;
        return $(n, Q(Q(Q({}, d), pn(f, ["onUpdate:value", "onUpdate:open"])), {}, {
          id: C,
          dropdownClassName: f.popupClassName,
          mode: void 0,
          ref: m,
          renderExtraFooter: f.addon || s.addon || f.renderExtraFooter || s.renderExtraFooter,
          onChange: v,
          onOpenChange: h,
          onFocus: g,
          onBlur: y,
          onOk: b
        }), s);
      };
    }
  }), r = /* @__PURE__ */ le({
    name: "ATimeRangePicker",
    inheritAttrs: !1,
    props: _(_(_(_({}, By()), mU()), c$()), {
      order: {
        type: Boolean,
        default: !0
      }
    }),
    slots: Object,
    setup(a, i) {
      let {
        slots: s,
        expose: c,
        emit: u,
        attrs: d
      } = i;
      const f = a, p = /* @__PURE__ */ H(), m = Ko();
      c({
        focus: () => {
          var x;
          (x = p.value) === null || x === void 0 || x.focus();
        },
        blur: () => {
          var x;
          (x = p.value) === null || x === void 0 || x.blur();
        }
      });
      const v = (x, E) => {
        u("update:value", x), u("change", x, E), m.onFieldChange();
      }, h = (x) => {
        u("update:open", x), u("openChange", x);
      }, g = (x) => {
        u("focus", x);
      }, y = (x) => {
        u("blur", x), m.onFieldBlur();
      }, b = (x, E) => {
        u("panelChange", x, E);
      }, C = (x) => {
        u("ok", x);
      }, w = (x, E, I) => {
        u("calendarChange", x, E, I);
      };
      return () => {
        const {
          id: x = m.id.value
        } = f;
        return $(o, Q(Q(Q({}, d), pn(f, ["onUpdate:open", "onUpdate:value"])), {}, {
          id: x,
          dropdownClassName: f.popupClassName,
          picker: "time",
          mode: void 0,
          ref: p,
          onChange: v,
          onOpenChange: h,
          onFocus: g,
          onBlur: y,
          onPanelChange: b,
          onOk: C,
          onCalendarChange: w
        }), s);
      };
    }
  });
  return {
    TimePicker: l,
    TimeRangePicker: r
  };
}
const {
  TimePicker: Ug,
  TimeRangePicker: r0
} = WGe(nT), KGe = _(Ug, {
  TimePicker: Ug,
  TimeRangePicker: r0,
  install: (e) => (e.component(Ug.name, Ug), e.component(r0.name, r0), e)
}), UGe = () => ({
  prefixCls: String,
  color: String,
  dot: de.any,
  pending: Qe(),
  position: de.oneOf($l("left", "right", "")).def(""),
  label: de.any
}), Wm = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ATimelineItem",
  props: sn(UGe(), {
    color: "blue",
    pending: !1
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o
    } = bt("timeline", e), l = O(() => ({
      [`${o.value}-item`]: !0,
      [`${o.value}-item-pending`]: e.pending
    })), r = O(() => /blue|red|green|gray/.test(e.color || "") ? void 0 : e.color || "blue"), a = O(() => ({
      [`${o.value}-item-head`]: !0,
      [`${o.value}-item-head-${e.color || "blue"}`]: !r.value
    }));
    return () => {
      var i, s, c;
      const {
        label: u = (i = n.label) === null || i === void 0 ? void 0 : i.call(n),
        dot: d = (s = n.dot) === null || s === void 0 ? void 0 : s.call(n)
      } = e;
      return $("li", {
        class: l.value
      }, [u && $("div", {
        class: `${o.value}-item-label`
      }, [u]), $("div", {
        class: `${o.value}-item-tail`
      }, null), $("div", {
        class: [a.value, !!d && `${o.value}-item-head-custom`],
        style: {
          borderColor: r.value,
          color: r.value
        }
      }, [d]), $("div", {
        class: `${o.value}-item-content`
      }, [(c = n.default) === null || c === void 0 ? void 0 : c.call(n)])]);
    };
  }
}), GGe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: _(_({}, nn(e)), {
      margin: 0,
      padding: 0,
      listStyle: "none",
      [`${t}-item`]: {
        position: "relative",
        margin: 0,
        paddingBottom: e.timeLineItemPaddingBottom,
        fontSize: e.fontSize,
        listStyle: "none",
        "&-tail": {
          position: "absolute",
          insetBlockStart: e.timeLineItemHeadSize,
          insetInlineStart: (e.timeLineItemHeadSize - e.timeLineItemTailWidth) / 2,
          height: `calc(100% - ${e.timeLineItemHeadSize}px)`,
          borderInlineStart: `${e.timeLineItemTailWidth}px ${e.lineType} ${e.colorSplit}`
        },
        "&-pending": {
          [`${t}-item-head`]: {
            fontSize: e.fontSizeSM,
            backgroundColor: "transparent"
          },
          [`${t}-item-tail`]: {
            display: "none"
          }
        },
        "&-head": {
          position: "absolute",
          width: e.timeLineItemHeadSize,
          height: e.timeLineItemHeadSize,
          backgroundColor: e.colorBgContainer,
          border: `${e.timeLineHeadBorderWidth}px ${e.lineType} transparent`,
          borderRadius: "50%",
          "&-blue": {
            color: e.colorPrimary,
            borderColor: e.colorPrimary
          },
          "&-red": {
            color: e.colorError,
            borderColor: e.colorError
          },
          "&-green": {
            color: e.colorSuccess,
            borderColor: e.colorSuccess
          },
          "&-gray": {
            color: e.colorTextDisabled,
            borderColor: e.colorTextDisabled
          }
        },
        "&-head-custom": {
          position: "absolute",
          insetBlockStart: e.timeLineItemHeadSize / 2,
          insetInlineStart: e.timeLineItemHeadSize / 2,
          width: "auto",
          height: "auto",
          marginBlockStart: 0,
          paddingBlock: e.timeLineItemCustomHeadPaddingVertical,
          lineHeight: 1,
          textAlign: "center",
          border: 0,
          borderRadius: 0,
          transform: "translate(-50%, -50%)"
        },
        "&-content": {
          position: "relative",
          insetBlockStart: -(e.fontSize * e.lineHeight - e.fontSize) + e.lineWidth,
          marginInlineStart: e.margin + e.timeLineItemHeadSize,
          marginInlineEnd: 0,
          marginBlockStart: 0,
          marginBlockEnd: 0,
          wordBreak: "break-word"
        },
        "&-last": {
          [`> ${t}-item-tail`]: {
            display: "none"
          },
          [`> ${t}-item-content`]: {
            minHeight: e.controlHeightLG * 1.2
          }
        }
      },
      [`&${t}-alternate,
        &${t}-right,
        &${t}-label`]: {
        [`${t}-item`]: {
          "&-tail, &-head, &-head-custom": {
            insetInlineStart: "50%"
          },
          "&-head": {
            marginInlineStart: `-${e.marginXXS}px`,
            "&-custom": {
              marginInlineStart: e.timeLineItemTailWidth / 2
            }
          },
          "&-left": {
            [`${t}-item-content`]: {
              insetInlineStart: `calc(50% - ${e.marginXXS}px)`,
              width: `calc(50% - ${e.marginSM}px)`,
              textAlign: "start"
            }
          },
          "&-right": {
            [`${t}-item-content`]: {
              width: `calc(50% - ${e.marginSM}px)`,
              margin: 0,
              textAlign: "end"
            }
          }
        }
      },
      [`&${t}-right`]: {
        [`${t}-item-right`]: {
          [`${t}-item-tail,
            ${t}-item-head,
            ${t}-item-head-custom`]: {
            insetInlineStart: `calc(100% - ${(e.timeLineItemHeadSize + e.timeLineItemTailWidth) / 2}px)`
          },
          [`${t}-item-content`]: {
            width: `calc(100% - ${e.timeLineItemHeadSize + e.marginXS}px)`
          }
        }
      },
      [`&${t}-pending
        ${t}-item-last
        ${t}-item-tail`]: {
        display: "block",
        height: `calc(100% - ${e.margin}px)`,
        borderInlineStart: `${e.timeLineItemTailWidth}px dotted ${e.colorSplit}`
      },
      [`&${t}-reverse
        ${t}-item-last
        ${t}-item-tail`]: {
        display: "none"
      },
      [`&${t}-reverse ${t}-item-pending`]: {
        [`${t}-item-tail`]: {
          insetBlockStart: e.margin,
          display: "block",
          height: `calc(100% - ${e.margin}px)`,
          borderInlineStart: `${e.timeLineItemTailWidth}px dotted ${e.colorSplit}`
        },
        [`${t}-item-content`]: {
          minHeight: e.controlHeightLG * 1.2
        }
      },
      [`&${t}-label`]: {
        [`${t}-item-label`]: {
          position: "absolute",
          insetBlockStart: -(e.fontSize * e.lineHeight - e.fontSize) + e.timeLineItemTailWidth,
          width: `calc(50% - ${e.marginSM}px)`,
          textAlign: "end"
        },
        [`${t}-item-right`]: {
          [`${t}-item-label`]: {
            insetInlineStart: `calc(50% + ${e.marginSM}px)`,
            width: `calc(50% - ${e.marginSM}px)`,
            textAlign: "start"
          }
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl",
        [`${t}-item-head-custom`]: {
          transform: "translate(50%, -50%)"
        }
      }
    })
  };
}, YGe = Zt("Timeline", (e) => {
  const t = Vt(e, {
    timeLineItemPaddingBottom: e.padding * 1.25,
    timeLineItemHeadSize: 10,
    timeLineItemCustomHeadPaddingVertical: e.paddingXXS,
    timeLinePaddingInlineEnd: 2,
    timeLineItemTailWidth: e.lineWidthBold,
    timeLineHeadBorderWidth: e.wireframe ? e.lineWidthBold : e.lineWidth * 3
  });
  return [GGe(t)];
}), XGe = () => ({
  prefixCls: String,
  /**  */
  pending: de.any,
  pendingDot: de.any,
  reverse: Qe(),
  mode: de.oneOf($l("left", "alternate", "right", ""))
}), Wv = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ATimeline",
  inheritAttrs: !1,
  props: sn(XGe(), {
    reverse: !1,
    mode: ""
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("timeline", e), [a, i] = YGe(l), s = (c, u) => {
      const d = c.props || {};
      return e.mode === "alternate" ? d.position === "right" ? `${l.value}-item-right` : d.position === "left" ? `${l.value}-item-left` : u % 2 === 0 ? `${l.value}-item-left` : `${l.value}-item-right` : e.mode === "left" ? `${l.value}-item-left` : e.mode === "right" ? `${l.value}-item-right` : d.position === "right" ? `${l.value}-item-right` : "";
    };
    return () => {
      var c, u, d;
      const {
        pending: f = (c = n.pending) === null || c === void 0 ? void 0 : c.call(n),
        pendingDot: p = (u = n.pendingDot) === null || u === void 0 ? void 0 : u.call(n),
        reverse: m,
        mode: v
      } = e, h = typeof f == "boolean" ? null : f, g = mo((d = n.default) === null || d === void 0 ? void 0 : d.call(n)), y = f ? $(Wm, {
        pending: !!f,
        dot: p || $(ar, null, null)
      }, {
        default: () => [h]
      }) : null;
      y && g.push(y);
      const b = m ? g.reverse() : g, C = b.length, w = `${l.value}-item-last`, x = b.map((T, P) => {
        const k = P === C - 2 ? w : "", N = P === C - 1 ? w : "";
        return No(T, {
          class: ke([!m && f ? k : N, s(T, P)])
        });
      }), E = b.some((T) => {
        var P, k;
        return !!(!((P = T.props) === null || P === void 0) && P.label || !((k = T.children) === null || k === void 0) && k.label);
      }), I = ke(l.value, {
        [`${l.value}-pending`]: !!f,
        [`${l.value}-reverse`]: !!m,
        [`${l.value}-${v}`]: !!v && !E,
        [`${l.value}-label`]: E,
        [`${l.value}-rtl`]: r.value === "rtl"
      }, o.class, i.value);
      return a($("ul", Q(Q({}, o), {}, {
        class: I
      }), [x]));
    };
  }
});
Wv.Item = Wm;
Wv.install = function(e) {
  return e.component(Wv.name, Wv), e.component(Wm.name, Wm), e;
};
var qGe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, name: "enter", theme: "outlined" };
function GR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      JGe(e, l, n[l]);
    });
  }
  return e;
}
function JGe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var MP = function(t, n) {
  var o = GR({}, t, n.attrs);
  return $(cn, GR({}, o, {
    icon: qGe
  }), null);
};
MP.displayName = "EnterOutlined";
MP.inheritAttrs = !1;
const ZGe = (e, t, n, o) => {
  const {
    sizeMarginHeadingVerticalEnd: l,
    fontWeightStrong: r
  } = o;
  return {
    marginBottom: l,
    color: n,
    fontWeight: r,
    fontSize: e,
    lineHeight: t
  };
}, QGe = (e) => {
  const t = [1, 2, 3, 4, 5], n = {};
  return t.forEach((o) => {
    n[`
      h${o}&,
      div&-h${o},
      div&-h${o} > textarea,
      h${o}
    `] = ZGe(e[`fontSizeHeading${o}`], e[`lineHeightHeading${o}`], e.colorTextHeading, e);
  }), n;
}, eYe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    "a&, a": _(_({}, cS(e)), {
      textDecoration: e.linkDecoration,
      "&:active, &:hover": {
        textDecoration: e.linkHoverDecoration
      },
      [`&[disabled], &${t}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed",
        "&:active, &:hover": {
          color: e.colorTextDisabled
        },
        "&:active": {
          pointerEvents: "none"
        }
      }
    })
  };
}, tYe = () => ({
  code: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.2em 0.1em",
    fontSize: "85%",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3
  },
  kbd: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.15em 0.1em",
    fontSize: "90%",
    background: "rgba(150, 150, 150, 0.06)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderBottomWidth: 2,
    borderRadius: 3
  },
  mark: {
    padding: 0,
    // FIXME hardcode in v4
    backgroundColor: Wke[2]
  },
  "u, ins": {
    textDecoration: "underline",
    textDecorationSkipInk: "auto"
  },
  "s, del": {
    textDecoration: "line-through"
  },
  strong: {
    fontWeight: 600
  },
  // list
  "ul, ol": {
    marginInline: 0,
    marginBlock: "0 1em",
    padding: 0,
    li: {
      marginInline: "20px 0",
      marginBlock: 0,
      paddingInline: "4px 0",
      paddingBlock: 0
    }
  },
  ul: {
    listStyleType: "circle",
    ul: {
      listStyleType: "disc"
    }
  },
  ol: {
    listStyleType: "decimal"
  },
  // pre & block
  "pre, blockquote": {
    margin: "1em 0"
  },
  pre: {
    padding: "0.4em 0.6em",
    whiteSpace: "pre-wrap",
    wordWrap: "break-word",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3,
    // Compatible for marked
    code: {
      display: "inline",
      margin: 0,
      padding: 0,
      fontSize: "inherit",
      fontFamily: "inherit",
      background: "transparent",
      border: 0
    }
  },
  blockquote: {
    paddingInline: "0.6em 0",
    paddingBlock: 0,
    borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
    opacity: 0.85
  }
}), nYe = (e) => {
  const {
    componentCls: t
  } = e, o = gd(e).inputPaddingVertical + 1;
  return {
    "&-edit-content": {
      position: "relative",
      "div&": {
        insetInlineStart: -e.paddingSM,
        marginTop: -o,
        marginBottom: `calc(1em - ${o}px)`
      },
      [`${t}-edit-content-confirm`]: {
        position: "absolute",
        insetInlineEnd: e.marginXS + 2,
        insetBlockEnd: e.marginXS,
        color: e.colorTextDescription,
        // default style
        fontWeight: "normal",
        fontSize: e.fontSize,
        fontStyle: "normal",
        pointerEvents: "none"
      },
      textarea: {
        margin: "0!important",
        // Fix Editable Textarea flash in Firefox
        MozTransition: "none",
        height: "1em"
      }
    }
  };
}, oYe = (e) => ({
  "&-copy-success": {
    "\n    &,\n    &:hover,\n    &:focus": {
      color: e.colorSuccess
    }
  }
}), lYe = () => ({
  "\n  a&-ellipsis,\n  span&-ellipsis\n  ": {
    display: "inline-block",
    maxWidth: "100%"
  },
  "&-single-line": {
    whiteSpace: "nowrap"
  },
  "&-ellipsis-single-line": {
    overflow: "hidden",
    textOverflow: "ellipsis",
    // https://blog.csdn.net/iefreer/article/details/50421025
    "a&, span&": {
      verticalAlign: "bottom"
    }
  },
  "&-ellipsis-multiple-line": {
    display: "-webkit-box",
    overflow: "hidden",
    WebkitLineClamp: 3,
    WebkitBoxOrient: "vertical"
  }
}), rYe = (e) => {
  const {
    componentCls: t,
    sizeMarginHeadingVerticalStart: n
  } = e;
  return {
    [t]: _(_(_(_(_(_(_(_(_({
      color: e.colorText,
      wordBreak: "break-word",
      lineHeight: e.lineHeight,
      [`&${t}-secondary`]: {
        color: e.colorTextDescription
      },
      [`&${t}-success`]: {
        color: e.colorSuccess
      },
      [`&${t}-warning`]: {
        color: e.colorWarning
      },
      [`&${t}-danger`]: {
        color: e.colorError,
        "a&:active, a&:focus": {
          color: e.colorErrorActive
        },
        "a&:hover": {
          color: e.colorErrorHover
        }
      },
      [`&${t}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed",
        userSelect: "none"
      },
      "\n        div&,\n        p\n      ": {
        marginBottom: "1em"
      }
    }, QGe(e)), {
      [`
      & + h1${t},
      & + h2${t},
      & + h3${t},
      & + h4${t},
      & + h5${t}
      `]: {
        marginTop: n
      },
      "\n      div,\n      ul,\n      li,\n      p,\n      h1,\n      h2,\n      h3,\n      h4,\n      h5": {
        "\n        + h1,\n        + h2,\n        + h3,\n        + h4,\n        + h5\n        ": {
          marginTop: n
        }
      }
    }), tYe()), eYe(e)), {
      // Operation
      [`
        ${t}-expand,
        ${t}-edit,
        ${t}-copy
      `]: _(_({}, cS(e)), {
        marginInlineStart: e.marginXXS
      })
    }), nYe(e)), oYe(e)), lYe()), {
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
}, nY = Zt("Typography", (e) => [rYe(e)], {
  sizeMarginHeadingVerticalStart: "1.2em",
  sizeMarginHeadingVerticalEnd: "0.5em"
}), aYe = () => ({
  prefixCls: String,
  value: String,
  maxlength: Number,
  autoSize: {
    type: [Boolean, Object]
  },
  onSave: Function,
  onCancel: Function,
  onEnd: Function,
  onChange: Function,
  originContent: String,
  direction: String,
  component: String
}), iYe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Editable",
  inheritAttrs: !1,
  props: aYe(),
  // emits: ['save', 'cancel', 'end', 'change'],
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      attrs: l
    } = t;
    const {
      prefixCls: r
    } = /* @__PURE__ */ to(e), a = /* @__PURE__ */ kt({
      current: e.value || "",
      lastKeyCode: void 0,
      inComposition: !1,
      cancelFlag: !1
    });
    pe(() => e.value, (y) => {
      a.current = y;
    });
    const i = /* @__PURE__ */ H();
    nt(() => {
      var y;
      if (i.value) {
        const b = (y = i.value) === null || y === void 0 ? void 0 : y.resizableTextArea, C = b == null ? void 0 : b.textArea;
        C.focus();
        const {
          length: w
        } = C.value;
        C.setSelectionRange(w, w);
      }
    });
    function s(y) {
      i.value = y;
    }
    function c(y) {
      let {
        target: {
          value: b
        }
      } = y;
      a.current = b.replace(/[\r\n]/g, ""), n("change", a.current);
    }
    function u() {
      a.inComposition = !0;
    }
    function d() {
      a.inComposition = !1;
    }
    function f(y) {
      const {
        keyCode: b
      } = y;
      b === ot.ENTER && y.preventDefault(), !a.inComposition && (a.lastKeyCode = b);
    }
    function p(y) {
      const {
        keyCode: b,
        ctrlKey: C,
        altKey: w,
        metaKey: x,
        shiftKey: E
      } = y;
      a.lastKeyCode === b && !a.inComposition && !C && !w && !x && !E && (b === ot.ENTER ? (v(), n("end")) : b === ot.ESC && (a.current = e.originContent, n("cancel")));
    }
    function m() {
      v();
    }
    function v() {
      n("save", a.current.trim());
    }
    const [h, g] = nY(r);
    return () => {
      const y = ke({
        [`${r.value}`]: !0,
        [`${r.value}-edit-content`]: !0,
        [`${r.value}-rtl`]: e.direction === "rtl",
        [e.component ? `${r.value}-${e.component}` : ""]: !0
      }, l.class, g.value);
      return h($("div", Q(Q({}, l), {}, {
        class: y
      }), [$(ZT, {
        ref: s,
        maxlength: e.maxlength,
        value: a.current,
        onChange: c,
        onKeydown: f,
        onKeyup: p,
        onCompositionstart: u,
        onCompositionend: d,
        onBlur: m,
        rows: 1,
        autoSize: e.autoSize === void 0 || e.autoSize
      }, null), o.enterIcon ? o.enterIcon({
        className: `${e.prefixCls}-edit-content-confirm`
      }) : $(MP, {
        class: `${e.prefixCls}-edit-content-confirm`
      }, null)]));
    };
  }
}), sYe = 3, cYe = 8;
let fr;
const u$ = {
  padding: 0,
  margin: 0,
  display: "inline",
  lineHeight: "inherit"
};
function oY(e, t) {
  e.setAttribute("aria-hidden", "true");
  const n = window.getComputedStyle(t), o = lNe(n);
  e.setAttribute("style", o), e.style.position = "fixed", e.style.left = "0", e.style.height = "auto", e.style.minHeight = "auto", e.style.maxHeight = "auto", e.style.paddingTop = "0", e.style.paddingBottom = "0", e.style.borderTopWidth = "0", e.style.borderBottomWidth = "0", e.style.top = "-999999px", e.style.zIndex = "-1000", e.style.textOverflow = "clip", e.style.whiteSpace = "normal", e.style.webkitLineClamp = "none";
}
function uYe(e) {
  const t = document.createElement("div");
  oY(t, e), t.appendChild(document.createTextNode("text")), document.body.appendChild(t);
  const n = t.getBoundingClientRect().height;
  return document.body.removeChild(t), n;
}
const dYe = (e, t, n, o, l) => {
  fr || (fr = document.createElement("div"), fr.setAttribute("aria-hidden", "true"), document.body.appendChild(fr));
  const {
    rows: r,
    suffix: a = ""
  } = t, i = uYe(e), s = Math.round(i * r * 100) / 100;
  oY(fr, e);
  const c = ZE({
    render() {
      return $("div", {
        style: u$
      }, [$("span", {
        style: u$
      }, [n, a]), $("span", {
        style: u$
      }, [o])]);
    }
  });
  c.mount(fr);
  function u() {
    return Math.round(fr.getBoundingClientRect().height * 100) / 100 - 0.1 <= s;
  }
  if (u())
    return c.unmount(), {
      content: n,
      text: fr.innerHTML,
      ellipsis: !1
    };
  const d = Array.prototype.slice.apply(fr.childNodes[0].childNodes[0].cloneNode(!0).childNodes).filter((b) => {
    let {
      nodeType: C,
      data: w
    } = b;
    return C !== cYe && w !== "";
  }), f = Array.prototype.slice.apply(fr.childNodes[0].childNodes[1].cloneNode(!0).childNodes);
  c.unmount();
  const p = [];
  fr.innerHTML = "";
  const m = document.createElement("span");
  fr.appendChild(m);
  const v = document.createTextNode(l + a);
  m.appendChild(v), f.forEach((b) => {
    fr.appendChild(b);
  });
  function h(b) {
    m.insertBefore(b, v);
  }
  function g(b, C) {
    let w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, x = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : C.length, E = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    const I = Math.floor((w + x) / 2), T = C.slice(0, I);
    if (b.textContent = T, w >= x - 1)
      for (let P = x; P >= w; P -= 1) {
        const k = C.slice(0, P);
        if (b.textContent = k, u() || !k)
          return P === C.length ? {
            finished: !1,
            vNode: C
          } : {
            finished: !0,
            vNode: k
          };
      }
    return u() ? g(b, C, I, x, I) : g(b, C, w, I, E);
  }
  function y(b) {
    if (b.nodeType === sYe) {
      const w = b.textContent || "", x = document.createTextNode(w);
      return h(x), g(x, w);
    }
    return {
      finished: !1,
      vNode: null
    };
  }
  return d.some((b) => {
    const {
      finished: C,
      vNode: w
    } = y(b);
    return w && p.push(w), C;
  }), {
    content: p,
    text: fr.innerHTML,
    ellipsis: !0
  };
};
var fYe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const pYe = () => ({
  prefixCls: String,
  direction: String,
  // Form Internal use
  component: String
}), vr = /* @__PURE__ */ le({
  name: "ATypography",
  inheritAttrs: !1,
  props: pYe(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: l,
      direction: r
    } = bt("typography", e), [a, i] = nY(l);
    return () => {
      var s;
      const c = _(_({}, e), o), {
        prefixCls: u,
        direction: d,
        component: f = "article"
      } = c, p = fYe(c, ["prefixCls", "direction", "component"]);
      return a($(f, Q(Q({}, p), {}, {
        class: ke(l.value, {
          [`${l.value}-rtl`]: r.value === "rtl"
        }, o.class, i.value)
      }), {
        default: () => [(s = n.default) === null || s === void 0 ? void 0 : s.call(n)]
      }));
    };
  }
}), vYe = () => {
  const e = document.getSelection();
  if (!e.rangeCount)
    return function() {
    };
  let t = document.activeElement;
  const n = [];
  for (let o = 0; o < e.rangeCount; o++)
    n.push(e.getRangeAt(o));
  switch (t.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      t.blur();
      break;
    default:
      t = null;
      break;
  }
  return e.removeAllRanges(), function() {
    e.type === "Caret" && e.removeAllRanges(), e.rangeCount || n.forEach(function(o) {
      e.addRange(o);
    }), t && t.focus();
  };
}, YR = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
}, mYe = "Copy to clipboard: #{key}, Enter";
function hYe(e) {
  const t = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
  return e.replace(/#{\s*key\s*}/g, t);
}
function gYe(e, t) {
  let n, o, l, r, a, i = !1;
  t || (t = {});
  const s = t.debug || !1;
  try {
    if (o = vYe(), l = document.createRange(), r = document.getSelection(), a = document.createElement("span"), a.textContent = e, a.style.all = "unset", a.style.position = "fixed", a.style.top = 0, a.style.clip = "rect(0, 0, 0, 0)", a.style.whiteSpace = "pre", a.style.webkitUserSelect = "text", a.style.MozUserSelect = "text", a.style.msUserSelect = "text", a.style.userSelect = "text", a.addEventListener("copy", function(u) {
      if (u.stopPropagation(), t.format)
        if (u.preventDefault(), typeof u.clipboardData == "undefined") {
          s && console.warn("unable to use e.clipboardData"), s && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          const d = YR[t.format] || YR.default;
          window.clipboardData.setData(d, e);
        } else
          u.clipboardData.clearData(), u.clipboardData.setData(t.format, e);
      t.onCopy && (u.preventDefault(), t.onCopy(u.clipboardData));
    }), document.body.appendChild(a), l.selectNodeContents(a), r.addRange(l), !document.execCommand("copy"))
      throw new Error("copy command was unsuccessful");
    i = !0;
  } catch (c) {
    s && console.error("unable to copy using execCommand: ", c), s && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(t.format || "text", e), t.onCopy && t.onCopy(window.clipboardData), i = !0;
    } catch (u) {
      s && console.error("unable to copy using clipboardData: ", u), s && console.error("falling back to prompt"), n = hYe("message" in t ? t.message : mYe), window.prompt(n, e);
    }
  } finally {
    r && (typeof r.removeRange == "function" ? r.removeRange(l) : r.removeAllRanges()), a && document.body.removeChild(a), o();
  }
  return i;
}
var bYe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, name: "copy", theme: "outlined" };
function XR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      yYe(e, l, n[l]);
    });
  }
  return e;
}
function yYe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var AP = function(t, n) {
  var o = XR({}, t, n.attrs);
  return $(cn, XR({}, o, {
    icon: bYe
  }), null);
};
AP.displayName = "CopyOutlined";
AP.inheritAttrs = !1;
var SYe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, name: "edit", theme: "outlined" };
function qR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      CYe(e, l, n[l]);
    });
  }
  return e;
}
function CYe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var RP = function(t, n) {
  var o = qR({}, t, n.attrs);
  return $(cn, qR({}, o, {
    icon: SYe
  }), null);
};
RP.displayName = "EditOutlined";
RP.inheritAttrs = !1;
var wYe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const $Ye = FT("webkitLineClamp"), xYe = FT("textOverflow"), JR = "...", Hh = () => ({
  editable: {
    type: [Boolean, Object],
    default: void 0
  },
  copyable: {
    type: [Boolean, Object],
    default: void 0
  },
  prefixCls: String,
  component: String,
  type: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  ellipsis: {
    type: [Boolean, Object],
    default: void 0
  },
  code: {
    type: Boolean,
    default: void 0
  },
  mark: {
    type: Boolean,
    default: void 0
  },
  underline: {
    type: Boolean,
    default: void 0
  },
  delete: {
    type: Boolean,
    default: void 0
  },
  strong: {
    type: Boolean,
    default: void 0
  },
  keyboard: {
    type: Boolean,
    default: void 0
  },
  content: String,
  "onUpdate:content": Function
}), jh = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "TypographyBase",
  inheritAttrs: !1,
  props: Hh(),
  // emits: ['update:content'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: l
    } = t;
    const {
      prefixCls: r,
      direction: a
    } = bt("typography", e), i = /* @__PURE__ */ kt({
      copied: !1,
      ellipsisText: "",
      ellipsisContent: null,
      isEllipsis: !1,
      expanded: !1,
      clientRendered: !1,
      //locale
      expandStr: "",
      copyStr: "",
      copiedStr: "",
      editStr: "",
      copyId: void 0,
      rafId: void 0,
      prevProps: void 0,
      originContent: ""
    }), s = /* @__PURE__ */ H(), c = /* @__PURE__ */ H(), u = O(() => {
      const D = e.ellipsis;
      return D ? _({
        rows: 1,
        expandable: !1
      }, typeof D == "object" ? D : null) : {};
    });
    nt(() => {
      i.clientRendered = !0, I();
    }), yt(() => {
      clearTimeout(i.copyId), rn.cancel(i.rafId);
    }), pe([() => u.value.rows, () => e.content], () => {
      Ke(() => {
        x();
      });
    }, {
      flush: "post",
      deep: !0
    }), Ot(() => {
      e.content === void 0 && (Hn(!e.editable, "Typography", "When `editable` is enabled, please use `content` instead of children"), Hn(!e.ellipsis, "Typography", "When `ellipsis` is enabled, please use `content` instead of children"));
    });
    function d() {
      var D;
      return e.ellipsis || e.editable ? e.content : (D = nr(s.value)) === null || D === void 0 ? void 0 : D.innerText;
    }
    function f(D) {
      const {
        onExpand: F
      } = u.value;
      i.expanded = !0, F == null || F(D);
    }
    function p(D) {
      D.preventDefault(), i.originContent = e.content, w(!0);
    }
    function m(D) {
      v(D), w(!1);
    }
    function v(D) {
      const {
        onChange: F
      } = y.value;
      D !== e.content && (l("update:content", D), F == null || F(D));
    }
    function h() {
      var D, F;
      (F = (D = y.value).onCancel) === null || F === void 0 || F.call(D), w(!1);
    }
    function g(D) {
      D.preventDefault(), D.stopPropagation();
      const {
        copyable: F
      } = e, M = _({}, typeof F == "object" ? F : null);
      M.text === void 0 && (M.text = d()), gYe(M.text || ""), i.copied = !0, Ke(() => {
        M.onCopy && M.onCopy(D), i.copyId = setTimeout(() => {
          i.copied = !1;
        }, 3e3);
      });
    }
    const y = O(() => {
      const D = e.editable;
      return D ? _({}, typeof D == "object" ? D : null) : {
        editing: !1
      };
    }), [b, C] = ro(!1, {
      value: O(() => y.value.editing)
    });
    function w(D) {
      const {
        onStart: F
      } = y.value;
      D && F && F(), C(D);
    }
    pe(b, (D) => {
      var F;
      D || (F = c.value) === null || F === void 0 || F.focus();
    }, {
      flush: "post"
    });
    function x(D) {
      if (D) {
        const {
          width: F,
          height: M
        } = D;
        if (!F || !M) return;
      }
      rn.cancel(i.rafId), i.rafId = rn(() => {
        I();
      });
    }
    const E = O(() => {
      const {
        rows: D,
        expandable: F,
        suffix: M,
        onEllipsis: A,
        tooltip: L
      } = u.value;
      return M || L || e.editable || e.copyable || F || A ? !1 : D === 1 ? xYe : $Ye;
    }), I = () => {
      const {
        ellipsisText: D,
        isEllipsis: F
      } = i, {
        rows: M,
        suffix: A,
        onEllipsis: L
      } = u.value;
      if (!M || M < 0 || !nr(s.value) || i.expanded || e.content === void 0 || E.value) return;
      const {
        content: B,
        text: V,
        ellipsis: j
      } = dYe(nr(s.value), {
        rows: M,
        suffix: A
      }, e.content, z(!0), JR);
      (D !== V || i.isEllipsis !== j) && (i.ellipsisText = V, i.ellipsisContent = B, i.isEllipsis = j, F !== j && L && L(j));
    };
    function T(D, F) {
      let {
        mark: M,
        code: A,
        underline: L,
        delete: B,
        strong: V,
        keyboard: j
      } = D, W = F;
      function Y(U, te) {
        if (!U) return;
        const J = /* @__PURE__ */ function() {
          return W;
        }();
        W = $(te, null, {
          default: () => [J]
        });
      }
      return Y(V, "strong"), Y(L, "u"), Y(B, "del"), Y(A, "code"), Y(M, "mark"), Y(j, "kbd"), W;
    }
    function P(D) {
      const {
        expandable: F,
        symbol: M
      } = u.value;
      if (!F || !D && (i.expanded || !i.isEllipsis)) return null;
      const A = (n.ellipsisSymbol ? n.ellipsisSymbol() : M) || i.expandStr;
      return $("a", {
        key: "expand",
        class: `${r.value}-expand`,
        onClick: f,
        "aria-label": i.expandStr
      }, [A]);
    }
    function k() {
      if (!e.editable) return;
      const {
        tooltip: D,
        triggerType: F = ["icon"]
      } = e.editable, M = n.editableIcon ? n.editableIcon() : $(RP, {
        role: "button"
      }, null), A = n.editableTooltip ? n.editableTooltip() : i.editStr, L = typeof A == "string" ? A : "";
      return F.indexOf("icon") !== -1 ? $(Sr, {
        key: "edit",
        title: D === !1 ? "" : A
      }, {
        default: () => [$(Ky, {
          ref: c,
          class: `${r.value}-edit`,
          onClick: p,
          "aria-label": L
        }, {
          default: () => [M]
        })]
      }) : null;
    }
    function N() {
      if (!e.copyable) return;
      const {
        tooltip: D
      } = e.copyable, F = i.copied ? i.copiedStr : i.copyStr, M = n.copyableTooltip ? n.copyableTooltip({
        copied: i.copied
      }) : F, A = typeof M == "string" ? M : "", L = i.copied ? $(Np, null, null) : $(AP, null, null), B = n.copyableIcon ? n.copyableIcon({
        copied: !!i.copied
      }) : L;
      return $(Sr, {
        key: "copy",
        title: D === !1 ? "" : M
      }, {
        default: () => [$(Ky, {
          class: [`${r.value}-copy`, {
            [`${r.value}-copy-success`]: i.copied
          }],
          onClick: g,
          "aria-label": A
        }, {
          default: () => [B]
        })]
      });
    }
    function R() {
      const {
        class: D,
        style: F
      } = o, {
        maxlength: M,
        autoSize: A,
        onEnd: L
      } = y.value;
      return $(iYe, {
        class: D,
        style: F,
        prefixCls: r.value,
        value: e.content,
        originContent: i.originContent,
        maxlength: M,
        autoSize: A,
        onSave: m,
        onChange: v,
        onCancel: h,
        onEnd: L,
        direction: a.value,
        component: e.component
      }, {
        enterIcon: n.editableEnterIcon
      });
    }
    function z(D) {
      return [P(D), k(), N()].filter((F) => F);
    }
    return () => {
      var D;
      const {
        triggerType: F = ["icon"]
      } = y.value, M = e.ellipsis || e.editable ? e.content !== void 0 ? e.content : (D = n.default) === null || D === void 0 ? void 0 : D.call(n) : n.default ? n.default() : e.content;
      return b.value ? R() : $(sd, {
        componentName: "Text",
        children: (A) => {
          const L = _(_({}, e), o), {
            type: B,
            disabled: V,
            content: j,
            class: W,
            style: Y
          } = L, U = wYe(L, ["type", "disabled", "content", "class", "style"]), {
            rows: te,
            suffix: J,
            tooltip: re
          } = u.value, {
            edit: oe,
            copy: q,
            copied: K,
            expand: se
          } = A;
          i.editStr = oe, i.copyStr = q, i.copiedStr = K, i.expandStr = se;
          const Z = pn(U, ["prefixCls", "editable", "copyable", "ellipsis", "mark", "code", "delete", "underline", "strong", "keyboard", "onUpdate:content"]), ee = E.value, fe = te === 1 && ee, me = te && te > 1 && ee;
          let ge = M, he;
          if (te && i.isEllipsis && !i.expanded && !ee) {
            const {
              title: ae
            } = U;
            let ce = ae || "";
            !ae && (typeof M == "string" || typeof M == "number") && (ce = String(M)), ce = ce == null ? void 0 : ce.slice(String(i.ellipsisContent || "").length), ge = $(Ge, null, [/* @__PURE__ */ Wt(i.ellipsisContent), $("span", {
              title: ce,
              "aria-hidden": "true"
            }, [JR]), J]);
          } else
            ge = $(Ge, null, [M, J]);
          ge = T(e, ge);
          const $e = re && te && i.isEllipsis && !i.expanded && !ee, ne = n.ellipsisTooltip ? n.ellipsisTooltip() : re;
          return $(ca, {
            onResize: x,
            disabled: !te
          }, {
            default: () => [$(vr, Q({
              ref: s,
              class: [{
                [`${r.value}-${B}`]: B,
                [`${r.value}-disabled`]: V,
                [`${r.value}-ellipsis`]: te,
                [`${r.value}-single-line`]: te === 1 && !i.isEllipsis,
                [`${r.value}-ellipsis-single-line`]: fe,
                [`${r.value}-ellipsis-multiple-line`]: me
              }, W],
              style: _(_({}, Y), {
                WebkitLineClamp: me ? te : void 0
              }),
              "aria-label": he,
              direction: a.value,
              onClick: F.indexOf("text") !== -1 ? p : () => {
              }
            }, Z), {
              default: () => [$e ? $(Sr, {
                title: re === !0 ? M : ne
              }, {
                default: () => [$("span", null, [ge])]
              }) : ge, z()]
            })]
          });
        }
      }, null);
    };
  }
});
var EYe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const OYe = () => pn(_(_({}, Hh()), {
  ellipsis: {
    type: Boolean,
    default: void 0
  }
}), ["component"]), Vp = (e, t) => {
  let {
    slots: n,
    attrs: o
  } = t;
  const l = _(_({}, e), o), {
    ellipsis: r,
    rel: a
  } = l, i = EYe(l, ["ellipsis", "rel"]);
  Hn(typeof r != "object", "Typography.Link", "`ellipsis` only supports boolean value.");
  const s = _(_({}, i), {
    rel: a === void 0 && i.target === "_blank" ? "noopener noreferrer" : a,
    ellipsis: !!r,
    component: "a"
  });
  return delete s.navigate, $(jh, s, n);
};
Vp.displayName = "ATypographyLink";
Vp.inheritAttrs = !1;
Vp.props = OYe();
const _Ye = () => pn(Hh(), ["component"]), zp = (e, t) => {
  let {
    slots: n,
    attrs: o
  } = t;
  const l = _(_(_({}, e), {
    component: "div"
  }), o);
  return $(jh, l, n);
};
zp.displayName = "ATypographyParagraph";
zp.inheritAttrs = !1;
zp.props = _Ye();
const IYe = () => _(_({}, pn(Hh(), ["component"])), {
  ellipsis: {
    type: [Boolean, Object],
    default: void 0
  }
}), Hp = (e, t) => {
  let {
    slots: n,
    attrs: o
  } = t;
  const {
    ellipsis: l
  } = e;
  Hn(typeof l != "object" || !l || !("expandable" in l) && !("rows" in l), "Typography.Text", "`ellipsis` do not support `expandable` or `rows` props.");
  const r = _(_(_({}, e), {
    ellipsis: l && typeof l == "object" ? pn(l, ["expandable", "rows"]) : l,
    component: "span"
  }), o);
  return $(jh, r, n);
};
Hp.displayName = "ATypographyText";
Hp.inheritAttrs = !1;
Hp.props = IYe();
var TYe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const PYe = NPe(1, 2, 3, 4, 5), kYe = () => _(_({}, pn(Hh(), ["component", "strong"])), {
  level: Number
}), jp = (e, t) => {
  let {
    slots: n,
    attrs: o
  } = t;
  const {
    level: l = 1
  } = e, r = TYe(e, ["level"]);
  let a;
  PYe.includes(l) ? a = `h${l}` : (Hn(!1, "Typography", "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value."), a = "h1");
  const i = _(_(_({}, r), {
    component: a
  }), o);
  return $(jh, i, n);
};
jp.displayName = "ATypographyTitle";
jp.inheritAttrs = !1;
jp.props = kYe();
vr.Text = Hp;
vr.Title = jp;
vr.Paragraph = zp;
vr.Link = Vp;
vr.Base = jh;
vr.install = function(e) {
  return e.component(vr.name, vr), e.component(vr.Text.displayName, Hp), e.component(vr.Title.displayName, jp), e.component(vr.Paragraph.displayName, zp), e.component(vr.Link.displayName, Vp), e;
};
function NYe(e, t) {
  const n = `cannot ${e.method} ${e.action} ${t.status}'`, o = new Error(n);
  return o.status = t.status, o.method = e.method, o.url = e.action, o;
}
function ZR(e) {
  const t = e.responseText || e.response;
  if (!t)
    return t;
  try {
    return JSON.parse(t);
  } catch (n) {
    return t;
  }
}
function MYe(e) {
  const t = new XMLHttpRequest();
  e.onProgress && t.upload && (t.upload.onprogress = function(r) {
    r.total > 0 && (r.percent = r.loaded / r.total * 100), e.onProgress(r);
  });
  const n = new FormData();
  e.data && Object.keys(e.data).forEach((l) => {
    const r = e.data[l];
    if (Array.isArray(r)) {
      r.forEach((a) => {
        n.append(`${l}[]`, a);
      });
      return;
    }
    n.append(l, r);
  }), e.file instanceof Blob ? n.append(e.filename, e.file, e.file.name) : n.append(e.filename, e.file), t.onerror = function(r) {
    e.onError(r);
  }, t.onload = function() {
    return t.status < 200 || t.status >= 300 ? e.onError(NYe(e, t), ZR(t)) : e.onSuccess(ZR(t), t);
  }, t.open(e.method, e.action, !0), e.withCredentials && "withCredentials" in t && (t.withCredentials = !0);
  const o = e.headers || {};
  return o["X-Requested-With"] !== null && t.setRequestHeader("X-Requested-With", "XMLHttpRequest"), Object.keys(o).forEach((l) => {
    o[l] !== null && t.setRequestHeader(l, o[l]);
  }), t.send(n), {
    abort() {
      t.abort();
    }
  };
}
const AYe = +/* @__PURE__ */ new Date();
let RYe = 0;
function d$() {
  return `vc-upload-${AYe}-${++RYe}`;
}
const f$ = (e, t) => {
  if (e && t) {
    const n = Array.isArray(t) ? t : t.split(","), o = e.name || "", l = e.type || "", r = l.replace(/\/.*$/, "");
    return n.some((a) => {
      const i = a.trim();
      if (/^\*(\/\*)?$/.test(a))
        return !0;
      if (i.charAt(0) === ".") {
        const s = o.toLowerCase(), c = i.toLowerCase();
        let u = [c];
        return (c === ".jpg" || c === ".jpeg") && (u = [".jpg", ".jpeg"]), u.some((d) => s.endsWith(d));
      }
      return /\/\*$/.test(i) ? r === i.replace(/\/.*$/, "") : l === i ? !0 : /^\w+$/.test(i) ? (bn(!1, `Upload takes an invalidate 'accept' type '${i}'.Skip for check.`), !0) : !1;
    });
  }
  return !0;
};
function DYe(e, t) {
  const n = e.createReader();
  let o = [];
  function l() {
    n.readEntries((r) => {
      const a = Array.prototype.slice.apply(r);
      o = o.concat(a), !a.length ? t(o) : l();
    });
  }
  l();
}
const LYe = (e, t, n) => {
  const o = (l, r) => {
    l.path = r || "", l.isFile ? l.file((a) => {
      n(a) && (l.fullPath && !a.webkitRelativePath && (Object.defineProperties(a, {
        webkitRelativePath: {
          writable: !0
        }
      }), a.webkitRelativePath = l.fullPath.replace(/^\//, ""), Object.defineProperties(a, {
        webkitRelativePath: {
          writable: !1
        }
      })), t([a]));
    }) : l.isDirectory && DYe(l, (a) => {
      a.forEach((i) => {
        o(i, `${r}${l.name}/`);
      });
    });
  };
  e.forEach((l) => {
    o(l.webkitGetAsEntry());
  });
}, lY = () => ({
  capture: [Boolean, String],
  multipart: {
    type: Boolean,
    default: void 0
  },
  name: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  componentTag: String,
  action: [String, Function],
  method: String,
  directory: {
    type: Boolean,
    default: void 0
  },
  data: [Object, Function],
  headers: Object,
  accept: String,
  multiple: {
    type: Boolean,
    default: void 0
  },
  onBatchStart: Function,
  onReject: Function,
  onStart: Function,
  onError: Function,
  onSuccess: Function,
  onProgress: Function,
  beforeUpload: Function,
  customRequest: Function,
  withCredentials: {
    type: Boolean,
    default: void 0
  },
  openFileDialogOnClick: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  id: String,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function
});
var BYe = function(e, t, n, o) {
  function l(r) {
    return r instanceof n ? r : new n(function(a) {
      a(r);
    });
  }
  return new (n || (n = Promise))(function(r, a) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (d) {
        a(d);
      }
    }
    function s(u) {
      try {
        c(o.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? r(u.value) : l(u.value).then(i, s);
    }
    c((o = o.apply(e, t || [])).next());
  });
}, FYe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const VYe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AjaxUploader",
  inheritAttrs: !1,
  props: lY(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: l
    } = t;
    const r = /* @__PURE__ */ H(d$()), a = {}, i = /* @__PURE__ */ H();
    let s = !1;
    const c = (y, b) => BYe(this, void 0, void 0, function* () {
      const {
        beforeUpload: C
      } = e;
      let w = y;
      if (C) {
        try {
          w = yield C(y, b);
        } catch (R) {
          w = !1;
        }
        if (w === !1)
          return {
            origin: y,
            parsedFile: null,
            action: null,
            data: null
          };
      }
      const {
        action: x
      } = e;
      let E;
      typeof x == "function" ? E = yield x(y) : E = x;
      const {
        data: I
      } = e;
      let T;
      typeof I == "function" ? T = yield I(y) : T = I;
      const P = (
        // string type is from legacy `transformFile`.
        // Not sure if this will work since no related test case works with it
        (typeof w == "object" || typeof w == "string") && w ? w : y
      );
      let k;
      P instanceof File ? k = P : k = new File([P], y.name, {
        type: y.type
      });
      const N = k;
      return N.uid = y.uid, {
        origin: y,
        data: T,
        parsedFile: N,
        action: E
      };
    }), u = (y) => {
      let {
        data: b,
        origin: C,
        action: w,
        parsedFile: x
      } = y;
      if (!s)
        return;
      const {
        onStart: E,
        customRequest: I,
        name: T,
        headers: P,
        withCredentials: k,
        method: N
      } = e, {
        uid: R
      } = C, z = I || MYe, D = {
        action: w,
        filename: T,
        data: b,
        file: x,
        headers: P,
        withCredentials: k,
        method: N || "post",
        onProgress: (F) => {
          const {
            onProgress: M
          } = e;
          M == null || M(F, x);
        },
        onSuccess: (F, M) => {
          const {
            onSuccess: A
          } = e;
          A == null || A(F, x, M), delete a[R];
        },
        onError: (F, M) => {
          const {
            onError: A
          } = e;
          A == null || A(F, M, x), delete a[R];
        }
      };
      E(C), a[R] = z(D);
    }, d = () => {
      r.value = d$();
    }, f = (y) => {
      if (y) {
        const b = y.uid ? y.uid : y;
        a[b] && a[b].abort && a[b].abort(), delete a[b];
      } else
        Object.keys(a).forEach((b) => {
          a[b] && a[b].abort && a[b].abort(), delete a[b];
        });
    };
    nt(() => {
      s = !0;
    }), yt(() => {
      s = !1, f();
    });
    const p = (y) => {
      const b = [...y], C = b.map((w) => (w.uid = d$(), c(w, b)));
      Promise.all(C).then((w) => {
        const {
          onBatchStart: x
        } = e;
        x == null || x(w.map((E) => {
          let {
            origin: I,
            parsedFile: T
          } = E;
          return {
            file: I,
            parsedFile: T
          };
        })), w.filter((E) => E.parsedFile !== null).forEach((E) => {
          u(E);
        });
      });
    }, m = (y) => {
      const {
        accept: b,
        directory: C
      } = e, {
        files: w
      } = y.target, x = [...w].filter((E) => !C || f$(E, b));
      p(x), d();
    }, v = (y) => {
      const b = i.value;
      if (!b)
        return;
      const {
        onClick: C
      } = e;
      b.click(), C && C(y);
    }, h = (y) => {
      y.key === "Enter" && v(y);
    }, g = (y) => {
      const {
        multiple: b
      } = e;
      if (y.preventDefault(), y.type !== "dragover")
        if (e.directory)
          LYe(Array.prototype.slice.call(y.dataTransfer.items), p, (C) => f$(C, e.accept));
        else {
          const C = Dae(Array.prototype.slice.call(y.dataTransfer.files), (E) => f$(E, e.accept));
          let w = C[0];
          const x = C[1];
          b === !1 && (w = w.slice(0, 1)), p(w), x.length && e.onReject && e.onReject(x);
        }
    };
    return l({
      abort: f
    }), () => {
      var y;
      const {
        componentTag: b,
        prefixCls: C,
        disabled: w,
        id: x,
        multiple: E,
        accept: I,
        capture: T,
        directory: P,
        openFileDialogOnClick: k,
        onMouseenter: N,
        onMouseleave: R
      } = e, z = FYe(e, ["componentTag", "prefixCls", "disabled", "id", "multiple", "accept", "capture", "directory", "openFileDialogOnClick", "onMouseenter", "onMouseleave"]), D = {
        [C]: !0,
        [`${C}-disabled`]: w,
        [o.class]: !!o.class
      }, F = P ? {
        directory: "directory",
        webkitdirectory: "webkitdirectory"
      } : {};
      return $(b, Q(Q({}, w ? {} : {
        onClick: k ? v : () => {
        },
        onKeydown: k ? h : () => {
        },
        onMouseenter: N,
        onMouseleave: R,
        onDrop: g,
        onDragover: g,
        tabindex: "0"
      }), {}, {
        class: D,
        role: "button",
        style: o.style
      }), {
        default: () => [$("input", Q(Q(Q({}, Mc(z, {
          aria: !0,
          data: !0
        })), {}, {
          id: x,
          type: "file",
          ref: i,
          onClick: (A) => A.stopPropagation(),
          onCancel: (A) => A.stopPropagation(),
          key: r.value,
          style: {
            display: "none"
          },
          accept: I
        }, F), {}, {
          multiple: E,
          onChange: m
        }, T != null ? {
          capture: T
        } : {}), null), (y = n.default) === null || y === void 0 ? void 0 : y.call(n)]
      });
    };
  }
});
function p$() {
}
const QR = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "Upload",
  inheritAttrs: !1,
  props: sn(lY(), {
    componentTag: "span",
    prefixCls: "rc-upload",
    data: {},
    headers: {},
    name: "file",
    multipart: !1,
    onStart: p$,
    onError: p$,
    onSuccess: p$,
    multiple: !1,
    beforeUpload: null,
    customRequest: null,
    withCredentials: !1,
    openFileDialogOnClick: !0
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: l
    } = t;
    const r = /* @__PURE__ */ H();
    return l({
      abort: (i) => {
        var s;
        (s = r.value) === null || s === void 0 || s.abort(i);
      }
    }), () => $(VYe, Q(Q(Q({}, e), o), {}, {
      ref: r
    }), n);
  }
});
var zYe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, name: "paper-clip", theme: "outlined" };
function eD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      HYe(e, l, n[l]);
    });
  }
  return e;
}
function HYe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var DP = function(t, n) {
  var o = eD({}, t, n.attrs);
  return $(cn, eD({}, o, {
    icon: zYe
  }), null);
};
DP.displayName = "PaperClipOutlined";
DP.inheritAttrs = !1;
var jYe = { icon: function(t, n) {
  return { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z", fill: t } }, { tag: "path", attrs: { d: "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z", fill: n } }, { tag: "path", attrs: { d: "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z", fill: n } }, { tag: "path", attrs: { d: "M276 368a28 28 0 1056 0 28 28 0 10-56 0z", fill: n } }, { tag: "path", attrs: { d: "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z", fill: t } }] };
}, name: "picture", theme: "twotone" };
function tD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      WYe(e, l, n[l]);
    });
  }
  return e;
}
function WYe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var LP = function(t, n) {
  var o = tD({}, t, n.attrs);
  return $(cn, tD({}, o, {
    icon: jYe
  }), null);
};
LP.displayName = "PictureTwoTone";
LP.inheritAttrs = !1;
var KYe = { icon: function(t, n) {
  return { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z", fill: n } }, { tag: "path", attrs: { d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z", fill: t } }] };
}, name: "file", theme: "twotone" };
function nD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      UYe(e, l, n[l]);
    });
  }
  return e;
}
function UYe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var BP = function(t, n) {
  var o = nD({}, t, n.attrs);
  return $(cn, nD({}, o, {
    icon: KYe
  }), null);
};
BP.displayName = "FileTwoTone";
BP.inheritAttrs = !1;
function rY() {
  return {
    capture: zt([Boolean, String]),
    type: At(),
    name: String,
    defaultFileList: $n(),
    fileList: $n(),
    action: zt([String, Function]),
    directory: Qe(),
    data: zt([Object, Function]),
    method: At(),
    headers: Nt(),
    showUploadList: zt([Boolean, Object]),
    multiple: Qe(),
    accept: String,
    beforeUpload: Fe(),
    onChange: Fe(),
    "onUpdate:fileList": Fe(),
    onDrop: Fe(),
    listType: At(),
    onPreview: Fe(),
    onDownload: Fe(),
    onReject: Fe(),
    onRemove: Fe(),
    /** @deprecated Please use `onRemove` directly */
    remove: Fe(),
    supportServerRender: Qe(),
    disabled: Qe(),
    prefixCls: String,
    customRequest: Fe(),
    withCredentials: Qe(),
    openFileDialogOnClick: Qe(),
    locale: Nt(),
    id: String,
    previewFile: Fe(),
    /** @deprecated Please use `beforeUpload` directly */
    transformFile: Fe(),
    iconRender: Fe(),
    isImageUrl: Fe(),
    progress: Nt(),
    itemRender: Fe(),
    /** Config max count of `fileList`. Will replace current one when `maxCount` is 1 */
    maxCount: Number,
    height: zt([Number, String]),
    removeIcon: Fe(),
    downloadIcon: Fe(),
    previewIcon: Fe()
  };
}
function GYe() {
  return {
    listType: At(),
    onPreview: Fe(),
    onDownload: Fe(),
    onRemove: Fe(),
    items: $n(),
    progress: Nt(),
    prefixCls: At(),
    showRemoveIcon: Qe(),
    showDownloadIcon: Qe(),
    showPreviewIcon: Qe(),
    removeIcon: Fe(),
    downloadIcon: Fe(),
    previewIcon: Fe(),
    locale: Nt(void 0),
    previewFile: Fe(),
    iconRender: Fe(),
    isImageUrl: Fe(),
    appendAction: Fe(),
    appendActionVisible: Qe(),
    itemRender: Fe()
  };
}
function Gg(e) {
  return _(_({}, e), {
    lastModified: e.lastModified,
    lastModifiedDate: e.lastModifiedDate,
    name: e.name,
    size: e.size,
    type: e.type,
    uid: e.uid,
    percent: 0,
    originFileObj: e
  });
}
function Yg(e, t) {
  const n = [...t], o = n.findIndex((l) => {
    let {
      uid: r
    } = l;
    return r === e.uid;
  });
  return o === -1 ? n.push(e) : n[o] = e, n;
}
function v$(e, t) {
  const n = e.uid !== void 0 ? "uid" : "name";
  return t.filter((o) => o[n] === e[n])[0];
}
function YYe(e, t) {
  const n = e.uid !== void 0 ? "uid" : "name", o = t.filter((l) => l[n] !== e[n]);
  return o.length === t.length ? null : o;
}
const XYe = function() {
  const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "").split("/"), o = t[t.length - 1].split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(o) || [""])[0];
}, aY = (e) => e.indexOf("image/") === 0, qYe = (e) => {
  if (e.type && !e.thumbUrl)
    return aY(e.type);
  const t = e.thumbUrl || e.url || "", n = XYe(t);
  return /^data:image\//.test(t) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i.test(n) ? !0 : !(/^data:/.test(t) || n);
}, Rs = 200;
function JYe(e) {
  return new Promise((t) => {
    if (!e.type || !aY(e.type)) {
      t("");
      return;
    }
    const n = document.createElement("canvas");
    n.width = Rs, n.height = Rs, n.style.cssText = `position: fixed; left: 0; top: 0; width: ${Rs}px; height: ${Rs}px; z-index: 9999; display: none;`, document.body.appendChild(n);
    const o = n.getContext("2d"), l = new Image();
    if (l.onload = () => {
      const {
        width: r,
        height: a
      } = l;
      let i = Rs, s = Rs, c = 0, u = 0;
      r > a ? (s = a * (Rs / r), u = -(s - i) / 2) : (i = r * (Rs / a), c = -(i - s) / 2), o.drawImage(l, c, u, i, s);
      const d = n.toDataURL();
      document.body.removeChild(n), t(d);
    }, l.crossOrigin = "anonymous", e.type.startsWith("image/svg+xml")) {
      const r = new FileReader();
      r.addEventListener("load", () => {
        r.result && (l.src = r.result);
      }), r.readAsDataURL(e);
    } else
      l.src = window.URL.createObjectURL(e);
  });
}
var ZYe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, name: "download", theme: "outlined" };
function oD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      QYe(e, l, n[l]);
    });
  }
  return e;
}
function QYe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var FP = function(t, n) {
  var o = oD({}, t, n.attrs);
  return $(cn, oD({}, o, {
    icon: ZYe
  }), null);
};
FP.displayName = "DownloadOutlined";
FP.inheritAttrs = !1;
const eXe = () => ({
  prefixCls: String,
  locale: Nt(void 0),
  file: Nt(),
  items: $n(),
  listType: At(),
  isImgUrl: Fe(),
  showRemoveIcon: Qe(),
  showDownloadIcon: Qe(),
  showPreviewIcon: Qe(),
  removeIcon: Fe(),
  downloadIcon: Fe(),
  previewIcon: Fe(),
  iconRender: Fe(),
  actionIconRender: Fe(),
  itemRender: Fe(),
  onPreview: Fe(),
  onClose: Fe(),
  onDownload: Fe(),
  progress: Nt()
}), tXe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "ListItem",
  inheritAttrs: !1,
  props: eXe(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    var l;
    const r = /* @__PURE__ */ Ce(!1), a = /* @__PURE__ */ Ce();
    nt(() => {
      a.value = setTimeout(() => {
        r.value = !0;
      }, 300);
    }), yt(() => {
      clearTimeout(a.value);
    });
    const i = /* @__PURE__ */ Ce((l = e.file) === null || l === void 0 ? void 0 : l.status);
    pe(() => {
      var u;
      return (u = e.file) === null || u === void 0 ? void 0 : u.status;
    }, (u) => {
      u !== "removed" && (i.value = u);
    });
    const {
      rootPrefixCls: s
    } = bt("upload", e), c = O(() => da(`${s.value}-fade`));
    return () => {
      var u, d;
      const {
        prefixCls: f,
        locale: p,
        listType: m,
        file: v,
        items: h,
        progress: g,
        iconRender: y = n.iconRender,
        actionIconRender: b = n.actionIconRender,
        itemRender: C = n.itemRender,
        isImgUrl: w,
        showPreviewIcon: x,
        showRemoveIcon: E,
        showDownloadIcon: I,
        previewIcon: T = n.previewIcon,
        removeIcon: P = n.removeIcon,
        downloadIcon: k = n.downloadIcon,
        onPreview: N,
        onDownload: R,
        onClose: z
      } = e, {
        class: D,
        style: F
      } = o, M = y({
        file: v
      });
      let A = $("div", {
        class: `${f}-text-icon`
      }, [M]);
      if (m === "picture" || m === "picture-card")
        if (i.value === "uploading" || !v.thumbUrl && !v.url) {
          const Z = {
            [`${f}-list-item-thumbnail`]: !0,
            [`${f}-list-item-file`]: i.value !== "uploading"
          };
          A = $("div", {
            class: Z
          }, [M]);
        } else {
          const Z = w != null && w(v) ? $("img", {
            src: v.thumbUrl || v.url,
            alt: v.name,
            class: `${f}-list-item-image`,
            crossorigin: v.crossOrigin
          }, null) : M, ee = {
            [`${f}-list-item-thumbnail`]: !0,
            [`${f}-list-item-file`]: w && !w(v)
          };
          A = $("a", {
            class: ee,
            onClick: (fe) => N(v, fe),
            href: v.url || v.thumbUrl,
            target: "_blank",
            rel: "noopener noreferrer"
          }, [Z]);
        }
      const L = {
        [`${f}-list-item`]: !0,
        [`${f}-list-item-${i.value}`]: !0
      }, B = typeof v.linkProps == "string" ? JSON.parse(v.linkProps) : v.linkProps, V = E ? b({
        customIcon: P ? P({
          file: v
        }) : $(rC, null, null),
        callback: () => z(v),
        prefixCls: f,
        title: p.removeFile
      }) : null, j = I && i.value === "done" ? b({
        customIcon: k ? k({
          file: v
        }) : $(FP, null, null),
        callback: () => R(v),
        prefixCls: f,
        title: p.downloadFile
      }) : null, W = m !== "picture-card" && $("span", {
        key: "download-delete",
        class: [`${f}-list-item-actions`, {
          picture: m === "picture"
        }]
      }, [j, V]), Y = `${f}-list-item-name`, U = v.url ? [$("a", Q(Q({
        key: "view",
        target: "_blank",
        rel: "noopener noreferrer",
        class: Y,
        title: v.name
      }, B), {}, {
        href: v.url,
        onClick: (Z) => N(v, Z)
      }), [v.name]), W] : [$("span", {
        key: "view",
        class: Y,
        onClick: (Z) => N(v, Z),
        title: v.name
      }, [v.name]), W], te = {
        pointerEvents: "none",
        opacity: 0.5
      }, J = x ? $("a", {
        href: v.url || v.thumbUrl,
        target: "_blank",
        rel: "noopener noreferrer",
        style: v.url || v.thumbUrl ? void 0 : te,
        onClick: (Z) => N(v, Z),
        title: p.previewFile
      }, [T ? T({
        file: v
      }) : $(Bh, null, null)]) : null, re = m === "picture-card" && i.value !== "uploading" && $("span", {
        class: `${f}-list-item-actions`
      }, [J, i.value === "done" && j, V]), oe = $("div", {
        class: L
      }, [A, U, re, r.value && $(Vn, c.value, {
        default: () => [_t($("div", {
          class: `${f}-list-item-progress`
        }, ["percent" in v ? $(vP, Q(Q({}, g), {}, {
          type: "line",
          percent: v.percent
        }), null) : null]), [[Jt, i.value === "uploading"]])]
      })]), q = {
        [`${f}-list-item-container`]: !0,
        [`${D}`]: !!D
      }, K = v.response && typeof v.response == "string" ? v.response : ((u = v.error) === null || u === void 0 ? void 0 : u.statusText) || ((d = v.error) === null || d === void 0 ? void 0 : d.message) || p.uploadError, se = i.value === "error" ? $(Sr, {
        title: K,
        getPopupContainer: (Z) => Z.parentNode
      }, {
        default: () => [oe]
      }) : oe;
      return $("div", {
        class: q,
        style: F
      }, [C ? C({
        originNode: se,
        file: v,
        fileList: h,
        actions: {
          download: R.bind(null, v),
          preview: N.bind(null, v),
          remove: z.bind(null, v)
        }
      }) : se]);
    };
  }
}), nXe = (e, t) => {
  let {
    slots: n
  } = t;
  var o;
  return mo((o = n.default) === null || o === void 0 ? void 0 : o.call(n))[0];
}, oXe = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AUploadList",
  props: sn(GYe(), {
    listType: "text",
    progress: {
      strokeWidth: 2,
      showInfo: !1
    },
    showRemoveIcon: !0,
    showDownloadIcon: !1,
    showPreviewIcon: !0,
    previewFile: JYe,
    isImageUrl: qYe,
    items: [],
    appendActionVisible: !0
  }),
  setup(e, t) {
    let {
      slots: n,
      expose: o
    } = t;
    const l = /* @__PURE__ */ Ce(!1);
    nt(() => {
      l.value == !0;
    });
    const r = /* @__PURE__ */ Ce([]);
    pe(() => e.items, function() {
      let v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      r.value = v.slice();
    }, {
      immediate: !0,
      deep: !0
    }), Ot(() => {
      if (e.listType !== "picture" && e.listType !== "picture-card")
        return;
      let v = !1;
      (e.items || []).forEach((h, g) => {
        typeof document == "undefined" || typeof window == "undefined" || !window.FileReader || !window.File || !(h.originFileObj instanceof File || h.originFileObj instanceof Blob) || h.thumbUrl !== void 0 || (h.thumbUrl = "", e.previewFile && e.previewFile(h.originFileObj).then((y) => {
          const b = y || "";
          b !== h.thumbUrl && (r.value[g].thumbUrl = b, v = !0);
        }));
      }), v && lf(r);
    });
    const a = (v, h) => {
      if (e.onPreview)
        return h == null || h.preventDefault(), e.onPreview(v);
    }, i = (v) => {
      typeof e.onDownload == "function" ? e.onDownload(v) : v.url && window.open(v.url);
    }, s = (v) => {
      var h;
      (h = e.onRemove) === null || h === void 0 || h.call(e, v);
    }, c = (v) => {
      let {
        file: h
      } = v;
      const g = e.iconRender || n.iconRender;
      if (g)
        return g({
          file: h,
          listType: e.listType
        });
      const y = h.status === "uploading", b = e.isImageUrl && e.isImageUrl(h) ? $(LP, null, null) : $(BP, null, null);
      let C = $(y ? ar : DP, null, null);
      return e.listType === "picture" ? C = y ? $(ar, null, null) : b : e.listType === "picture-card" && (C = y ? e.locale.uploading : b), C;
    }, u = (v) => {
      const {
        customIcon: h,
        callback: g,
        prefixCls: y,
        title: b
      } = v, C = {
        type: "text",
        size: "small",
        title: b,
        onClick: () => {
          g();
        },
        class: `${y}-list-item-action`
      };
      return Io(h) ? $(ko, C, {
        icon: () => h
      }) : $(ko, C, {
        default: () => [$("span", null, [h])]
      });
    };
    o({
      handlePreview: a,
      handleDownload: i
    });
    const {
      prefixCls: d,
      rootPrefixCls: f
    } = bt("upload", e), p = O(() => ({
      [`${d.value}-list`]: !0,
      [`${d.value}-list-${e.listType}`]: !0
    })), m = O(() => {
      const v = _({}, Ph(`${f.value}-motion-collapse`));
      delete v.onAfterAppear, delete v.onAfterEnter, delete v.onAfterLeave;
      const h = _(_({}, vS(`${d.value}-${e.listType === "picture-card" ? "animate-inline" : "animate"}`)), {
        class: p.value,
        appear: l.value
      });
      return e.listType !== "picture-card" ? _(_({}, v), h) : h;
    });
    return () => {
      const {
        listType: v,
        locale: h,
        isImageUrl: g,
        showPreviewIcon: y,
        showRemoveIcon: b,
        showDownloadIcon: C,
        removeIcon: w,
        previewIcon: x,
        downloadIcon: E,
        progress: I,
        appendAction: T,
        itemRender: P,
        appendActionVisible: k
      } = e, N = T == null ? void 0 : T(), R = r.value;
      return $(mp, Q(Q({}, m.value), {}, {
        tag: "div"
      }), {
        default: () => [R.map((z) => {
          const {
            uid: D
          } = z;
          return $(tXe, {
            key: D,
            locale: h,
            prefixCls: d.value,
            file: z,
            items: R,
            progress: I,
            listType: v,
            isImgUrl: g,
            showPreviewIcon: y,
            showRemoveIcon: b,
            showDownloadIcon: C,
            onPreview: a,
            onDownload: i,
            onClose: s,
            removeIcon: w,
            previewIcon: x,
            downloadIcon: E,
            itemRender: P
          }, _(_({}, n), {
            iconRender: c,
            actionIconRender: u
          }));
        }), T ? _t($(nXe, {
          key: "__ant_upload_appendAction"
        }, {
          default: () => N
        }), [[Jt, !!k]]) : null]
      });
    };
  }
}), lXe = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [`${t}-wrapper`]: {
      [`${t}-drag`]: {
        position: "relative",
        width: "100%",
        height: "100%",
        textAlign: "center",
        background: e.colorFillAlter,
        border: `${e.lineWidth}px dashed ${e.colorBorder}`,
        borderRadius: e.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${e.motionDurationSlow}`,
        [t]: {
          padding: `${e.padding}px 0`
        },
        [`${t}-btn`]: {
          display: "table",
          width: "100%",
          height: "100%",
          outline: "none"
        },
        [`${t}-drag-container`]: {
          display: "table-cell",
          verticalAlign: "middle"
        },
        [`&:not(${t}-disabled):hover`]: {
          borderColor: e.colorPrimaryHover
        },
        [`p${t}-drag-icon`]: {
          marginBottom: e.margin,
          [n]: {
            color: e.colorPrimary,
            fontSize: e.uploadThumbnailSize
          }
        },
        [`p${t}-text`]: {
          margin: `0 0 ${e.marginXXS}px`,
          color: e.colorTextHeading,
          fontSize: e.fontSizeLG
        },
        [`p${t}-hint`]: {
          color: e.colorTextDescription,
          fontSize: e.fontSize
        },
        // ===================== Disabled =====================
        [`&${t}-disabled`]: {
          cursor: "not-allowed",
          [`p${t}-drag-icon ${n},
            p${t}-text,
            p${t}-hint
          `]: {
            color: e.colorTextDisabled
          }
        }
      }
    }
  };
}, rXe = (e) => {
  const {
    componentCls: t,
    antCls: n,
    iconCls: o,
    fontSize: l,
    lineHeight: r
  } = e, a = `${t}-list-item`, i = `${a}-actions`, s = `${a}-action`, c = Math.round(l * r);
  return {
    [`${t}-wrapper`]: {
      [`${t}-list`]: _(_({}, ja()), {
        lineHeight: e.lineHeight,
        [a]: {
          position: "relative",
          height: e.lineHeight * l,
          marginTop: e.marginXS,
          fontSize: l,
          display: "flex",
          alignItems: "center",
          transition: `background-color ${e.motionDurationSlow}`,
          "&:hover": {
            backgroundColor: e.controlItemBgHover
          },
          [`${a}-name`]: _(_({}, Fo), {
            padding: `0 ${e.paddingXS}px`,
            lineHeight: r,
            flex: "auto",
            transition: `all ${e.motionDurationSlow}`
          }),
          [i]: {
            [s]: {
              opacity: 0
            },
            [`${s}${n}-btn-sm`]: {
              height: c,
              border: 0,
              lineHeight: 1,
              // FIXME: should not override small button
              "> span": {
                transform: "scale(1)"
              }
            },
            [`
              ${s}:focus,
              &.picture ${s}
            `]: {
              opacity: 1
            },
            [o]: {
              color: e.colorTextDescription,
              transition: `all ${e.motionDurationSlow}`
            },
            [`&:hover ${o}`]: {
              color: e.colorText
            }
          },
          [`${t}-icon ${o}`]: {
            color: e.colorTextDescription,
            fontSize: l
          },
          [`${a}-progress`]: {
            position: "absolute",
            bottom: -e.uploadProgressOffset,
            width: "100%",
            paddingInlineStart: l + e.paddingXS,
            fontSize: l,
            lineHeight: 0,
            pointerEvents: "none",
            "> div": {
              margin: 0
            }
          }
        },
        [`${a}:hover ${s}`]: {
          opacity: 1,
          color: e.colorText
        },
        [`${a}-error`]: {
          color: e.colorError,
          [`${a}-name, ${t}-icon ${o}`]: {
            color: e.colorError
          },
          [i]: {
            [`${o}, ${o}:hover`]: {
              color: e.colorError
            },
            [s]: {
              opacity: 1
            }
          }
        },
        [`${t}-list-item-container`]: {
          transition: `opacity ${e.motionDurationSlow}, height ${e.motionDurationSlow}`,
          // For smooth removing animation
          "&::before": {
            display: "table",
            width: 0,
            height: 0,
            content: '""'
          }
        }
      })
    }
  };
}, lD = new mn("uploadAnimateInlineIn", {
  from: {
    width: 0,
    height: 0,
    margin: 0,
    padding: 0,
    opacity: 0
  }
}), rD = new mn("uploadAnimateInlineOut", {
  to: {
    width: 0,
    height: 0,
    margin: 0,
    padding: 0,
    opacity: 0
  }
}), aXe = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-animate-inline`;
  return [{
    [`${t}-wrapper`]: {
      [`${n}-appear, ${n}-enter, ${n}-leave`]: {
        animationDuration: e.motionDurationSlow,
        animationTimingFunction: e.motionEaseInOutCirc,
        animationFillMode: "forwards"
      },
      [`${n}-appear, ${n}-enter`]: {
        animationName: lD
      },
      [`${n}-leave`]: {
        animationName: rD
      }
    }
  }, lD, rD];
}, iXe = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    uploadThumbnailSize: o,
    uploadProgressOffset: l
  } = e, r = `${t}-list`, a = `${r}-item`;
  return {
    [`${t}-wrapper`]: {
      // ${listCls} 
      [`${r}${r}-picture, ${r}${r}-picture-card`]: {
        [a]: {
          position: "relative",
          height: o + e.lineWidth * 2 + e.paddingXS * 2,
          padding: e.paddingXS,
          border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
          borderRadius: e.borderRadiusLG,
          "&:hover": {
            background: "transparent"
          },
          [`${a}-thumbnail`]: _(_({}, Fo), {
            width: o,
            height: o,
            lineHeight: `${o + e.paddingSM}px`,
            textAlign: "center",
            flex: "none",
            [n]: {
              fontSize: e.fontSizeHeading2,
              color: e.colorPrimary
            },
            img: {
              display: "block",
              width: "100%",
              height: "100%",
              overflow: "hidden"
            }
          }),
          [`${a}-progress`]: {
            bottom: l,
            width: `calc(100% - ${e.paddingSM * 2}px)`,
            marginTop: 0,
            paddingInlineStart: o + e.paddingXS
          }
        },
        [`${a}-error`]: {
          borderColor: e.colorError,
          // Adjust the color of the error icon : https://github.com/ant-design/ant-design/pull/24160
          [`${a}-thumbnail ${n}`]: {
            "svg path[fill='#e6f7ff']": {
              fill: e.colorErrorBg
            },
            "svg path[fill='#1890ff']": {
              fill: e.colorError
            }
          }
        },
        [`${a}-uploading`]: {
          borderStyle: "dashed",
          [`${a}-name`]: {
            marginBottom: l
          }
        }
      }
    }
  };
}, sXe = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    fontSizeLG: o,
    colorTextLightSolid: l
  } = e, r = `${t}-list`, a = `${r}-item`, i = e.uploadPicCardSize;
  return {
    [`${t}-wrapper${t}-picture-card-wrapper`]: _(_({}, ja()), {
      display: "inline-block",
      width: "100%",
      [`${t}${t}-select`]: {
        width: i,
        height: i,
        marginInlineEnd: e.marginXS,
        marginBottom: e.marginXS,
        textAlign: "center",
        verticalAlign: "top",
        backgroundColor: e.colorFillAlter,
        border: `${e.lineWidth}px dashed ${e.colorBorder}`,
        borderRadius: e.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${e.motionDurationSlow}`,
        [`> ${t}`]: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          textAlign: "center"
        },
        [`&:not(${t}-disabled):hover`]: {
          borderColor: e.colorPrimary
        }
      },
      // list
      [`${r}${r}-picture-card`]: {
        [`${r}-item-container`]: {
          display: "inline-block",
          width: i,
          height: i,
          marginBlock: `0 ${e.marginXS}px`,
          marginInline: `0 ${e.marginXS}px`,
          verticalAlign: "top"
        },
        "&::after": {
          display: "none"
        },
        [a]: {
          height: "100%",
          margin: 0,
          "&::before": {
            position: "absolute",
            zIndex: 1,
            width: `calc(100% - ${e.paddingXS * 2}px)`,
            height: `calc(100% - ${e.paddingXS * 2}px)`,
            backgroundColor: e.colorBgMask,
            opacity: 0,
            transition: `all ${e.motionDurationSlow}`,
            content: '" "'
          }
        },
        [`${a}:hover`]: {
          [`&::before, ${a}-actions`]: {
            opacity: 1
          }
        },
        [`${a}-actions`]: {
          position: "absolute",
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          whiteSpace: "nowrap",
          textAlign: "center",
          opacity: 0,
          transition: `all ${e.motionDurationSlow}`,
          [`${n}-eye, ${n}-download, ${n}-delete`]: {
            zIndex: 10,
            width: o,
            margin: `0 ${e.marginXXS}px`,
            fontSize: o,
            cursor: "pointer",
            transition: `all ${e.motionDurationSlow}`
          }
        },
        [`${a}-actions, ${a}-actions:hover`]: {
          [`${n}-eye, ${n}-download, ${n}-delete`]: {
            color: new xn(l).setAlpha(0.65).toRgbString(),
            "&:hover": {
              color: l
            }
          }
        },
        [`${a}-thumbnail, ${a}-thumbnail img`]: {
          position: "static",
          display: "block",
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        [`${a}-name`]: {
          display: "none",
          textAlign: "center"
        },
        [`${a}-file + ${a}-name`]: {
          position: "absolute",
          bottom: e.margin,
          display: "block",
          width: `calc(100% - ${e.paddingXS * 2}px)`
        },
        [`${a}-uploading`]: {
          [`&${a}`]: {
            backgroundColor: e.colorFillAlter
          },
          [`&::before, ${n}-eye, ${n}-download, ${n}-delete`]: {
            display: "none"
          }
        },
        [`${a}-progress`]: {
          bottom: e.marginXL,
          width: `calc(100% - ${e.paddingXS * 2}px)`,
          paddingInlineStart: 0
        }
      }
    })
  };
}, cXe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl"
    }
  };
}, uXe = (e) => {
  const {
    componentCls: t,
    colorTextDisabled: n
  } = e;
  return {
    [`${t}-wrapper`]: _(_({}, nn(e)), {
      [t]: {
        outline: 0,
        "input[type='file']": {
          cursor: "pointer"
        }
      },
      [`${t}-select`]: {
        display: "inline-block"
      },
      [`${t}-disabled`]: {
        color: n,
        cursor: "not-allowed"
      }
    })
  };
}, dXe = Zt("Upload", (e) => {
  const {
    fontSizeHeading3: t,
    fontSize: n,
    lineHeight: o,
    lineWidth: l,
    controlHeightLG: r
  } = e, a = Math.round(n * o), i = Vt(e, {
    uploadThumbnailSize: t * 2,
    uploadProgressOffset: a / 2 + l,
    uploadPicCardSize: r * 2.55
  });
  return [uXe(i), lXe(i), iXe(i), sXe(i), rXe(i), aXe(i), cXe(i), Ih(i)];
});
var fXe = function(e, t, n, o) {
  function l(r) {
    return r instanceof n ? r : new n(function(a) {
      a(r);
    });
  }
  return new (n || (n = Promise))(function(r, a) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (d) {
        a(d);
      }
    }
    function s(u) {
      try {
        c(o.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? r(u.value) : l(u.value).then(i, s);
    }
    c((o = o.apply(e, t || [])).next());
  });
}, pXe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const Sv = `__LIST_IGNORE_${Date.now()}__`, a0 = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AUpload",
  inheritAttrs: !1,
  props: sn(rY(), {
    type: "select",
    multiple: !1,
    action: "",
    data: {},
    accept: "",
    showUploadList: !0,
    listType: "text",
    supportServerRender: !0
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: l
    } = t;
    const r = Ko(), {
      prefixCls: a,
      direction: i,
      disabled: s
    } = bt("upload", e), [c, u] = dXe(a), d = Cr(), f = O(() => {
      var k;
      return (k = s.value) !== null && k !== void 0 ? k : d.value;
    }), [p, m] = ro(e.defaultFileList || [], {
      value: /* @__PURE__ */ ft(e, "fileList"),
      postState: (k) => {
        const N = Date.now();
        return (k != null ? k : []).map((R, z) => (!R.uid && !Object.isFrozen(R) && (R.uid = `__AUTO__${N}_${z}__`), R));
      }
    }), v = /* @__PURE__ */ H("drop"), h = /* @__PURE__ */ H(null);
    nt(() => {
      un(e.fileList !== void 0 || o.value === void 0, "Upload", "`value` is not a valid prop, do you mean `fileList`?"), un(e.transformFile === void 0, "Upload", "`transformFile` is deprecated. Please use `beforeUpload` directly."), un(e.remove === void 0, "Upload", "`remove` props is deprecated. Please use `remove` event.");
    });
    const g = (k, N, R) => {
      var z, D;
      let F = [...N];
      e.maxCount === 1 ? F = F.slice(-1) : e.maxCount && (F = F.slice(0, e.maxCount)), m(F);
      const M = {
        file: k,
        fileList: F
      };
      R && (M.event = R), (z = e["onUpdate:fileList"]) === null || z === void 0 || z.call(e, M.fileList), (D = e.onChange) === null || D === void 0 || D.call(e, M), r.onFieldChange();
    }, y = (k, N) => fXe(this, void 0, void 0, function* () {
      const {
        beforeUpload: R,
        transformFile: z
      } = e;
      let D = k;
      if (R) {
        const F = yield R(k, N);
        if (F === !1)
          return !1;
        if (delete k[Sv], F === Sv)
          return Object.defineProperty(k, Sv, {
            value: !0,
            configurable: !0
          }), !1;
        typeof F == "object" && F && (D = F);
      }
      return z && (D = yield z(D)), D;
    }), b = (k) => {
      const N = k.filter((D) => !D.file[Sv]);
      if (!N.length)
        return;
      const R = N.map((D) => Gg(D.file));
      let z = [...p.value];
      R.forEach((D) => {
        z = Yg(D, z);
      }), R.forEach((D, F) => {
        let M = D;
        if (N[F].parsedFile)
          D.status = "uploading";
        else {
          const {
            originFileObj: A
          } = D;
          let L;
          try {
            L = new File([A], A.name, {
              type: A.type
            });
          } catch (B) {
            L = new Blob([A], {
              type: A.type
            }), L.name = A.name, L.lastModifiedDate = /* @__PURE__ */ new Date(), L.lastModified = (/* @__PURE__ */ new Date()).getTime();
          }
          L.uid = D.uid, M = L;
        }
        g(M, z);
      });
    }, C = (k, N, R) => {
      try {
        typeof k == "string" && (k = JSON.parse(k));
      } catch (F) {
      }
      if (!v$(N, p.value))
        return;
      const z = Gg(N);
      z.status = "done", z.percent = 100, z.response = k, z.xhr = R;
      const D = Yg(z, p.value);
      g(z, D);
    }, w = (k, N) => {
      if (!v$(N, p.value))
        return;
      const R = Gg(N);
      R.status = "uploading", R.percent = k.percent;
      const z = Yg(R, p.value);
      g(R, z, k);
    }, x = (k, N, R) => {
      if (!v$(R, p.value))
        return;
      const z = Gg(R);
      z.error = k, z.response = N, z.status = "error";
      const D = Yg(z, p.value);
      g(z, D);
    }, E = (k) => {
      let N;
      const R = e.onRemove || e.remove;
      Promise.resolve(typeof R == "function" ? R(k) : R).then((z) => {
        var D, F;
        if (z === !1)
          return;
        const M = YYe(k, p.value);
        M && (N = _(_({}, k), {
          status: "removed"
        }), (D = p.value) === null || D === void 0 || D.forEach((A) => {
          const L = N.uid !== void 0 ? "uid" : "name";
          A[L] === N[L] && !Object.isFrozen(A) && (A.status = "removed");
        }), (F = h.value) === null || F === void 0 || F.abort(N), g(N, M));
      });
    }, I = (k) => {
      var N;
      v.value = k.type, k.type === "drop" && ((N = e.onDrop) === null || N === void 0 || N.call(e, k));
    };
    l({
      onBatchStart: b,
      onSuccess: C,
      onProgress: w,
      onError: x,
      fileList: p,
      upload: h
    });
    const [T] = fa("Upload", rr.Upload, O(() => e.locale)), P = (k, N) => {
      const {
        removeIcon: R,
        previewIcon: z,
        downloadIcon: D,
        previewFile: F,
        onPreview: M,
        onDownload: A,
        isImageUrl: L,
        progress: B,
        itemRender: V,
        iconRender: j,
        showUploadList: W
      } = e, {
        showDownloadIcon: Y,
        showPreviewIcon: U,
        showRemoveIcon: te
      } = typeof W == "boolean" ? {} : W;
      return W ? $(oXe, {
        prefixCls: a.value,
        listType: e.listType,
        items: p.value,
        previewFile: F,
        onPreview: M,
        onDownload: A,
        onRemove: E,
        showRemoveIcon: !f.value && te,
        showPreviewIcon: U,
        showDownloadIcon: Y,
        removeIcon: R,
        previewIcon: z,
        downloadIcon: D,
        iconRender: j,
        locale: T.value,
        isImageUrl: L,
        progress: B,
        itemRender: V,
        appendActionVisible: N,
        appendAction: k
      }, _({}, n)) : k == null ? void 0 : k();
    };
    return () => {
      var k, N, R;
      const {
        listType: z,
        type: D
      } = e, {
        class: F,
        style: M
      } = o, A = pXe(o, ["class", "style"]), L = _(_(_({
        onBatchStart: b,
        onError: x,
        onProgress: w,
        onSuccess: C
      }, A), e), {
        id: (k = e.id) !== null && k !== void 0 ? k : r.id.value,
        prefixCls: a.value,
        beforeUpload: y,
        onChange: void 0,
        disabled: f.value
      });
      delete L.remove, (!n.default || f.value) && delete L.id;
      const B = {
        [`${a.value}-rtl`]: i.value === "rtl"
      };
      if (D === "drag") {
        const Y = ke(a.value, {
          [`${a.value}-drag`]: !0,
          [`${a.value}-drag-uploading`]: p.value.some((U) => U.status === "uploading"),
          [`${a.value}-drag-hover`]: v.value === "dragover",
          [`${a.value}-disabled`]: f.value,
          [`${a.value}-rtl`]: i.value === "rtl"
        }, o.class, u.value);
        return c($("span", Q(Q({}, o), {}, {
          class: ke(`${a.value}-wrapper`, B, F, u.value)
        }), [$("div", {
          class: Y,
          onDrop: I,
          onDragover: I,
          onDragleave: I,
          style: o.style
        }, [$(QR, Q(Q({}, L), {}, {
          ref: h,
          class: `${a.value}-btn`
        }), Q({
          default: () => [$("div", {
            class: `${a.value}-drag-container`
          }, [(N = n.default) === null || N === void 0 ? void 0 : N.call(n)])]
        }, n))]), P()]));
      }
      const V = ke(a.value, {
        [`${a.value}-select`]: !0,
        [`${a.value}-select-${z}`]: !0,
        [`${a.value}-disabled`]: f.value,
        [`${a.value}-rtl`]: i.value === "rtl"
      }), j = Fn((R = n.default) === null || R === void 0 ? void 0 : R.call(n)), W = (Y) => $("div", {
        class: V,
        style: Y
      }, [$(QR, Q(Q({}, L), {}, {
        ref: h
      }), n)]);
      return c(z === "picture-card" ? $("span", Q(Q({}, o), {}, {
        class: ke(`${a.value}-wrapper`, `${a.value}-picture-card-wrapper`, B, o.class, u.value)
      }), [P(W, !!(j && j.length))]) : $("span", Q(Q({}, o), {}, {
        class: ke(`${a.value}-wrapper`, B, o.class, u.value)
      }), [W(j && j.length ? void 0 : {
        display: "none"
      }), P()]));
    };
  }
});
var aD = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const i0 = /* @__PURE__ */ le({
  compatConfig: {
    MODE: 3
  },
  name: "AUploadDragger",
  inheritAttrs: !1,
  props: rY(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    return () => {
      const {
        height: l
      } = e, r = aD(e, ["height"]), {
        style: a
      } = o, i = aD(o, ["style"]), s = _(_(_({}, r), i), {
        type: "drag",
        style: _(_({}, a), {
          height: typeof l == "number" ? `${l}px` : l
        })
      });
      return $(a0, s, n);
    };
  }
}), vXe = i0, mXe = _(a0, {
  Dragger: i0,
  LIST_IGNORE: Sv,
  install(e) {
    return e.component(a0.name, a0), e.component(i0.name, i0), e;
  }
});
function hXe(e) {
  return e.replace(/([A-Z])/g, "-$1").toLowerCase();
}
function gXe(e) {
  return Object.keys(e).map((t) => `${hXe(t)}: ${e[t]};`).join(" ");
}
function iD() {
  return window.devicePixelRatio || 1;
}
function m$(e, t, n, o) {
  e.translate(t, n), e.rotate(Math.PI / 180 * Number(o)), e.translate(-t, -n);
}
const bXe = (e, t) => {
  let n = !1;
  return e.removedNodes.length && (n = Array.from(e.removedNodes).some((o) => o === t)), e.type === "attributes" && e.target === t && (n = !0), n;
};
var yXe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
function SXe(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    window: o = BW
  } = n, l = yXe(n, ["window"]);
  let r;
  const a = DW(() => o && "MutationObserver" in o), i = () => {
    r && (r.disconnect(), r = void 0);
  }, s = pe(() => wT(e), (u) => {
    i(), a.value && o && u && (r = new MutationObserver(t), r.observe(u, l));
  }, {
    immediate: !0
  }), c = () => {
    i(), s();
  };
  return RW(c), {
    isSupported: a,
    stop: c
  };
}
const h$ = 2, sD = 3, CXe = () => ({
  zIndex: Number,
  rotate: Number,
  width: Number,
  height: Number,
  image: String,
  content: zt([String, Array]),
  font: Nt(),
  rootClassName: String,
  gap: $n(),
  offset: $n()
}), wXe = /* @__PURE__ */ le({
  name: "AWatermark",
  inheritAttrs: !1,
  props: sn(CXe(), {
    zIndex: 9,
    rotate: -22,
    font: {},
    gap: [100, 100]
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const [, l] = _s(), r = /* @__PURE__ */ Ce(), a = /* @__PURE__ */ Ce(), i = /* @__PURE__ */ Ce(!1), s = O(() => {
      var P, k;
      return (k = (P = e.gap) === null || P === void 0 ? void 0 : P[0]) !== null && k !== void 0 ? k : 100;
    }), c = O(() => {
      var P, k;
      return (k = (P = e.gap) === null || P === void 0 ? void 0 : P[1]) !== null && k !== void 0 ? k : 100;
    }), u = O(() => s.value / 2), d = O(() => c.value / 2), f = O(() => {
      var P, k;
      return (k = (P = e.offset) === null || P === void 0 ? void 0 : P[0]) !== null && k !== void 0 ? k : u.value;
    }), p = O(() => {
      var P, k;
      return (k = (P = e.offset) === null || P === void 0 ? void 0 : P[1]) !== null && k !== void 0 ? k : d.value;
    }), m = O(() => {
      var P, k;
      return (k = (P = e.font) === null || P === void 0 ? void 0 : P.fontSize) !== null && k !== void 0 ? k : l.value.fontSizeLG;
    }), v = O(() => {
      var P, k;
      return (k = (P = e.font) === null || P === void 0 ? void 0 : P.fontWeight) !== null && k !== void 0 ? k : "normal";
    }), h = O(() => {
      var P, k;
      return (k = (P = e.font) === null || P === void 0 ? void 0 : P.fontStyle) !== null && k !== void 0 ? k : "normal";
    }), g = O(() => {
      var P, k;
      return (k = (P = e.font) === null || P === void 0 ? void 0 : P.fontFamily) !== null && k !== void 0 ? k : "sans-serif";
    }), y = O(() => {
      var P, k;
      return (k = (P = e.font) === null || P === void 0 ? void 0 : P.color) !== null && k !== void 0 ? k : l.value.colorFill;
    }), b = O(() => {
      var P;
      const k = {
        zIndex: (P = e.zIndex) !== null && P !== void 0 ? P : 9,
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
        backgroundRepeat: "repeat"
      };
      let N = f.value - u.value, R = p.value - d.value;
      return N > 0 && (k.left = `${N}px`, k.width = `calc(100% - ${N}px)`, N = 0), R > 0 && (k.top = `${R}px`, k.height = `calc(100% - ${R}px)`, R = 0), k.backgroundPosition = `${N}px ${R}px`, k;
    }), C = () => {
      a.value && (a.value.remove(), a.value = void 0);
    }, w = (P, k) => {
      var N;
      r.value && a.value && (i.value = !0, a.value.setAttribute("style", gXe(_(_({}, b.value), {
        backgroundImage: `url('${P}')`,
        backgroundSize: `${(s.value + k) * h$}px`
      }))), (N = r.value) === null || N === void 0 || N.append(a.value), setTimeout(() => {
        i.value = !1;
      }));
    }, x = (P) => {
      let k = 120, N = 64;
      const R = e.content, z = e.image, D = e.width, F = e.height;
      if (!z && P.measureText) {
        P.font = `${Number(m.value)}px ${g.value}`;
        const M = Array.isArray(R) ? R : [R], A = M.map((L) => P.measureText(L).width);
        k = Math.ceil(Math.max(...A)), N = Number(m.value) * M.length + (M.length - 1) * sD;
      }
      return [D != null ? D : k, F != null ? F : N];
    }, E = (P, k, N, R, z) => {
      const D = iD(), F = e.content, M = Number(m.value) * D;
      P.font = `${h.value} normal ${v.value} ${M}px/${z}px ${g.value}`, P.fillStyle = y.value, P.textAlign = "center", P.textBaseline = "top", P.translate(R / 2, 0);
      const A = Array.isArray(F) ? F : [F];
      A == null || A.forEach((L, B) => {
        P.fillText(L != null ? L : "", k, N + B * (M + sD * D));
      });
    }, I = () => {
      var P;
      const k = document.createElement("canvas"), N = k.getContext("2d"), R = e.image, z = (P = e.rotate) !== null && P !== void 0 ? P : -22;
      if (N) {
        a.value || (a.value = document.createElement("div"));
        const D = iD(), [F, M] = x(N), A = (s.value + F) * D, L = (c.value + M) * D;
        k.setAttribute("width", `${A * h$}px`), k.setAttribute("height", `${L * h$}px`);
        const B = s.value * D / 2, V = c.value * D / 2, j = F * D, W = M * D, Y = (j + s.value * D) / 2, U = (W + c.value * D) / 2, te = B + A, J = V + L, re = Y + A, oe = U + L;
        if (N.save(), m$(N, Y, U, z), R) {
          const q = new Image();
          q.onload = () => {
            N.drawImage(q, B, V, j, W), N.restore(), m$(N, re, oe, z), N.drawImage(q, te, J, j, W), w(k.toDataURL(), F);
          }, q.crossOrigin = "anonymous", q.referrerPolicy = "no-referrer", q.src = R;
        } else
          E(N, B, V, j, W), N.restore(), m$(N, re, oe, z), E(N, te, J, j, W), w(k.toDataURL(), F);
      }
    };
    return nt(() => {
      I();
    }), pe(() => [e, l.value.colorFill, l.value.fontSizeLG], () => {
      I();
    }, {
      deep: !0,
      flush: "post"
    }), yt(() => {
      C();
    }), SXe(r, (P) => {
      i.value || P.forEach((k) => {
        bXe(k, a.value) && (C(), I());
      });
    }, {
      attributes: !0,
      subtree: !0,
      childList: !0,
      attributeFilter: ["style", "class"]
    }), () => {
      var P;
      return $("div", Q(Q({}, o), {}, {
        ref: r,
        class: [o.class, e.rootClassName],
        style: [{
          position: "relative"
        }, o.style]
      }), [(P = n.default) === null || P === void 0 ? void 0 : P.call(n)]);
    };
  }
}), $Xe = po(wXe);
function cD(e, t) {
  return {
    [`${e}, ${e}:hover, ${e}:focus`]: {
      color: t.colorTextDisabled,
      cursor: "not-allowed"
    }
  };
}
function uD(e) {
  return {
    backgroundColor: e.bgColorSelected,
    boxShadow: e.boxShadow
  };
}
const xXe = _({
  overflow: "hidden"
}, Fo), EXe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: _(_(_(_(_({}, nn(e)), {
      display: "inline-block",
      padding: e.segmentedContainerPadding,
      color: e.labelColor,
      backgroundColor: e.bgColor,
      borderRadius: e.borderRadius,
      transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
      [`${t}-group`]: {
        position: "relative",
        display: "flex",
        alignItems: "stretch",
        justifyItems: "flex-start",
        width: "100%"
      },
      // RTL styles
      [`&${t}-rtl`]: {
        direction: "rtl"
      },
      // block styles
      [`&${t}-block`]: {
        display: "flex"
      },
      [`&${t}-block ${t}-item`]: {
        flex: 1,
        minWidth: 0
      },
      // item styles
      [`${t}-item`]: {
        position: "relative",
        textAlign: "center",
        cursor: "pointer",
        transition: `color ${e.motionDurationMid} ${e.motionEaseInOut}`,
        borderRadius: e.borderRadiusSM,
        "&-selected": _(_({}, uD(e)), {
          color: e.labelColorHover
        }),
        "&::after": {
          content: '""',
          position: "absolute",
          width: "100%",
          height: "100%",
          top: 0,
          insetInlineStart: 0,
          borderRadius: "inherit",
          transition: `background-color ${e.motionDurationMid}`,
          pointerEvents: "none"
        },
        [`&:hover:not(${t}-item-selected):not(${t}-item-disabled)`]: {
          color: e.labelColorHover,
          "&::after": {
            backgroundColor: e.bgColorHover
          }
        },
        "&-label": _({
          minHeight: e.controlHeight - e.segmentedContainerPadding * 2,
          lineHeight: `${e.controlHeight - e.segmentedContainerPadding * 2}px`,
          padding: `0 ${e.segmentedPaddingHorizontal}px`
        }, xXe),
        // syntactic sugar to add `icon` for Segmented Item
        "&-icon + *": {
          marginInlineStart: e.marginSM / 2
        },
        "&-input": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none"
        }
      },
      // thumb styles
      [`${t}-thumb`]: _(_({}, uD(e)), {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: 0,
        height: "100%",
        padding: `${e.paddingXXS}px 0`,
        borderRadius: e.borderRadiusSM,
        [`& ~ ${t}-item:not(${t}-item-selected):not(${t}-item-disabled)::after`]: {
          backgroundColor: "transparent"
        }
      }),
      // size styles
      [`&${t}-lg`]: {
        borderRadius: e.borderRadiusLG,
        [`${t}-item-label`]: {
          minHeight: e.controlHeightLG - e.segmentedContainerPadding * 2,
          lineHeight: `${e.controlHeightLG - e.segmentedContainerPadding * 2}px`,
          padding: `0 ${e.segmentedPaddingHorizontal}px`,
          fontSize: e.fontSizeLG
        },
        [`${t}-item, ${t}-thumb`]: {
          borderRadius: e.borderRadius
        }
      },
      [`&${t}-sm`]: {
        borderRadius: e.borderRadiusSM,
        [`${t}-item-label`]: {
          minHeight: e.controlHeightSM - e.segmentedContainerPadding * 2,
          lineHeight: `${e.controlHeightSM - e.segmentedContainerPadding * 2}px`,
          padding: `0 ${e.segmentedPaddingHorizontalSM}px`
        },
        [`${t}-item, ${t}-thumb`]: {
          borderRadius: e.borderRadiusXS
        }
      }
    }), cD(`&-disabled ${t}-item`, e)), cD(`${t}-item-disabled`, e)), {
      // transition effect when `appear-active`
      [`${t}-thumb-motion-appear-active`]: {
        transition: `transform ${e.motionDurationSlow} ${e.motionEaseInOut}, width ${e.motionDurationSlow} ${e.motionEaseInOut}`,
        willChange: "transform, width"
      }
    })
  };
}, OXe = Zt("Segmented", (e) => {
  const {
    lineWidthBold: t,
    lineWidth: n,
    colorTextLabel: o,
    colorText: l,
    colorFillSecondary: r,
    colorBgLayout: a,
    colorBgElevated: i
  } = e, s = Vt(e, {
    segmentedPaddingHorizontal: e.controlPaddingHorizontal - n,
    segmentedPaddingHorizontalSM: e.controlPaddingHorizontalSM - n,
    segmentedContainerPadding: t,
    labelColor: o,
    labelColorHover: l,
    bgColor: a,
    bgColorHover: r,
    bgColorSelected: i
  });
  return [EXe(s)];
}), dD = (e) => e ? {
  left: e.offsetLeft,
  right: e.parentElement.clientWidth - e.clientWidth - e.offsetLeft,
  width: e.clientWidth
} : null, Dd = (e) => e !== void 0 ? `${e}px` : void 0, _Xe = /* @__PURE__ */ le({
  props: {
    value: Wn(),
    getValueIndex: Wn(),
    prefixCls: Wn(),
    motionName: Wn(),
    onMotionStart: Wn(),
    onMotionEnd: Wn(),
    direction: Wn(),
    containerRef: Wn()
  },
  emits: ["motionStart", "motionEnd"],
  setup(e, t) {
    let {
      emit: n
    } = t;
    const o = /* @__PURE__ */ H(), l = (m) => {
      var v;
      const h = e.getValueIndex(m), g = (v = e.containerRef.value) === null || v === void 0 ? void 0 : v.querySelectorAll(`.${e.prefixCls}-item`)[h];
      return (g == null ? void 0 : g.offsetParent) && g;
    }, r = /* @__PURE__ */ H(null), a = /* @__PURE__ */ H(null);
    pe(() => e.value, (m, v) => {
      const h = l(v), g = l(m), y = dD(h), b = dD(g);
      r.value = y, a.value = b, n(h && g ? "motionStart" : "motionEnd");
    }, {
      flush: "post"
    });
    const i = O(() => {
      var m, v;
      return e.direction === "rtl" ? Dd(-((m = r.value) === null || m === void 0 ? void 0 : m.right)) : Dd((v = r.value) === null || v === void 0 ? void 0 : v.left);
    }), s = O(() => {
      var m, v;
      return e.direction === "rtl" ? Dd(-((m = a.value) === null || m === void 0 ? void 0 : m.right)) : Dd((v = a.value) === null || v === void 0 ? void 0 : v.left);
    });
    let c;
    const u = (m) => {
      clearTimeout(c), Ke(() => {
        m && (m.style.transform = "translateX(var(--thumb-start-left))", m.style.width = "var(--thumb-start-width)");
      });
    }, d = (m) => {
      c = setTimeout(() => {
        m && (Ey(m, `${e.motionName}-appear-active`), m.style.transform = "translateX(var(--thumb-active-left))", m.style.width = "var(--thumb-active-width)");
      });
    }, f = (m) => {
      r.value = null, a.value = null, m && (m.style.transform = null, m.style.width = null, Oy(m, `${e.motionName}-appear-active`)), n("motionEnd");
    }, p = O(() => {
      var m, v;
      return {
        "--thumb-start-left": i.value,
        "--thumb-start-width": Dd((m = r.value) === null || m === void 0 ? void 0 : m.width),
        "--thumb-active-left": s.value,
        "--thumb-active-width": Dd((v = a.value) === null || v === void 0 ? void 0 : v.width)
      };
    });
    return yt(() => {
      clearTimeout(c);
    }), () => {
      const m = {
        ref: o,
        style: p.value,
        class: [`${e.prefixCls}-thumb`]
      };
      return process.env.NODE_ENV === "test" && (m["data-test-style"] = JSON.stringify(p.value)), $(Vn, {
        appear: !0,
        onBeforeEnter: u,
        onEnter: d,
        onAfterEnter: f
      }, {
        default: () => [!r.value || !a.value ? null : $("div", m, null)]
      });
    };
  }
});
function IXe(e) {
  return e.map((t) => typeof t == "object" && t !== null ? t : {
    label: t == null ? void 0 : t.toString(),
    title: t == null ? void 0 : t.toString(),
    value: t
  });
}
const TXe = () => ({
  prefixCls: String,
  options: $n(),
  block: Qe(),
  disabled: Qe(),
  size: At(),
  value: _(_({}, zt([String, Number])), {
    required: !0
  }),
  motionName: String,
  onChange: Fe(),
  "onUpdate:value": Fe()
}), iY = (e, t) => {
  let {
    slots: n,
    emit: o
  } = t;
  const {
    value: l,
    disabled: r,
    payload: a,
    title: i,
    prefixCls: s,
    label: c = n.label,
    checked: u,
    className: d
  } = e, f = (p) => {
    r || o("change", p, l);
  };
  return $("label", {
    class: ke({
      [`${s}-item-disabled`]: r
    }, d)
  }, [$("input", {
    class: `${s}-item-input`,
    type: "radio",
    disabled: r,
    checked: u,
    onChange: f
  }, null), $("div", {
    class: `${s}-item-label`,
    title: typeof i == "string" ? i : ""
  }, [typeof c == "function" ? c({
    value: l,
    disabled: r,
    payload: a,
    title: i
  }) : c != null ? c : l])]);
};
iY.inheritAttrs = !1;
const PXe = /* @__PURE__ */ le({
  name: "ASegmented",
  inheritAttrs: !1,
  props: sn(TXe(), {
    options: [],
    motionName: "thumb-motion"
  }),
  slots: Object,
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      attrs: l
    } = t;
    const {
      prefixCls: r,
      direction: a,
      size: i
    } = bt("segmented", e), [s, c] = OXe(r), u = /* @__PURE__ */ Ce(), d = /* @__PURE__ */ Ce(!1), f = O(() => IXe(e.options)), p = (m, v) => {
      e.disabled || (n("update:value", v), n("change", v));
    };
    return () => {
      const m = r.value;
      return s($("div", Q(Q({}, l), {}, {
        class: ke(m, {
          [c.value]: !0,
          [`${m}-block`]: e.block,
          [`${m}-disabled`]: e.disabled,
          [`${m}-lg`]: i.value == "large",
          [`${m}-sm`]: i.value == "small",
          [`${m}-rtl`]: a.value === "rtl"
        }, l.class),
        ref: u
      }), [$("div", {
        class: `${m}-group`
      }, [$(_Xe, {
        containerRef: u,
        prefixCls: m,
        value: e.value,
        motionName: `${m}-${e.motionName}`,
        direction: a.value,
        getValueIndex: (v) => f.value.findIndex((h) => h.value === v),
        onMotionStart: () => {
          d.value = !0;
        },
        onMotionEnd: () => {
          d.value = !1;
        }
      }, null), f.value.map((v) => $(iY, Q(Q({
        key: v.value,
        prefixCls: m,
        checked: v.value === e.value,
        onChange: p
      }, v), {}, {
        className: ke(v.className, `${m}-item`, {
          [`${m}-item-selected`]: v.value === e.value && !d.value
        }),
        disabled: !!e.disabled || !!v.disabled
      }), o))])]));
    };
  }
}), kXe = po(PXe), NXe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: _(_({}, nn(e)), {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: e.paddingSM,
      backgroundColor: e.colorWhite,
      borderRadius: e.borderRadiusLG,
      border: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`,
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      [`& > ${t}-mask`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: 10,
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        height: "100%",
        color: e.colorText,
        lineHeight: e.lineHeight,
        background: e.QRCodeMaskBackgroundColor,
        textAlign: "center",
        [`& > ${t}-expired , & > ${t}-scanned`]: {
          color: e.QRCodeTextColor
        }
      },
      "&-icon": {
        marginBlockEnd: e.marginXS,
        fontSize: e.controlHeight
      }
    }),
    [`${t}-borderless`]: {
      borderColor: "transparent"
    }
  };
}, MXe = Zt("QRCode", (e) => NXe(Vt(e, {
  QRCodeTextColor: "rgba(0, 0, 0, 0.88)",
  QRCodeMaskBackgroundColor: "rgba(255, 255, 255, 0.96)"
})));
var AXe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.1 209.3l-56.4 44.1C775.8 155.1 656.2 92 521.9 92 290 92 102.3 279.5 102 511.5 101.7 743.7 289.8 932 521.9 932c181.3 0 335.8-115 394.6-276.1 1.5-4.2-.7-8.9-4.9-10.3l-56.7-19.5a8 8 0 00-10.1 4.8c-1.8 5-3.8 10-5.9 14.9-17.3 41-42.1 77.8-73.7 109.4A344.77 344.77 0 01655.9 829c-42.3 17.9-87.4 27-133.8 27-46.5 0-91.5-9.1-133.8-27A341.5 341.5 0 01279 755.2a342.16 342.16 0 01-73.7-109.4c-17.9-42.4-27-87.4-27-133.9s9.1-91.5 27-133.9c17.3-41 42.1-77.8 73.7-109.4 31.6-31.6 68.4-56.4 109.3-73.8 42.3-17.9 87.4-27 133.8-27 46.5 0 91.5 9.1 133.8 27a341.5 341.5 0 01109.3 73.8c9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47a8 8 0 003 14.1l175.6 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c-.1-6.6-7.8-10.3-13-6.2z" } }] }, name: "reload", theme: "outlined" };
function fD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(l) {
      return Object.getOwnPropertyDescriptor(n, l).enumerable;
    }))), o.forEach(function(l) {
      RXe(e, l, n[l]);
    });
  }
  return e;
}
function RXe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var VP = function(t, n) {
  var o = fD({}, t, n.attrs);
  return $(cn, fD({}, o, {
    icon: AXe
  }), null);
};
VP.displayName = "ReloadOutlined";
VP.inheritAttrs = !1;
const zP = () => ({
  size: {
    type: Number,
    default: 160
  },
  value: {
    type: String,
    required: !0
  },
  type: At("canvas"),
  color: String,
  bgColor: String,
  includeMargin: Boolean,
  imageSettings: Nt()
}), DXe = () => _(_({}, zP()), {
  errorLevel: At("M"),
  icon: String,
  iconSize: {
    type: Number,
    default: 40
  },
  status: At("active"),
  bordered: {
    type: Boolean,
    default: !0
  }
});
/**
 * @license QR Code generator library (TypeScript)
 * Copyright (c) Project Nayuki.
 * SPDX-License-Identifier: MIT
 */
var ea;
(function(e) {
  class t {
    /*-- Static factory functions (high level) --*/
    // Returns a QR Code representing the given Unicode text string at the given error correction level.
    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
    // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
    // ecl argument if it can be done without increasing the version.
    static encodeText(i, s) {
      const c = e.QrSegment.makeSegments(i);
      return t.encodeSegments(c, s);
    }
    // Returns a QR Code representing the given binary data at the given error correction level.
    // This function always encodes using the binary segment mode, not any text mode. The maximum number of
    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
    static encodeBinary(i, s) {
      const c = e.QrSegment.makeBytes(i);
      return t.encodeSegments([c], s);
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a QR Code representing the given segments with the given encoding parameters.
    // The smallest possible QR Code version within the given range is automatically
    // chosen for the output. Iff boostEcl is true, then the ECC level of the result
    // may be higher than the ecl argument if it can be done without increasing the
    // version. The mask number is either between 0 to 7 (inclusive) to force that
    // mask, or -1 to automatically choose an appropriate mask (which may be slow).
    // This function allows the user to create a custom sequence of segments that switches
    // between modes (such as alphanumeric and byte) to encode text in less space.
    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
    static encodeSegments(i, s) {
      let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 40, d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1, f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0;
      if (!(t.MIN_VERSION <= c && c <= u && u <= t.MAX_VERSION) || d < -1 || d > 7) throw new RangeError("Invalid value");
      let p, m;
      for (p = c; ; p++) {
        const y = t.getNumDataCodewords(p, s) * 8, b = r.getTotalBits(i, p);
        if (b <= y) {
          m = b;
          break;
        }
        if (p >= u)
          throw new RangeError("Data too long");
      }
      for (const y of [t.Ecc.MEDIUM, t.Ecc.QUARTILE, t.Ecc.HIGH])
        f && m <= t.getNumDataCodewords(p, y) * 8 && (s = y);
      const v = [];
      for (const y of i) {
        n(y.mode.modeBits, 4, v), n(y.numChars, y.mode.numCharCountBits(p), v);
        for (const b of y.getData()) v.push(b);
      }
      l(v.length == m);
      const h = t.getNumDataCodewords(p, s) * 8;
      l(v.length <= h), n(0, Math.min(4, h - v.length), v), n(0, (8 - v.length % 8) % 8, v), l(v.length % 8 == 0);
      for (let y = 236; v.length < h; y ^= 253) n(y, 8, v);
      const g = [];
      for (; g.length * 8 < v.length; ) g.push(0);
      return v.forEach((y, b) => g[b >>> 3] |= y << 7 - (b & 7)), new t(p, s, g, d);
    }
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code with the given version number,
    // error correction level, data codeword bytes, and mask number.
    // This is a low-level API that most users should not use directly.
    // A mid-level API is the encodeSegments() function.
    constructor(i, s, c, u) {
      if (this.version = i, this.errorCorrectionLevel = s, this.modules = [], this.isFunction = [], i < t.MIN_VERSION || i > t.MAX_VERSION) throw new RangeError("Version value out of range");
      if (u < -1 || u > 7) throw new RangeError("Mask value out of range");
      this.size = i * 4 + 17;
      const d = [];
      for (let p = 0; p < this.size; p++) d.push(!1);
      for (let p = 0; p < this.size; p++)
        this.modules.push(d.slice()), this.isFunction.push(d.slice());
      this.drawFunctionPatterns();
      const f = this.addEccAndInterleave(c);
      if (this.drawCodewords(f), u == -1) {
        let p = 1e9;
        for (let m = 0; m < 8; m++) {
          this.applyMask(m), this.drawFormatBits(m);
          const v = this.getPenaltyScore();
          v < p && (u = m, p = v), this.applyMask(m);
        }
      }
      l(0 <= u && u <= 7), this.mask = u, this.applyMask(u), this.drawFormatBits(u), this.isFunction = [];
    }
    /*-- Accessor methods --*/
    // Returns the color of the module (pixel) at the given coordinates, which is false
    // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
    // If the given coordinates are out of bounds, then false (light) is returned.
    getModule(i, s) {
      return 0 <= i && i < this.size && 0 <= s && s < this.size && this.modules[s][i];
    }
    // Modified to expose modules for easy access
    getModules() {
      return this.modules;
    }
    /*-- Private helper methods for constructor: Drawing function modules --*/
    // Reads this object's version field, and draws and marks all function modules.
    drawFunctionPatterns() {
      for (let c = 0; c < this.size; c++)
        this.setFunctionModule(6, c, c % 2 == 0), this.setFunctionModule(c, 6, c % 2 == 0);
      this.drawFinderPattern(3, 3), this.drawFinderPattern(this.size - 4, 3), this.drawFinderPattern(3, this.size - 4);
      const i = this.getAlignmentPatternPositions(), s = i.length;
      for (let c = 0; c < s; c++)
        for (let u = 0; u < s; u++)
          c == 0 && u == 0 || c == 0 && u == s - 1 || c == s - 1 && u == 0 || this.drawAlignmentPattern(i[c], i[u]);
      this.drawFormatBits(0), this.drawVersion();
    }
    // Draws two copies of the format bits (with its own error correction code)
    // based on the given mask and this object's error correction level field.
    drawFormatBits(i) {
      const s = this.errorCorrectionLevel.formatBits << 3 | i;
      let c = s;
      for (let d = 0; d < 10; d++) c = c << 1 ^ (c >>> 9) * 1335;
      const u = (s << 10 | c) ^ 21522;
      l(u >>> 15 == 0);
      for (let d = 0; d <= 5; d++) this.setFunctionModule(8, d, o(u, d));
      this.setFunctionModule(8, 7, o(u, 6)), this.setFunctionModule(8, 8, o(u, 7)), this.setFunctionModule(7, 8, o(u, 8));
      for (let d = 9; d < 15; d++) this.setFunctionModule(14 - d, 8, o(u, d));
      for (let d = 0; d < 8; d++) this.setFunctionModule(this.size - 1 - d, 8, o(u, d));
      for (let d = 8; d < 15; d++) this.setFunctionModule(8, this.size - 15 + d, o(u, d));
      this.setFunctionModule(8, this.size - 8, !0);
    }
    // Draws two copies of the version bits (with its own error correction code),
    // based on this object's version field, iff 7 <= version <= 40.
    drawVersion() {
      if (this.version < 7) return;
      let i = this.version;
      for (let c = 0; c < 12; c++) i = i << 1 ^ (i >>> 11) * 7973;
      const s = this.version << 12 | i;
      l(s >>> 18 == 0);
      for (let c = 0; c < 18; c++) {
        const u = o(s, c), d = this.size - 11 + c % 3, f = Math.floor(c / 3);
        this.setFunctionModule(d, f, u), this.setFunctionModule(f, d, u);
      }
    }
    // Draws a 9*9 finder pattern including the border separator,
    // with the center module at (x, y). Modules can be out of bounds.
    drawFinderPattern(i, s) {
      for (let c = -4; c <= 4; c++)
        for (let u = -4; u <= 4; u++) {
          const d = Math.max(Math.abs(u), Math.abs(c)), f = i + u, p = s + c;
          0 <= f && f < this.size && 0 <= p && p < this.size && this.setFunctionModule(f, p, d != 2 && d != 4);
        }
    }
    // Draws a 5*5 alignment pattern, with the center module
    // at (x, y). All modules must be in bounds.
    drawAlignmentPattern(i, s) {
      for (let c = -2; c <= 2; c++)
        for (let u = -2; u <= 2; u++) this.setFunctionModule(i + u, s + c, Math.max(Math.abs(u), Math.abs(c)) != 1);
    }
    // Sets the color of a module and marks it as a function module.
    // Only used by the constructor. Coordinates must be in bounds.
    setFunctionModule(i, s, c) {
      this.modules[s][i] = c, this.isFunction[s][i] = !0;
    }
    /*-- Private helper methods for constructor: Codewords and masking --*/
    // Returns a new byte string representing the given data with the appropriate error correction
    // codewords appended to it, based on this object's version and error correction level.
    addEccAndInterleave(i) {
      const s = this.version, c = this.errorCorrectionLevel;
      if (i.length != t.getNumDataCodewords(s, c)) throw new RangeError("Invalid argument");
      const u = t.NUM_ERROR_CORRECTION_BLOCKS[c.ordinal][s], d = t.ECC_CODEWORDS_PER_BLOCK[c.ordinal][s], f = Math.floor(t.getNumRawDataModules(s) / 8), p = u - f % u, m = Math.floor(f / u), v = [], h = t.reedSolomonComputeDivisor(d);
      for (let y = 0, b = 0; y < u; y++) {
        const C = i.slice(b, b + m - d + (y < p ? 0 : 1));
        b += C.length;
        const w = t.reedSolomonComputeRemainder(C, h);
        y < p && C.push(0), v.push(C.concat(w));
      }
      const g = [];
      for (let y = 0; y < v[0].length; y++)
        v.forEach((b, C) => {
          (y != m - d || C >= p) && g.push(b[y]);
        });
      return l(g.length == f), g;
    }
    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
    // data area of this QR Code. Function modules need to be marked off before this is called.
    drawCodewords(i) {
      if (i.length != Math.floor(t.getNumRawDataModules(this.version) / 8)) throw new RangeError("Invalid argument");
      let s = 0;
      for (let c = this.size - 1; c >= 1; c -= 2) {
        c == 6 && (c = 5);
        for (let u = 0; u < this.size; u++)
          for (let d = 0; d < 2; d++) {
            const f = c - d, m = (c + 1 & 2) == 0 ? this.size - 1 - u : u;
            !this.isFunction[m][f] && s < i.length * 8 && (this.modules[m][f] = o(i[s >>> 3], 7 - (s & 7)), s++);
          }
      }
      l(s == i.length * 8);
    }
    // XORs the codeword modules in this QR Code with the given mask pattern.
    // The function modules must be marked and the codeword bits must be drawn
    // before masking. Due to the arithmetic of XOR, calling applyMask() with
    // the same mask value a second time will undo the mask. A final well-formed
    // QR Code needs exactly one (not zero, two, etc.) mask applied.
    applyMask(i) {
      if (i < 0 || i > 7) throw new RangeError("Mask value out of range");
      for (let s = 0; s < this.size; s++)
        for (let c = 0; c < this.size; c++) {
          let u;
          switch (i) {
            case 0:
              u = (c + s) % 2 == 0;
              break;
            case 1:
              u = s % 2 == 0;
              break;
            case 2:
              u = c % 3 == 0;
              break;
            case 3:
              u = (c + s) % 3 == 0;
              break;
            case 4:
              u = (Math.floor(c / 3) + Math.floor(s / 2)) % 2 == 0;
              break;
            case 5:
              u = c * s % 2 + c * s % 3 == 0;
              break;
            case 6:
              u = (c * s % 2 + c * s % 3) % 2 == 0;
              break;
            case 7:
              u = ((c + s) % 2 + c * s % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          !this.isFunction[s][c] && u && (this.modules[s][c] = !this.modules[s][c]);
        }
    }
    // Calculates and returns the penalty score based on state of this QR Code's current modules.
    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
    getPenaltyScore() {
      let i = 0;
      for (let d = 0; d < this.size; d++) {
        let f = !1, p = 0;
        const m = [0, 0, 0, 0, 0, 0, 0];
        for (let v = 0; v < this.size; v++)
          this.modules[d][v] == f ? (p++, p == 5 ? i += t.PENALTY_N1 : p > 5 && i++) : (this.finderPenaltyAddHistory(p, m), f || (i += this.finderPenaltyCountPatterns(m) * t.PENALTY_N3), f = this.modules[d][v], p = 1);
        i += this.finderPenaltyTerminateAndCount(f, p, m) * t.PENALTY_N3;
      }
      for (let d = 0; d < this.size; d++) {
        let f = !1, p = 0;
        const m = [0, 0, 0, 0, 0, 0, 0];
        for (let v = 0; v < this.size; v++)
          this.modules[v][d] == f ? (p++, p == 5 ? i += t.PENALTY_N1 : p > 5 && i++) : (this.finderPenaltyAddHistory(p, m), f || (i += this.finderPenaltyCountPatterns(m) * t.PENALTY_N3), f = this.modules[v][d], p = 1);
        i += this.finderPenaltyTerminateAndCount(f, p, m) * t.PENALTY_N3;
      }
      for (let d = 0; d < this.size - 1; d++)
        for (let f = 0; f < this.size - 1; f++) {
          const p = this.modules[d][f];
          p == this.modules[d][f + 1] && p == this.modules[d + 1][f] && p == this.modules[d + 1][f + 1] && (i += t.PENALTY_N2);
        }
      let s = 0;
      for (const d of this.modules) s = d.reduce((f, p) => f + (p ? 1 : 0), s);
      const c = this.size * this.size, u = Math.ceil(Math.abs(s * 20 - c * 10) / c) - 1;
      return l(0 <= u && u <= 9), i += u * t.PENALTY_N4, l(0 <= i && i <= 2568888), i;
    }
    /*-- Private helper functions --*/
    // Returns an ascending list of positions of alignment patterns for this version number.
    // Each position is in the range [0,177), and are used on both the x and y axes.
    // This could be implemented as lookup table of 40 variable-length lists of integers.
    getAlignmentPatternPositions() {
      if (this.version == 1) return [];
      {
        const i = Math.floor(this.version / 7) + 2, s = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (i * 2 - 2)) * 2, c = [6];
        for (let u = this.size - 7; c.length < i; u -= s) c.splice(1, 0, u);
        return c;
      }
    }
    // Returns the number of data bits that can be stored in a QR Code of the given version number, after
    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
    static getNumRawDataModules(i) {
      if (i < t.MIN_VERSION || i > t.MAX_VERSION) throw new RangeError("Version number out of range");
      let s = (16 * i + 128) * i + 64;
      if (i >= 2) {
        const c = Math.floor(i / 7) + 2;
        s -= (25 * c - 10) * c - 55, i >= 7 && (s -= 36);
      }
      return l(208 <= s && s <= 29648), s;
    }
    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
    // QR Code of the given version number and error correction level, with remainder bits discarded.
    // This stateless pure function could be implemented as a (40*4)-cell lookup table.
    static getNumDataCodewords(i, s) {
      return Math.floor(t.getNumRawDataModules(i) / 8) - t.ECC_CODEWORDS_PER_BLOCK[s.ordinal][i] * t.NUM_ERROR_CORRECTION_BLOCKS[s.ordinal][i];
    }
    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
    static reedSolomonComputeDivisor(i) {
      if (i < 1 || i > 255) throw new RangeError("Degree out of range");
      const s = [];
      for (let u = 0; u < i - 1; u++) s.push(0);
      s.push(1);
      let c = 1;
      for (let u = 0; u < i; u++) {
        for (let d = 0; d < s.length; d++)
          s[d] = t.reedSolomonMultiply(s[d], c), d + 1 < s.length && (s[d] ^= s[d + 1]);
        c = t.reedSolomonMultiply(c, 2);
      }
      return s;
    }
    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
    static reedSolomonComputeRemainder(i, s) {
      const c = s.map((u) => 0);
      for (const u of i) {
        const d = u ^ c.shift();
        c.push(0), s.forEach((f, p) => c[p] ^= t.reedSolomonMultiply(f, d));
      }
      return c;
    }
    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
    // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
    static reedSolomonMultiply(i, s) {
      if (i >>> 8 || s >>> 8) throw new RangeError("Byte out of range");
      let c = 0;
      for (let u = 7; u >= 0; u--)
        c = c << 1 ^ (c >>> 7) * 285, c ^= (s >>> u & 1) * i;
      return l(c >>> 8 == 0), c;
    }
    // Can only be called immediately after a light run is added, and
    // returns either 0, 1, or 2. A helper function for getPenaltyScore().
    finderPenaltyCountPatterns(i) {
      const s = i[1];
      l(s <= this.size * 3);
      const c = s > 0 && i[2] == s && i[3] == s * 3 && i[4] == s && i[5] == s;
      return (c && i[0] >= s * 4 && i[6] >= s ? 1 : 0) + (c && i[6] >= s * 4 && i[0] >= s ? 1 : 0);
    }
    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
    finderPenaltyTerminateAndCount(i, s, c) {
      return i && (this.finderPenaltyAddHistory(s, c), s = 0), s += this.size, this.finderPenaltyAddHistory(s, c), this.finderPenaltyCountPatterns(c);
    }
    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
    finderPenaltyAddHistory(i, s) {
      s[0] == 0 && (i += this.size), s.pop(), s.unshift(i);
    }
  }
  t.MIN_VERSION = 1, t.MAX_VERSION = 40, t.PENALTY_N1 = 3, t.PENALTY_N2 = 3, t.PENALTY_N3 = 40, t.PENALTY_N4 = 10, t.ECC_CODEWORDS_PER_BLOCK = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
    // High
  ], t.NUM_ERROR_CORRECTION_BLOCKS = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
    // High
  ], e.QrCode = t;
  function n(a, i, s) {
    if (i < 0 || i > 31 || a >>> i) throw new RangeError("Value out of range");
    for (let c = i - 1; c >= 0; c--) s.push(a >>> c & 1);
  }
  function o(a, i) {
    return (a >>> i & 1) != 0;
  }
  function l(a) {
    if (!a) throw new Error("Assertion error");
  }
  class r {
    /*-- Static factory functions (mid level) --*/
    // Returns a segment representing the given binary data encoded in
    // byte mode. All input byte arrays are acceptable. Any text string
    // can be converted to UTF-8 bytes and encoded as a byte mode segment.
    static makeBytes(i) {
      const s = [];
      for (const c of i) n(c, 8, s);
      return new r(r.Mode.BYTE, i.length, s);
    }
    // Returns a segment representing the given string of decimal digits encoded in numeric mode.
    static makeNumeric(i) {
      if (!r.isNumeric(i)) throw new RangeError("String contains non-numeric characters");
      const s = [];
      for (let c = 0; c < i.length; ) {
        const u = Math.min(i.length - c, 3);
        n(parseInt(i.substring(c, c + u), 10), u * 3 + 1, s), c += u;
      }
      return new r(r.Mode.NUMERIC, i.length, s);
    }
    // Returns a segment representing the given text string encoded in alphanumeric mode.
    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static makeAlphanumeric(i) {
      if (!r.isAlphanumeric(i)) throw new RangeError("String contains unencodable characters in alphanumeric mode");
      const s = [];
      let c;
      for (c = 0; c + 2 <= i.length; c += 2) {
        let u = r.ALPHANUMERIC_CHARSET.indexOf(i.charAt(c)) * 45;
        u += r.ALPHANUMERIC_CHARSET.indexOf(i.charAt(c + 1)), n(u, 11, s);
      }
      return c < i.length && n(r.ALPHANUMERIC_CHARSET.indexOf(i.charAt(c)), 6, s), new r(r.Mode.ALPHANUMERIC, i.length, s);
    }
    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
    // The result may use various segment modes and switch modes to optimize the length of the bit stream.
    static makeSegments(i) {
      return i == "" ? [] : r.isNumeric(i) ? [r.makeNumeric(i)] : r.isAlphanumeric(i) ? [r.makeAlphanumeric(i)] : [r.makeBytes(r.toUtf8ByteArray(i))];
    }
    // Returns a segment representing an Extended Channel Interpretation
    // (ECI) designator with the given assignment value.
    static makeEci(i) {
      const s = [];
      if (i < 0) throw new RangeError("ECI assignment value out of range");
      if (i < 128) n(i, 8, s);
      else if (i < 16384)
        n(2, 2, s), n(i, 14, s);
      else if (i < 1e6)
        n(6, 3, s), n(i, 21, s);
      else throw new RangeError("ECI assignment value out of range");
      return new r(r.Mode.ECI, 0, s);
    }
    // Tests whether the given string can be encoded as a segment in numeric mode.
    // A string is encodable iff each character is in the range 0 to 9.
    static isNumeric(i) {
      return r.NUMERIC_REGEX.test(i);
    }
    // Tests whether the given string can be encoded as a segment in alphanumeric mode.
    // A string is encodable iff each character is in the following set: 0 to 9, A to Z
    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static isAlphanumeric(i) {
      return r.ALPHANUMERIC_REGEX.test(i);
    }
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code segment with the given attributes and data.
    // The character count (numChars) must agree with the mode and the bit buffer length,
    // but the constraint isn't checked. The given bit buffer is cloned and stored.
    constructor(i, s, c) {
      if (this.mode = i, this.numChars = s, this.bitData = c, s < 0) throw new RangeError("Invalid argument");
      this.bitData = c.slice();
    }
    /*-- Methods --*/
    // Returns a new copy of the data bits of this segment.
    getData() {
      return this.bitData.slice();
    }
    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
    // the given version. The result is infinity if a segment has too many characters to fit its length field.
    static getTotalBits(i, s) {
      let c = 0;
      for (const u of i) {
        const d = u.mode.numCharCountBits(s);
        if (u.numChars >= 1 << d) return 1 / 0;
        c += 4 + d + u.bitData.length;
      }
      return c;
    }
    // Returns a new array of bytes representing the given string encoded in UTF-8.
    static toUtf8ByteArray(i) {
      i = encodeURI(i);
      const s = [];
      for (let c = 0; c < i.length; c++)
        i.charAt(c) != "%" ? s.push(i.charCodeAt(c)) : (s.push(parseInt(i.substring(c + 1, c + 3), 16)), c += 2);
      return s;
    }
  }
  r.NUMERIC_REGEX = /^[0-9]*$/, r.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/, r.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:", e.QrSegment = r;
})(ea || (ea = {}));
(function(e) {
  (function(t) {
    class n {
      /*-- Constructor and fields --*/
      constructor(l, r) {
        this.ordinal = l, this.formatBits = r;
      }
    }
    n.LOW = new n(0, 1), n.MEDIUM = new n(1, 0), n.QUARTILE = new n(2, 3), n.HIGH = new n(3, 2), t.Ecc = n;
  })(e.QrCode || (e.QrCode = {}));
})(ea || (ea = {}));
(function(e) {
  (function(t) {
    class n {
      /*-- Constructor and fields --*/
      constructor(l, r) {
        this.modeBits = l, this.numBitsCharCount = r;
      }
      /*-- Method --*/
      // (Package-private) Returns the bit width of the character count field for a segment in
      // this mode in a QR Code at the given version number. The result is in the range [0, 16].
      numCharCountBits(l) {
        return this.numBitsCharCount[Math.floor((l + 7) / 17)];
      }
    }
    n.NUMERIC = new n(1, [10, 12, 14]), n.ALPHANUMERIC = new n(2, [9, 11, 13]), n.BYTE = new n(4, [8, 16, 16]), n.KANJI = new n(8, [8, 10, 12]), n.ECI = new n(7, [0, 0, 0]), t.Mode = n;
  })(e.QrSegment || (e.QrSegment = {}));
})(ea || (ea = {}));
const sY = {
  L: ea.QrCode.Ecc.LOW,
  M: ea.QrCode.Ecc.MEDIUM,
  Q: ea.QrCode.Ecc.QUARTILE,
  H: ea.QrCode.Ecc.HIGH
}, SE = 128, cY = "L", uY = "#FFFFFF", dY = "#000000", fY = !1, LXe = 4, BXe = 0, FXe = 0.1;
function pY(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const n = [];
  return e.forEach(function(o, l) {
    let r = null;
    o.forEach(function(a, i) {
      if (!a && r !== null) {
        n.push(`M${r + t} ${l + t}h${i - r}v1H${r + t}z`), r = null;
        return;
      }
      if (i === o.length - 1) {
        if (!a)
          return;
        r === null ? n.push(`M${i + t},${l + t} h1v1H${i + t}z`) : n.push(`M${r + t},${l + t} h${i + 1 - r}v1H${r + t}z`);
        return;
      }
      a && r === null && (r = i);
    });
  }), n.join("");
}
function vY(e, t) {
  return e.slice().map((n, o) => o < t.y || o >= t.y + t.h ? n : n.map((l, r) => r < t.x || r >= t.x + t.w ? l : !1));
}
function mY(e, t, n, o) {
  if (o == null)
    return null;
  const l = e.length + n * 2, r = Math.floor(t * FXe), a = l / t, i = (o.width || r) * a, s = (o.height || r) * a, c = o.x == null ? e.length / 2 - i / 2 : o.x * a, u = o.y == null ? e.length / 2 - s / 2 : o.y * a;
  let d = null;
  if (o.excavate) {
    const f = Math.floor(c), p = Math.floor(u), m = Math.ceil(i + c - f), v = Math.ceil(s + u - p);
    d = {
      x: f,
      y: p,
      w: m,
      h: v
    };
  }
  return {
    x: c,
    y: u,
    h: s,
    w: i,
    excavation: d
  };
}
function hY(e, t) {
  return t != null ? Math.floor(t) : e ? LXe : BXe;
}
const VXe = function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e) {
    return !1;
  }
  return !0;
}(), zXe = /* @__PURE__ */ le({
  name: "QRCodeCanvas",
  inheritAttrs: !1,
  props: _(_({}, zP()), {
    level: String,
    bgColor: String,
    fgColor: String,
    marginSize: Number
  }),
  setup(e, t) {
    let {
      attrs: n,
      expose: o
    } = t;
    const l = O(() => {
      var s;
      return (s = e.imageSettings) === null || s === void 0 ? void 0 : s.src;
    }), r = /* @__PURE__ */ Ce(null), a = /* @__PURE__ */ Ce(null), i = /* @__PURE__ */ Ce(!1);
    return o({
      toDataURL: (s, c) => {
        var u;
        return (u = r.value) === null || u === void 0 ? void 0 : u.toDataURL(s, c);
      }
    }), Ot(() => {
      const {
        value: s,
        size: c = SE,
        level: u = cY,
        bgColor: d = uY,
        fgColor: f = dY,
        includeMargin: p = fY,
        marginSize: m,
        imageSettings: v
      } = e;
      if (r.value != null) {
        const h = r.value, g = h.getContext("2d");
        if (!g)
          return;
        let y = ea.QrCode.encodeText(s, sY[u]).getModules();
        const b = hY(p, m), C = y.length + b * 2, w = mY(y, c, b, v), x = a.value, E = i.value && w != null && x !== null && x.complete && x.naturalHeight !== 0 && x.naturalWidth !== 0;
        E && w.excavation != null && (y = vY(y, w.excavation));
        const I = window.devicePixelRatio || 1;
        h.height = h.width = c * I;
        const T = c / C * I;
        g.scale(T, T), g.fillStyle = d, g.fillRect(0, 0, C, C), g.fillStyle = f, VXe ? g.fill(new Path2D(pY(y, b))) : y.forEach(function(P, k) {
          P.forEach(function(N, R) {
            N && g.fillRect(R + b, k + b, 1, 1);
          });
        }), E && g.drawImage(x, w.x + b, w.y + b, w.w, w.h);
      }
    }, {
      flush: "post"
    }), pe(l, () => {
      i.value = !1;
    }), () => {
      var s;
      const c = (s = e.size) !== null && s !== void 0 ? s : SE, u = {
        height: `${c}px`,
        width: `${c}px`
      };
      let d = null;
      return l.value != null && (d = $("img", {
        src: l.value,
        key: l.value,
        style: {
          display: "none"
        },
        onLoad: () => {
          i.value = !0;
        },
        ref: a
      }, null)), $(Ge, null, [$("canvas", Q(Q({}, n), {}, {
        style: [u, n.style],
        ref: r
      }), null), d]);
    };
  }
}), HXe = /* @__PURE__ */ le({
  name: "QRCodeSVG",
  inheritAttrs: !1,
  props: _(_({}, zP()), {
    color: String,
    level: String,
    bgColor: String,
    fgColor: String,
    marginSize: Number,
    title: String
  }),
  setup(e) {
    let t = null, n = null, o = null, l = null, r = null, a = null;
    return Ot(() => {
      const {
        value: i,
        size: s = SE,
        level: c = cY,
        includeMargin: u = fY,
        marginSize: d,
        imageSettings: f
      } = e;
      t = ea.QrCode.encodeText(i, sY[c]).getModules(), n = hY(u, d), o = t.length + n * 2, l = mY(t, s, n, f), f != null && l != null && (l.excavation != null && (t = vY(t, l.excavation)), a = $("image", {
        "xlink:href": f.src,
        height: l.h,
        width: l.w,
        x: l.x + n,
        y: l.y + n,
        preserveAspectRatio: "none"
      }, null)), r = pY(t, n);
    }), () => {
      const i = e.bgColor && uY, s = e.fgColor && dY;
      return $("svg", {
        height: e.size,
        width: e.size,
        viewBox: `0 0 ${o} ${o}`
      }, [!!e.title && $("title", null, [e.title]), $("path", {
        fill: i,
        d: `M0,0 h${o}v${o}H0z`,
        "shape-rendering": "crispEdges"
      }, null), $("path", {
        fill: s,
        d: r,
        "shape-rendering": "crispEdges"
      }, null), a]);
    };
  }
}), jXe = /* @__PURE__ */ le({
  name: "AQrcode",
  inheritAttrs: !1,
  props: DXe(),
  emits: ["refresh"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      expose: l
    } = t;
    process.env.NODE_ENV !== "production" && Hn(!(e.icon && e.errorLevel === "L"), "QRCode", "ErrorLevel `L` is not recommended to be used with `icon`, for scanning result would be affected by low level.");
    const [r] = fa("QRCode"), {
      prefixCls: a
    } = bt("qrcode", e), [i, s] = MXe(a), [, c] = _s(), u = /* @__PURE__ */ H();
    l({
      toDataURL: (f, p) => {
        var m;
        return (m = u.value) === null || m === void 0 ? void 0 : m.toDataURL(f, p);
      }
    });
    const d = O(() => {
      const {
        value: f,
        icon: p = "",
        size: m = 160,
        iconSize: v = 40,
        color: h = c.value.colorText,
        bgColor: g = "transparent",
        errorLevel: y = "M"
      } = e, b = {
        src: p,
        x: void 0,
        y: void 0,
        height: v,
        width: v,
        excavate: !0
      };
      return {
        value: f,
        size: m - (c.value.paddingSM + c.value.lineWidth) * 2,
        level: y,
        bgColor: g,
        fgColor: h,
        imageSettings: p ? b : void 0
      };
    });
    return () => {
      const f = a.value;
      return i($("div", Q(Q({}, o), {}, {
        style: [o.style, {
          width: `${e.size}px`,
          height: `${e.size}px`,
          backgroundColor: d.value.bgColor
        }],
        class: [s.value, f, {
          [`${f}-borderless`]: !e.bordered
        }]
      }), [e.status !== "active" && $("div", {
        class: `${f}-mask`
      }, [e.status === "loading" && $(yi, null, null), e.status === "expired" && $(Ge, null, [$("p", {
        class: `${f}-expired`
      }, [r.value.expired]), $(ko, {
        type: "link",
        onClick: (p) => n("refresh", p)
      }, {
        default: () => [r.value.refresh],
        icon: () => $(VP, null, null)
      })]), e.status === "scanned" && $("p", {
        class: `${f}-scanned`
      }, [r.value.scanned])]), e.type === "canvas" ? $(zXe, Q({
        ref: u
      }, d.value), null) : $(HXe, d.value, null)]));
    };
  }
}), WXe = po(jXe);
function KXe(e) {
  const t = window.innerWidth || document.documentElement.clientWidth, n = window.innerHeight || document.documentElement.clientHeight, {
    top: o,
    right: l,
    bottom: r,
    left: a
  } = e.getBoundingClientRect();
  return o >= 0 && a >= 0 && l <= t && r <= n;
}
function UXe(e, t, n, o) {
  const [l, r] = Bn(void 0);
  Ot(() => {
    const u = typeof e.value == "function" ? e.value() : e.value;
    r(u || null);
  }, {
    flush: "post"
  });
  const [a, i] = Bn(null), s = () => {
    if (!t.value) {
      i(null);
      return;
    }
    if (l.value) {
      !KXe(l.value) && t.value && l.value.scrollIntoView(o.value);
      const {
        left: u,
        top: d,
        width: f,
        height: p
      } = l.value.getBoundingClientRect(), m = {
        left: u,
        top: d,
        width: f,
        height: p,
        radius: 0
      };
      JSON.stringify(a.value) !== JSON.stringify(m) && i(m);
    } else
      i(null);
  };
  return nt(() => {
    pe([t, l], () => {
      s();
    }, {
      flush: "post",
      immediate: !0
    }), window.addEventListener("resize", s);
  }), yt(() => {
    window.removeEventListener("resize", s);
  }), [O(() => {
    var u, d;
    if (!a.value)
      return a.value;
    const f = ((u = n.value) === null || u === void 0 ? void 0 : u.offset) || 6, p = ((d = n.value) === null || d === void 0 ? void 0 : d.radius) || 2;
    return {
      left: a.value.left - f,
      top: a.value.top - f,
      width: a.value.width + f * 2,
      height: a.value.height + f * 2,
      radius: p
    };
  }), l];
}
const GXe = () => ({
  arrow: zt([Boolean, Object]),
  target: zt([String, Function, Object]),
  title: zt([String, Object]),
  description: zt([String, Object]),
  placement: At(),
  mask: zt([Object, Boolean], !0),
  className: {
    type: String
  },
  style: Nt(),
  scrollIntoViewOptions: zt([Boolean, Object])
}), HP = () => _(_({}, GXe()), {
  prefixCls: {
    type: String
  },
  total: {
    type: Number
  },
  current: {
    type: Number
  },
  onClose: Fe(),
  onFinish: Fe(),
  renderPanel: Fe(),
  onPrev: Fe(),
  onNext: Fe()
}), YXe = /* @__PURE__ */ le({
  name: "DefaultPanel",
  inheritAttrs: !1,
  props: HP(),
  setup(e, t) {
    let {
      attrs: n
    } = t;
    return () => {
      const {
        prefixCls: o,
        current: l,
        total: r,
        title: a,
        description: i,
        onClose: s,
        onPrev: c,
        onNext: u,
        onFinish: d
      } = e;
      return $("div", Q(Q({}, n), {}, {
        class: ke(`${o}-content`, n.class)
      }), [$("div", {
        class: `${o}-inner`
      }, [$("button", {
        type: "button",
        onClick: s,
        "aria-label": "Close",
        class: `${o}-close`
      }, [$("span", {
        class: `${o}-close-x`
      }, [Ft("")])]), $("div", {
        class: `${o}-header`
      }, [$("div", {
        class: `${o}-title`
      }, [a])]), $("div", {
        class: `${o}-description`
      }, [i]), $("div", {
        class: `${o}-footer`
      }, [$("div", {
        class: `${o}-sliders`
      }, [r > 1 ? [...Array.from({
        length: r
      }).keys()].map((f, p) => $("span", {
        key: f,
        class: p === l ? "active" : ""
      }, null)) : null]), $("div", {
        class: `${o}-buttons`
      }, [l !== 0 ? $("button", {
        class: `${o}-prev-btn`,
        onClick: c
      }, [Ft("Prev")]) : null, l === r - 1 ? $("button", {
        class: `${o}-finish-btn`,
        onClick: d
      }, [Ft("Finish")]) : $("button", {
        class: `${o}-next-btn`,
        onClick: u
      }, [Ft("Next")])])])])]);
    };
  }
}), XXe = /* @__PURE__ */ le({
  name: "TourStep",
  inheritAttrs: !1,
  props: HP(),
  setup(e, t) {
    let {
      attrs: n
    } = t;
    return () => {
      const {
        current: o,
        renderPanel: l
      } = e;
      return $(Ge, null, [typeof l == "function" ? l(_(_({}, n), e), o) : $(YXe, Q(Q({}, n), e), null)]);
    };
  }
});
let pD = 0;
const qXe = process.env.NODE_ENV !== "test" && Fl();
function JXe() {
  let e;
  return qXe ? (e = pD, pD += 1) : e = "TEST_OR_SSR", e;
}
function ZXe() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ H("");
  const t = `vc_unique_${JXe()}`;
  return e.value || t;
}
const Xg = {
  fill: "transparent",
  "pointer-events": "auto"
}, QXe = /* @__PURE__ */ le({
  name: "TourMask",
  props: {
    prefixCls: {
      type: String
    },
    pos: Nt(),
    rootClassName: {
      type: String
    },
    showMask: Qe(),
    fill: {
      type: String,
      default: "rgba(0,0,0,0.5)"
    },
    open: Qe(),
    animated: zt([Boolean, Object]),
    zIndex: {
      type: Number
    }
  },
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const o = ZXe();
    return () => {
      const {
        prefixCls: l,
        open: r,
        rootClassName: a,
        pos: i,
        showMask: s,
        fill: c,
        animated: u,
        zIndex: d
      } = e, f = `${l}-mask-${o}`, p = typeof u == "object" ? u == null ? void 0 : u.placeholder : u;
      return $(Eh, {
        visible: r,
        autoLock: !0
      }, {
        default: () => r && $("div", Q(Q({}, n), {}, {
          class: ke(`${l}-mask`, a, n.class),
          style: [{
            position: "fixed",
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            zIndex: d,
            pointerEvents: "none"
          }, n.style]
        }), [s ? $("svg", {
          style: {
            width: "100%",
            height: "100%"
          }
        }, [$("defs", null, [$("mask", {
          id: f
        }, [$("rect", {
          x: "0",
          y: "0",
          width: "100vw",
          height: "100vh",
          fill: "white"
        }, null), i && $("rect", {
          x: i.left,
          y: i.top,
          rx: i.radius,
          width: i.width,
          height: i.height,
          fill: "black",
          class: p ? `${l}-placeholder-animated` : ""
        }, null)])]), $("rect", {
          x: "0",
          y: "0",
          width: "100%",
          height: "100%",
          fill: c,
          mask: `url(#${f})`
        }, null), i && $(Ge, null, [$("rect", Q(Q({}, Xg), {}, {
          x: "0",
          y: "0",
          width: "100%",
          height: i.top
        }), null), $("rect", Q(Q({}, Xg), {}, {
          x: "0",
          y: "0",
          width: i.left,
          height: "100%"
        }), null), $("rect", Q(Q({}, Xg), {}, {
          x: "0",
          y: i.top + i.height,
          width: "100%",
          height: `calc(100vh - ${i.top + i.height}px)`
        }), null), $("rect", Q(Q({}, Xg), {}, {
          x: i.left + i.width,
          y: "0",
          width: `calc(100vw - ${i.left + i.width}px)`,
          height: "100%"
        }), null)])]) : null])
      });
    };
  }
}), eqe = [0, 0], vD = {
  left: {
    points: ["cr", "cl"],
    offset: [-8, 0]
  },
  right: {
    points: ["cl", "cr"],
    offset: [8, 0]
  },
  top: {
    points: ["bc", "tc"],
    offset: [0, -8]
  },
  bottom: {
    points: ["tc", "bc"],
    offset: [0, 8]
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -8]
  },
  leftTop: {
    points: ["tr", "tl"],
    offset: [-8, 0]
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -8]
  },
  rightTop: {
    points: ["tl", "tr"],
    offset: [8, 0]
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 8]
  },
  rightBottom: {
    points: ["bl", "br"],
    offset: [8, 0]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 8]
  },
  leftBottom: {
    points: ["br", "bl"],
    offset: [-8, 0]
  }
};
function gY() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
  const t = {};
  return Object.keys(vD).forEach((n) => {
    t[n] = _(_({}, vD[n]), {
      autoArrow: e,
      targetOffset: eqe
    });
  }), t;
}
gY();
var tqe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const g$ = {
  left: "50%",
  top: "50%",
  width: "1px",
  height: "1px"
}, bY = () => {
  const {
    builtinPlacements: e,
    popupAlign: t
  } = rj();
  return {
    builtinPlacements: e,
    popupAlign: t,
    steps: $n(),
    open: Qe(),
    defaultCurrent: {
      type: Number
    },
    current: {
      type: Number
    },
    onChange: Fe(),
    onClose: Fe(),
    onFinish: Fe(),
    mask: zt([Boolean, Object], !0),
    arrow: zt([Boolean, Object], !0),
    rootClassName: {
      type: String
    },
    placement: At("bottom"),
    prefixCls: {
      type: String,
      default: "rc-tour"
    },
    renderPanel: Fe(),
    gap: Nt(),
    animated: zt([Boolean, Object]),
    scrollIntoViewOptions: zt([Boolean, Object], !0),
    zIndex: {
      type: Number,
      default: 1001
    }
  };
}, nqe = /* @__PURE__ */ le({
  name: "Tour",
  inheritAttrs: !1,
  props: sn(bY(), {}),
  setup(e) {
    const {
      defaultCurrent: t,
      placement: n,
      mask: o,
      scrollIntoViewOptions: l,
      open: r,
      gap: a,
      arrow: i
    } = /* @__PURE__ */ to(e), s = /* @__PURE__ */ H(), [c, u] = ro(0, {
      value: O(() => e.current),
      defaultValue: t.value
    }), [d, f] = ro(void 0, {
      value: O(() => e.open),
      postState: (E) => c.value < 0 || c.value >= e.steps.length ? !1 : E != null ? E : !0
    }), p = /* @__PURE__ */ Ce(d.value);
    Ot(() => {
      d.value && !p.value && u(0), p.value = d.value;
    });
    const m = O(() => e.steps[c.value] || {}), v = O(() => {
      var E;
      return (E = m.value.placement) !== null && E !== void 0 ? E : n.value;
    }), h = O(() => {
      var E;
      return d.value && ((E = m.value.mask) !== null && E !== void 0 ? E : o.value);
    }), g = O(() => {
      var E;
      return (E = m.value.scrollIntoViewOptions) !== null && E !== void 0 ? E : l.value;
    }), [y, b] = UXe(O(() => m.value.target), r, a, g), C = O(() => b.value ? typeof m.value.arrow == "undefined" ? i.value : m.value.arrow : !1), w = O(() => typeof C.value == "object" ? C.value.pointAtCenter : !1);
    pe(w, () => {
      var E;
      (E = s.value) === null || E === void 0 || E.forcePopupAlign();
    }), pe(c, () => {
      var E;
      (E = s.value) === null || E === void 0 || E.forcePopupAlign();
    });
    const x = (E) => {
      var I;
      u(E), (I = e.onChange) === null || I === void 0 || I.call(e, E);
    };
    return () => {
      var E;
      const {
        prefixCls: I,
        steps: T,
        onClose: P,
        onFinish: k,
        rootClassName: N,
        renderPanel: R,
        animated: z,
        zIndex: D
      } = e, F = tqe(e, ["prefixCls", "steps", "onClose", "onFinish", "rootClassName", "renderPanel", "animated", "zIndex"]);
      if (b.value === void 0)
        return null;
      const M = () => {
        f(!1), P == null || P(c.value);
      }, A = typeof h.value == "boolean" ? h.value : !!h.value, L = typeof h.value == "boolean" ? void 0 : h.value, B = () => b.value || document.body, V = () => $(XXe, Q({
        arrow: C.value,
        key: "content",
        prefixCls: I,
        total: T.length,
        renderPanel: R,
        onPrev: () => {
          x(c.value - 1);
        },
        onNext: () => {
          x(c.value + 1);
        },
        onClose: M,
        current: c.value,
        onFinish: () => {
          M(), k == null || k();
        }
      }, m.value), null), j = O(() => {
        const W = y.value || g$, Y = {};
        return Object.keys(W).forEach((U) => {
          typeof W[U] == "number" ? Y[U] = `${W[U]}px` : Y[U] = W[U];
        }), Y;
      });
      return d.value ? $(Ge, null, [$(QXe, {
        zIndex: D,
        prefixCls: I,
        pos: y.value,
        showMask: A,
        style: L == null ? void 0 : L.style,
        fill: L == null ? void 0 : L.color,
        open: d.value,
        animated: z,
        rootClassName: N
      }, null), $(fd, Q(Q({}, F), {}, {
        arrow: !!F.arrow,
        builtinPlacements: m.value.target ? (E = F.builtinPlacements) !== null && E !== void 0 ? E : gY(w.value) : void 0,
        ref: s,
        popupStyle: m.value.target ? m.value.style : _(_({}, m.value.style), {
          position: "fixed",
          left: g$.left,
          top: g$.top,
          transform: "translate(-50%, -50%)"
        }),
        popupPlacement: v.value,
        popupVisible: d.value,
        popupClassName: ke(N, m.value.className),
        prefixCls: I,
        popup: V,
        forceRender: !1,
        destroyPopupOnHide: !0,
        zIndex: D,
        mask: !1,
        getTriggerDOMNode: B
      }), {
        default: () => [$(Eh, {
          visible: d.value,
          autoLock: !0
        }, {
          default: () => [$("div", {
            class: ke(N, `${I}-target-placeholder`),
            style: _(_({}, j.value), {
              position: "fixed",
              pointerEvents: "none"
            })
          }, null)]
        })]
      })]) : null;
    };
  }
}), oqe = () => _(_({}, bY()), {
  steps: {
    type: Array
  },
  prefixCls: {
    type: String
  },
  current: {
    type: Number
  },
  type: {
    type: String
  },
  "onUpdate:current": Function
}), lqe = () => _(_({}, HP()), {
  cover: {
    type: Object
  },
  nextButtonProps: {
    type: Object
  },
  prevButtonProps: {
    type: Object
  },
  current: {
    type: Number
  },
  type: {
    type: String
  }
}), rqe = /* @__PURE__ */ le({
  name: "ATourPanel",
  inheritAttrs: !1,
  props: lqe(),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      current: l,
      total: r
    } = /* @__PURE__ */ to(e), a = O(() => l.value === r.value - 1), i = (c) => {
      var u;
      const d = e.prevButtonProps;
      (u = e.onPrev) === null || u === void 0 || u.call(e, c), typeof (d == null ? void 0 : d.onClick) == "function" && (d == null || d.onClick());
    }, s = (c) => {
      var u, d;
      const f = e.nextButtonProps;
      a.value ? (u = e.onFinish) === null || u === void 0 || u.call(e, c) : (d = e.onNext) === null || d === void 0 || d.call(e, c), typeof (f == null ? void 0 : f.onClick) == "function" && (f == null || f.onClick());
    };
    return () => {
      const {
        prefixCls: c,
        title: u,
        onClose: d,
        cover: f,
        description: p,
        type: m,
        arrow: v
      } = e, h = e.prevButtonProps, g = e.nextButtonProps;
      let y;
      u && (y = $("div", {
        class: `${c}-header`
      }, [$("div", {
        class: `${c}-title`
      }, [u])]));
      let b;
      p && (b = $("div", {
        class: `${c}-description`
      }, [p]));
      let C;
      f && (C = $("div", {
        class: `${c}-cover`
      }, [f]));
      let w;
      o.indicatorsRender ? w = o.indicatorsRender({
        current: l.value,
        total: r
      }) : w = [...Array.from({
        length: r.value
      }).keys()].map((I, T) => $("span", {
        key: I,
        class: ke(T === l.value && `${c}-indicator-active`, `${c}-indicator`)
      }, null));
      const x = m === "primary" ? "default" : "primary", E = {
        type: "default",
        ghost: m === "primary"
      };
      return $(sd, {
        componentName: "Tour",
        defaultLocale: rr.Tour
      }, {
        default: (I) => {
          var T;
          return $("div", Q(Q({}, n), {}, {
            class: ke(m === "primary" ? `${c}-primary` : "", n.class, `${c}-content`)
          }), [v && $("div", {
            class: `${c}-arrow`,
            key: "arrow"
          }, null), $("div", {
            class: `${c}-inner`
          }, [$(Hl, {
            class: `${c}-close`,
            onClick: d
          }, null), C, y, b, $("div", {
            class: `${c}-footer`
          }, [r.value > 1 && $("div", {
            class: `${c}-indicators`
          }, [w]), $("div", {
            class: `${c}-buttons`
          }, [l.value !== 0 ? $(ko, Q(Q(Q({}, E), h), {}, {
            onClick: i,
            size: "small",
            class: ke(`${c}-prev-btn`, h == null ? void 0 : h.className)
          }), {
            default: () => [o2(h == null ? void 0 : h.children) ? h.children() : (T = h == null ? void 0 : h.children) !== null && T !== void 0 ? T : I.Previous]
          }) : null, $(ko, Q(Q({
            type: x
          }, g), {}, {
            onClick: s,
            size: "small",
            class: ke(`${c}-next-btn`, g == null ? void 0 : g.className)
          }), {
            default: () => [o2(g == null ? void 0 : g.children) ? g == null ? void 0 : g.children() : a.value ? I.Finish : I.Next]
          })])])])]);
        }
      });
    };
  }
}), aqe = (e) => {
  let {
    defaultType: t,
    steps: n,
    current: o,
    defaultCurrent: l
  } = e;
  const r = /* @__PURE__ */ H(l == null ? void 0 : l.value), a = O(() => o == null ? void 0 : o.value);
  pe(a, (u) => {
    r.value = u != null ? u : l == null ? void 0 : l.value;
  }, {
    immediate: !0
  });
  const i = (u) => {
    r.value = u;
  }, s = O(() => {
    var u, d;
    return typeof r.value == "number" ? n && ((d = (u = n.value) === null || u === void 0 ? void 0 : u[r.value]) === null || d === void 0 ? void 0 : d.type) : t == null ? void 0 : t.value;
  });
  return {
    currentMergedType: O(() => {
      var u;
      return (u = s.value) !== null && u !== void 0 ? u : t == null ? void 0 : t.value;
    }),
    updateInnerCurrent: i
  };
}, iqe = (e) => {
  const {
    componentCls: t,
    lineHeight: n,
    padding: o,
    paddingXS: l,
    borderRadius: r,
    borderRadiusXS: a,
    colorPrimary: i,
    colorText: s,
    colorFill: c,
    indicatorHeight: u,
    indicatorWidth: d,
    boxShadowTertiary: f,
    tourZIndexPopup: p,
    fontSize: m,
    colorBgContainer: v,
    fontWeightStrong: h,
    marginXS: g,
    colorTextLightSolid: y,
    tourBorderRadius: b,
    colorWhite: C,
    colorBgTextHover: w,
    tourCloseSize: x,
    motionDurationSlow: E,
    antCls: I
  } = e;
  return [
    {
      [t]: _(_({}, nn(e)), {
        color: s,
        position: "absolute",
        zIndex: p,
        display: "block",
        visibility: "visible",
        fontSize: m,
        lineHeight: n,
        width: 520,
        "--antd-arrow-background-color": v,
        "&-pure": {
          maxWidth: "100%",
          position: "relative"
        },
        [`&${t}-hidden`]: {
          display: "none"
        },
        // ============================= panel content ============================
        [`${t}-content`]: {
          position: "relative"
        },
        [`${t}-inner`]: {
          textAlign: "start",
          textDecoration: "none",
          borderRadius: b,
          boxShadow: f,
          position: "relative",
          backgroundColor: v,
          border: "none",
          backgroundClip: "padding-box",
          [`${t}-close`]: {
            position: "absolute",
            top: o,
            insetInlineEnd: o,
            color: e.colorIcon,
            outline: "none",
            width: x,
            height: x,
            borderRadius: e.borderRadiusSM,
            transition: `background-color ${e.motionDurationMid}, color ${e.motionDurationMid}`,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            "&:hover": {
              color: e.colorIconHover,
              backgroundColor: e.wireframe ? "transparent" : e.colorFillContent
            }
          },
          [`${t}-cover`]: {
            textAlign: "center",
            padding: `${o + x + l}px ${o}px 0`,
            img: {
              width: "100%"
            }
          },
          [`${t}-header`]: {
            padding: `${o}px ${o}px ${l}px`,
            [`${t}-title`]: {
              lineHeight: n,
              fontSize: m,
              fontWeight: h
            }
          },
          [`${t}-description`]: {
            padding: `0 ${o}px`,
            lineHeight: n,
            wordWrap: "break-word"
          },
          [`${t}-footer`]: {
            padding: `${l}px ${o}px ${o}px`,
            textAlign: "end",
            borderRadius: `0 0 ${a}px ${a}px`,
            display: "flex",
            [`${t}-indicators`]: {
              display: "inline-block",
              [`${t}-indicator`]: {
                width: d,
                height: u,
                display: "inline-block",
                borderRadius: "50%",
                background: c,
                "&:not(:last-child)": {
                  marginInlineEnd: u
                },
                "&-active": {
                  background: i
                }
              }
            },
            [`${t}-buttons`]: {
              marginInlineStart: "auto",
              [`${I}-btn`]: {
                marginInlineStart: g
              }
            }
          }
        },
        // =============================  primary type  ===========================
        // `$` for panel, `&$` for pure panel
        [`${t}-primary, &${t}-primary`]: {
          "--antd-arrow-background-color": i,
          [`${t}-inner`]: {
            color: y,
            textAlign: "start",
            textDecoration: "none",
            backgroundColor: i,
            borderRadius: r,
            boxShadow: f,
            [`${t}-close`]: {
              color: y
            },
            [`${t}-indicators`]: {
              [`${t}-indicator`]: {
                background: new xn(y).setAlpha(0.15).toRgbString(),
                "&-active": {
                  background: y
                }
              }
            },
            [`${t}-prev-btn`]: {
              color: y,
              borderColor: new xn(y).setAlpha(0.15).toRgbString(),
              backgroundColor: i,
              "&:hover": {
                backgroundColor: new xn(y).setAlpha(0.15).toRgbString(),
                borderColor: "transparent"
              }
            },
            [`${t}-next-btn`]: {
              color: i,
              borderColor: "transparent",
              background: C,
              "&:hover": {
                background: new xn(w).onBackground(C).toRgbString()
              }
            }
          }
        }
      }),
      // ============================= mask ===========================
      [`${t}-mask`]: {
        [`${t}-placeholder-animated`]: {
          transition: `all ${E}`
        }
      },
      // =========== Limit left and right placement radius ==============
      [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
        [`${t}-inner`]: {
          borderRadius: Math.min(b, UI)
        }
      }
    },
    // ============================= Arrow ===========================
    GI(e, {
      colorBg: "var(--antd-arrow-background-color)",
      contentRadius: b,
      limitVerticalRadius: !0
    })
  ];
}, sqe = Zt("Tour", (e) => {
  const {
    borderRadiusLG: t,
    fontSize: n,
    lineHeight: o
  } = e, l = Vt(e, {
    tourZIndexPopup: e.zIndexPopupBase + 70,
    indicatorWidth: 6,
    indicatorHeight: 6,
    tourBorderRadius: t,
    tourCloseSize: n * o
  });
  return [iqe(l)];
});
var cqe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const uqe = /* @__PURE__ */ le({
  name: "ATour",
  inheritAttrs: !1,
  props: oqe(),
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      slots: l
    } = t;
    const {
      current: r,
      type: a,
      steps: i,
      defaultCurrent: s
    } = /* @__PURE__ */ to(e), {
      prefixCls: c,
      direction: u
    } = bt("tour", e), [d, f] = sqe(c), {
      currentMergedType: p,
      updateInnerCurrent: m
    } = aqe({
      defaultType: a,
      steps: i,
      current: r,
      defaultCurrent: s
    });
    return () => {
      const {
        steps: v,
        current: h,
        type: g,
        rootClassName: y
      } = e, b = cqe(e, ["steps", "current", "type", "rootClassName"]), C = ke({
        [`${c.value}-primary`]: p.value === "primary",
        [`${c.value}-rtl`]: u.value === "rtl"
      }, f.value, y), w = (I, T) => $(rqe, Q(Q({}, I), {}, {
        type: g,
        current: T
      }), {
        indicatorsRender: l.indicatorsRender
      }), x = (I) => {
        m(I), o("update:current", I), o("change", I);
      }, E = O(() => KI({
        arrowPointAtCenter: !0,
        autoAdjustOverflow: !0
      }));
      return d($(nqe, Q(Q(Q({}, n), b), {}, {
        rootClassName: C,
        prefixCls: c.value,
        current: h,
        defaultCurrent: e.defaultCurrent,
        animated: !0,
        renderPanel: w,
        onChange: x,
        steps: v,
        builtinPlacements: E.value
      }), null));
    };
  }
}), dqe = po(uqe), yY = Symbol("appConfigContext"), fqe = (e) => at(yY, e), pqe = () => ze(yY, {}), SY = Symbol("appContext"), vqe = (e) => at(SY, e), mqe = /* @__PURE__ */ kt({
  message: {},
  notification: {},
  modal: {}
}), hqe = () => ze(SY, mqe), gqe = (e) => {
  const {
    componentCls: t,
    colorText: n,
    fontSize: o,
    lineHeight: l,
    fontFamily: r
  } = e;
  return {
    [t]: {
      color: n,
      fontSize: o,
      lineHeight: l,
      fontFamily: r
    }
  };
}, bqe = Zt("App", (e) => [gqe(e)]), yqe = () => ({
  rootClassName: String,
  message: Nt(),
  notification: Nt()
}), Sqe = () => hqe(), Kv = /* @__PURE__ */ le({
  name: "AApp",
  props: sn(yqe(), {}),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o
    } = bt("app", e), [l, r] = bqe(o), a = O(() => ke(r.value, o.value, e.rootClassName)), i = pqe(), s = O(() => ({
      message: _(_({}, i.message), e.message),
      notification: _(_({}, i.notification), e.notification)
    }));
    fqe(s.value);
    const [c, u] = KK(s.value.message), [d, f] = oU(s.value.notification), [p, m] = aG(), v = O(() => ({
      message: c,
      notification: d,
      modal: p
    }));
    return vqe(v.value), () => {
      var h;
      return l($("div", {
        class: a.value
      }, [m(), u(), f(), (h = n.default) === null || h === void 0 ? void 0 : h.call(n)]));
    };
  }
});
Kv.useApp = Sqe;
Kv.install = function(e) {
  e.component(Kv.name, Kv);
};
const CY = ["wrap", "nowrap", "wrap-reverse"], wY = ["flex-start", "flex-end", "start", "end", "center", "space-between", "space-around", "space-evenly", "stretch", "normal", "left", "right"], $Y = ["center", "start", "end", "flex-start", "flex-end", "self-start", "self-end", "baseline", "normal", "stretch"], Cqe = (e, t) => {
  const n = {};
  return CY.forEach((o) => {
    n[`${e}-wrap-${o}`] = t.wrap === o;
  }), n;
}, wqe = (e, t) => {
  const n = {};
  return $Y.forEach((o) => {
    n[`${e}-align-${o}`] = t.align === o;
  }), n[`${e}-align-stretch`] = !t.align && !!t.vertical, n;
}, $qe = (e, t) => {
  const n = {};
  return wY.forEach((o) => {
    n[`${e}-justify-${o}`] = t.justify === o;
  }), n;
};
function xqe(e, t) {
  return ke(_(_(_({}, Cqe(e, t)), wqe(e, t)), $qe(e, t)));
}
const Eqe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      display: "flex",
      "&-vertical": {
        flexDirection: "column"
      },
      "&-rtl": {
        direction: "rtl"
      },
      "&:empty": {
        display: "none"
      }
    }
  };
}, Oqe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      "&-gap-small": {
        gap: e.flexGapSM
      },
      "&-gap-middle": {
        gap: e.flexGap
      },
      "&-gap-large": {
        gap: e.flexGapLG
      }
    }
  };
}, _qe = (e) => {
  const {
    componentCls: t
  } = e, n = {};
  return CY.forEach((o) => {
    n[`${t}-wrap-${o}`] = {
      flexWrap: o
    };
  }), n;
}, Iqe = (e) => {
  const {
    componentCls: t
  } = e, n = {};
  return $Y.forEach((o) => {
    n[`${t}-align-${o}`] = {
      alignItems: o
    };
  }), n;
}, Tqe = (e) => {
  const {
    componentCls: t
  } = e, n = {};
  return wY.forEach((o) => {
    n[`${t}-justify-${o}`] = {
      justifyContent: o
    };
  }), n;
}, Pqe = Zt("Flex", (e) => {
  const t = Vt(e, {
    flexGapSM: e.paddingXS,
    flexGap: e.padding,
    flexGapLG: e.paddingLG
  });
  return [Eqe(t), Oqe(t), _qe(t), Iqe(t), Tqe(t)];
});
function mD(e) {
  return ["small", "middle", "large"].includes(e);
}
const kqe = () => ({
  prefixCls: At(),
  vertical: Qe(),
  wrap: At(),
  justify: At(),
  align: At(),
  flex: zt([Number, String]),
  gap: zt([Number, String]),
  component: Wn()
});
var Nqe = function(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var l = 0, o = Object.getOwnPropertySymbols(e); l < o.length; l++)
    t.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[l]) && (n[o[l]] = e[o[l]]);
  return n;
};
const Mqe = /* @__PURE__ */ le({
  name: "AFlex",
  inheritAttrs: !1,
  props: kqe(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      flex: l,
      direction: r
    } = oS(), {
      prefixCls: a
    } = bt("flex", e), [i, s] = Pqe(a), c = O(() => {
      var u;
      return [a.value, s.value, xqe(a.value, e), {
        [`${a.value}-rtl`]: r.value === "rtl",
        [`${a.value}-gap-${e.gap}`]: mD(e.gap),
        [`${a.value}-vertical`]: (u = e.vertical) !== null && u !== void 0 ? u : l == null ? void 0 : l.value.vertical
      }];
    });
    return () => {
      var u;
      const {
        flex: d,
        gap: f,
        component: p = "div"
      } = e, m = Nqe(e, ["flex", "gap", "component"]), v = {};
      return d && (v.flex = d), f && !mD(f) && (v.gap = `${f}px`), i($(p, Q({
        class: [o.class, c.value],
        style: [o.style, v]
      }, pn(m, ["justify", "wrap", "align", "vertical"])), {
        default: () => [(u = n.default) === null || u === void 0 ? void 0 : u.call(n)]
      }));
    };
  }
}), Aqe = po(Mqe), hD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Affix: jH,
  Alert: y6e,
  Anchor: iu,
  AnchorLink: mI,
  App: Kv,
  AutoComplete: Y8e,
  AutoCompleteOptGroup: G8e,
  AutoCompleteOption: U8e,
  Avatar: Pu,
  AvatarGroup: gy,
  BackTop: zy,
  Badge: Lv,
  BadgeRibbon: by,
  Breadcrumb: ku,
  BreadcrumbItem: Lm,
  BreadcrumbSeparator: _y,
  Button: ko,
  ButtonGroup: $y,
  Calendar: FDe,
  Card: Ef,
  CardGrid: Ny,
  CardMeta: ky,
  Carousel: ELe,
  Cascader: s7e,
  CheckableTag: Ly,
  Checkbox: la,
  CheckboxGroup: Ry,
  Col: v7e,
  Collapse: Fv,
  CollapsePanel: My,
  Comment: y7e,
  Compact: my,
  ConfigProvider: Mu,
  DatePicker: DFe,
  Descriptions: Ud,
  DescriptionsItem: bU,
  DirectoryTree: e0,
  Divider: XFe,
  Drawer: u9e,
  Dropdown: Ia,
  DropdownButton: Dm,
  Empty: qs,
  Flex: Aqe,
  FloatButton: pc,
  FloatButtonGroup: Vy,
  Form: Js,
  FormItem: LK,
  FormItemRest: py,
  Grid: p7e,
  Image: cu,
  ImagePreviewGroup: zU,
  Input: Yo,
  InputGroup: IU,
  InputNumber: zVe,
  InputPassword: kU,
  InputSearch: TU,
  Layout: eze,
  LayoutContent: QVe,
  LayoutFooter: JVe,
  LayoutHeader: qVe,
  LayoutSider: ZVe,
  List: zs,
  ListItem: UU,
  ListItemMeta: WU,
  LocaleProvider: zK,
  Mentions: iHe,
  MentionsOption: qb,
  Menu: Do,
  MenuDivider: Fm,
  MenuItem: bi,
  MenuItemGroup: Bm,
  Modal: nl,
  MonthPicker: zb,
  PageHeader: LHe,
  Pagination: ZS,
  Popconfirm: jHe,
  Popover: YI,
  Progress: vP,
  QRCode: WXe,
  QuarterPicker: Hb,
  Radio: Jl,
  RadioButton: Ty,
  RadioGroup: $T,
  RangePicker: jb,
  Rate: Pje,
  Result: Ru,
  Row: Uje,
  Segmented: kXe,
  Select: pl,
  SelectOptGroup: j8e,
  SelectOption: H8e,
  Skeleton: Tl,
  SkeletonAvatar: MT,
  SkeletonButton: PT,
  SkeletonImage: NT,
  SkeletonInput: kT,
  SkeletonTitle: MS,
  Slider: cWe,
  Space: Tf,
  Spin: yi,
  Statistic: ls,
  StatisticCountdown: $He,
  Step: Jb,
  Steps: _We,
  SubMenu: Zu,
  Switch: LWe,
  TabPane: Py,
  Table: qUe,
  TableColumn: n0,
  TableColumnGroup: o0,
  TableSummary: l0,
  TableSummaryCell: Xy,
  TableSummaryRow: Yy,
  Tabs: Nu,
  Tag: If,
  Textarea: ZT,
  TimePicker: KGe,
  TimeRangePicker: r0,
  Timeline: Wv,
  TimelineItem: Wm,
  Tooltip: Sr,
  Tour: dqe,
  Transfer: yGe,
  Tree: WG,
  TreeNode: t0,
  TreeSelect: jGe,
  TreeSelectNode: yE,
  Typography: vr,
  TypographyLink: Vp,
  TypographyParagraph: zp,
  TypographyText: Hp,
  TypographyTitle: jp,
  Upload: mXe,
  UploadDragger: vXe,
  Watermark: $Xe,
  WeekPicker: Vb,
  message: Qu,
  notification: Ec
}, Symbol.toStringTag, { value: "Module" })), Rqe = function(e) {
  return Object.keys(hD).forEach((t) => {
    const n = hD[t];
    n.install && e.use(n);
  }), e.use(Bke.StyleProvider), e.config.globalProperties.$message = Qu, e.config.globalProperties.$notification = Ec, e.config.globalProperties.$info = nl.info, e.config.globalProperties.$success = nl.success, e.config.globalProperties.$error = nl.error, e.config.globalProperties.$warning = nl.warning, e.config.globalProperties.$confirm = nl.confirm, e.config.globalProperties.$destroyAll = nl.destroyAll, e;
}, Dqe = {
  version: NH,
  install: Rqe
}, Lqe = { id: "app" }, Bqe = /* @__PURE__ */ le({
  __name: "App",
  setup(e) {
    return nt(() => {
      console.log("Supplier Web ");
    }), (t, n) => (G(), ue("div", Lqe, [...n[0] || (n[0] = [
      ve("div", { class: "supplier-app" }, [
        ve("h1", null, "B"),
        ve("p", null, "")
      ], -1)
    ])]));
  }
}), Fqe = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, l] of t)
    n[o] = l;
  return n;
}, Vqe = /* @__PURE__ */ Fqe(Bqe, [["__scopeId", "data-v-0d230146"]]);
/*!
 * vue-router v4.6.4
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
const Zi = typeof document != "undefined";
function xY(e) {
  return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e;
}
function zqe(e) {
  return e.__esModule || e[Symbol.toStringTag] === "Module" || e.default && xY(e.default);
}
const Yn = Object.assign;
function b$(e, t) {
  const n = {};
  for (const o in t) {
    const l = t[o];
    n[o] = Fr(l) ? l.map(e) : e(l);
  }
  return n;
}
const Uv = () => {
}, Fr = Array.isArray;
function gD(e, t) {
  const n = {};
  for (const o in e) n[o] = o in t ? t[o] : e[o];
  return n;
}
function Rn(e) {
  const t = Array.from(arguments).slice(1);
  console.warn.apply(console, ["[Vue Router warn]: " + e].concat(t));
}
const EY = /#/g, Hqe = /&/g, jqe = /\//g, Wqe = /=/g, Kqe = /\?/g, OY = /\+/g, Uqe = /%5B/g, Gqe = /%5D/g, _Y = /%5E/g, Yqe = /%60/g, IY = /%7B/g, Xqe = /%7C/g, TY = /%7D/g, qqe = /%20/g;
function jP(e) {
  return e == null ? "" : encodeURI("" + e).replace(Xqe, "|").replace(Uqe, "[").replace(Gqe, "]");
}
function Jqe(e) {
  return jP(e).replace(IY, "{").replace(TY, "}").replace(_Y, "^");
}
function CE(e) {
  return jP(e).replace(OY, "%2B").replace(qqe, "+").replace(EY, "%23").replace(Hqe, "%26").replace(Yqe, "`").replace(IY, "{").replace(TY, "}").replace(_Y, "^");
}
function Zqe(e) {
  return CE(e).replace(Wqe, "%3D");
}
function Qqe(e) {
  return jP(e).replace(EY, "%23").replace(Kqe, "%3F");
}
function eJe(e) {
  return Qqe(e).replace(jqe, "%2F");
}
function dp(e) {
  if (e == null) return null;
  try {
    return decodeURIComponent("" + e);
  } catch (t) {
    process.env.NODE_ENV !== "production" && Rn(`Error decoding "${e}". Using original value`);
  }
  return "" + e;
}
const tJe = /\/$/, nJe = (e) => e.replace(tJe, "");
function y$(e, t, n = "/") {
  let o, l = {}, r = "", a = "";
  const i = t.indexOf("#");
  let s = t.indexOf("?");
  return s = i >= 0 && s > i ? -1 : s, s >= 0 && (o = t.slice(0, s), r = t.slice(s, i > 0 ? i : t.length), l = e(r.slice(1))), i >= 0 && (o = o || t.slice(0, i), a = t.slice(i, t.length)), o = rJe(o != null ? o : t, n), {
    fullPath: o + r + a,
    path: o,
    query: l,
    hash: dp(a)
  };
}
function oJe(e, t) {
  const n = t.query ? e(t.query) : "";
  return t.path + (n && "?") + n + (t.hash || "");
}
function bD(e, t) {
  return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/";
}
function yD(e, t, n) {
  const o = t.matched.length - 1, l = n.matched.length - 1;
  return o > -1 && o === l && Oc(t.matched[o], n.matched[l]) && PY(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash;
}
function Oc(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t);
}
function PY(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length) return !1;
  for (var n in e) if (!lJe(e[n], t[n])) return !1;
  return !0;
}
function lJe(e, t) {
  return Fr(e) ? SD(e, t) : Fr(t) ? SD(t, e) : (e == null ? void 0 : e.valueOf()) === (t == null ? void 0 : t.valueOf());
}
function SD(e, t) {
  return Fr(t) ? e.length === t.length && e.every((n, o) => n === t[o]) : e.length === 1 && e[0] === t;
}
function rJe(e, t) {
  if (e.startsWith("/")) return e;
  if (process.env.NODE_ENV !== "production" && !t.startsWith("/"))
    return Rn(`Cannot resolve a relative location without an absolute path. Trying to resolve "${e}" from "${t}". It should look like "/${t}".`), e;
  if (!e) return t;
  const n = t.split("/"), o = e.split("/"), l = o[o.length - 1];
  (l === ".." || l === ".") && o.push("");
  let r = n.length - 1, a, i;
  for (a = 0; a < o.length; a++)
    if (i = o[a], i !== ".")
      if (i === "..")
        r > 1 && r--;
      else break;
  return n.slice(0, r).join("/") + "/" + o.slice(a).join("/");
}
const Ds = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
let wE = /* @__PURE__ */ function(e) {
  return e.pop = "pop", e.push = "push", e;
}({}), S$ = /* @__PURE__ */ function(e) {
  return e.back = "back", e.forward = "forward", e.unknown = "", e;
}({});
function aJe(e) {
  if (!e) if (Zi) {
    const t = document.querySelector("base");
    e = t && t.getAttribute("href") || "/", e = e.replace(/^\w+:\/\/[^\/]+/, "");
  } else e = "/";
  return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), nJe(e);
}
const iJe = /^[^#]+#/;
function sJe(e, t) {
  return e.replace(iJe, "#") + t;
}
function cJe(e, t) {
  const n = document.documentElement.getBoundingClientRect(), o = e.getBoundingClientRect();
  return {
    behavior: t.behavior,
    left: o.left - n.left - (t.left || 0),
    top: o.top - n.top - (t.top || 0)
  };
}
const aC = () => ({
  left: window.scrollX,
  top: window.scrollY
});
function uJe(e) {
  let t;
  if ("el" in e) {
    const n = e.el, o = typeof n == "string" && n.startsWith("#");
    if (process.env.NODE_ENV !== "production" && typeof e.el == "string" && (!o || !document.getElementById(e.el.slice(1))))
      try {
        const r = document.querySelector(e.el);
        if (o && r) {
          Rn(`The selector "${e.el}" should be passed as "el: document.querySelector('${e.el}')" because it starts with "#".`);
          return;
        }
      } catch (r) {
        Rn(`The selector "${e.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
        return;
      }
    const l = typeof n == "string" ? o ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
    if (!l) {
      process.env.NODE_ENV !== "production" && Rn(`Couldn't find element using selector "${e.el}" returned by scrollBehavior.`);
      return;
    }
    t = cJe(l, e);
  } else t = e;
  "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY);
}
function CD(e, t) {
  return (history.state ? history.state.position - t : -1) + e;
}
const $E = /* @__PURE__ */ new Map();
function dJe(e, t) {
  $E.set(e, t);
}
function fJe(e) {
  const t = $E.get(e);
  return $E.delete(e), t;
}
function qy(e) {
  return typeof e == "string" || e && typeof e == "object";
}
function kY(e) {
  return typeof e == "string" || typeof e == "symbol";
}
let Ro = /* @__PURE__ */ function(e) {
  return e[e.MATCHER_NOT_FOUND = 1] = "MATCHER_NOT_FOUND", e[e.NAVIGATION_GUARD_REDIRECT = 2] = "NAVIGATION_GUARD_REDIRECT", e[e.NAVIGATION_ABORTED = 4] = "NAVIGATION_ABORTED", e[e.NAVIGATION_CANCELLED = 8] = "NAVIGATION_CANCELLED", e[e.NAVIGATION_DUPLICATED = 16] = "NAVIGATION_DUPLICATED", e;
}({});
const xE = Symbol(process.env.NODE_ENV !== "production" ? "navigation failure" : ""), pJe = {
  [Ro.MATCHER_NOT_FOUND]({ location: e, currentLocation: t }) {
    return `No match for
 ${JSON.stringify(e)}${t ? `
while being at
` + JSON.stringify(t) : ""}`;
  },
  [Ro.NAVIGATION_GUARD_REDIRECT]({ from: e, to: t }) {
    return `Redirected from "${e.fullPath}" to "${mJe(t)}" via a navigation guard.`;
  },
  [Ro.NAVIGATION_ABORTED]({ from: e, to: t }) {
    return `Navigation aborted from "${e.fullPath}" to "${t.fullPath}" via a navigation guard.`;
  },
  [Ro.NAVIGATION_CANCELLED]({ from: e, to: t }) {
    return `Navigation cancelled from "${e.fullPath}" to "${t.fullPath}" with a new navigation.`;
  },
  [Ro.NAVIGATION_DUPLICATED]({ from: e, to: t }) {
    return `Avoided redundant navigation to current location: "${e.fullPath}".`;
  }
};
function fp(e, t) {
  return process.env.NODE_ENV !== "production" ? Yn(new Error(pJe[e](t)), {
    type: e,
    [xE]: !0
  }, t) : Yn(/* @__PURE__ */ new Error(), {
    type: e,
    [xE]: !0
  }, t);
}
function Wi(e, t) {
  return e instanceof Error && xE in e && (t == null || !!(e.type & t));
}
const vJe = [
  "params",
  "query",
  "hash"
];
function mJe(e) {
  if (typeof e == "string") return e;
  if (e.path != null) return e.path;
  const t = {};
  for (const n of vJe) n in e && (t[n] = e[n]);
  return JSON.stringify(t, null, 2);
}
function hJe(e) {
  const t = {};
  if (e === "" || e === "?") return t;
  const n = (e[0] === "?" ? e.slice(1) : e).split("&");
  for (let o = 0; o < n.length; ++o) {
    const l = n[o].replace(OY, " "), r = l.indexOf("="), a = dp(r < 0 ? l : l.slice(0, r)), i = r < 0 ? null : dp(l.slice(r + 1));
    if (a in t) {
      let s = t[a];
      Fr(s) || (s = t[a] = [s]), s.push(i);
    } else t[a] = i;
  }
  return t;
}
function wD(e) {
  let t = "";
  for (let n in e) {
    const o = e[n];
    if (n = Zqe(n), o == null) {
      o !== void 0 && (t += (t.length ? "&" : "") + n);
      continue;
    }
    (Fr(o) ? o.map((l) => l && CE(l)) : [o && CE(o)]).forEach((l) => {
      l !== void 0 && (t += (t.length ? "&" : "") + n, l != null && (t += "=" + l));
    });
  }
  return t;
}
function gJe(e) {
  const t = {};
  for (const n in e) {
    const o = e[n];
    o !== void 0 && (t[n] = Fr(o) ? o.map((l) => l == null ? null : "" + l) : o == null ? o : "" + o);
  }
  return t;
}
const bJe = Symbol(process.env.NODE_ENV !== "production" ? "router view location matched" : ""), $D = Symbol(process.env.NODE_ENV !== "production" ? "router view depth" : ""), WP = Symbol(process.env.NODE_ENV !== "production" ? "router" : ""), NY = Symbol(process.env.NODE_ENV !== "production" ? "route location" : ""), EE = Symbol(process.env.NODE_ENV !== "production" ? "router view location" : "");
function cv() {
  let e = [];
  function t(o) {
    return e.push(o), () => {
      const l = e.indexOf(o);
      l > -1 && e.splice(l, 1);
    };
  }
  function n() {
    e = [];
  }
  return {
    add: t,
    list: () => e.slice(),
    reset: n
  };
}
function Ks(e, t, n, o, l, r = (a) => a()) {
  const a = o && (o.enterCallbacks[l] = o.enterCallbacks[l] || []);
  return () => new Promise((i, s) => {
    const c = (f) => {
      f === !1 ? s(fp(Ro.NAVIGATION_ABORTED, {
        from: n,
        to: t
      })) : f instanceof Error ? s(f) : qy(f) ? s(fp(Ro.NAVIGATION_GUARD_REDIRECT, {
        from: t,
        to: f
      })) : (a && o.enterCallbacks[l] === a && typeof f == "function" && a.push(f), i());
    }, u = r(() => e.call(o && o.instances[l], t, n, process.env.NODE_ENV !== "production" ? yJe(c, t, n) : c));
    let d = Promise.resolve(u);
    if (e.length < 3 && (d = d.then(c)), process.env.NODE_ENV !== "production" && e.length > 2) {
      const f = `The "next" callback was never called inside of ${e.name ? '"' + e.name + '"' : ""}:
${e.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
      if (typeof u == "object" && "then" in u) d = d.then((p) => c._called ? p : (Rn(f), Promise.reject(/* @__PURE__ */ new Error("Invalid navigation guard"))));
      else if (u !== void 0 && !c._called) {
        Rn(f), s(/* @__PURE__ */ new Error("Invalid navigation guard"));
        return;
      }
    }
    d.catch((f) => s(f));
  });
}
function yJe(e, t, n) {
  let o = 0;
  return function() {
    o++ === 1 && Rn(`The "next" callback was called more than once in one navigation guard when going from "${n.fullPath}" to "${t.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`), e._called = !0, o === 1 && e.apply(null, arguments);
  };
}
function C$(e, t, n, o, l = (r) => r()) {
  const r = [];
  for (const a of e) {
    process.env.NODE_ENV !== "production" && !a.components && a.children && !a.children.length && Rn(`Record with path "${a.path}" is either missing a "component(s)" or "children" property.`);
    for (const i in a.components) {
      let s = a.components[i];
      if (process.env.NODE_ENV !== "production") {
        if (!s || typeof s != "object" && typeof s != "function")
          throw Rn(`Component "${i}" in record with path "${a.path}" is not a valid component. Received "${String(s)}".`), new Error("Invalid route component");
        if ("then" in s) {
          Rn(`Component "${i}" in record with path "${a.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);
          const c = s;
          s = () => c;
        } else s.__asyncLoader && !s.__warnedDefineAsync && (s.__warnedDefineAsync = !0, Rn(`Component "${i}" in record with path "${a.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`));
      }
      if (!(t !== "beforeRouteEnter" && !a.instances[i]))
        if (xY(s)) {
          const c = (s.__vccOpts || s)[t];
          c && r.push(Ks(c, n, o, a, i, l));
        } else {
          let c = s();
          process.env.NODE_ENV !== "production" && !("catch" in c) && (Rn(`Component "${i}" in record with path "${a.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`), c = Promise.resolve(c)), r.push(() => c.then((u) => {
            if (!u) throw new Error(`Couldn't resolve component "${i}" at "${a.path}"`);
            const d = zqe(u) ? u.default : u;
            a.mods[i] = u, a.components[i] = d;
            const f = (d.__vccOpts || d)[t];
            return f && Ks(f, n, o, a, i, l)();
          }));
        }
    }
  }
  return r;
}
function SJe(e, t) {
  const n = [], o = [], l = [], r = Math.max(t.matched.length, e.matched.length);
  for (let a = 0; a < r; a++) {
    const i = t.matched[a];
    i && (e.matched.find((c) => Oc(c, i)) ? o.push(i) : n.push(i));
    const s = e.matched[a];
    s && (t.matched.find((c) => Oc(c, s)) || l.push(s));
  }
  return [
    n,
    o,
    l
  ];
}
function uv(e, t) {
  const n = Yn({}, e, { matched: e.matched.map((o) => kJe(o, [
    "instances",
    "children",
    "aliasOf"
  ])) });
  return { _custom: {
    type: null,
    readOnly: !0,
    display: e.fullPath,
    tooltip: t,
    value: n
  } };
}
function qg(e) {
  return { _custom: { display: e } };
}
let CJe = 0;
function wJe(e, t, n) {
  if (t.__hasDevtools) return;
  t.__hasDevtools = !0;
  const o = CJe++;
  f1({
    id: "org.vuejs.router" + (o ? "." + o : ""),
    label: "Vue Router",
    packageName: "vue-router",
    homepage: "https://router.vuejs.org",
    logo: "https://router.vuejs.org/logo.png",
    componentStateTypes: ["Routing"],
    app: e
  }, (l) => {
    typeof l.now != "function" && Rn("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), l.on.inspectComponent((u, d) => {
      u.instanceData && u.instanceData.state.push({
        type: "Routing",
        key: "$route",
        editable: !1,
        value: uv(t.currentRoute.value, "Current Route")
      });
    }), l.on.visitComponentTree(({ treeNode: u, componentInstance: d }) => {
      if (d.__vrv_devtools) {
        const f = d.__vrv_devtools;
        u.tags.push({
          label: (f.name ? `${f.name.toString()}: ` : "") + f.path,
          textColor: 0,
          tooltip: "This component is rendered by &lt;router-view&gt;",
          backgroundColor: MY
        });
      }
      Fr(d.__vrl_devtools) && (d.__devtoolsApi = l, d.__vrl_devtools.forEach((f) => {
        let p = f.route.path, m = DY, v = "", h = 0;
        f.error ? (p = f.error, m = _Je, h = IJe) : f.isExactActive ? (m = RY, v = "This is exactly active") : f.isActive && (m = AY, v = "This link is active"), u.tags.push({
          label: p,
          textColor: h,
          tooltip: v,
          backgroundColor: m
        });
      }));
    }), pe(t.currentRoute, () => {
      s(), l.notifyComponentUpdate(), l.sendInspectorTree(i), l.sendInspectorState(i);
    });
    const r = "router:navigations:" + o;
    l.addTimelineLayer({
      id: r,
      label: `Router${o ? " " + o : ""} Navigations`,
      color: 4237508
    }), t.onError((u, d) => {
      l.addTimelineEvent({
        layerId: r,
        event: {
          title: "Error during Navigation",
          subtitle: d.fullPath,
          logType: "error",
          time: l.now(),
          data: { error: u },
          groupId: d.meta.__navigationId
        }
      });
    });
    let a = 0;
    t.beforeEach((u, d) => {
      const f = {
        guard: qg("beforeEach"),
        from: uv(d, "Current Location during this navigation"),
        to: uv(u, "Target location")
      };
      Object.defineProperty(u.meta, "__navigationId", { value: a++ }), l.addTimelineEvent({
        layerId: r,
        event: {
          time: l.now(),
          title: "Start of navigation",
          subtitle: u.fullPath,
          data: f,
          groupId: u.meta.__navigationId
        }
      });
    }), t.afterEach((u, d, f) => {
      const p = { guard: qg("afterEach") };
      f ? (p.failure = { _custom: {
        type: Error,
        readOnly: !0,
        display: f ? f.message : "",
        tooltip: "Navigation Failure",
        value: f
      } }, p.status = qg("")) : p.status = qg(""), p.from = uv(d, "Current Location during this navigation"), p.to = uv(u, "Target location"), l.addTimelineEvent({
        layerId: r,
        event: {
          title: "End of navigation",
          subtitle: u.fullPath,
          time: l.now(),
          data: p,
          logType: f ? "warning" : "default",
          groupId: u.meta.__navigationId
        }
      });
    });
    const i = "router-inspector:" + o;
    l.addInspector({
      id: i,
      label: "Routes" + (o ? " " + o : ""),
      icon: "book",
      treeFilterPlaceholder: "Search routes"
    });
    function s() {
      if (!c) return;
      const u = c;
      let d = n.getRoutes().filter((f) => !f.parent || !f.parent.record.components);
      d.forEach(FY), u.filter && (d = d.filter((f) => OE(f, u.filter.toLowerCase()))), d.forEach((f) => BY(f, t.currentRoute.value)), u.rootNodes = d.map(LY);
    }
    let c;
    l.on.getInspectorTree((u) => {
      c = u, u.app === e && u.inspectorId === i && s();
    }), l.on.getInspectorState((u) => {
      if (u.app === e && u.inspectorId === i) {
        const d = n.getRoutes().find((f) => f.record.__vd_id === u.nodeId);
        d && (u.state = { options: xJe(d) });
      }
    }), l.sendInspectorTree(i), l.sendInspectorState(i);
  });
}
function $Je(e) {
  return e.optional ? e.repeatable ? "*" : "?" : e.repeatable ? "+" : "";
}
function xJe(e) {
  const { record: t } = e, n = [{
    editable: !1,
    key: "path",
    value: t.path
  }];
  return t.name != null && n.push({
    editable: !1,
    key: "name",
    value: t.name
  }), n.push({
    editable: !1,
    key: "regexp",
    value: e.re
  }), e.keys.length && n.push({
    editable: !1,
    key: "keys",
    value: { _custom: {
      type: null,
      readOnly: !0,
      display: e.keys.map((o) => `${o.name}${$Je(o)}`).join(" "),
      tooltip: "Param keys",
      value: e.keys
    } }
  }), t.redirect != null && n.push({
    editable: !1,
    key: "redirect",
    value: t.redirect
  }), e.alias.length && n.push({
    editable: !1,
    key: "aliases",
    value: e.alias.map((o) => o.record.path)
  }), Object.keys(e.record.meta).length && n.push({
    editable: !1,
    key: "meta",
    value: e.record.meta
  }), n.push({
    key: "score",
    editable: !1,
    value: { _custom: {
      type: null,
      readOnly: !0,
      display: e.score.map((o) => o.join(", ")).join(" | "),
      tooltip: "Score used to sort routes",
      value: e.score
    } }
  }), n;
}
const MY = 15485081, AY = 2450411, RY = 8702998, EJe = 2282478, DY = 16486972, OJe = 6710886, _Je = 16704226, IJe = 12131356;
function LY(e) {
  const t = [], { record: n } = e;
  n.name != null && t.push({
    label: String(n.name),
    textColor: 0,
    backgroundColor: EJe
  }), n.aliasOf && t.push({
    label: "alias",
    textColor: 0,
    backgroundColor: DY
  }), e.__vd_match && t.push({
    label: "matches",
    textColor: 0,
    backgroundColor: MY
  }), e.__vd_exactActive && t.push({
    label: "exact",
    textColor: 0,
    backgroundColor: RY
  }), e.__vd_active && t.push({
    label: "active",
    textColor: 0,
    backgroundColor: AY
  }), n.redirect && t.push({
    label: typeof n.redirect == "string" ? `redirect: ${n.redirect}` : "redirects",
    textColor: 16777215,
    backgroundColor: OJe
  });
  let o = n.__vd_id;
  return o == null && (o = String(TJe++), n.__vd_id = o), {
    id: o,
    label: n.path,
    tags: t,
    children: e.children.map(LY)
  };
}
let TJe = 0;
const PJe = /^\/(.*)\/([a-z]*)$/;
function BY(e, t) {
  const n = t.matched.length && Oc(t.matched[t.matched.length - 1], e.record);
  e.__vd_exactActive = e.__vd_active = n, n || (e.__vd_active = t.matched.some((o) => Oc(o, e.record))), e.children.forEach((o) => BY(o, t));
}
function FY(e) {
  e.__vd_match = !1, e.children.forEach(FY);
}
function OE(e, t) {
  const n = String(e.re).match(PJe);
  if (e.__vd_match = !1, !n || n.length < 3) return !1;
  if (new RegExp(n[1].replace(/\$$/, ""), n[2]).test(t))
    return e.children.forEach((r) => OE(r, t)), e.record.path !== "/" || t === "/" ? (e.__vd_match = e.re.test(t), !0) : !1;
  const o = e.record.path.toLowerCase(), l = dp(o);
  return !t.startsWith("/") && (l.includes(t) || o.includes(t)) || l.startsWith(t) || o.startsWith(t) || e.record.name && String(e.record.name).includes(t) ? !0 : e.children.some((r) => OE(r, t));
}
function kJe(e, t) {
  const n = {};
  for (const o in e) t.includes(o) || (n[o] = e[o]);
  return n;
}
/*!
 * vue-router v4.6.4
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let NJe = () => location.protocol + "//" + location.host;
function VY(e, t) {
  const { pathname: n, search: o, hash: l } = t, r = e.indexOf("#");
  if (r > -1) {
    let a = l.includes(e.slice(r)) ? e.slice(r).length : 1, i = l.slice(a);
    return i[0] !== "/" && (i = "/" + i), bD(i, "");
  }
  return bD(n, e) + o + l;
}
function MJe(e, t, n, o) {
  let l = [], r = [], a = null;
  const i = ({ state: f }) => {
    const p = VY(e, location), m = n.value, v = t.value;
    let h = 0;
    if (f) {
      if (n.value = p, t.value = f, a && a === m) {
        a = null;
        return;
      }
      h = v ? f.position - v.position : 0;
    } else o(p);
    l.forEach((g) => {
      g(n.value, m, {
        delta: h,
        type: wE.pop,
        direction: h ? h > 0 ? S$.forward : S$.back : S$.unknown
      });
    });
  };
  function s() {
    a = n.value;
  }
  function c(f) {
    l.push(f);
    const p = () => {
      const m = l.indexOf(f);
      m > -1 && l.splice(m, 1);
    };
    return r.push(p), p;
  }
  function u() {
    if (document.visibilityState === "hidden") {
      const { history: f } = window;
      if (!f.state) return;
      f.replaceState(Yn({}, f.state, { scroll: aC() }), "");
    }
  }
  function d() {
    for (const f of r) f();
    r = [], window.removeEventListener("popstate", i), window.removeEventListener("pagehide", u), document.removeEventListener("visibilitychange", u);
  }
  return window.addEventListener("popstate", i), window.addEventListener("pagehide", u), document.addEventListener("visibilitychange", u), {
    pauseListeners: s,
    listen: c,
    destroy: d
  };
}
function xD(e, t, n, o = !1, l = !1) {
  return {
    back: e,
    current: t,
    forward: n,
    replaced: o,
    position: window.history.length,
    scroll: l ? aC() : null
  };
}
function AJe(e) {
  const { history: t, location: n } = window, o = { value: VY(e, n) }, l = { value: t.state };
  l.value || r(o.value, {
    back: null,
    current: o.value,
    forward: null,
    position: t.length - 1,
    replaced: !0,
    scroll: null
  }, !0);
  function r(s, c, u) {
    const d = e.indexOf("#"), f = d > -1 ? (n.host && document.querySelector("base") ? e : e.slice(d)) + s : NJe() + e + s;
    try {
      t[u ? "replaceState" : "pushState"](c, "", f), l.value = c;
    } catch (p) {
      process.env.NODE_ENV !== "production" ? Rn("Error with push/replace State", p) : console.error(p), n[u ? "replace" : "assign"](f);
    }
  }
  function a(s, c) {
    r(s, Yn({}, t.state, xD(l.value.back, s, l.value.forward, !0), c, { position: l.value.position }), !0), o.value = s;
  }
  function i(s, c) {
    const u = Yn({}, l.value, t.state, {
      forward: s,
      scroll: aC()
    });
    process.env.NODE_ENV !== "production" && !t.state && Rn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://router.vuejs.org/guide/migration/#Usage-of-history-state`), r(u.current, u, !0), r(s, Yn({}, xD(o.value, s, null), { position: u.position + 1 }, c), !1), o.value = s;
  }
  return {
    location: o,
    state: l,
    push: i,
    replace: a
  };
}
function RJe(e) {
  e = aJe(e);
  const t = AJe(e), n = MJe(e, t.state, t.location, t.replace);
  function o(r, a = !0) {
    a || n.pauseListeners(), history.go(r);
  }
  const l = Yn({
    location: "",
    base: e,
    go: o,
    createHref: sJe.bind(null, e)
  }, t, n);
  return Object.defineProperty(l, "location", {
    enumerable: !0,
    get: () => t.location.value
  }), Object.defineProperty(l, "state", {
    enumerable: !0,
    get: () => t.state.value
  }), l;
}
let bu = /* @__PURE__ */ function(e) {
  return e[e.Static = 0] = "Static", e[e.Param = 1] = "Param", e[e.Group = 2] = "Group", e;
}({});
var el = /* @__PURE__ */ function(e) {
  return e[e.Static = 0] = "Static", e[e.Param = 1] = "Param", e[e.ParamRegExp = 2] = "ParamRegExp", e[e.ParamRegExpEnd = 3] = "ParamRegExpEnd", e[e.EscapeNext = 4] = "EscapeNext", e;
}(el || {});
const DJe = {
  type: bu.Static,
  value: ""
}, LJe = /[a-zA-Z0-9_]/;
function BJe(e) {
  if (!e) return [[]];
  if (e === "/") return [[DJe]];
  if (!e.startsWith("/")) throw new Error(process.env.NODE_ENV !== "production" ? `Route paths should start with a "/": "${e}" should be "/${e}".` : `Invalid path "${e}"`);
  function t(p) {
    throw new Error(`ERR (${n})/"${c}": ${p}`);
  }
  let n = el.Static, o = n;
  const l = [];
  let r;
  function a() {
    r && l.push(r), r = [];
  }
  let i = 0, s, c = "", u = "";
  function d() {
    c && (n === el.Static ? r.push({
      type: bu.Static,
      value: c
    }) : n === el.Param || n === el.ParamRegExp || n === el.ParamRegExpEnd ? (r.length > 1 && (s === "*" || s === "+") && t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), r.push({
      type: bu.Param,
      value: c,
      regexp: u,
      repeatable: s === "*" || s === "+",
      optional: s === "*" || s === "?"
    })) : t("Invalid state to consume buffer"), c = "");
  }
  function f() {
    c += s;
  }
  for (; i < e.length; ) {
    if (s = e[i++], s === "\\" && n !== el.ParamRegExp) {
      o = n, n = el.EscapeNext;
      continue;
    }
    switch (n) {
      case el.Static:
        s === "/" ? (c && d(), a()) : s === ":" ? (d(), n = el.Param) : f();
        break;
      case el.EscapeNext:
        f(), n = o;
        break;
      case el.Param:
        s === "(" ? n = el.ParamRegExp : LJe.test(s) ? f() : (d(), n = el.Static, s !== "*" && s !== "?" && s !== "+" && i--);
        break;
      case el.ParamRegExp:
        s === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + s : n = el.ParamRegExpEnd : u += s;
        break;
      case el.ParamRegExpEnd:
        d(), n = el.Static, s !== "*" && s !== "?" && s !== "+" && i--, u = "";
        break;
      default:
        t("Unknown state");
        break;
    }
  }
  return n === el.ParamRegExp && t(`Unfinished custom RegExp for param "${c}"`), d(), a(), l;
}
const ED = "[^/]+?", FJe = {
  sensitive: !1,
  strict: !1,
  start: !0,
  end: !0
};
var Xl = /* @__PURE__ */ function(e) {
  return e[e._multiplier = 10] = "_multiplier", e[e.Root = 90] = "Root", e[e.Segment = 40] = "Segment", e[e.SubSegment = 30] = "SubSegment", e[e.Static = 40] = "Static", e[e.Dynamic = 20] = "Dynamic", e[e.BonusCustomRegExp = 10] = "BonusCustomRegExp", e[e.BonusWildcard = -50] = "BonusWildcard", e[e.BonusRepeatable = -20] = "BonusRepeatable", e[e.BonusOptional = -8] = "BonusOptional", e[e.BonusStrict = 0.7000000000000001] = "BonusStrict", e[e.BonusCaseSensitive = 0.25] = "BonusCaseSensitive", e;
}(Xl || {});
const VJe = /[.+*?^${}()[\]/\\]/g;
function zJe(e, t) {
  const n = Yn({}, FJe, t), o = [];
  let l = n.start ? "^" : "";
  const r = [];
  for (const c of e) {
    const u = c.length ? [] : [Xl.Root];
    n.strict && !c.length && (l += "/");
    for (let d = 0; d < c.length; d++) {
      const f = c[d];
      let p = Xl.Segment + (n.sensitive ? Xl.BonusCaseSensitive : 0);
      if (f.type === bu.Static)
        d || (l += "/"), l += f.value.replace(VJe, "\\$&"), p += Xl.Static;
      else if (f.type === bu.Param) {
        const { value: m, repeatable: v, optional: h, regexp: g } = f;
        r.push({
          name: m,
          repeatable: v,
          optional: h
        });
        const y = g || ED;
        if (y !== ED) {
          p += Xl.BonusCustomRegExp;
          try {
            `${y}`;
          } catch (C) {
            throw new Error(`Invalid custom RegExp for param "${m}" (${y}): ` + C.message);
          }
        }
        let b = v ? `((?:${y})(?:/(?:${y}))*)` : `(${y})`;
        d || (b = h && c.length < 2 ? `(?:/${b})` : "/" + b), h && (b += "?"), l += b, p += Xl.Dynamic, h && (p += Xl.BonusOptional), v && (p += Xl.BonusRepeatable), y === ".*" && (p += Xl.BonusWildcard);
      }
      u.push(p);
    }
    o.push(u);
  }
  if (n.strict && n.end) {
    const c = o.length - 1;
    o[c][o[c].length - 1] += Xl.BonusStrict;
  }
  n.strict || (l += "/?"), n.end ? l += "$" : n.strict && !l.endsWith("/") && (l += "(?:/|$)");
  const a = new RegExp(l, n.sensitive ? "" : "i");
  function i(c) {
    const u = c.match(a), d = {};
    if (!u) return null;
    for (let f = 1; f < u.length; f++) {
      const p = u[f] || "", m = r[f - 1];
      d[m.name] = p && m.repeatable ? p.split("/") : p;
    }
    return d;
  }
  function s(c) {
    let u = "", d = !1;
    for (const f of e) {
      (!d || !u.endsWith("/")) && (u += "/"), d = !1;
      for (const p of f) if (p.type === bu.Static) u += p.value;
      else if (p.type === bu.Param) {
        const { value: m, repeatable: v, optional: h } = p, g = m in c ? c[m] : "";
        if (Fr(g) && !v) throw new Error(`Provided param "${m}" is an array but it is not repeatable (* or + modifiers)`);
        const y = Fr(g) ? g.join("/") : g;
        if (!y) if (h)
          f.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : d = !0);
        else throw new Error(`Missing required param "${m}"`);
        u += y;
      }
    }
    return u || "/";
  }
  return {
    re: a,
    score: o,
    keys: r,
    parse: i,
    stringify: s
  };
}
function HJe(e, t) {
  let n = 0;
  for (; n < e.length && n < t.length; ) {
    const o = t[n] - e[n];
    if (o) return o;
    n++;
  }
  return e.length < t.length ? e.length === 1 && e[0] === Xl.Static + Xl.Segment ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === Xl.Static + Xl.Segment ? 1 : -1 : 0;
}
function zY(e, t) {
  let n = 0;
  const o = e.score, l = t.score;
  for (; n < o.length && n < l.length; ) {
    const r = HJe(o[n], l[n]);
    if (r) return r;
    n++;
  }
  if (Math.abs(l.length - o.length) === 1) {
    if (OD(o)) return 1;
    if (OD(l)) return -1;
  }
  return l.length - o.length;
}
function OD(e) {
  const t = e[e.length - 1];
  return e.length > 0 && t[t.length - 1] < 0;
}
const jJe = {
  strict: !1,
  end: !0,
  sensitive: !1
};
function WJe(e, t, n) {
  const o = zJe(BJe(e.path), n);
  if (process.env.NODE_ENV !== "production") {
    const r = /* @__PURE__ */ new Set();
    for (const a of o.keys)
      r.has(a.name) && Rn(`Found duplicated params with name "${a.name}" for path "${e.path}". Only the last one will be available on "$route.params".`), r.add(a.name);
  }
  const l = Yn(o, {
    record: e,
    parent: t,
    children: [],
    alias: []
  });
  return t && !l.record.aliasOf == !t.record.aliasOf && t.children.push(l), l;
}
function KJe(e, t) {
  const n = [], o = /* @__PURE__ */ new Map();
  t = gD(jJe, t);
  function l(d) {
    return o.get(d);
  }
  function r(d, f, p) {
    const m = !p, v = ID(d);
    process.env.NODE_ENV !== "production" && XJe(v, f), v.aliasOf = p && p.record;
    const h = gD(t, d), g = [v];
    if ("alias" in d) {
      const C = typeof d.alias == "string" ? [d.alias] : d.alias;
      for (const w of C) g.push(ID(Yn({}, v, {
        components: p ? p.record.components : v.components,
        path: w,
        aliasOf: p ? p.record : v
      })));
    }
    let y, b;
    for (const C of g) {
      const { path: w } = C;
      if (f && w[0] !== "/") {
        const x = f.record.path, E = x[x.length - 1] === "/" ? "" : "/";
        C.path = f.record.path + (w && E + w);
      }
      if (process.env.NODE_ENV !== "production" && C.path === "*") throw new Error(`Catch all routes ("*") must now be defined using a param with a custom regexp.
See more at https://router.vuejs.org/guide/migration/#Removed-star-or-catch-all-routes.`);
      if (y = WJe(C, f, h), process.env.NODE_ENV !== "production" && f && w[0] === "/" && JJe(y, f), p ? (p.alias.push(y), process.env.NODE_ENV !== "production" && YJe(p, y)) : (b = b || y, b !== y && b.alias.push(y), m && d.name && !TD(y) && (process.env.NODE_ENV !== "production" && qJe(d, f), a(d.name))), HY(y) && s(y), v.children) {
        const x = v.children;
        for (let E = 0; E < x.length; E++) r(x[E], y, p && p.children[E]);
      }
      p = p || y;
    }
    return b ? () => {
      a(b);
    } : Uv;
  }
  function a(d) {
    if (kY(d)) {
      const f = o.get(d);
      f && (o.delete(d), n.splice(n.indexOf(f), 1), f.children.forEach(a), f.alias.forEach(a));
    } else {
      const f = n.indexOf(d);
      f > -1 && (n.splice(f, 1), d.record.name && o.delete(d.record.name), d.children.forEach(a), d.alias.forEach(a));
    }
  }
  function i() {
    return n;
  }
  function s(d) {
    const f = ZJe(d, n);
    n.splice(f, 0, d), d.record.name && !TD(d) && o.set(d.record.name, d);
  }
  function c(d, f) {
    let p, m = {}, v, h;
    if ("name" in d && d.name) {
      if (p = o.get(d.name), !p) throw fp(Ro.MATCHER_NOT_FOUND, { location: d });
      if (process.env.NODE_ENV !== "production") {
        const b = Object.keys(d.params || {}).filter((C) => !p.keys.find((w) => w.name === C));
        b.length && Rn(`Discarded invalid param(s) "${b.join('", "')}" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);
      }
      h = p.record.name, m = Yn(_D(f.params, p.keys.filter((b) => !b.optional).concat(p.parent ? p.parent.keys.filter((b) => b.optional) : []).map((b) => b.name)), d.params && _D(d.params, p.keys.map((b) => b.name))), v = p.stringify(m);
    } else if (d.path != null)
      v = d.path, process.env.NODE_ENV !== "production" && !v.startsWith("/") && Rn(`The Matcher cannot resolve relative paths but received "${v}". Unless you directly called \`matcher.resolve("${v}")\`, this is probably a bug in vue-router. Please open an issue at https://github.com/vuejs/router/issues/new/choose.`), p = n.find((b) => b.re.test(v)), p && (m = p.parse(v), h = p.record.name);
    else {
      if (p = f.name ? o.get(f.name) : n.find((b) => b.re.test(f.path)), !p) throw fp(Ro.MATCHER_NOT_FOUND, {
        location: d,
        currentLocation: f
      });
      h = p.record.name, m = Yn({}, f.params, d.params), v = p.stringify(m);
    }
    const g = [];
    let y = p;
    for (; y; )
      g.unshift(y.record), y = y.parent;
    return {
      name: h,
      path: v,
      params: m,
      matched: g,
      meta: GJe(g)
    };
  }
  e.forEach((d) => r(d));
  function u() {
    n.length = 0, o.clear();
  }
  return {
    addRoute: r,
    resolve: c,
    removeRoute: a,
    clearRoutes: u,
    getRoutes: i,
    getRecordMatcher: l
  };
}
function _D(e, t) {
  const n = {};
  for (const o of t) o in e && (n[o] = e[o]);
  return n;
}
function ID(e) {
  const t = {
    path: e.path,
    redirect: e.redirect,
    name: e.name,
    meta: e.meta || {},
    aliasOf: e.aliasOf,
    beforeEnter: e.beforeEnter,
    props: UJe(e),
    children: e.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in e ? e.components || null : e.component && { default: e.component }
  };
  return Object.defineProperty(t, "mods", { value: {} }), t;
}
function UJe(e) {
  const t = {}, n = e.props || !1;
  if ("component" in e) t.default = n;
  else for (const o in e.components) t[o] = typeof n == "object" ? n[o] : n;
  return t;
}
function TD(e) {
  for (; e; ) {
    if (e.record.aliasOf) return !0;
    e = e.parent;
  }
  return !1;
}
function GJe(e) {
  return e.reduce((t, n) => Yn(t, n.meta), {});
}
function _E(e, t) {
  return e.name === t.name && e.optional === t.optional && e.repeatable === t.repeatable;
}
function YJe(e, t) {
  for (const n of e.keys) if (!n.optional && !t.keys.find(_E.bind(null, n))) return Rn(`Alias "${t.record.path}" and the original record: "${e.record.path}" must have the exact same param named "${n.name}"`);
  for (const n of t.keys) if (!n.optional && !e.keys.find(_E.bind(null, n))) return Rn(`Alias "${t.record.path}" and the original record: "${e.record.path}" must have the exact same param named "${n.name}"`);
}
function XJe(e, t) {
  t && t.record.name && !e.name && !e.path && Rn(`The route named "${String(t.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);
}
function qJe(e, t) {
  for (let n = t; n; n = n.parent) if (n.record.name === e.name) throw new Error(`A route named "${String(e.name)}" has been added as a ${t === n ? "child" : "descendant"} of a route with the same name. Route names must be unique and a nested route cannot use the same name as an ancestor.`);
}
function JJe(e, t) {
  for (const n of t.keys) if (!e.keys.find(_E.bind(null, n))) return Rn(`Absolute path "${e.record.path}" must have the exact same param named "${n.name}" as its parent "${t.record.path}".`);
}
function ZJe(e, t) {
  let n = 0, o = t.length;
  for (; n !== o; ) {
    const r = n + o >> 1;
    zY(e, t[r]) < 0 ? o = r : n = r + 1;
  }
  const l = QJe(e);
  return l && (o = t.lastIndexOf(l, o - 1), process.env.NODE_ENV !== "production" && o < 0 && Rn(`Finding ancestor route "${l.record.path}" failed for "${e.record.path}"`)), o;
}
function QJe(e) {
  let t = e;
  for (; t = t.parent; ) if (HY(t) && zY(e, t) === 0) return t;
}
function HY({ record: e }) {
  return !!(e.name || e.components && Object.keys(e.components).length || e.redirect);
}
function PD(e) {
  const t = ze(WP), n = ze(NY);
  let o = !1, l = null;
  const r = O(() => {
    const u = S(e.to);
    return process.env.NODE_ENV !== "production" && (!o || u !== l) && (qy(u) || (o ? Rn(`Invalid value for prop "to" in useLink()
- to:`, u, `
- previous to:`, l, `
- props:`, e) : Rn(`Invalid value for prop "to" in useLink()
- to:`, u, `
- props:`, e)), l = u, o = !0), t.resolve(u);
  }), a = O(() => {
    const { matched: u } = r.value, { length: d } = u, f = u[d - 1], p = n.matched;
    if (!f || !p.length) return -1;
    const m = p.findIndex(Oc.bind(null, f));
    if (m > -1) return m;
    const v = kD(u[d - 2]);
    return d > 1 && kD(f) === v && p[p.length - 1].path !== v ? p.findIndex(Oc.bind(null, u[d - 2])) : m;
  }), i = O(() => a.value > -1 && lZe(n.params, r.value.params)), s = O(() => a.value > -1 && a.value === n.matched.length - 1 && PY(n.params, r.value.params));
  function c(u = {}) {
    if (oZe(u)) {
      const d = t[S(e.replace) ? "replace" : "push"](S(e.to)).catch(Uv);
      return e.viewTransition && typeof document != "undefined" && "startViewTransition" in document && document.startViewTransition(() => d), d;
    }
    return Promise.resolve();
  }
  if (process.env.NODE_ENV !== "production" && Zi) {
    const u = xt();
    if (u) {
      const d = {
        route: r.value,
        isActive: i.value,
        isExactActive: s.value,
        error: null
      };
      u.__vrl_devtools = u.__vrl_devtools || [], u.__vrl_devtools.push(d), Ot(() => {
        d.route = r.value, d.isActive = i.value, d.isExactActive = s.value, d.error = qy(S(e.to)) ? null : 'Invalid "to" value';
      }, { flush: "post" });
    }
  }
  return {
    route: r,
    href: O(() => r.value.href),
    isActive: i,
    isExactActive: s,
    navigate: c
  };
}
function eZe(e) {
  return e.length === 1 ? e[0] : e;
}
const tZe = /* @__PURE__ */ le({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: !0
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    },
    viewTransition: Boolean
  },
  useLink: PD,
  setup(e, { slots: t }) {
    const n = /* @__PURE__ */ kt(PD(e)), { options: o } = ze(WP), l = O(() => ({
      [ND(e.activeClass, o.linkActiveClass, "router-link-active")]: n.isActive,
      [ND(e.exactActiveClass, o.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
    }));
    return () => {
      const r = t.default && eZe(t.default(n));
      return e.custom ? r : ht("a", {
        "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
        href: n.href,
        onClick: n.navigate,
        class: l.value
      }, r);
    };
  }
}), nZe = tZe;
function oZe(e) {
  if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
    if (e.currentTarget && e.currentTarget.getAttribute) {
      const t = e.currentTarget.getAttribute("target");
      if (/\b_blank\b/i.test(t)) return;
    }
    return e.preventDefault && e.preventDefault(), !0;
  }
}
function lZe(e, t) {
  for (const n in t) {
    const o = t[n], l = e[n];
    if (typeof o == "string") {
      if (o !== l) return !1;
    } else if (!Fr(l) || l.length !== o.length || o.some((r, a) => r.valueOf() !== l[a].valueOf())) return !1;
  }
  return !0;
}
function kD(e) {
  return e ? e.aliasOf ? e.aliasOf.path : e.path : "";
}
const ND = (e, t, n) => e != null ? e : t != null ? t : n, rZe = /* @__PURE__ */ le({
  name: "RouterView",
  inheritAttrs: !1,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  compatConfig: { MODE: 3 },
  setup(e, { attrs: t, slots: n }) {
    process.env.NODE_ENV !== "production" && iZe();
    const o = ze(EE), l = O(() => e.route || o.value), r = ze($D, 0), a = O(() => {
      let c = S(r);
      const { matched: u } = l.value;
      let d;
      for (; (d = u[c]) && !d.components; ) c++;
      return c;
    }), i = O(() => l.value.matched[a.value]);
    at($D, O(() => a.value + 1)), at(bJe, i), at(EE, l);
    const s = /* @__PURE__ */ H();
    return pe(() => [
      s.value,
      i.value,
      e.name
    ], ([c, u, d], [f, p, m]) => {
      u && (u.instances[d] = c, p && p !== u && c && c === f && (u.leaveGuards.size || (u.leaveGuards = p.leaveGuards), u.updateGuards.size || (u.updateGuards = p.updateGuards))), c && u && (!p || !Oc(u, p) || !f) && (u.enterCallbacks[d] || []).forEach((v) => v(c));
    }, { flush: "post" }), () => {
      const c = l.value, u = e.name, d = i.value, f = d && d.components[u];
      if (!f) return MD(n.default, {
        Component: f,
        route: c
      });
      const p = d.props[u], m = p ? p === !0 ? c.params : typeof p == "function" ? p(c) : p : null, h = ht(f, Yn({}, m, t, {
        onVnodeUnmounted: (g) => {
          g.component.isUnmounted && (d.instances[u] = null);
        },
        ref: s
      }));
      if (process.env.NODE_ENV !== "production" && Zi && h.ref) {
        const g = {
          depth: a.value,
          name: d.name,
          path: d.path,
          meta: d.meta
        };
        (Fr(h.ref) ? h.ref.map((y) => y.i) : [h.ref.i]).forEach((y) => {
          y.__vrv_devtools = g;
        });
      }
      return MD(n.default, {
        Component: h,
        route: c
      }) || h;
    };
  }
});
function MD(e, t) {
  if (!e) return null;
  const n = e(t);
  return n.length === 1 ? n[0] : n;
}
const aZe = rZe;
function iZe() {
  const e = xt(), t = e.parent && e.parent.type.name, n = e.parent && e.parent.subTree && e.parent.subTree.type;
  if (t && (t === "KeepAlive" || t.includes("Transition")) && typeof n == "object" && n.name === "RouterView") {
    const o = t === "KeepAlive" ? "keep-alive" : "transition";
    Rn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${o}>
    <component :is="Component" />
  </${o}>
</router-view>`);
  }
}
function sZe(e) {
  const t = KJe(e.routes, e), n = e.parseQuery || hJe, o = e.stringifyQuery || wD, l = e.history;
  if (process.env.NODE_ENV !== "production" && !l) throw new Error('Provide the "history" option when calling "createRouter()": https://router.vuejs.org/api/interfaces/RouterOptions.html#history');
  const r = cv(), a = cv(), i = cv(), s = /* @__PURE__ */ Ce(Ds);
  let c = Ds;
  Zi && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
  const u = b$.bind(null, (J) => "" + J), d = b$.bind(null, eJe), f = b$.bind(null, dp);
  function p(J, re) {
    let oe, q;
    return kY(J) ? (oe = t.getRecordMatcher(J), process.env.NODE_ENV !== "production" && !oe && Rn(`Parent route "${String(J)}" not found when adding child route`, re), q = re) : q = J, t.addRoute(q, oe);
  }
  function m(J) {
    const re = t.getRecordMatcher(J);
    re ? t.removeRoute(re) : process.env.NODE_ENV !== "production" && Rn(`Cannot remove non-existent route "${String(J)}"`);
  }
  function v() {
    return t.getRoutes().map((J) => J.record);
  }
  function h(J) {
    return !!t.getRecordMatcher(J);
  }
  function g(J, re) {
    if (re = Yn({}, re || s.value), typeof J == "string") {
      const ee = y$(n, J, re.path), fe = t.resolve({ path: ee.path }, re), me = l.createHref(ee.fullPath);
      return process.env.NODE_ENV !== "production" && (me.startsWith("//") ? Rn(`Location "${J}" resolved to "${me}". A resolved location cannot start with multiple slashes.`) : fe.matched.length || Rn(`No match found for location with path "${J}"`)), Yn(ee, fe, {
        params: f(fe.params),
        hash: dp(ee.hash),
        redirectedFrom: void 0,
        href: me
      });
    }
    if (process.env.NODE_ENV !== "production" && !qy(J))
      return Rn(`router.resolve() was passed an invalid location. This will fail in production.
- Location:`, J), g({});
    let oe;
    if (J.path != null)
      process.env.NODE_ENV !== "production" && "params" in J && !("name" in J) && Object.keys(J.params).length && Rn(`Path "${J.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`), oe = Yn({}, J, { path: y$(n, J.path, re.path).path });
    else {
      const ee = Yn({}, J.params);
      for (const fe in ee) ee[fe] == null && delete ee[fe];
      oe = Yn({}, J, { params: d(ee) }), re.params = d(re.params);
    }
    const q = t.resolve(oe, re), K = J.hash || "";
    process.env.NODE_ENV !== "production" && K && !K.startsWith("#") && Rn(`A \`hash\` should always start with the character "#". Replace "${K}" with "#${K}".`), q.params = u(f(q.params));
    const se = oJe(o, Yn({}, J, {
      hash: Jqe(K),
      path: q.path
    })), Z = l.createHref(se);
    return process.env.NODE_ENV !== "production" && (Z.startsWith("//") ? Rn(`Location "${J}" resolved to "${Z}". A resolved location cannot start with multiple slashes.`) : q.matched.length || Rn(`No match found for location with path "${J.path != null ? J.path : J}"`)), Yn({
      fullPath: se,
      hash: K,
      query: o === wD ? gJe(J.query) : J.query || {}
    }, q, {
      redirectedFrom: void 0,
      href: Z
    });
  }
  function y(J) {
    return typeof J == "string" ? y$(n, J, s.value.path) : Yn({}, J);
  }
  function b(J, re) {
    if (c !== J) return fp(Ro.NAVIGATION_CANCELLED, {
      from: re,
      to: J
    });
  }
  function C(J) {
    return E(J);
  }
  function w(J) {
    return C(Yn(y(J), { replace: !0 }));
  }
  function x(J, re) {
    const oe = J.matched[J.matched.length - 1];
    if (oe && oe.redirect) {
      const { redirect: q } = oe;
      let K = typeof q == "function" ? q(J, re) : q;
      if (typeof K == "string" && (K = K.includes("?") || K.includes("#") ? K = y(K) : { path: K }, K.params = {}), process.env.NODE_ENV !== "production" && K.path == null && !("name" in K))
        throw Rn(`Invalid redirect found:
${JSON.stringify(K, null, 2)}
 when navigating to "${J.fullPath}". A redirect must contain a name or path. This will break in production.`), new Error("Invalid redirect");
      return Yn({
        query: J.query,
        hash: J.hash,
        params: K.path != null ? {} : J.params
      }, K);
    }
  }
  function E(J, re) {
    const oe = c = g(J), q = s.value, K = J.state, se = J.force, Z = J.replace === !0, ee = x(oe, q);
    if (ee) return E(Yn(y(ee), {
      state: typeof ee == "object" ? Yn({}, K, ee.state) : K,
      force: se,
      replace: Z
    }), re || oe);
    const fe = oe;
    fe.redirectedFrom = re;
    let me;
    return !se && yD(o, q, oe) && (me = fp(Ro.NAVIGATION_DUPLICATED, {
      to: fe,
      from: q
    }), V(q, q, !0, !1)), (me ? Promise.resolve(me) : P(fe, q)).catch((ge) => Wi(ge) ? Wi(ge, Ro.NAVIGATION_GUARD_REDIRECT) ? ge : B(ge) : A(ge, fe, q)).then((ge) => {
      if (ge) {
        if (Wi(ge, Ro.NAVIGATION_GUARD_REDIRECT))
          return process.env.NODE_ENV !== "production" && yD(o, g(ge.to), fe) && re && (re._count = re._count ? re._count + 1 : 1) > 30 ? (Rn(`Detected a possibly infinite redirection in a navigation guard when going from "${q.fullPath}" to "${fe.fullPath}". Aborting to avoid a Stack Overflow.
 Are you always returning a new location within a navigation guard? That would lead to this error. Only return when redirecting or aborting, that should fix this. This might break in production if not fixed.`), Promise.reject(/* @__PURE__ */ new Error("Infinite redirect in navigation guard"))) : E(Yn({ replace: Z }, y(ge.to), {
            state: typeof ge.to == "object" ? Yn({}, K, ge.to.state) : K,
            force: se
          }), re || fe);
      } else ge = N(fe, q, !0, Z, K);
      return k(fe, q, ge), ge;
    });
  }
  function I(J, re) {
    const oe = b(J, re);
    return oe ? Promise.reject(oe) : Promise.resolve();
  }
  function T(J) {
    const re = Y.values().next().value;
    return re && typeof re.runWithContext == "function" ? re.runWithContext(J) : J();
  }
  function P(J, re) {
    let oe;
    const [q, K, se] = SJe(J, re);
    oe = C$(q.reverse(), "beforeRouteLeave", J, re);
    for (const ee of q) ee.leaveGuards.forEach((fe) => {
      oe.push(Ks(fe, J, re));
    });
    const Z = I.bind(null, J, re);
    return oe.push(Z), te(oe).then(() => {
      oe = [];
      for (const ee of r.list()) oe.push(Ks(ee, J, re));
      return oe.push(Z), te(oe);
    }).then(() => {
      oe = C$(K, "beforeRouteUpdate", J, re);
      for (const ee of K) ee.updateGuards.forEach((fe) => {
        oe.push(Ks(fe, J, re));
      });
      return oe.push(Z), te(oe);
    }).then(() => {
      oe = [];
      for (const ee of se) if (ee.beforeEnter) if (Fr(ee.beforeEnter)) for (const fe of ee.beforeEnter) oe.push(Ks(fe, J, re));
      else oe.push(Ks(ee.beforeEnter, J, re));
      return oe.push(Z), te(oe);
    }).then(() => (J.matched.forEach((ee) => ee.enterCallbacks = {}), oe = C$(se, "beforeRouteEnter", J, re, T), oe.push(Z), te(oe))).then(() => {
      oe = [];
      for (const ee of a.list()) oe.push(Ks(ee, J, re));
      return oe.push(Z), te(oe);
    }).catch((ee) => Wi(ee, Ro.NAVIGATION_CANCELLED) ? ee : Promise.reject(ee));
  }
  function k(J, re, oe) {
    i.list().forEach((q) => T(() => q(J, re, oe)));
  }
  function N(J, re, oe, q, K) {
    const se = b(J, re);
    if (se) return se;
    const Z = re === Ds, ee = Zi ? history.state : {};
    oe && (q || Z ? l.replace(J.fullPath, Yn({ scroll: Z && ee && ee.scroll }, K)) : l.push(J.fullPath, K)), s.value = J, V(J, re, oe, Z), B();
  }
  let R;
  function z() {
    R || (R = l.listen((J, re, oe) => {
      if (!U.listening) return;
      const q = g(J), K = x(q, U.currentRoute.value);
      if (K) {
        E(Yn(K, {
          replace: !0,
          force: !0
        }), q).catch(Uv);
        return;
      }
      c = q;
      const se = s.value;
      Zi && dJe(CD(se.fullPath, oe.delta), aC()), P(q, se).catch((Z) => Wi(Z, Ro.NAVIGATION_ABORTED | Ro.NAVIGATION_CANCELLED) ? Z : Wi(Z, Ro.NAVIGATION_GUARD_REDIRECT) ? (E(Yn(y(Z.to), { force: !0 }), q).then((ee) => {
        Wi(ee, Ro.NAVIGATION_ABORTED | Ro.NAVIGATION_DUPLICATED) && !oe.delta && oe.type === wE.pop && l.go(-1, !1);
      }).catch(Uv), Promise.reject()) : (oe.delta && l.go(-oe.delta, !1), A(Z, q, se))).then((Z) => {
        Z = Z || N(q, se, !1), Z && (oe.delta && !Wi(Z, Ro.NAVIGATION_CANCELLED) ? l.go(-oe.delta, !1) : oe.type === wE.pop && Wi(Z, Ro.NAVIGATION_ABORTED | Ro.NAVIGATION_DUPLICATED) && l.go(-1, !1)), k(q, se, Z);
      }).catch(Uv);
    }));
  }
  let D = cv(), F = cv(), M;
  function A(J, re, oe) {
    B(J);
    const q = F.list();
    return q.length ? q.forEach((K) => K(J, re, oe)) : (process.env.NODE_ENV !== "production" && Rn("uncaught error during route navigation:"), console.error(J)), Promise.reject(J);
  }
  function L() {
    return M && s.value !== Ds ? Promise.resolve() : new Promise((J, re) => {
      D.add([J, re]);
    });
  }
  function B(J) {
    return M || (M = !J, z(), D.list().forEach(([re, oe]) => J ? oe(J) : re()), D.reset()), J;
  }
  function V(J, re, oe, q) {
    const { scrollBehavior: K } = e;
    if (!Zi || !K) return Promise.resolve();
    const se = !oe && fJe(CD(J.fullPath, 0)) || (q || !oe) && history.state && history.state.scroll || null;
    return Ke().then(() => K(J, re, se)).then((Z) => Z && uJe(Z)).catch((Z) => A(Z, J, re));
  }
  const j = (J) => l.go(J);
  let W;
  const Y = /* @__PURE__ */ new Set(), U = {
    currentRoute: s,
    listening: !0,
    addRoute: p,
    removeRoute: m,
    clearRoutes: t.clearRoutes,
    hasRoute: h,
    getRoutes: v,
    resolve: g,
    options: e,
    push: C,
    replace: w,
    go: j,
    back: () => j(-1),
    forward: () => j(1),
    beforeEach: r.add,
    beforeResolve: a.add,
    afterEach: i.add,
    onError: F.add,
    isReady: L,
    install(J) {
      J.component("RouterLink", nZe), J.component("RouterView", aZe), J.config.globalProperties.$router = U, Object.defineProperty(J.config.globalProperties, "$route", {
        enumerable: !0,
        get: () => S(s)
      }), Zi && !W && s.value === Ds && (W = !0, C(l.location).catch((q) => {
        process.env.NODE_ENV !== "production" && Rn("Unexpected error when starting the router:", q);
      }));
      const re = {};
      for (const q in Ds) Object.defineProperty(re, q, {
        get: () => s.value[q],
        enumerable: !0
      });
      J.provide(WP, U), J.provide(NY, /* @__PURE__ */ o1(re)), J.provide(EE, s);
      const oe = J.unmount;
      Y.add(J), J.unmount = function() {
        Y.delete(J), Y.size < 1 && (c = Ds, R && R(), R = null, s.value = Ds, W = !1, M = !1), oe();
      }, process.env.NODE_ENV !== "production" && Zi && wJe(J, U, t);
    }
  };
  function te(J) {
    return J.reduce((re, oe) => re.then(() => T(oe)), Promise.resolve());
  }
  return U;
}
const cZe = [
  {
    path: "/",
    name: "SupplierHome",
    component: () => import("./Dashboard-UsMJdcJ1.js")
  }
], uZe = sZe({
  history: RJe("/supplier"),
  routes: cZe
}), dZe = () => {
  console.log("Supplier Web Wujie ");
}, Jy = Fee({
  legacy: !1,
  locale: localStorage.getItem("locale") || "zh",
  fallbackLocale: "zh",
  messages: {}
}), jY = (e) => Rt(void 0, null, function* () {
  if (!Jy.global.availableLocales.includes(e))
    try {
      const t = yield XY(/* @__PURE__ */ Object.assign({ "./locales/en.ts": () => import("./en-B0Upd_1p.js"), "./locales/es.ts": () => import("./es-COTZg3n4.js"), "./locales/index.ts": () => import("./index-CN8RNCrd.js"), "./locales/zh.ts": () => import("./zh-CTrjNB0H.js") }), `./locales/${e}.ts`, 3);
      Jy.global.setLocaleMessage(e, t.default);
    } catch (t) {
      console.warn(`Failed to load locale ${e}:`, t);
    }
}), SZe = (e) => Rt(void 0, null, function* () {
  yield jY(e), Jy.global.locale.value = e;
}), Wp = ZE(Vqe), fZe = xZ();
Wp.use(fZe);
Wp.use(uZe);
Wp.use(Jy);
Wp.use(GTe);
Wp.use(Dqe);
dZe();
const pZe = localStorage.getItem("locale") || "zh";
jY(pZe).then(() => {
  Wp.mount("#app");
});
export {
  Fqe as _,
  ve as a,
  ue as c,
  G as o,
  SZe as s
};
